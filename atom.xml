<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-01-12T08:20:13.690Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>装配Bean之通过Java代码装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配Bean之通过Java代码装配Bean/</id>
    <published>2019-01-12T07:37:41.000Z</published>
    <updated>2019-01-12T08:20:13.690Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。此时，你必须采取显式装配的方式，在进行显式配置的时候，有两种可选的方案：Java和XML。下面主要是学习如何使用Java来进行配置。在读这篇文章之前，建议先阅读我的上一篇文章<strong><big><a href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/">装配Bean之自动化装配Bean</a><big></big></big></strong></p><h3 id="1、创建配置类"><a href="#1、创建配置类" class="headerlink" title="1、创建配置类"></a>1、创建配置类</h3><pre><code>@Configurationpublic class CDPlayerConfig{    ...}</code></pre><p>创建 JavaConfig 的关键在于为其添加@Configuration注解，此外，该类应该包含在Spring应用上下文中创建bean的细节。</p><h3 id="2、声明简单的bean"><a href="#2、声明简单的bean" class="headerlink" title="2、声明简单的bean"></a>2、声明简单的bean</h3><p>(1)要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解，下面的代码声明了CompactDisc bean:</p><pre><code>@Beanpublic CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><p>@Bean注解会告诉Spring这个方法会返回一个对象，该对象需要注册为Spring应用上下文中的bean，方法体中包含了最终产生bean实例的逻辑。</p><p>(2)默认情况下，bean的ID与带有@Bean注解的方法名是一样的。如果你想为其设置一个不同的名字的话，你可以重命名该方法，或者通过name属性指定一个不同的名字。如下：</p><pre><code>@Bean(name=&quot;lonelyHeartsClubBand&quot;)public CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><h3 id="3、借助JavaConfig注入"><a href="#3、借助JavaConfig注入" class="headerlink" title="3、借助JavaConfig注入"></a>3、借助JavaConfig注入</h3><p>(1)我们前面所声明的CompactDisc bean是非常简单的，其自身没有其他的依赖。现在，我们需要声明CDPlayer bean，它依赖于CompactDisc，在JavaConfig中要像下面那样将它们装配到一起：</p><pre><code>@Beanpublic CDPlayer cdPlayer(){    return new CDPlayer(sgtPeppers());}</code></pre><p>看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此，在默认情况下，Spring中的bean都是单例的，因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。即对sgtPeppers()方法的调用返回的是Spring本身在调用sgtPeppers()时所创建的CompactDisc bean。</p><p>(2)可以看到，通过方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：</p><pre><code>@Beanpublic CDPlyer cdPlayer(CompactDisc compactDisc) {    return new CDPlayer(compactDisc);}</code></pre><p>通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowir
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之自动化装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配bean之自动化装配Bean/</id>
    <published>2019-01-12T04:21:32.000Z</published>
    <updated>2019-01-12T07:26:36.783Z</updated>
    
    <content type="html"><![CDATA[<p>Spring从两个角度来实现自动化装配：</p><p>(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。</p><p>(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。</p><h3 id="1、创建可被发现的Bean"><a href="#1、创建可被发现的Bean" class="headerlink" title="1、创建可被发现的Bean"></a>1、创建可被发现的Bean</h3><p>(1)创建一个接口CompactDisc：</p><pre><code>package soundsystem;public interface CompactDisc{    void play();}</code></pre><p>(2)创建带有@Component注解的CompactDisc接口的一个实现类：</p><pre><code>package soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc{    private String title = &quot;Sgt, Pepper&apos;s Lonely Hearts Club Band&quot;;    private String artist = &quot;The Beatles&quot;;    public void play(){        System.out.println(&quot;Playing &quot; + title + &quot; By &quot; + artist);    }}</code></pre><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><h5 id="Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。"><a href="#Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。" class="headerlink" title="@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。"></a>@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。</h5><p>(3)创建配置类:</p><pre><code>package soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig{    ...}</code></pre><h5 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h5><h5 id="ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"><a href="#ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。" class="headerlink" title="@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"></a>@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。</h5><p>(4)当然我们也可以使用XML配置的方式来启动组件扫描：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt;&lt;/beans&gt;</code></pre><p>(5)Junit测试：</p><pre><code>package soundsystem;import org.junit.Test;import static org.junit.Assert.*;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest {    @Autowired    private CompactDisc cd;    @Test    public void cdShuldNotBeNull(){        assertNotNull(cd);    }}</code></pre><h5 id="注：-2"><a href="#注：-2" class="headerlink" title="注："></a>注：</h5><h5 id="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"><a href="#a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。" class="headerlink" title="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"></a>a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。</h5><h5 id="b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"><a href="#b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。" class="headerlink" title="b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"></a>b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。</h5><h5 id="c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。"><a href="#c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。" class="headerlink" title="c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。"></a>c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。</h5><h3 id="2、为组件扫描的bean命名"><a href="#2、为组件扫描的bean命名" class="headerlink" title="2、为组件扫描的bean命名"></a>2、为组件扫描的bean命名</h3><p>(1)Spring上下文中所有的bean都会给定一个ID，若直接使用 @Component 注解来声明一个 bean，其bean 的名字默认为类名首字母小写。例如，如上 SgtPeppers 类的默认 bean 名称为 sgtPeppers。当然我们可以在 @Component 注解中说明此 bean 的名称。</p><pre><code>@Component(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><p>也可以使用另外一种为bean命名的方式：</p><pre><code>@Named(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><h5 id="注：-3"><a href="#注：-3" class="headerlink" title="注："></a>注：</h5><h5 id="Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。"><a href="#Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。" class="headerlink" title="@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。"></a>@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。</h5><h3 id="3、设置组件扫描的基础包"><a href="#3、设置组件扫描的基础包" class="headerlink" title="3、设置组件扫描的基础包"></a>3、设置组件扫描的基础包</h3><p>在之前的案列中，我们没有为 @ComponentScan注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件。但是有个原因会促使我们要明确的设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。</p><p>(1)为了指定不同的包，只需要在 @ComponentScan的value属性中指明包的名称:</p><pre><code>@Configuration@ComponentScan(&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(2)如果你想更加明确的表名你所设置的是基础包，那么你可以通过basePackages属性进行配置:</p><pre><code>@Configuration@ComponentScan(basePackages=&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(3)如果你想扫描多个包，只需要将basePackages属性的值设置为要扫描包的一个数组即可:</p><pre><code>@Configuration@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})public class CDPlayerConfig{    ...}</code></pre><p>(4)在上面的例子当中，basePackages属性的值是一个String类型的数组，这样配置没有问题，但却是类型不安全的，如果要重构代码的话，这些包的名字可能会被修改，从而导致包扫描出现错误，除了将包设置为简单的String类型之外，@ComponentScan 还提供了另一种方法，那就是将其指定为要扫描包中所含的类或接口。</p><pre><code>@Configuration@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})public class CDPlayerConfig{    ...}</code></pre><h5 id="注：-4"><a href="#注：-4" class="headerlink" title="注："></a>注：</h5><h5 id="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"><a href="#你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。" class="headerlink" title="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"></a>你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。</h5><h3 id="4、通过为bean添加注解实现自动装配"><a href="#4、通过为bean添加注解实现自动装配" class="headerlink" title="4、通过为bean添加注解实现自动装配"></a>4、通过为bean添加注解实现自动装配</h3><p>在你的应用程序当中，如果所有的对象都是独立的，彼此之间没有任何的依赖，就像ShtPeppers的bean一样，那么你所需要的可能就是组件的扫描而已。但是很多对象会依赖其他的对象才能完成任务。如此一来，我们就需要有一种方法将组件扫描得到的bean和它们的依赖装配在一起。这就涉及到Spring的自动装配。自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean，这里借助@Autowired注解来声明自动装配。</p><p>(1)以下示例的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器进行实例化并传入一个CompactDisc类型的 bean。<strong><big>@Autowired 注解可以用在类的任何方法上。</big></strong></p><pre><code>@Componentpublic class CDPlayer implements MediaPlayer{    private CompactDisc cd;    @Autowired    public CDPlayer(CompacrDisc cd){        this.cd = cd;    }    public void play(){        cd.play();    }}</code></pre><p>(2)不管是构造器、Setter 方法还是其他方法，Spring 都会尝试满足方法参数上所声明的依赖，假如有且仅有一个bean依赖需求的话，那么这个bean就会被装填进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：</p><pre><code>@Autowired(required=false)public CDPlayer(CompactDisc cd){    this.cd = cd;}</code></pre><h5 id="注：-5"><a href="#注：-5" class="headerlink" title="注："></a>注：</h5><h5 id="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"><a href="#但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。" class="headerlink" title="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"></a>但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。</h5><p>(3)如果有多个bean都能满足依赖关系的话，Spring也将会抛出一个异常，表明没有明确指定要选择那个bean进行装配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring从两个角度来实现自动化装配：&lt;/p&gt;
&lt;p&gt;(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。&lt;/p&gt;
&lt;p&gt;(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发中遇到的几个问题</title>
    <link href="http://www.echodemo.cc/2018/11/30/SpringBoot%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/11/30/SpringBoot开发中遇到的几个问题/</id>
    <published>2018-11-30T04:42:21.000Z</published>
    <updated>2018-11-30T06:51:48.235Z</updated>
    
    <content type="html"><![CDATA[<p>1、java.net.MalformedURLException: no protocol 异常</p><p>在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、java.net.MalformedURLException: no protocol 异常&lt;/p&gt;
&lt;p&gt;在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中的FastJson</title>
    <link href="http://www.echodemo.cc/2018/11/29/SpringBoot%E4%B8%AD%E7%9A%84FastJson/"/>
    <id>http://www.echodemo.cc/2018/11/29/SpringBoot中的FastJson/</id>
    <published>2018-11-29T12:59:47.000Z</published>
    <updated>2018-11-29T13:54:29.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.37&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、导入包和主要的方法"><a href="#2、导入包和主要的方法" class="headerlink" title="2、导入包和主要的方法"></a>2、导入包和主要的方法</h3><p>1、导入包</p><pre><code>import com.alibaba.fastjson.JSON;</code></pre><p>2、将JSONObject转化为String</p><pre><code>String jsonStr = JSONObject.toJsonString(jsonObject);</code></pre><p>3、将String转化为JSONObject</p><pre><code>JSONObject jsonObject = JSONObject.parseObject(jsonStr);</code></pre><p>4、将String转化为JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(jsonStr);</code></pre><p>5、将JSONArray转化为JSONObject</p><pre><code>JSONObject jsonObject = new JOSNObject();for (int i; i &lt; jsonArray.length(); i++) {    jsonObject = jsonArray.getJSONObject[i];}</code></pre><p>6、将JSONObject转化为JOSNArray</p><pre><code>JSONArray jsonObject = JSONObject.get(&quot;key&quot;);</code></pre><p>7、将List转JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(JSON.toJSONString(list))；</code></pre><p>8、将JSONArray转化为List</p><pre><code>List&lt;EventColAttr&gt; list = JSONObject.parseArray(jsonArray.toJSONString(), EventColAttr.class);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/gr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Log4j</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88Log4j/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合Log4j/</id>
    <published>2018-11-20T14:43:58.000Z</published>
    <updated>2018-11-20T14:54:15.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;!-- spring boot start --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- 排除自带的logback依赖 --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- springboot-log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;    &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、Log4j配置文件-建立在和application文件同级的目录下"><a href="#2、Log4j配置文件-建立在和application文件同级的目录下" class="headerlink" title="2、Log4j配置文件(建立在和application文件同级的目录下)"></a>2、Log4j配置文件(建立在和application文件同级的目录下)</h3><pre><code># Log4j配置log4j.rootCategory=INFO,stdout#控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n</code></pre><p>注：该文件里的stdout全部替换成CONSOLE也是没有问题的。当然你也可以在文件中配置file,error,debug等其他的日志信息。</p><h3 id="3、使用Log4j"><a href="#3、使用Log4j" class="headerlink" title="3、使用Log4j"></a>3、使用Log4j</h3><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author EchoDemo * @ClassName cn.aduu.web.HelloController * @Description */@RestControllerpublic class HelloController{    private static final Logger logger = LoggerFactory.getLogger(HelloController.class);    @RequestMapping(&quot;hello&quot;)    public String hello() throws JsonProcessingException {        logger.info(&quot;Hello World！&quot;);        return &quot;hello world&quot;;    }}</code></pre><p>注：启动之后在浏览器访问就好了。</p><h3 id="4、日志打印效果"><a href="#4、日志打印效果" class="headerlink" title="4、日志打印效果"></a>4、日志打印效果</h3><pre><code>十一月 20, 2018 10:42:10 下午 org.apache.catalina.core.ApplicationContext log2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization started信息: Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 23 ms2018-11-20-22-42 [http-nio-8080-exec-1] [com.echodemo.girl.web.UserController] [INFO] - Hello World!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- spring boot start --&amp;gt;
&amp;lt;dependency&amp;gt;
  
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合MyBatis</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合MyBatis/</id>
    <published>2018-11-20T13:51:36.000Z</published>
    <updated>2018-11-20T14:11:18.179Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/saytime/article/details/74783296" target="_blank" rel="noopener">CSDN学习链接</a></p><p>1、无配置文件注解版</p><p>(1)@MapperScan(“com.echodemo.girl.mapper”)这里是包名。</p><p>(2)注意到以下两个SQL语句，insert当中没有user.username是因为当它只有一个对象作为参数传递时本身进行了处理，而update当中，有两个参数传递进来，此时需要@Param的协助，并且需要以user.username的形式把值传给SQL语句当中。而单个的id则直接传递。</p><pre><code>@Insert(&quot;INSERT INTO tb_user(username, age, ctm) VALUES(#{username}, #{age}, now())&quot;)int add(User user);@Update(&quot;UPDATE tb_user SET username = #{user.username}, age = #{user.age} WHERE id = #{id}&quot;)int update(@Param(&quot;id&quot;) Integer id, @Param(&quot;user&quot;) User user);</code></pre><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p><p>2、配置文件注解版</p><p>(1)在userMapper.xml文件当中，resultMap部分，里面的jdbcType类型都需要大写，当时INTEGER只有首字母大写了，然后找bug找了好久。</p><p>(2)在UserMapper当中要加上@Repository注解，不然在UserServiceImpl.java文件中会提示bean不存在。</p><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisConfigAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/saytime/article/details/74783296&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN学习链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、无配置文件注解版&lt;/p&gt;
&lt;p&gt;(1)
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《了不起的盖茨比》</title>
    <link href="http://www.echodemo.cc/2018/11/17/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94%E3%80%8B/"/>
    <id>http://www.echodemo.cc/2018/11/17/《了不起的盖茨比》/</id>
    <published>2018-11-17T14:43:39.000Z</published>
    <updated>2018-11-17T14:57:37.478Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片陌生的天空；他一定感到毛骨悚然，当他发现玫瑰是多么丑恶，而阳光照在刚刚露头的小草上又是多么残忍。这是一个新世界，物质的世界，没有真实可言，可怜的鬼魂呼吸着空气一般的梦想，四处飘荡……就像那个灰蒙蒙的怪人穿过杂乱的树林悄悄向他走来一样。”可以这样说：盖茨比梦想、希望和肉体的覆灭是黛西和汤姆两个人共同的杰作，当然也因为他的纯真和勇敢。但归根究底他是被残酷的社会现实活生生地扼杀的，过去是这样，现在在依然是这样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>洪水猛兽</title>
    <link href="http://www.echodemo.cc/2018/11/14/%E6%B4%AA%E6%B0%B4%E7%8C%9B%E5%85%BD/"/>
    <id>http://www.echodemo.cc/2018/11/14/洪水猛兽/</id>
    <published>2018-11-14T04:59:52.000Z</published>
    <updated>2018-11-14T05:08:25.442Z</updated>
    
    <content type="html"><![CDATA[<p>我已经老了</p><p>在那汹涌的时光之河中逆流而上的</p><p>是我焦急的等待和对幸福的憧憬</p><p>那些孤独、失眠并痛苦着的夜晚</p><p>我是多么渴望</p><p>有一天能够在某个幽静的花园里</p><p>在黄色的落叶铺满整个季节的时候</p><p>坐在一棵干枯杏树下的长凳上</p><p>再为你读一首浪漫动情的诗篇</p><p>因为只有这样</p><p>才能缓解我无法避免地从思念的村庄路过时的情绪</p><p>而你并不知道我始终身陷囹圄、画地为牢</p><p>在无穷无尽的深渊里甘为囚徒、难以自拔</p><p>染上了名为爱情的霍乱</p><h6 id="注：此诗因读《霍乱时期的爱情》有感而写"><a href="#注：此诗因读《霍乱时期的爱情》有感而写" class="headerlink" title="注：此诗因读《霍乱时期的爱情》有感而写"></a>注：此诗因读《霍乱时期的爱情》有感而写</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我已经老了&lt;/p&gt;
&lt;p&gt;在那汹涌的时光之河中逆流而上的&lt;/p&gt;
&lt;p&gt;是我焦急的等待和对幸福的憧憬&lt;/p&gt;
&lt;p&gt;那些孤独、失眠并痛苦着的夜晚&lt;/p&gt;
&lt;p&gt;我是多么渴望&lt;/p&gt;
&lt;p&gt;有一天能够在某个幽静的花园里&lt;/p&gt;
&lt;p&gt;在黄色的落叶铺满整个季节的时候&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合JdbcTemplate</title>
    <link href="http://www.echodemo.cc/2018/11/14/SpringBoot%E6%95%B4%E5%90%88JdbcTemplate/"/>
    <id>http://www.echodemo.cc/2018/11/14/SpringBoot整合JdbcTemplate/</id>
    <published>2018-11-14T04:24:48.000Z</published>
    <updated>2018-11-14T04:53:54.629Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/saytime/article/details/74783294" target="_blank" rel="noopener">CSDN学习链接</a></p><p>下面是这篇博客当中一些需要注意的问题：</p><pre><code>1、在yml文件当中，注意空格问题。2、在UserDaoImpl.java文件当中，类需要加上@Repository注解。3、在UserServiceimpl.java文件当中，类需要加上@Service注解。4、在UserController.java文件当中，类需要加上@RestController注解。5、JsonResult实体类需要生成get和set方法。*另外，自己的项目里面的controller路径有所改变。</code></pre><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/JdbcTemplate-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/saytime/article/details/74783294&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN学习链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是这篇博客当中一些需要注意的问题：&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中Controller的使用</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E4%B8%ADController%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot中Controller的使用/</id>
    <published>2018-11-05T13:02:28.000Z</published>
    <updated>2018-11-06T12:58:39.483Z</updated>
    
    <content type="html"><![CDATA[<p>1、Controller方法和类的注解</p><p><img src="/images/2018/11/9.png" alt="&quot;1&quot;"></p><p>其中@RequestMapping可以给整个Controller类设置注解。还可以通过如下的设置让不同的链接参数来进行访问：</p><pre><code>@RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;}, method = RequestMethod.GET)public String say(){    return &quot;Hello SpringBoot!&quot;;}</code></pre><p><img src="/images/2018/11/10.png" alt="&quot;2&quot;"><br><img src="/images/2018/11/11.png" alt="&quot;3&quot;"></p><p>当然为了让代码更加得简洁，可以使用@GetMapping(value = “/hello”)和@PostMapping(value = “/hello”)来替代@RequestMapping(value = “/hello”, method = RequestMethod.GET)和@RequestMapping(value = “/hello”, method = RequestMethod.POST)的。</p><p>2、Controller当中的参数传递</p><p><img src="/images/2018/11/12.png" alt="&quot;4&quot;"></p><p>（1）@PathVariable</p><pre><code>@RequestMapping(value = &quot;/hello/{id}&quot;,method = RequestMethod.GET)public String say(@PathVariable(&quot;id&quot;) Integer id){    return &quot;id: &quot; + id;}</code></pre><p><img src="/images/2018/11/13.png" alt="&quot;5&quot;"></p><p>（2）@RequestParam(可以设置默认值)</p><pre><code>@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)public String say(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) Integer id){    return &quot;id: &quot; + id;}</code></pre><p><img src="/images/2018/11/14.png" alt="&quot;6&quot;"><br><img src="/images/2018/11/15.png" alt="&quot;7&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Controller方法和类的注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/11/9.png&quot; alt=&quot;&amp;quot;1&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中@RequestMapping可以给整个Controller类设置注解。还可以通过如下的设置让
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot的第一个入门程序/</id>
    <published>2018-11-05T12:34:41.000Z</published>
    <updated>2018-11-05T15:10:50.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK"><a href="#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK" class="headerlink" title="1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)"></a>1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)</h3><p><img src="/images/2018/11/1.png" alt="&quot;1&quot;"></p><p><img src="/images/2018/11/2.png" alt="&quot;2&quot;"></p><p><img src="/images/2018/11/3.png" alt="&quot;3&quot;"></p><p><img src="/images/2018/11/4.png" alt="&quot;4&quot;"></p><h3 id="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。"><a href="#2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。" class="headerlink" title="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。"></a>2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。</h3><p><img src="/images/2018/11/5.png" alt="&quot;打开GirlApplication.java文件&quot;"></p><p><img src="/images/2018/11/6.png" alt="&quot;创建HelloController.java文件&quot;"></p><h3 id="3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。"><a href="#3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。" class="headerlink" title="3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。"></a>3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。</h3><p><img src="/images/2018/11/7.png" alt="&quot;在浏览器查看&quot;"></p><h3 id="4、项目属性配置-创建配置文件和配置文件属性类"><a href="#4、项目属性配置-创建配置文件和配置文件属性类" class="headerlink" title="4、项目属性配置(创建配置文件和配置文件属性类)"></a>4、项目属性配置(创建配置文件和配置文件属性类)</h3><p><img src="/images/2018/11/8.png" alt="&quot;文件分布&quot;"></p><p>（1）生产、测试环境以及主配置文件内容</p><pre><code>//测试环境内容server:  port: 8080girl:  cupSize: B  age: 18//生产环境内容server:  port: 8081girl:  cupSize: F  age: 18//调用配置文件的主配置文件内容spring:  profiles:    active: prod</code></pre><p>（2）创建配置文件属性类</p><pre><code>package com.echodemo.girl;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;//获取前缀是girl的配置，注入配置需要加Component注解@Component@ConfigurationProperties(prefix = &quot;girl&quot;)public class GirlProperties {    private String cupSize;    private Integer age;    public String getCupSize() {        return cupSize;    }    public void setCupSize(String cupSize) {        this.cupSize = cupSize;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><p>（3）HelloController文件内容</p><pre><code>package com.echodemo.girl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {/*    //通过注解的方式获取配置文件值(Value注解太low了)    @Value(&quot;${server.cupSize}&quot;)    private String cupSize;    @Value(&quot;${server.age}&quot;)    private Integer age;*/    //通过创建配置文件属性类来获取配置文件中的值    @Autowired    private GirlProperties girlProperties;    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)    public String say(){        return girlProperties.getCupSize();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK&quot;&gt;&lt;a href=&quot;#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-ma
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(二)/</id>
    <published>2018-10-06T15:12:32.000Z</published>
    <updated>2018-10-06T15:18:23.483Z</updated>
    
    <content type="html"><![CDATA[<p>1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想要得到什么、实现什么。</p><p>2、关系要获得成长，首先是处在关系中的人要成长。比如，有的女人婚后成了全职太太，将个人成长的停滞归咎于操持家庭，和先生在阅历和思想上逐渐脱节，渐行渐远。又比如，有的男性一直保持着学生时期的心态，沉迷于游戏和其他娱乐活动，拒绝面对自己的成长，也不愿认真思考未来。</p><p>3、我们不知道自己想要什么，是因为有太多担心和顾虑，眼前的问题阻碍了我们看清自己的方向。</p><p>4、怎样知道你对一件事情有激情？你每天早上醒来和晚上临睡前都会忍不住去想、去做的，就是让你充满激情的事情。如果连开始一件事情都缺少决断力，那么之后一旦遇到困难或者冲突，必然会很快选择放弃。所以，如果你已经发现自己的激情所在，想要去做一件事情，那么现在就开始！</p><p>5、你可以试试把自己关在一个空房间里，5分钟，10分钟，半小时。不带手机，不看电脑，你可以观察自己在寂寞时会有什么反应，会做什么，这样可以很好地帮助你了解自己。</p><p>6、喜欢把工作忙、圈子小、性格内向、不善交际这些说辞挂在嘴边的人并没有想过，他们提出的每一点理由都只是一种暂时的状态，而非不可改变的现实。那些成功者与你起点相同，但最终获得成功，这才是你和他们的本质区别。</p><p>7、走出自卑，是一条重新审视自己的生活、重新定义自我价值、重新设计自我行为的漫长之路。走出自卑，需要你对客观现实和自我认知有强烈的渴望，这样才能够打破长久以来的自我偏见；走出自卑，意味着要学会忍耐自卑带来的不适感，将更多精力放在优化自己的实际行为上。</p><p>8、愤怒的表达是本能，对愤怒带来的伤害的修复比表达更为重要，但是许多人都把更多注意力放在了调整和弱化表达上面。（压抑自己的情绪）如果我们懂得如何在伤害产生后修复关系，表达我们的歉意、关怀和爱，那么伤害反而成了拉近关系和建立信任的机会。使用回避、沉默、逃避、疏远以及终止关系来表达愤怒。其结果就是，情绪得不到合理表达，引发更深层的抑郁，同时也失去了建立信任感和亲密关系的机会，在人际关系中越发感到被孤立。</p><h2 id="9、“想要”和“需要”"><a href="#9、“想要”和“需要”" class="headerlink" title="9、“想要”和“需要”"></a>9、“想要”和“需要”</h2><p>关于是否足够了解自己的情感需求这个话题，我会用一个简单的问题来测试：“你为什么要恋爱、结婚？”对此，我得到的常见答案是：自己到了一定年纪应该稳定下来了，家里人也比较着急，看到周围的同事、朋友也都结婚了，所以就结婚了。在我看来，这就是不了解自己情感需求的表现，因为这里给出的是一个人想要却未必需要的东西。关于人的想要和需要，我们要进行一下区分。你可以将这两者的关系理解为路径和目标，我们通过得到想要的东西，来满足根本的需要。想要的东西往往是某些具体的事物，而需要很多时候则是主观的体验和感受。比如，我想要很多钱，因为有了钱别人就会尊重我，所以我需要的其实是尊重；我想要先生对我很专一，这会让我感觉他很重视我，所以我需要的是重视；我想要很多漂亮的衣服和包，因为我打扮漂亮了，别人才会认可我，所以我需要的是认可。当一个人告诉我她走进一段感情是因为年龄、家人和社会压力时，她的真正需要可能是自信、安全感、归属感，以及被认可、被尊重、被接纳等。更进一步说，一个人得到了想要的东西，是否就一定能满足自己的需要？很多人在这两者的关系认知上存在着很大的偏差。比如走入婚姻，需要的是被别人认可和尊重，但是满足了家人和社会的期望，就一定能被别人认可和尊重吗？</p><p>如果无法区分想要和需要，便会把生命浪费在肤浅的、想要的事物上。而人只有当需要被满足时，才会感到发自内心的满意。</p><h2 id="10、划分人生阶段"><a href="#10、划分人生阶段" class="headerlink" title="10、划分人生阶段"></a>10、划分人生阶段</h2><p>将自己的人生划分为8个阶段，这个数字没有特定的含义，只是一个结构上的要求。每个阶段用一个重要的事件或者时间节点来界定。第一个阶段从出生开始，最后一个阶段一直持续到当下。</p><h3 id="罗列重要事件"><a href="#罗列重要事件" class="headerlink" title="罗列重要事件"></a>罗列重要事件</h3><p>从每个阶段里找出10件对你影响重大的事件，这个数字也仅是一个结构上的要求而已。这些事件应该对你的情感、性格、生活轨迹、人际关系产生过比较大的影响。我建议你关注这样一些事件：让你的生活轨迹发生变化的转折点，重大的失败或意外，重要的决定，对情感造成较大冲击的事件，记忆深刻的事件。另外这些事件多半与他人有关，我建议你重点关注你的父母或者其他亲近的人。罗列这80件事情本身就是个挑战，有的需要努力回忆，有的需要去询问他人。你可以先定义好一个阶段，去搜罗事件，进行分析，然后再进入下一个阶段。</p><h3 id="分析事件"><a href="#分析事件" class="headerlink" title="分析事件"></a>分析事件</h3><p>每一个事件下面，你都需要回答以下几个问题：</p><pre><code>（1）这件事给你带来了哪些认知和想法上的变化？（2）这件事给你带来了哪些情感上的冲击或者影响？（3）这件事和现在的你有什么关系？换句话说，这件事如何塑造了今天的你？</code></pre><p>内容上没有太多要求，每个人都有权利以自己喜欢的方式写一部自己的个人史。唯一需要你坚持的是8个阶段，总共80件事情，每件事情3个问题，这样写出来的东西才能足够细化。每个问题你可以随便回答，或者详细地描述。要花多少时间，要写多少，由你自己决定。你的收获完成这份“作业”可能需要花费很多时间，多到远远超出你的预期。写的过程中你可能会哭、会笑、会感慨。你可能需要他人帮助你回忆某些事。我介绍身边的一些人尝试过这种方法，包括我的长辈。我没有看他们写的东西（你最好不给别人看，这样才能保证内容最真实）。但是大家给我的反馈一致：做这样一件事对自己有太多益处。这个练习是我大学时期的一位心理学教授布置的期末论文题目。当时的我花费两个月的时间，写下一万多字。它开启了我对自我认知的探寻之路，是我到目前为止做过的最重要的几件事情之一。最终的效果因人而异。但对我来说，写作的过程已让我受益匪浅，一边写一边思考，看清了很多以往忽略或者误解的问题。写完之后，整个人有一种“觉醒”的感觉，它带来的思考，也会持续影响自己。同时，你会更理解自己，会看到所处的环境对自己的影响，而不再把所有事情都归因于自己或者身边的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(一)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(一)/</id>
    <published>2018-10-06T15:07:21.000Z</published>
    <updated>2018-10-06T15:10:51.268Z</updated>
    
    <content type="html"><![CDATA[<p>1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。</p><p>2、在深入了解双方的想法时，例如聊到和前任的关系或者异性朋友这类比较敏感的话题时，建议你平和而又诚恳地邀请对方表达，让对方感到安全：“我知道这个话题对你来说可能比较敏感，或许你可以试着说说看，我很想了解你，也向你保证，我不会在没有完全理解你的时候给你贴标签或者批判你。”</p><p>3、矛盾冲突永远存在，但是高质量的关系可以保障亲密关系中的满意度更持久。很多人在亲密关系中所犯的错误就是为了争论对错、分出输赢、掌握控制权，宁可牺牲亲密关系，因为我们往往习惯了以强制的方式使对方接受。</p><p>4、你可能习惯了不说话，在人群里永远保持沉默，有着很强的戒备心理，对异性充满恐惧。你可能有很多情结、障碍、缺点，但你必须要走出自己熟悉的舒适区，做以前没做过的事情。浪漫的事情，都多少带些不寻常甚至是冒险。在恐惧、焦虑、不确定的时候，你习惯了逃避，那么，多半也会错过那些美好奇妙的邂逅。</p><p>5、许多人总要求对方要与自己有精神共鸣、有生活情趣、要浪漫、要体贴入微。要求别人之前先看看自己，你是个爱读书、爱思考的人吗？你的生活是不是充满了各种趣味？你是否有自己独特的手艺和爱好可以用来营造浪漫？你是否习惯于帮助他人和奉献自我？长久积累的品质才能产生魅力，而平庸和平淡的你，拿什么吸引心仪的人，拿什么让亲密关系保鲜？</p><p>6、我极力推荐大家去看看《摩登家庭》，此剧一个重要的看点就是学习剧中人物在处理家庭关系时如何用积极的、有建设性的语言沟通彼此的感受。</p><p>7、我希望用文字鼓励那些心有所向的人，不要因为可能被拒绝就患得患失，不要因为希望渺茫就放弃。感情不能用得失、成败来衡量，因为感情中的失败其实是一种提示，是在告诉你且行且珍惜，你完全没必要和失败过不去。</p><p>8、我真心希望每一个恋爱中的人，都不要只顾着享受对方带给你的感动和温暖，要多想想自己可以为他做些什么。在你感到最幸福、最满足的时候，记得问问自己：他是否和我一样幸福？</p><p>9、任何形式的失败，其实都是生活在提示我们：你的方法不对，需要调整。拒绝分手或者离婚，找各种理由说服自己死扛，本质就是拒绝承认错误。当你忽视生活给你的提示时，获得的只能是更多更激烈和强硬的提示，直到你被彻底打垮。</p><p>10、每当你和伴侣之间出现矛盾的时候，你需要先思考以下两个问题：对方怎么改变能够让你感到满意？如果有人要让你做出这样的改变，激励你的最好方式是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。&lt;/p&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《自控力》摘句</title>
    <link href="http://www.echodemo.cc/2018/09/08/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2018/09/08/《自控力》摘句/</id>
    <published>2018-09-08T13:23:43.000Z</published>
    <updated>2018-09-08T13:33:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。</p><p>2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。</p><p>3、从每章挑选一个策略，选和你的挑战最相关的一个，而不是一次尝试10种策略。</p><p>4、人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学数学，它就会越来越擅长数学。如果你让它忧虑，它就会越来越忧虑。如果你让它专注，它就会越来越专注。</p><p>5、如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</p><p>6、人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</p><p>7、如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。</p><p>8、如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。</p><p>9、自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。</p><p>10、道德许可：当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p><p>11、只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。</p><p>12、当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？·你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？·你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？</p><p>13、我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。</p><p>14、你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？</p><p>15、这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？</p><p>16、如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。</p><p>17、你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。）</p><p>18、是什么让你的多巴胺神经元不停燃烧？你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？</p><p>19、谁在控制你的多巴胺神经元？让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。&lt;/p&gt;
&lt;p&gt;2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。&lt;/p&gt;
&lt;p&gt;3、从每章挑选一个策略，选和你的挑战最相关的一个，而
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>故乡</title>
    <link href="http://www.echodemo.cc/2018/08/22/%E6%95%85%E4%B9%A1/"/>
    <id>http://www.echodemo.cc/2018/08/22/故乡/</id>
    <published>2018-08-22T13:29:58.000Z</published>
    <updated>2018-08-27T10:55:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专程看望和问询；郑愁予的故乡是始终心系的祖国；还有一个人的故乡是他十年来力排众议在艰难的环境和地形下修筑的几十公里的山路。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一辆Hello共享单车，在幽暗的路上漫无目的地游荡。想起考研未果的日子，我知道，那时候选择找工作而不是二战，是因为自己在逃避，害怕再一次的失败，不知道自己的退路在哪。如今来到偌大的城市里，繁华是你。刚来的日子里满心欢喜，为自己能够来到这座城市而庆幸，把冥冥中的注定看作美好的开始。但此刻自己的内心是茫然的，故乡对我而言意味着什么，一个人需要怎样的经历和过去才能够看清？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立在公交站台旁的我，用手机写着这段文字的时候，抬头望着夜空中笼罩在云里的月，顿下来，目光又顺着车流望向灯火斑斓的远方，好像知道了点什么，转身往回走去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>音乐诗人</title>
    <link href="http://www.echodemo.cc/2018/08/19/%E9%9F%B3%E4%B9%90%E8%AF%97%E4%BA%BA/"/>
    <id>http://www.echodemo.cc/2018/08/19/音乐诗人/</id>
    <published>2018-08-19T02:46:32.000Z</published>
    <updated>2018-08-27T10:53:03.803Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，动听的曲，美的无与伦比。台上的他，于言谈举止之间无时无刻不透露着温文儒雅的气质。近来知晓他与其妻子的爱情，从两小无猜的年纪到同是清华的学子，彼此之间缘深缘浅，自是懂得，这一切都是最好的安排。据说在李健的每一张专辑里都有一首歌是写给孟小蓓的，他对她说：和你在一起的日子才叫时光。他爱咖啡，也爱清茶，更爱读书，这也是他随口而出的词句里文化深厚的原因。他的音乐如诗，爱情如诗，更是把生活过成了一首诗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>萤火虫</title>
    <link href="http://www.echodemo.cc/2018/08/18/%E8%90%A4%E7%81%AB%E8%99%AB/"/>
    <id>http://www.echodemo.cc/2018/08/18/萤火虫/</id>
    <published>2018-08-18T06:39:59.000Z</published>
    <updated>2018-08-27T10:51:45.655Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种做法，想想都是美的。以前小时候在故乡，秋天的夜晚，带着随意的瓶子跑到屋子外面去捕萤火虫，满天的星光下，是我们奔跑的身影和不尽的欢笑。那时候小，把一只又一只的萤火虫都塞进瓶中，第二天一大早起来，见到的就是它们的躯体，自己伤心极了，便下定决心不再捕捉，只是远观这些闪烁着的精灵就足够了。如今年岁见长，到远离故乡的城市里读书，再到现在的新入职场，一切都变得遥远。大概现在已经有好几年没有见到过萤火虫了。一方面是人类发展导致的环境恶化，另一方面是自己在这样的时节里和故乡难以靠近。昨天七夕，不禁想起唐代诗人杜牧那首《秋夕》“银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星”，给此时的自己又增添了一份美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺&lt;/p&gt;
&lt;p&gt;&amp;nbsp
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的XML配置</title>
    <link href="http://www.echodemo.cc/2018/08/16/MyBatis%E4%B8%AD%E7%9A%84XML%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2018/08/16/MyBatis中的XML配置/</id>
    <published>2018-08-16T07:11:29.000Z</published>
    <updated>2018-08-16T08:05:20.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、properties"><a href="#1、properties" class="headerlink" title="1、properties"></a>1、properties</h3><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。首先在同级目录下新建一个db.properties文件。</p><pre><code>&lt;!-- db.properties文件 --&gt;driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root&lt;!-- properties配置 --&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;&lt;!-- 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，如下所示： --&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;&lt;!--     1、在properties元素体内指定的属性首先被读取。    2、然后根据properties元素中的resource属性读取类路径下属性文件或根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性。    3、最后读取作为方法参数(parameterType)传递的属性，并覆盖已读取的同名属性。    4、通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。--&gt;</code></pre><h3 id="2、Setting"><a href="#2、Setting" class="headerlink" title="2、Setting"></a>2、Setting</h3><p>它们会修改MyBatis在运行时的行为方式，ibatis的全局配置参数，包括很多的性能参数(最大线程数、最大等待时间等)，通过调用这些性能参数使用ibatis达到高性能的运行。MyBatis运行时调整全局参数，相当于软件运行时的参数。(需要小心配置，配置参数会影响MyBatis的执行)</p><h3 id="3、typeAlias"><a href="#3、typeAlias" class="headerlink" title="3、typeAlias"></a>3、typeAlias</h3><pre><code>&lt;!--    1、类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。     2、自定义别名:alias别名；type类型。如果指定包中所有类都有别名，使用类名作为别名(大小写不敏感)。--&gt;&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;user&quot; type=&quot;com.entity.User&quot;/&gt;    &lt;package name=&quot;com.entity&quot;/&gt;&lt;/typeAliases&gt;</code></pre><h3 id="4、environments"><a href="#4、environments" class="headerlink" title="4、environments"></a>4、environments</h3><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。</p><pre><code>&lt;!-- 可以接受环境配置的两个方法签名 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);&lt;!-- 如果忽略了环境参数，那么默认环境将会被加载 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 在MyBatis中有两种类型的事务管理器：1、JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。2、MANAGED这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 --&gt;&lt;transactionManager type=&quot;MANAGED&quot;&gt;      &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><h3 id="5、mappers"><a href="#5、mappers" class="headerlink" title="5、mappers"></a>5、mappers</h3><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、properties&quot;&gt;&lt;a href=&quot;#1、properties&quot; class=&quot;headerlink&quot; title=&quot;1、properties&quot;&gt;&lt;/a&gt;1、properties&lt;/h3&gt;&lt;p&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Jav
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/08/15/MyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/08/15/MyBatis第一个入门程序/</id>
    <published>2018-08-15T07:37:43.000Z</published>
    <updated>2018-08-16T08:58:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>2、写一个mybatis的入门程序</p><p>(1)在Myeclipse上新建一个Java项目。首先导入jar包，在该项目下新建一个lib目录，将下列的jar包导入到lib目录下。</p><p><img src="/images/2018/8/1.jpg" alt="&quot;jar包&quot;"></p><p>(2)在该项目下创建一个与src同级的source folder，取名为config。在这其中存放xml配置文件。</p><p>1)sqlMapConfig.xml(名字是自行定义的):其中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。如下所示：这里要注意DOCTYPE首部最好是在mybatis文档当中复制粘贴，不要自己手打。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- 全局配置文件 --&gt;&lt;configuration&gt;    &lt;!-- 环境变量 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 事务管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据源 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;!-- 以下的数据库以及密码需要配置自己的 --&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射定义信息) --&gt;        &lt;mapper resource=&quot;Usermapper.xml&quot; /&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>2)Usermapper.xml(和上面的配置文件中的mappers当中的mapper是一一对应的):这个配置文件主要用于进行SQL的配置。同时记得在数据库当中创建users表，且添加数据。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml(配置SQL) --&gt;&lt;!-- namespace命名空间，为了对SQL语句进行隔离，方便管理 mapper开发dao方式，有特殊的作用。 --&gt;&lt;mapper namespace=&quot;mappertest&quot;&gt;    &lt;!--     mapper.xml文件配置的SQL语句，执行每一个SQL，都将封装为mapperStatement对象。    mapper.xml以statement为单位管理SQL语句 。    --&gt;    &lt;!-- ID唯一标识Statement --&gt;    &lt;!-- parameterType：输入参数类型，通过#{}，#{}中名称任意 --&gt;    &lt;!-- resultType：输出结果的类型，返回单条或者多条记录，指明类型 --&gt;    &lt;!-- #{}表示占位符，如果参数给出String，自动添加&apos;&apos;；${value}表示SQL语句拼接，不会自动添加&apos;&apos;。 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where id=#{id}    &lt;/select&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username=#{username}    &lt;/select&gt;    &lt;select id=&quot;findUserByName1&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username like &apos;%${value}%&apos;    &lt;/select&gt;    &lt;!-- 添加用户,传参时将大括号中填写的是属性名 --&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        &lt;!--         order设置是取SQL语句执行之前还是之后的值 。        resultType：返回类型。        keyProperty：将主键设置到属性。        last_insert_id()：获得刚插入的记录自动编号的值。        --&gt;        &lt;selectKey order=&quot;AFTER&quot; resultType=&quot;int&quot; keyProperty=&quot;id&quot;&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into users(username,age) values(#{username},#{age})    &lt;/insert&gt;    &lt;!-- 删除用户 --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from users where id=#{id}    &lt;/delete&gt;    &lt;!-- 修改用户 ，用户的ID一定需要有值--&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        update users set username=#{username},age=#{age} where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>(3)创建一个com.entity包，在此包下新建User.java文件。</p><pre><code>package com.entity;public class User {    private int id;    private String username;    private int age;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public User(){        super();    }    public User(String username, int age) {        super();        this.username = username;        this.age = age;    }    public User(int id, String username, int age) {        super();        this.id = id;        this.username = username;        this.age = age;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><p>(4)最后创建一个com.test包，创建一个APPTest.java文件，用于junit测试(记得导入junit的jar包)。</p><pre><code>package com.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.entity.User;public class AppTest {    SqlSessionFactory sqlSessionFactory = null;    @Before    public void Init() throws IOException{        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testSelectUser() {//查找数据        SqlSession sqlSession = sqlSessionFactory.openSession();        //第一个参数是Statement的id,第二个参数是SQL语句中所需要的值。        /*User user = (User)sqlSession.selectOne(&quot;findUserById&quot;, 2);        System.out.println(user.toString());*/        //List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName&quot;, &quot;EchoDemo&quot;);        List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName1&quot;, &quot;Echo&quot;);        for(User user:list){            System.out.println(user.toString());        }        sqlSession.close();    }    @Test    public void testInsertUser(){//插入数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(&quot;落叶物语&quot;,24);        sqlSession.insert(&quot;addUser&quot;, user);        sqlSession.commit();//提交        sqlSession.close();        System.out.println(&quot;当前插入用户的ID:&quot; + user.getId());    }    @Test    public void testDeleteUser(){//删除数据        SqlSession sqlSession = sqlSessionFactory.openSession();        sqlSession.delete(&quot;deleteUser&quot;,2);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testUpdateUser(){//更新数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(3,&quot;紫苏半夏&quot;,22);        sqlSession.update(&quot;updateUser&quot;, user);        sqlSession.commit();        sqlSession.close();    }}</code></pre><p>1)每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。</p><p>2)SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在以保证所有的XML解析资源开放给更重要的事情。</p><p>3)SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p>4)每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Pl
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML</title>
    <link href="http://www.echodemo.cc/2018/08/07/Java%E4%B8%AD%E7%9A%84XML/"/>
    <id>http://www.echodemo.cc/2018/08/07/Java中的XML/</id>
    <published>2018-08-07T08:50:21.000Z</published>
    <updated>2018-08-07T08:51:40.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、XML定义"><a href="#1、XML定义" class="headerlink" title="1、XML定义"></a>1、XML定义</h3><p>(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输，类似HTML，不同的是它的设计宗旨是传输数据，而非显示数据。</p><p>(2)XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。XML标签没有被预定义，开发者根据需要自行定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。</p><h3 id="2、XML文档结构"><a href="#2、XML文档结构" class="headerlink" title="2、XML文档结构"></a>2、XML文档结构</h3><p>(1)XML声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p>(2)XML根元素定义：XML文档的树形结构要求必须有一个根元素。根元素的起始标记要放在所有其他元素起始标记之前，根元素的结束标记放在其他元素的结束标记之后。</p><p>(3)XML元素：元素的基本结构由开始标记，数据内容，结束标记组成。</p><h3 id="3、XML语法规则"><a href="#3、XML语法规则" class="headerlink" title="3、XML语法规则"></a>3、XML语法规则</h3><pre><code>(1)所有XML元素都须有关闭标签。(2)XML标签对大小写敏感。(3)XML必须正确地嵌套。(4)XML文档必须有根元素。(5)XML的属性以名值对方式组成，值须加引号。(6)XML可编写注释。(7)在XML中，空格会被保留，文档中的空格不会被删节。</code></pre><h3 id="4、举例说明"><a href="#4、举例说明" class="headerlink" title="4、举例说明"></a>4、举例说明</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;    &lt;book bookno=&quot;001&quot;&gt;        &lt;title&gt;Java语言编程&lt;/title&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;80&lt;/price&gt;    &lt;/book&gt;    .    .    .&lt;/bookstore&gt;</code></pre><h3 id="5、XML-SAX解析器"><a href="#5、XML-SAX解析器" class="headerlink" title="5、XML SAX解析器"></a>5、XML SAX解析器</h3><p>(1)SAX(Simple API For XML)是一个公共的基于事件的XML文档解析标准，能够通过一个简单的、快速的方法来对XML文档进行处理，和DOM相比它所占用的系统资源更少。</p><p>(2)SAX既是一个接口，也是一个软件包。作为接口，SAX是事件驱动型XML解析的一个标准接口，对文档进行顺序扫描，当扫描到文档(document)开始、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</p><h3 id="6、SAX解析器API"><a href="#6、SAX解析器API" class="headerlink" title="6、SAX解析器API"></a>6、SAX解析器API</h3><p>(1)事件类型，大多数的SAX会产生以下类型的事件：</p><pre><code>1)在文档的开始时和结束时触发文档处理事件。2)在文档内每一XML元素接受解析的前后触发元素事件。3)任何的元数据通常由单独的事件处理。</code></pre><p>(2)举例说明</p><pre><code>&lt;doc&gt;    &lt;para&gt;Hello,iotek!&lt;/para&gt;&lt;doc&gt;其解析过程为：1)start document;2)start element:doc;3)start element.para;4)characters:Hello,iotek!;5)end element:para;6)end element:doc;7)end document;</code></pre><p>(3)解析步骤</p><pre><code>1)创建事件处理程序(即编写ContentHandler的实现类，一般继承自DefaultHandler类，采用adapter模式)2)创建SAX解析器3)将事件处理程序分配到解析器。4)对文档进行解析，将每个事件发送至事件处理程序。</code></pre><p>(4)常用接口：ContentHandler接口</p><p>1)ContentHandler是Java类包中一个特殊的SAX接口。该接口封装了一些对事件处理的方法，当XML解析器开始解析XML输入文档时，他会遇到某些特殊的事件，比如文档的开头和结束、元素开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法(回调方法)来响应该事件。</p><p>2)ContentHandler接口常用方法：</p><pre><code>void startDocument();//文档解析开始的处理。void endDocument();//文档解析结束的处理。void startElement(String uri,String localName,String qName,Attributes atts);//ElementNode开始的处理。void endElement(String uri,String localName,String qName);//ElementNode结束的处理。void character(char[] ch,int start,int length);//具体在某一节点中的处理。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、XML定义&quot;&gt;&lt;a href=&quot;#1、XML定义&quot; class=&quot;headerlink&quot; title=&quot;1、XML定义&quot;&gt;&lt;/a&gt;1、XML定义&lt;/h3&gt;&lt;p&gt;(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
</feed>
