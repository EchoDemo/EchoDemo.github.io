<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-02-17T03:27:54.687Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器错误码</title>
    <link href="http://www.echodemo.cc/2019/02/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <id>http://www.echodemo.cc/2019/02/17/浏览器错误码/</id>
    <published>2019-02-17T03:16:28.000Z</published>
    <updated>2019-02-17T03:27:54.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、1XX"><a href="#1、1XX" class="headerlink" title="1、1XX"></a>1、1XX</h3><pre><code>100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。</code></pre><h3 id="2、2XX"><a href="#2、2XX" class="headerlink" title="2、2XX"></a>2、2XX</h3><pre><code>200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）：服务器成功处理了请求，但没有返回任何内容。 205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 206（部分内容）：服务器成功处理了部分 GET 请求。</code></pre><h3 id="3、3xx-（重定向）"><a href="#3、3xx-（重定向）" class="headerlink" title="3、3xx （重定向）"></a>3、3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><pre><code>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</code></pre><h3 id="4、4xx（请求错误）"><a href="#4、4xx（请求错误）" class="headerlink" title="4、4xx（请求错误）"></a>4、4xx（请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><pre><code>400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。 404（未找到）：服务器找不到请求的网页。 405（方法禁用）：禁用请求中指定的方法。 406（不接受）：无法使用请求的内容特性响应请求的网页。 407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408（请求超时）：服务器等候请求时发生超时。 409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。 411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）：请求的格式不受请求页面的支持。 416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。 417（未满足期望值）：服务器未满足”期望”请求标头字段的要求。</code></pre><h3 id="5、5xx（服务器错误）"><a href="#5、5xx（服务器错误）" class="headerlink" title="5、5xx（服务器错误）"></a>5、5xx（服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><pre><code>500（服务器内部错误）：服务器遇到错误，无法完成请求。 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、1XX&quot;&gt;&lt;a href=&quot;#1、1XX&quot; class=&quot;headerlink&quot; title=&quot;1、1XX&quot;&gt;&lt;/a&gt;1、1XX&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《房思琪的初恋乐园》摘句</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E6%88%BF%E6%80%9D%E7%90%AA%E7%9A%84%E5%88%9D%E6%81%8B%E4%B9%90%E5%9B%AD%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2019/02/16/《房思琪的初恋乐园》摘句/</id>
    <published>2019-02-16T06:50:48.000Z</published>
    <updated>2019-02-16T06:25:24.309Z</updated>
    
    <content type="html"><![CDATA[<p>1、刚刚在饭桌上，思琪用面包涂奶油的口气对妈妈说：“我们的家教好像什么都有，就是没有性教育。”妈妈诧异地看着她，回答：“什么性教育？性教育是给那些需要性的人。所谓教育不就是这样吗？”思琪一时间明白了，在这个故事中父母将永远缺席，他们旷课了，却自以为是还没开学。</p><p>2、他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。罪恶感是古老而血统纯正的牧羊犬。</p><p>3、思琪在家一面整理行李，一面用一种天真的口吻对妈妈说：“听说学校有个同学跟老师在一起。”“谁？”“不认识。”“这么小年纪就这么骚。”思琪不说话了。她一瞬间决定从此一辈子不说话了。她脸上挂着天真的表情把桌上的点心。</p><p>4、思琪的声音像一盘冷掉的菜肴，她说：“怡婷，我早已不是我自己了，那是我对自己的乡愁。”</p><p>5、整个中学生涯，她拒绝过许多中学生，一些高中生，几个大学生。她每次都说这一句“对不起，我真的没办法喜欢你”，一面说一面感觉木木的脸皮下有火烧上来。</p><p>其实是我配不上你们。我是馊掉的橙子汁和浓汤，我是爬满虫卵的玫瑰和百合，我是一个灯火流丽的都市里明明存在却没有人看得到也没有人需要的北极星。</p><p>6、为什么这个世界是这个样子？为什么所谓教养就是受苦的人该闭嘴？为什么打人的人上电视上广告广告牌？姐姐，我好失望，但我不是对你失望，这个世界，或是生活、命运，或叫它神，或无论叫它什么，它好差劲，我现在读小说，如果读到赏善罚恶的好结局，我就会哭，我宁愿大家承认人间有一些痛苦是不能和解的，我最讨厌人说经过痛苦才成为更好的人，我好希望大家承认有些痛苦是毁灭的，我讨厌大团圆的抒情传统，讨厌王子跟公主在一起，正面思考是多么媚俗！可是姐姐，你知道我更恨什么吗？我宁愿我是一个媚俗的人，我宁愿无知，也不想要看过世界的背面。</p><p>7、其实我第一次想到死的时候就已经死了。人生如衣物，如此容易被剥夺。</p><p>8、我要等等我灵魂的双胞胎，她被你丢弃在十三岁，也被我遗忘在十三岁，我要躺在那里等她，等她赶上我，我要跟她在一起。抱住他的小腿。</p><p>9、怡婷，你才十八岁，你有选择，你可以假装世界上没有人以强暴小女孩为乐；假装从没有小女孩被强暴；假装思琪从不存在；假装你从未跟另一个人共享奶嘴、钢琴，从未有另一个人与你有一模一样的胃口和思绪，你可以过一个资产阶级和平安逸的日子；假装世界上没有精神上的癌；假装世界上没有一个地方有铁栏杆，栏杆背后人人精神癌到了末期；你可以假装世界上只有马卡龙、手冲咖啡和进口文具。但是你也可以选择经历所有思琪曾经感受过的痛楚，学习所有她为了抵御这些痛楚付出的努力，从你们出生相处的时光，到你从日记里读来的时光。你要替思琪上大学，念研究所，谈恋爱，结婚，生小孩，也许会被退学，也许会离婚，也许会死胎。但是，思琪连那种最庸俗、呆钝、刻板的人生都没有办法经历。你懂吗？你要经历并牢牢记住她所有的思想、思绪、感情、感觉，记忆与幻想、她的爱、讨厌、恐惧、失重、荒芜、柔情和欲望，你要紧紧拥抱着思琪的痛苦，你可以变成思琪，然后，替她活下去，连思琪的份一起好好地活下去。</p><p>10、忍耐不是美德，把忍耐当成美德是这个伪善的世界维持它扭曲的秩序的方式，生气才是美德。<br>11、我怕消费任何一个房思琪。我不愿伤害她们。不愿猎奇。不愿煽情。我每天写八个小时，写的过程中痛苦不堪，泪流满面。写完以后再看，最可怕的就是：我所写的、最可怕的事，竟然是真实发生过的事。而我能做的只有写。女孩子被伤害了。女孩子在读者读到这段对话的当下也正在被伤害。而恶人还高高挂在招牌上。我恨透了自己只会写字。”</p><h4 id="感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。"><a href="#感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。" class="headerlink" title="感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。"></a>感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、刚刚在饭桌上，思琪用面包涂奶油的口气对妈妈说：“我们的家教好像什么都有，就是没有性教育。”妈妈诧异地看着她，回答：“什么性教育？性教育是给那些需要性的人。所谓教育不就是这样吗？”思琪一时间明白了，在这个故事中父母将永远缺席，他们旷课了，却自以为是还没开学。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《不止代码》摘句(二)</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2019/02/16/《不止代码》摘句(二)/</id>
    <published>2019-02-16T06:04:31.000Z</published>
    <updated>2019-02-16T06:11:04.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是架构？"><a href="#什么是架构？" class="headerlink" title="什么是架构？"></a>什么是架构？</h3><p>在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义：</p><p>1、组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。</p><p>2、组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如 RPC 框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。</p><p>3、组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。</p><p>4、组织全局，对外输出：架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。</p><p>很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。</p><h3 id="架构目标需要适应业务的发展"><a href="#架构目标需要适应业务的发展" class="headerlink" title="架构目标需要适应业务的发展"></a>架构目标需要适应业务的发展</h3><p>架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单 300 万，基于对未来的可能预测，明年可能有 3000 万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到 2 个 9 还是 3 个 9。回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。</p><p>另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader 问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以<br>不久 leader 就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。</p><p>当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。</p><h3 id="从价值出发－找寻学习与工作的新思路"><a href="#从价值出发－找寻学习与工作的新思路" class="headerlink" title="从价值出发－找寻学习与工作的新思路"></a>从价值出发－找寻学习与工作的新思路</h3><p>迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？明确自身的业务相关主体：找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。</p><p>向前一步，为更大的价值负责：不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。</p><p>像架构师一样思考，用价值找寻重心：人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。学会连接，构建体系：前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是架构？&quot;&gt;&lt;a href=&quot;#什么是架构？&quot; class=&quot;headerlink&quot; title=&quot;什么是架构？&quot;&gt;&lt;/a&gt;什么是架构？&lt;/h3&gt;&lt;p&gt;在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《不止代码》摘句(一)</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2019/02/16/《不止代码》摘句(一)/</id>
    <published>2019-02-16T05:57:20.000Z</published>
    <updated>2019-02-16T15:21:50.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一阶段：大学毕业3到5年"><a href="#第一阶段：大学毕业3到5年" class="headerlink" title="第一阶段：大学毕业3到5年"></a>第一阶段：大学毕业3到5年</h3><p>● 基础的 Java 知识：你会开始看《Java 编程思想》、《Effective Java》。</p><p>● 高质量代码进阶知识：你会开始看《重构：改善既有代码的设计》、《代码大全》、《编程珠玑》。</p><p>● 常用的主流框架：比如 SSH 相关的《Spring 实战》、《Spring Boot 实战》、《Hibernate 实战 ( 第 2 版 )》。当然，这些书已经不够了，你会通过 Google、Baidu 大量地浏览在线的资源：Apache 官网、Spring 官网、Hibernate 官网。你会去 StackOverflow 问问题或找答案。</p><p>● 系统设计与算法知识：《系统分析与设计方法》、《设计模式》、《需求分析与系统设计》、《面向对象分析与设计》、《UML 用户指南》、《算法导论》</p><p>● 其他知识：比如数据库调优、缓存框架、NoSQL 数据库、日志框架等等</p><p>在这5年间，快速地完成这些基础知识的学习，并能在项目中快速地学以致用。不仅自身能获得比较高的成就感，而且实际的用人的单位、猎头也会非常喜欢这类熟练工。</p><p>从大部分人的实际发展轨迹看，这个阶段发展快的人和正常发展速度的人，差别还不是很大。比如，发展非常快的人，从毕业就入职阿里的 P5 到P7（注：阿里内部职称评级），可能三年就可以做到。发展速度正常的人，可能需要 5-6 年也可以到 P7。也就是说，这个阶段正常发展速度的同学也仅仅比发展速度快的人慢 2-3 年而已。</p><p>这 2 到 3 年的差距，是可以通过有针对性的学习、重大项目的历练等完成这些知识的学习。无非是，有的同学会严格要求自己，有严格的学习计划；有的同学赶早参加了一些重点的、痛苦的项目得到了锻炼。只要是做技术的，其实迟早都会经历过，都会成长起来。</p><h3 id="第二阶段：大学毕业-5-到-10-年"><a href="#第二阶段：大学毕业-5-到-10-年" class="headerlink" title="第二阶段：大学毕业 5 到 10 年"></a>第二阶段：大学毕业 5 到 10 年</h3><p>很多本科同学，特别是研究生同学。在毕业 10 年后，就已经到了 34、35 岁左右了。也是前段时间网上广泛讨论的所谓 34+ 岁现象。其实，年龄并不是问题的真正原因。真正的原因还是在于自身“竞争力”是否符合这个年龄所应该具备的。到了这个年龄的人，往往已经不是“个人贡献者”了，而是“团队贡献者”。团<br>队贡献者可能是带团队的 TL，也可能是个架构师，在技术决策上具有团队影响力和话语权。</p><h4 id="那么，为什么这些人能管理团队或者有影响力呢？"><a href="#那么，为什么这些人能管理团队或者有影响力呢？" class="headerlink" title="那么，为什么这些人能管理团队或者有影响力呢？"></a>那么，为什么这些人能管理团队或者有影响力呢？</h4><p>从公司的经营视角看，一个管理团队的人，他必须为业务的成功负责。说个大白话，一个 TL 管了 N 个人，他至少要能保证大家输出所产生的价值，至少要高于这个团队的工资、奖金、五险一金、OPEX、CAPEX 等等吧。这个 TL 为了大家输出得有价值，他是不是需要能：</p><p>● 能对所负责领域的业务特点、发展趋势、友商竞争分析有很好的洞察？能知道这个业务领域的客户是谁？他们的需求是什么？他们的痛点是什么？所以，这个 TL 应该需要学习《咨询的奥秘》、《探索需求》、《系统化思维导论》。对于技术型的 TL，还应该了解《成为技术领导者：掌握全面解决问题的方法》。</p><p>● 服务于特定领域的客户，我们需要能了解我们的客户企业架构、业务知识。要了解清楚规划的产品、服务，什么才是客户所需要的。那么，从理论上，我们是否应该学习一些 TOGAF、NGOSS、ITIL 等业务理论以及业务知识？</p><p>● 作为 TL， 是否有必要能将自己对于市场的洞察转换成业务规划，并能向自己的老板（或者投资人）说清楚、讲明白？并争取到老板的同意，包括资金、人力资源等。对于，能否把事情讲明白，我们可能需要学习《金字塔原理》，并能非常清晰、有逻辑性地进行表达与沟通。当然，有些业务发展的事不一定特别有逻辑，是需要摸索、尝试，那么你是否能将一个不确定的领域说服老板并获得支持，我们又需要什么？《博弈论》、《影响力》等。</p><p>● 获得老板支持后，就需要开始带着兄弟们干活了。作为带头人，你看我们是否需要能将业务趋势、客户痛点进行业务建模好让团队的 PD、技术都能理解？在做业务进一步深入分析，可能就需要学习《领域驱动设计 : 软件核心复杂性应对之道》、《实现领域驱动设计》、《企业应用架构模式》、《恰如其分的软件架<br>构》等等。</p><p>● 做完业务设计后，开始要带着团队做技术方案设计、接口设计以及编码实现等。这个过程，TL 又需要具备软件项目管理的能力。无论是《PMBOK 指南》，还是《敏捷软件开发》、《人月神话》、《程序开发心理学》，相信总归还是会有点帮助的。</p><p>● 对于一些有国际化要求的，还需要再学习英语吧！</p><p>● 嗯，还需要有个好的身体，还需要经常锻炼，学习科学的健身吧（说起来自己脸红）。至少我明白了一个道理，以前我都是跟自己说，等这段时间过了，闲下来去锻炼一下。其实，我发现，越是忙的时候，越需要锻炼身体！</p><p>● 另外，在这 10 年内，比较关键的是——你还经历过什么有挑战的业务、技术、产品、平台等方面的成功与失败经验？在这些经历里，你可能会遇到这些困难与挑战：团队磨合的挑战、技术方案上的争执、平台优先 or 业务优先的博弈、低落的团队氛围、个人的低谷等等。这些困难与挑战，你是退缩了？还是有成长？在带团队时，再次面临这些挑战时，这时你是否有解或者有勇气了？</p><p>发现没有？毕业 10 年后，作为一个团队贡献者，你可能需要具备这些能力，并且还远远不止。而且，更可悲的时，当毕业 10 年后，突然发现自己不具备这个能力时（比如晋升失败时发现了），这些能力GAP就不再是 2 到 3 年就能追得上的了。我见过一些有准备的同学，他们给自己的目标是在毕业第 7 年就要具备这些能力，他有严格的学习计划、实践计划、甚至是冒险的创业经历。当他到第 10 年这个点时，这些高阶技能很可能已经有 3 年的实践经验了。如果我们没有做好准备，10 年后，如何和这批人竞争？这些软、硬知识，从十年这个时间刻度倒排，学习计划、实践计划的执行还是很紧张的。所以，从现在开始给自己制定一个严格的学习计划、严格执行，多实践吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一阶段：大学毕业3到5年&quot;&gt;&lt;a href=&quot;#第一阶段：大学毕业3到5年&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：大学毕业3到5年&quot;&gt;&lt;/a&gt;第一阶段：大学毕业3到5年&lt;/h3&gt;&lt;p&gt;● 基础的 Java 知识：你会开始看《Java 编
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>RequestBody注解</title>
    <link href="http://www.echodemo.cc/2019/02/11/RequestBody%E6%B3%A8%E8%A7%A3/"/>
    <id>http://www.echodemo.cc/2019/02/11/RequestBody注解/</id>
    <published>2019-02-11T12:53:31.000Z</published>
    <updated>2019-02-11T13:52:27.982Z</updated>
    
    <content type="html"><![CDATA[<p>1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。</p><p>2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p><p>3、在后端的同一个接收方法里，@RequestBody 与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</p><p>4、当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、数组、集合、对象等等(即:当@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。</p><p>5、如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值)，如果没有xxx名的话，那么请求会出错，报400。如果参数前不写@RequestParam(xxx)的话，那么前端可以有也可以没有对应的xxx名字，如果有xxx名的话，那么就会自动匹配；没有的话，请求也能正确发送。</p><p>6、如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求:</p><p>(1)后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时,会根据json字符串中的key来匹配对应实体类的属性,如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性,这一条会在本节末尾详细分析。</p><p>(2)json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””,如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。json字符串中，如果value为null的话，后端对应收到的就是null。</p><p>(3)如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中;要么写value时，必须有值，null  或””都行。千万不能有类似”stature”:,这样的写法。</p><p>7、举例说明</p><p>(1)创建User类：</p><pre><code>package com.aspire.entity;/** * 用户实体类模型 * * @author JustryDeng * @date 2018年7月6日 上午1:55:59 */@Datapublic class User {    private String name;    private Integer age;    private String gender;    private String motto;    @Override    public String toString() {        return age + &quot;岁&quot; + gender + &quot;人[&quot; + name + &quot;]的座右铭居然是: &quot; + motto + &quot;!!!&quot;;    }}</code></pre><h4 id="注：-Data注解请见Lombok"><a href="#注：-Data注解请见Lombok" class="headerlink" title="注：@Data注解请见Lombok"></a>注：@Data注解请见<a href="http://www.echodemo.cc/2019/02/01/Lombok/">Lombok</a></h4><p>(2)创建Team类：</p><pre><code>package com.aspire.entity;import java.util.List;/** * 小组测试实体类模型 * * @author JustryDeng * @date 2018年7月8日 下午11:23:51 */@Datapublic class Team {    private Integer id;    private String teamName;    private List&lt;String&gt; honors;    private List&lt;User&gt; teamMembers;    /**     * 重写toString     *      * @see java.lang.Object#toString()     */    @Override    public String toString() {        // 遍历出小组所获荣耀        StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;);        for (String honor : honors) {            sbHonors.append(honor);            sbHonors.append(&quot;\n&quot;);        }        sbHonors.append(&quot;荣耀end----\n&quot;);        // 遍历出小组成员        StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;);        for (User user : teamMembers) {            sbMembers.append(user.toString());            sbMembers.append(&quot;\n&quot;);        }        sbMembers.append(&quot;成员end----\n&quot;);        return &quot;小组id:&quot; + id + &quot;\n&quot; + &quot;小组名字:&quot; + teamName + &quot;\n&quot; + &quot;小组所获荣誉:&quot;                    + sbHonors + &quot;\n&quot; + &quot;小组成员:&quot; + sbMembers;    }}</code></pre><p>(3)@RequestBody直接以String接收前端传过来的json数据:</p><pre><code>@RequestMapping(&quot;mytest0&quot;)public String myTestController0(@RequestBody String jsonString) {    System.out.println(jsonString);    return jsonString;}</code></pre><p>(4)@RequestBody以简单对象接收前端传过来的json数据(SpringMVC会智能的将符合要求的数据装配进该User对象中):</p><pre><code>@RequestMapping(&quot;mytest1&quot;)public String myTestController1(@RequestBody User user) {    System.out.println(user.toString());    return user.toString();}</code></pre><p>(5)以较复杂的Team对象接收前端传过来的json数据 (SpringMVC会智能的将符合要求的数据装配进该Teamr对象中):</p><pre><code>@RequestMapping(&quot;mytest2&quot;)public String myTestController2(@RequestBody Team team) {    System.out.println(team.toString());    return team.toString();}</code></pre><p>(6)@RequestBody与简单的@RequestParam()同时使用:</p><pre><code>@RequestMapping(&quot;mytest3&quot;)public String myTestController3(@RequestBody User user, @RequestParam(&quot;token&quot;) String token) {    System.out.println(user.toString());    System.out.println(token);    return token + &quot;&gt;&gt;&gt;&quot; + user.toString();}</code></pre><p>(7)@RequestBody与复杂的@RequestParam()同时使用:</p><pre><code>@RequestMapping(&quot;mytest5&quot;)public String myTestController5(@RequestBody User user, @RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays) {    System.out.println(user.toString());    StringBuffer sb = new StringBuffer();    for (String array : arrays) {        sb.append(array);        sb.append(&quot;  &quot;);        System.out.println(array);    }    return sb.toString() + user.toString();}</code></pre><p>(8)@RequestBody接收请求体中的json数据;不加注解接收URL中的数据并组装为对象:</p><pre><code>@RequestMapping(&quot;mytest4&quot;)public String myTestController4(@RequestBody User user1,  User user2) {    System.out.println(user1.toString());    System.out.println(user2.toString());    return user2.toString() + &quot;\n&quot; + user1.toString();}</code></pre><h4 id="注：该文章转载自-RequestBody的使用"><a href="#注：该文章转载自-RequestBody的使用" class="headerlink" title="注：该文章转载自@RequestBody的使用"></a>注：该文章转载自<a href="https://blog.csdn.net/justry_deng/article/details/80972817" target="_blank" rel="noopener">@RequestBody的使用</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。&lt;/p&gt;
&lt;p&gt;2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。&lt;/p&gt;
&lt;p&gt;3、在后端的
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>System进程占用80端口</title>
    <link href="http://www.echodemo.cc/2019/02/11/System%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A880%E7%AB%AF%E5%8F%A3/"/>
    <id>http://www.echodemo.cc/2019/02/11/System进程占用80端口/</id>
    <published>2019-02-11T12:38:43.000Z</published>
    <updated>2019-02-11T12:52:18.034Z</updated>
    
    <content type="html"><![CDATA[<p>80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，主要用于WWW（World Wide Web）即万维网传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入“:80”了。</p><p>8080、8001等端口其实本质上没什么区别，而且它们本身无实际意义，只是用于代理服务器端口来代理服务，如tomcat、nginx、IIS等。大部分服务提供方都默认使用8080端口用于WWW代理服务，因此经常会发现8080端口被占用的情况。但我们可以通过修改配置文件来解决端口占用问题，如改成8001等。</p><p>1、在windows的cmd窗口中输入：netstat -ano|findstr “80”。查看80端口占用对应的PID。再使用：tasklist发现是System进程占用了80端口。接下来不管是在任务管理器中找到System进程后，选中，结束进程，还是直接在窗口中输入：taskkill /pid (pid号) -f。发现都无法解决。原来System进程它是Windows页面内存管理进程，拥有0级优先权，没有它系统无法启动。 也就是说，System进程是无法关闭的，如果你强行结束system进程树会直接导致蓝屏。</p><h3 id="2、后来发现是SqlServer的Reporting-Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。"><a href="#2、后来发现是SqlServer的Reporting-Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。" class="headerlink" title="2、后来发现是SqlServer的Reporting Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。"></a>2、后来发现是SqlServer的Reporting Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，主要用于WWW（World Wide Web）即万维网传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok</title>
    <link href="http://www.echodemo.cc/2019/02/01/Lombok/"/>
    <id>http://www.echodemo.cc/2019/02/01/Lombok/</id>
    <published>2019-02-01T13:28:32.000Z</published>
    <updated>2019-02-11T13:10:43.109Z</updated>
    
    <content type="html"><![CDATA[<p>Lombok项目是一个Java库，它能够自动嵌入到你的IDE编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有val特性等。它基本上支持所有主流的 IDE 开发工具及编译构建工具。比如Eclipse、IDEA、Myeclipse等等。</p><p>在IDEA中安装该插件，首先去下载好和你的IDEA版本匹配的包，打开Settings，点击plugins，选择Install plugin from disk导入下载好的包导入即可。（在 IDEA 中安装 Lombok 插件，这样在使用 Lombok 的时候就不会编译报错。）最后要在Maven 的依赖配置中引入lombok依赖。</p><p>1、添加 @Getter 和 @Setter 注解用在 Java Bean 类上面，无需生成 get/ set 方法，会自动生成所有的 get/ set 方法及一个默认的构造方法。</p><p>2、@ToString使用在类上，默认生成所有非静态字段以下面的格式输出。</p><p>3、@NoArgsConstructor用在类上，用来生成一个默认的无参构造方法。</p><p>4、@RequiredArgsConstructor用在类上，使用类中所有带有 @NonNull 注解和 final 类型的字段生成对应的构造方法。</p><p>5、@AllArgsConstructor用在类上，生成一个所有参数的构造方法，默认不提供无参构造方法。</p><p>6、@Data用在类上，等同于下面这几个注解合集。</p><pre><code>@Getter@Setter@RequiredArgsConstructor@ToString@EqualsAndHashCode</code></pre><p>7、@Value用在类上，等同于下面这几个注解合集。</p><pre><code>@Getter@FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE)@AllArgsConstructor@ToString@EqualsAndHashCode</code></pre><p>8、@NonNull用在属性上，用于字段的非空检查，如果传入到 set 方法中的值为空，则抛出空指针异常，该注解也会生成一个默认的构造方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lombok项目是一个Java库，它能够自动嵌入到你的IDE编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有val特性等。它基本上支持所有主流的 IDE 开发工具及编译构建工具。比如Eclipse、IDEA、Myeclipse等等。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="杂说" scheme="http://www.echodemo.cc/tags/%E6%9D%82%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://www.echodemo.cc/2019/01/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2019/01/30/Linux常用命令/</id>
    <published>2019-01-30T09:26:32.000Z</published>
    <updated>2019-01-30T09:29:08.805Z</updated>
    
    <content type="html"><![CDATA[<p>1、查看当前在线用户</p><pre><code>[root@jaja ~]# w</code></pre><p>2、查看Linux版本</p><pre><code>[root@jaja ~]# lsb_release -a</code></pre><p>3、查看进程树</p><pre><code>[root@jaja docker]# pstree -p</code></pre><p>4、使用ZMODEM进行文件传输</p><pre><code>从Windows上传至Linux：[root@jaja docker]# rz从Linux下载至Windows：[root@jaja docker]# sz</code></pre><p>5、查看内存使用情况</p><pre><code>[root@jaja docker]# free -m</code></pre><p>6、查看磁盘剩余空间</p><pre><code>[root@jaja docker]# df -h</code></pre><p>7、查看Linux内核版本</p><pre><code>[root@jaja docker]# uname -r </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、查看当前在线用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja ~]# w
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、查看Linux版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja ~]# lsb_release -a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、查看进
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://www.echodemo.cc/2019/01/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2019/01/20/Docker常用命令/</id>
    <published>2019-01-20T04:16:40.000Z</published>
    <updated>2019-01-30T09:26:43.577Z</updated>
    
    <content type="html"><![CDATA[<p>1、查看所有的容器</p><pre><code>[root@jaja docker]# docker ps -a</code></pre><p>2、查看正在运行的容器</p><pre><code>[root@jaja docker]# docker ps</code></pre><p>3、启动已终止的容器</p><pre><code>[root@jaja docker]# docker start (container id)</code></pre><p>4、终止已启动的容器</p><pre><code>[root@jaja docker]# docker stop (container id)</code></pre><p>5、重启容器</p><pre><code>[root@jaja docker]# docker restart (container id)</code></pre><p>6、进入容器交互式环境</p><pre><code>[root@jaja docker]# docker exec -it (container id) /bin/bash</code></pre><p>7、退出容器交互式环境</p><pre><code>[root@jaja docker]# exit 或者使用快捷键 Ctrl + D</code></pre><p>8、导出容器</p><pre><code>[root@jaja docker]# docker export (container id) &gt; (filename).tar</code></pre><p>9、导入容器</p><pre><code>[root@jaja docker]# cat (filename).tar | docker import - (image name):(tag)</code></pre><p>10、查看当前宿主机上的镜像列表</p><pre><code>[root@jaja docker]# docker image ls 或者 docker images</code></pre><p>11、删除处于终止状态的容器</p><pre><code>(1)直接终止容器：[root@jaja docker]# docker rm (container id)(2)如果正在运行则要先终止：[root@jaja docker]# docker stop (container id)</code></pre><p>12、删除所有处于终止状态的容器</p><pre><code>[root@jaja docker]# docker container prune</code></pre><p>13、打印容器的标准输出</p><pre><code>[root@jaja docker]# docker logs</code></pre><p>14、删除镜像(在删除镜像之前需要先停止容器，再删除容器)</p><pre><code>[root@jaja docker]# docker rmi (image id)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、查看所有的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja docker]# docker ps -a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、查看正在运行的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja docker]# docker ps
&lt;/code
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>醒来</title>
    <link href="http://www.echodemo.cc/2019/01/20/%E9%86%92%E6%9D%A5/"/>
    <id>http://www.echodemo.cc/2019/01/20/醒来/</id>
    <published>2019-01-20T02:16:34.000Z</published>
    <updated>2019-01-20T04:07:40.437Z</updated>
    
    <content type="html"><![CDATA[<p>来呀，将我从一场忧伤的梦中惊醒</p><p>把我的沉睡赶走</p><p>这该死的虚无</p><p><br><br>昨夜的大雨</p><p>无尽的黑夜</p><p>喧嚣的逼仄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来呀，将我从一场忧伤的梦中惊醒&lt;/p&gt;
&lt;p&gt;把我的沉睡赶走&lt;/p&gt;
&lt;p&gt;这该死的虚无&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;昨夜的大雨&lt;/p&gt;
&lt;p&gt;无尽的黑夜&lt;/p&gt;
&lt;p&gt;喧嚣的逼仄&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 买卖股票的最佳时机 II</title>
    <link href="http://www.echodemo.cc/2019/01/19/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <id>http://www.echodemo.cc/2019/01/19/LeetCode-买卖股票的最佳时机-II/</id>
    <published>2019-01-19T15:49:20.000Z</published>
    <updated>2019-01-19T16:29:19.452Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><pre><code>示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;pre&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之通过XML装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配Bean之通过XML装配Bean/</id>
    <published>2019-01-12T08:27:20.000Z</published>
    <updated>2019-01-27T06:44:14.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建XML配置规范"><a href="#1、创建XML配置规范" class="headerlink" title="1、创建XML配置规范"></a>1、创建XML配置规范</h3><p>在使用XML为Spring装配bean之前，需要创建一个新的配置规范。在使用JavaConfig的时候，这意味着要创建一个带有@Configuration注解的类，而在XML配置中，这意味着要创建一个XML文件，并且要以beans元素为根。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- ... --&gt;&lt;/beans&gt;</code></pre><h3 id="2、声明一个简单的bean"><a href="#2、声明一个简单的bean" class="headerlink" title="2、声明一个简单的bean"></a>2、声明一个简单的bean</h3><p>要在基于XML的Spring配置中声明一个bean，我们要使用spring-beans模式中的另外一个元素：bean。bean元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明CompactDisc bean：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code></pre><p>当Spring发现这个bean元素时，它将会调用SgtPeppers的默认构造器来创建bean。</p><h3 id="3、借助构造器注入初始化的bean"><a href="#3、借助构造器注入初始化的bean" class="headerlink" title="3、借助构造器注入初始化的bean"></a>3、借助构造器注入初始化的bean</h3><h4 id="1-构造器注入bean的引用"><a href="#1-构造器注入bean的引用" class="headerlink" title="(1)构造器注入bean的引用"></a>(1)构造器注入bean的引用</h4><p>1)使用constructor-arg元素：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot;/&gt;&lt;/bean&gt;</code></pre><p>2)使用Spring3.0所引入的c-命名空间：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;     c:cd-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>属性名以c:开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后”-ref”，告诉Spring正在装配的是一个bean的引用。</p><p>在这里它直接引用构造器参数的名称即上面的”cd”，如果参数的名称修改了，此处的配置也要进行修改，因此可以使用参数在整个参数列表中的位置来替代：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;      c:_0-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>如果只有一个构造器参数则可以使用下面的方案：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;      c:_-ref=&quot;compactDisc&quot;/&gt;</code></pre><h5 id="注：使用c-命名空间需要先在XML的顶部声明其模式："><a href="#注：使用c-命名空间需要先在XML的顶部声明其模式：" class="headerlink" title="注：使用c-命名空间需要先在XML的顶部声明其模式："></a>注：使用c-命名空间需要先在XML的顶部声明其模式：</h5><pre><code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></pre><h4 id="2-将字面量注入到构造器中"><a href="#2-将字面量注入到构造器中" class="headerlink" title="(2)将字面量注入到构造器中"></a>(2)将字面量注入到构造器中</h4><pre><code>package soundsystem;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    public BlankDisc(String title, String artist) {        this.title = title;        this.artist = artist;    }}</code></pre><p>1) 使用constructor-arg元素：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;&lt;/bean&gt;</code></pre><p>2)使用c-命名空间：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_title=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;      c:_artist=&quot;The Beatles&quot;/&gt;</code></pre><p>或</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_0=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;      c:_1=&quot;The Beatles&quot;/&gt;</code></pre><p>如果只有一个构造器参数：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;</code></pre><h4 id="3-装配集合"><a href="#3-装配集合" class="headerlink" title="(3)装配集合"></a>(3)装配集合</h4><pre><code>package soundsystem;import java.util.List;import soundsystem.CompactDisc;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    private List&lt;String&gt; tracks;    public BlankDisc(String title, String artist, List&lt;String&gt; tracks) {        this.title = title;        this.artist = artist;        this.tracks = tracks;    }}</code></pre><p>1)使用list元素将其声明为一个列表(目前，使用c-命名空间的属性无法实现装配集合的功能)。</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/list&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><p>或</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;set&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/set&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><p>2)使用ref元素替代value,从而实现bean引用列表的装配。</p><p>假设现在有一个Discography类,它的构造器如下：</p><pre><code>public Discography(String artist, List&lt;CompactDisc cds) { ... }</code></pre><p>那么可以以如下的方式配置它的bean：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;ref bean=&quot;sgtPeppers&quot;/&gt;            &lt;ref bean=&quot;whiteAlbum&quot;/&gt;            ...            &lt;ref bean=&quot;revolver&quot;/&gt;        &lt;/list&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><h4 id="4-设置属性"><a href="#4-设置属性" class="headerlink" title="(4)设置属性"></a>(4)设置属性</h4><p>(1)setter方法注入bean的引用：</p><pre><code>package soundsystem;import soundsystem.CompactDisc;import soundsystem.MediaPalyer;import org.springframework.beans.factory.annotation.Autowired;public class CDPlayer implements MediaPalyer {    private CompactDisc compactDisc;    @Autowired    public void setCompactDisc(CompactDisc compactDisc) {        this.compactDisc = compactDisc;    }}</code></pre><p>在这之前都是通过构造器来进行注入的，没有使用属性的setter方法，现在我们来看一下如何使用spring XML实现属性的注入。property元素为属性的setter方法所提供的功能与constructor-arg元素为构造器所提供的功能是一样的。</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;property name=&quot;compactDisc&quot; ref=&quot;compaceDisc&quot; /&gt;&lt;/bean&gt;</code></pre><p>(2)setter方法将字面量注入到属性中：</p><pre><code>package soundsystem;import java.util.List;import soundsystem.CompactDisc;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    private List&lt;String&gt; tracks;    public void setTitle(String title) {        this.title = title;    }    public void setArtist(String artist) {        this.artist = artist;    }    public void setTracks(List&lt;String&gt; tracks) {        this.tracks = tracks;    }}</code></pre><p>这里和先前的constructor-arg装配tracks是完全一样的：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、创建XML配置规范&quot;&gt;&lt;a href=&quot;#1、创建XML配置规范&quot; class=&quot;headerlink&quot; title=&quot;1、创建XML配置规范&quot;&gt;&lt;/a&gt;1、创建XML配置规范&lt;/h3&gt;&lt;p&gt;在使用XML为Spring装配bean之前，需要创建一个新的配置规范
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之通过Java代码装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配Bean之通过Java代码装配Bean/</id>
    <published>2019-01-12T07:37:41.000Z</published>
    <updated>2019-01-12T08:29:53.196Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。此时，你必须采取显式装配的方式，在进行显式配置的时候，有两种可选的方案：Java和XML。下面主要是学习如何使用Java来进行配置。在读这篇文章之前，建议先阅读我的上一篇文章<strong><big><a href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/">装配bean之自动化装配Bean</a><big></big></big></strong></p><h3 id="1、创建配置类"><a href="#1、创建配置类" class="headerlink" title="1、创建配置类"></a>1、创建配置类</h3><pre><code>@Configurationpublic class CDPlayerConfig{    ...}</code></pre><p>创建 JavaConfig 的关键在于为其添加@Configuration注解，此外，该类应该包含在Spring应用上下文中创建bean的细节。</p><h3 id="2、声明简单的bean"><a href="#2、声明简单的bean" class="headerlink" title="2、声明简单的bean"></a>2、声明简单的bean</h3><p>(1)要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解，下面的代码声明了CompactDisc bean:</p><pre><code>@Beanpublic CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><p>@Bean注解会告诉Spring这个方法会返回一个对象，该对象需要注册为Spring应用上下文中的bean，方法体中包含了最终产生bean实例的逻辑。</p><p>(2)默认情况下，bean的ID与带有@Bean注解的方法名是一样的。如果你想为其设置一个不同的名字的话，你可以重命名该方法，或者通过name属性指定一个不同的名字。如下：</p><pre><code>@Bean(name=&quot;lonelyHeartsClubBand&quot;)public CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><h3 id="3、借助JavaConfig注入"><a href="#3、借助JavaConfig注入" class="headerlink" title="3、借助JavaConfig注入"></a>3、借助JavaConfig注入</h3><p>(1)我们前面所声明的CompactDisc bean是非常简单的，其自身没有其他的依赖。现在，我们需要声明CDPlayer bean，它依赖于CompactDisc，在JavaConfig中要像下面那样将它们装配到一起：</p><pre><code>@Beanpublic CDPlayer cdPlayer(){    return new CDPlayer(sgtPeppers());}</code></pre><p>看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此，在默认情况下，Spring中的bean都是单例的，因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。即对sgtPeppers()方法的调用返回的是Spring本身在调用sgtPeppers()时所创建的CompactDisc bean。</p><p>(2)可以看到，通过方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：</p><pre><code>@Beanpublic CDPlyer cdPlayer(CompactDisc compactDisc) {    return new CDPlayer(compactDisc);}</code></pre><p>通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowir
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之自动化装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配bean之自动化装配Bean/</id>
    <published>2019-01-12T04:21:32.000Z</published>
    <updated>2019-01-12T07:26:36.783Z</updated>
    
    <content type="html"><![CDATA[<p>Spring从两个角度来实现自动化装配：</p><p>(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。</p><p>(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。</p><h3 id="1、创建可被发现的Bean"><a href="#1、创建可被发现的Bean" class="headerlink" title="1、创建可被发现的Bean"></a>1、创建可被发现的Bean</h3><p>(1)创建一个接口CompactDisc：</p><pre><code>package soundsystem;public interface CompactDisc{    void play();}</code></pre><p>(2)创建带有@Component注解的CompactDisc接口的一个实现类：</p><pre><code>package soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc{    private String title = &quot;Sgt, Pepper&apos;s Lonely Hearts Club Band&quot;;    private String artist = &quot;The Beatles&quot;;    public void play(){        System.out.println(&quot;Playing &quot; + title + &quot; By &quot; + artist);    }}</code></pre><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><h5 id="Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。"><a href="#Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。" class="headerlink" title="@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。"></a>@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。</h5><p>(3)创建配置类:</p><pre><code>package soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig{    ...}</code></pre><h5 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h5><h5 id="ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"><a href="#ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。" class="headerlink" title="@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"></a>@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。</h5><p>(4)当然我们也可以使用XML配置的方式来启动组件扫描：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt;&lt;/beans&gt;</code></pre><p>(5)Junit测试：</p><pre><code>package soundsystem;import org.junit.Test;import static org.junit.Assert.*;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest {    @Autowired    private CompactDisc cd;    @Test    public void cdShuldNotBeNull(){        assertNotNull(cd);    }}</code></pre><h5 id="注：-2"><a href="#注：-2" class="headerlink" title="注："></a>注：</h5><h5 id="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"><a href="#a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。" class="headerlink" title="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"></a>a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。</h5><h5 id="b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"><a href="#b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。" class="headerlink" title="b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"></a>b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。</h5><h5 id="c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。"><a href="#c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。" class="headerlink" title="c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。"></a>c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。</h5><h3 id="2、为组件扫描的bean命名"><a href="#2、为组件扫描的bean命名" class="headerlink" title="2、为组件扫描的bean命名"></a>2、为组件扫描的bean命名</h3><p>(1)Spring上下文中所有的bean都会给定一个ID，若直接使用 @Component 注解来声明一个 bean，其bean 的名字默认为类名首字母小写。例如，如上 SgtPeppers 类的默认 bean 名称为 sgtPeppers。当然我们可以在 @Component 注解中说明此 bean 的名称。</p><pre><code>@Component(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><p>也可以使用另外一种为bean命名的方式：</p><pre><code>@Named(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><h5 id="注：-3"><a href="#注：-3" class="headerlink" title="注："></a>注：</h5><h5 id="Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。"><a href="#Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。" class="headerlink" title="@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。"></a>@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。</h5><h3 id="3、设置组件扫描的基础包"><a href="#3、设置组件扫描的基础包" class="headerlink" title="3、设置组件扫描的基础包"></a>3、设置组件扫描的基础包</h3><p>在之前的案列中，我们没有为 @ComponentScan注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件。但是有个原因会促使我们要明确的设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。</p><p>(1)为了指定不同的包，只需要在 @ComponentScan的value属性中指明包的名称:</p><pre><code>@Configuration@ComponentScan(&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(2)如果你想更加明确的表名你所设置的是基础包，那么你可以通过basePackages属性进行配置:</p><pre><code>@Configuration@ComponentScan(basePackages=&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(3)如果你想扫描多个包，只需要将basePackages属性的值设置为要扫描包的一个数组即可:</p><pre><code>@Configuration@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})public class CDPlayerConfig{    ...}</code></pre><p>(4)在上面的例子当中，basePackages属性的值是一个String类型的数组，这样配置没有问题，但却是类型不安全的，如果要重构代码的话，这些包的名字可能会被修改，从而导致包扫描出现错误，除了将包设置为简单的String类型之外，@ComponentScan 还提供了另一种方法，那就是将其指定为要扫描包中所含的类或接口。</p><pre><code>@Configuration@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})public class CDPlayerConfig{    ...}</code></pre><h5 id="注：-4"><a href="#注：-4" class="headerlink" title="注："></a>注：</h5><h5 id="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"><a href="#你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。" class="headerlink" title="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"></a>你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。</h5><h3 id="4、通过为bean添加注解实现自动装配"><a href="#4、通过为bean添加注解实现自动装配" class="headerlink" title="4、通过为bean添加注解实现自动装配"></a>4、通过为bean添加注解实现自动装配</h3><p>在你的应用程序当中，如果所有的对象都是独立的，彼此之间没有任何的依赖，就像ShtPeppers的bean一样，那么你所需要的可能就是组件的扫描而已。但是很多对象会依赖其他的对象才能完成任务。如此一来，我们就需要有一种方法将组件扫描得到的bean和它们的依赖装配在一起。这就涉及到Spring的自动装配。自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean，这里借助@Autowired注解来声明自动装配。</p><p>(1)以下示例的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器进行实例化并传入一个CompactDisc类型的 bean。<strong><big>@Autowired 注解可以用在类的任何方法上。</big></strong></p><pre><code>@Componentpublic class CDPlayer implements MediaPlayer{    private CompactDisc cd;    @Autowired    public CDPlayer(CompacrDisc cd){        this.cd = cd;    }    public void play(){        cd.play();    }}</code></pre><p>(2)不管是构造器、Setter 方法还是其他方法，Spring 都会尝试满足方法参数上所声明的依赖，假如有且仅有一个bean依赖需求的话，那么这个bean就会被装填进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：</p><pre><code>@Autowired(required=false)public CDPlayer(CompactDisc cd){    this.cd = cd;}</code></pre><h5 id="注：-5"><a href="#注：-5" class="headerlink" title="注："></a>注：</h5><h5 id="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"><a href="#但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。" class="headerlink" title="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"></a>但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。</h5><p>(3)如果有多个bean都能满足依赖关系的话，Spring也将会抛出一个异常，表明没有明确指定要选择那个bean进行装配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring从两个角度来实现自动化装配：&lt;/p&gt;
&lt;p&gt;(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。&lt;/p&gt;
&lt;p&gt;(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发中遇到的几个问题</title>
    <link href="http://www.echodemo.cc/2018/11/30/SpringBoot%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/11/30/SpringBoot开发中遇到的几个问题/</id>
    <published>2018-11-30T04:42:21.000Z</published>
    <updated>2018-11-30T06:51:48.235Z</updated>
    
    <content type="html"><![CDATA[<p>1、java.net.MalformedURLException: no protocol 异常</p><p>在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、java.net.MalformedURLException: no protocol 异常&lt;/p&gt;
&lt;p&gt;在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中的FastJson</title>
    <link href="http://www.echodemo.cc/2018/11/29/SpringBoot%E4%B8%AD%E7%9A%84FastJson/"/>
    <id>http://www.echodemo.cc/2018/11/29/SpringBoot中的FastJson/</id>
    <published>2018-11-29T12:59:47.000Z</published>
    <updated>2018-11-29T13:54:29.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.37&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、导入包和主要的方法"><a href="#2、导入包和主要的方法" class="headerlink" title="2、导入包和主要的方法"></a>2、导入包和主要的方法</h3><p>1、导入包</p><pre><code>import com.alibaba.fastjson.JSON;</code></pre><p>2、将JSONObject转化为String</p><pre><code>String jsonStr = JSONObject.toJsonString(jsonObject);</code></pre><p>3、将String转化为JSONObject</p><pre><code>JSONObject jsonObject = JSONObject.parseObject(jsonStr);</code></pre><p>4、将String转化为JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(jsonStr);</code></pre><p>5、将JSONArray转化为JSONObject</p><pre><code>JSONObject jsonObject = new JOSNObject();for (int i; i &lt; jsonArray.length(); i++) {    jsonObject = jsonArray.getJSONObject[i];}</code></pre><p>6、将JSONObject转化为JOSNArray</p><pre><code>JSONArray jsonObject = JSONObject.get(&quot;key&quot;);</code></pre><p>7、将List转JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(JSON.toJSONString(list))；</code></pre><p>8、将JSONArray转化为List</p><pre><code>List&lt;EventColAttr&gt; list = JSONObject.parseArray(jsonArray.toJSONString(), EventColAttr.class);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/gr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Log4j</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88Log4j/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合Log4j/</id>
    <published>2018-11-20T14:43:58.000Z</published>
    <updated>2018-11-20T14:54:15.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;!-- spring boot start --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- 排除自带的logback依赖 --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- springboot-log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;    &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、Log4j配置文件-建立在和application文件同级的目录下"><a href="#2、Log4j配置文件-建立在和application文件同级的目录下" class="headerlink" title="2、Log4j配置文件(建立在和application文件同级的目录下)"></a>2、Log4j配置文件(建立在和application文件同级的目录下)</h3><pre><code># Log4j配置log4j.rootCategory=INFO,stdout#控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n</code></pre><p>注：该文件里的stdout全部替换成CONSOLE也是没有问题的。当然你也可以在文件中配置file,error,debug等其他的日志信息。</p><h3 id="3、使用Log4j"><a href="#3、使用Log4j" class="headerlink" title="3、使用Log4j"></a>3、使用Log4j</h3><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author EchoDemo * @ClassName cn.aduu.web.HelloController * @Description */@RestControllerpublic class HelloController{    private static final Logger logger = LoggerFactory.getLogger(HelloController.class);    @RequestMapping(&quot;hello&quot;)    public String hello() throws JsonProcessingException {        logger.info(&quot;Hello World！&quot;);        return &quot;hello world&quot;;    }}</code></pre><p>注：启动之后在浏览器访问就好了。</p><h3 id="4、日志打印效果"><a href="#4、日志打印效果" class="headerlink" title="4、日志打印效果"></a>4、日志打印效果</h3><pre><code>十一月 20, 2018 10:42:10 下午 org.apache.catalina.core.ApplicationContext log2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization started信息: Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 23 ms2018-11-20-22-42 [http-nio-8080-exec-1] [com.echodemo.girl.web.UserController] [INFO] - Hello World!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- spring boot start --&amp;gt;
&amp;lt;dependency&amp;gt;
  
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合MyBatis</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合MyBatis/</id>
    <published>2018-11-20T13:51:36.000Z</published>
    <updated>2018-11-20T14:11:18.179Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/saytime/article/details/74783296" target="_blank" rel="noopener">CSDN学习链接</a></p><p>1、无配置文件注解版</p><p>(1)@MapperScan(“com.echodemo.girl.mapper”)这里是包名。</p><p>(2)注意到以下两个SQL语句，insert当中没有user.username是因为当它只有一个对象作为参数传递时本身进行了处理，而update当中，有两个参数传递进来，此时需要@Param的协助，并且需要以user.username的形式把值传给SQL语句当中。而单个的id则直接传递。</p><pre><code>@Insert(&quot;INSERT INTO tb_user(username, age, ctm) VALUES(#{username}, #{age}, now())&quot;)int add(User user);@Update(&quot;UPDATE tb_user SET username = #{user.username}, age = #{user.age} WHERE id = #{id}&quot;)int update(@Param(&quot;id&quot;) Integer id, @Param(&quot;user&quot;) User user);</code></pre><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p><p>2、配置文件注解版</p><p>(1)在userMapper.xml文件当中，resultMap部分，里面的jdbcType类型都需要大写，当时INTEGER只有首字母大写了，然后找bug找了好久。</p><p>(2)在UserMapper当中要加上@Repository注解，不然在UserServiceImpl.java文件中会提示bean不存在。</p><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisConfigAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/saytime/article/details/74783296&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN学习链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、无配置文件注解版&lt;/p&gt;
&lt;p&gt;(1)
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《了不起的盖茨比》</title>
    <link href="http://www.echodemo.cc/2018/11/17/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94%E3%80%8B/"/>
    <id>http://www.echodemo.cc/2018/11/17/《了不起的盖茨比》/</id>
    <published>2018-11-17T14:43:39.000Z</published>
    <updated>2018-11-17T14:57:37.478Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片陌生的天空；他一定感到毛骨悚然，当他发现玫瑰是多么丑恶，而阳光照在刚刚露头的小草上又是多么残忍。这是一个新世界，物质的世界，没有真实可言，可怜的鬼魂呼吸着空气一般的梦想，四处飘荡……就像那个灰蒙蒙的怪人穿过杂乱的树林悄悄向他走来一样。”可以这样说：盖茨比梦想、希望和肉体的覆灭是黛西和汤姆两个人共同的杰作，当然也因为他的纯真和勇敢。但归根究底他是被残酷的社会现实活生生地扼杀的，过去是这样，现在在依然是这样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>洪水猛兽</title>
    <link href="http://www.echodemo.cc/2018/11/14/%E6%B4%AA%E6%B0%B4%E7%8C%9B%E5%85%BD/"/>
    <id>http://www.echodemo.cc/2018/11/14/洪水猛兽/</id>
    <published>2018-11-14T04:59:52.000Z</published>
    <updated>2018-11-14T05:08:25.442Z</updated>
    
    <content type="html"><![CDATA[<p>我已经老了</p><p>在那汹涌的时光之河中逆流而上的</p><p>是我焦急的等待和对幸福的憧憬</p><p>那些孤独、失眠并痛苦着的夜晚</p><p>我是多么渴望</p><p>有一天能够在某个幽静的花园里</p><p>在黄色的落叶铺满整个季节的时候</p><p>坐在一棵干枯杏树下的长凳上</p><p>再为你读一首浪漫动情的诗篇</p><p>因为只有这样</p><p>才能缓解我无法避免地从思念的村庄路过时的情绪</p><p>而你并不知道我始终身陷囹圄、画地为牢</p><p>在无穷无尽的深渊里甘为囚徒、难以自拔</p><p>染上了名为爱情的霍乱</p><h6 id="注：此诗因读《霍乱时期的爱情》有感而写"><a href="#注：此诗因读《霍乱时期的爱情》有感而写" class="headerlink" title="注：此诗因读《霍乱时期的爱情》有感而写"></a>注：此诗因读《霍乱时期的爱情》有感而写</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我已经老了&lt;/p&gt;
&lt;p&gt;在那汹涌的时光之河中逆流而上的&lt;/p&gt;
&lt;p&gt;是我焦急的等待和对幸福的憧憬&lt;/p&gt;
&lt;p&gt;那些孤独、失眠并痛苦着的夜晚&lt;/p&gt;
&lt;p&gt;我是多么渴望&lt;/p&gt;
&lt;p&gt;有一天能够在某个幽静的花园里&lt;/p&gt;
&lt;p&gt;在黄色的落叶铺满整个季节的时候&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
</feed>
