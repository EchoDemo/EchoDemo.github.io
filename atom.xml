<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2020-03-01T04:51:40.594Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 用队列实现栈</title>
    <link href="http://www.echodemo.cc/2020/03/01/LeetCode-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://www.echodemo.cc/2020/03/01/LeetCode-用队列实现栈/</id>
    <published>2020-03-01T02:22:10.000Z</published>
    <updated>2020-03-01T04:51:40.594Z</updated>
    
    <content type="html"><![CDATA[<p>使用队列实现栈的下列操作：</p><pre><code>1、push(x) -- 元素 x 入栈2、pop() -- 移除栈顶元素3、top() -- 获取栈顶元素4、empty() -- 返回栈是否为空</code></pre><p>注意:</p><pre><code>1、你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。2、你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。3、你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</code></pre><h3 id="题解1-两个队列，压入O-1-，-弹出-O-n"><a href="#题解1-两个队列，压入O-1-，-弹出-O-n" class="headerlink" title="题解1(两个队列，压入O(1)， 弹出 O(n))"></a>题解1(两个队列，压入O(1)， 弹出 O(n))</h3><p>维护一个队列 q2，这个队列用作临时存储 q1 中出队的元素。q2 中最后入队的元素将作为新的栈顶元素。接着将 q1 中最后剩下的元素出队。我们通过把 q1 和 q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p><pre><code>public class MyStack {    private Queue&lt;Integer&gt; q1;    private Queue&lt;Integer&gt; q2;    private int top;    public MyStack() {        q1 = new LinkedList&lt;&gt;();        q2 = new LinkedList&lt;&gt;();    }    public void push(int x) {        q1.add(x);        top = x;    }    public int pop() {        while (q1.size() &gt; 1) {            top = q1.remove();            q2.add(top);        }        int popValue = q1.remove();        Queue&lt;Integer&gt; temp = q1;        q1 = q2;        q2 = temp;        return popValue;    }    public int top() {        return top;    }    public boolean empty() {        return q1.isEmpty();    }}执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗 :37 MB, 在所有 Java 提交中击败了(木有看到)的用户</code></pre><h3 id="题解2-两个队列，压入O-n-，-弹出-O-1"><a href="#题解2-两个队列，压入O-n-，-弹出-O-1" class="headerlink" title="题解2(两个队列，压入O(n)， 弹出 O(1))"></a>题解2(两个队列，压入O(n)， 弹出 O(1))</h3><p>让每一个新元素从 q2 入队，同时把这个元素作为栈顶元素保存。当 q1 非空（也就是栈非空），我们让 q1 中所有的元素全部出队，再将出队的元素从 q2 入队。通过这样的方式，新元素（栈中的栈顶元素）将会在 q2 的前端。我们通过将 q1， q2 互相交换的方式来避免把 q2 中的元素往 q1 中拷贝。</p><pre><code>public class MyStack {    private Queue&lt;Integer&gt; q1;    private Queue&lt;Integer&gt; q2;    private int top;    public MyStack() {        q1 = new LinkedList&lt;&gt;();        q2 = new LinkedList&lt;&gt;();    }    public void push(int x) {        q2.add(x);        top = x;        while (!q1.isEmpty()) {            q2.add(q1.remove());        }        Queue&lt;Integer&gt; temp = q1;        q1 = q2;        q2 = temp;    }    public int pop() {        int temp = q1.remove();        while (!q1.isEmpty()) {            top = q1.peek();        }        return temp;    }    public int top() {        return top;    }    public boolean empty() {        return q1.isEmpty();    }}</code></pre><p>超时了！</p><h3 id="题解3-一个队列，-压入O-n-，-弹出O-1"><a href="#题解3-一个队列，-压入O-n-，-弹出O-1" class="headerlink" title="题解3(一个队列， 压入O(n)， 弹出O(1))"></a>题解3(一个队列， 压入O(n)， 弹出O(1))</h3><p>每当入队一个新元素的时候，我们可以把队列的顺序反转过来。</p><pre><code>public class MyStack {    private Queue&lt;Integer&gt; q1;    public MyStack() {        q1 = new LinkedList&lt;&gt;();    }    public void push(int x) {        q1.add(x);        int len = q1.size();        while (len &gt; 1) {            q1.add(q1.remove());            len--;        }    }    public int pop() {        return q1.remove();    }    public int top() {        return q1.peek();    }    public boolean empty() {        return q1.isEmpty();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用队列实现栈的下列操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、push(x) -- 元素 x 入栈

2、pop() -- 移除栈顶元素

3、top() -- 获取栈顶元素

4、empty() -- 返回栈是否为空
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;
&lt;pr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 搜索插入位置</title>
    <link href="http://www.echodemo.cc/2020/03/01/LeetCode-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2020/03/01/LeetCode-搜索插入位置/</id>
    <published>2020-03-01T01:36:01.000Z</published>
    <updated>2020-03-01T02:21:04.795Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p><pre><code>示例 1:输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0</code></pre><h3 id="题解-二分查找法"><a href="#题解-二分查找法" class="headerlink" title="题解(二分查找法)"></a>题解(二分查找法)</h3><pre><code>class Solution {    public int strStr(int nums[], int target) {        int len = nums.length;        int left = 0, right = len -1;        int mid = (left + right) / 2;        while (left &lt; right) {            if (nums[mid] == target) {                return mid;            } else if (nums[mid] &gt; target) {                right = mid - 1;            } else {                left = mid + 1;            }            mid = (left + right) / 2;        }        return nums[left] &lt; target ? left + 1 : left;    }}执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗 :38.9 MB, 在所有 Java 提交中击败了47.57%的用户</code></pre><p>后来看精选代码可以稍微优化一点点：</p><pre><code>class Solution {    public int searchInsert(int[] nums, int target) {        int left = 0, right = nums.length - 1;        while(left &lt;= right) {            int mid = (left + right) / 2;            if(nums[mid] == target) {                return mid;            } else if(nums[mid] &lt; target) {                left = mid + 1;            } else {                right = mid - 1;            }        }        return left;    }}执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗 :38.9 MB, 在所有 Java 提交中击败了41.85%的用户</code></pre><p>由此可见，这个跑分还是在波动的，哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [1,3,5,6], 5
输出: 2


示例 2:

输入: [1,3
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 实现strStr()</title>
    <link href="http://www.echodemo.cc/2020/03/01/LeetCode-%E5%AE%9E%E7%8E%B0strStr()/"/>
    <id>http://www.echodemo.cc/2020/03/01/LeetCode-实现strStr()/</id>
    <published>2020-03-01T01:10:27.000Z</published>
    <updated>2020-03-01T01:35:45.558Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><pre><code>示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1</code></pre><p>说明:</p><p>当 needle 是空字符串时，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h3 id="题解1-直接使用java的indexOf-方法-难道它不香吗？"><a href="#题解1-直接使用java的indexOf-方法-难道它不香吗？" class="headerlink" title="题解1(直接使用java的indexOf()方法,难道它不香吗？)"></a>题解1(直接使用java的indexOf()方法,难道它不香吗？)</h3><pre><code>class Solution {    public int strStr(String haystack, String needle) {        return haystack.indexOf(needle);    }}执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗 :38.3 MB, 在所有 Java 提交中击败了5.04%的用户</code></pre><h3 id="题解2-在题解区有一个大神给出了详细的KMP算法解析"><a href="#题解2-在题解区有一个大神给出了详细的KMP算法解析" class="headerlink" title="题解2(在题解区有一个大神给出了详细的KMP算法解析)"></a>题解2(在题解区有一个大神给出了详细的KMP算法解析)</h3><h4 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h4><pre><code>// 伪代码public int strStr(String haystack, String needle) {        int M = needle.length();        int N = haystack.length();        for (int i = 0; i &lt; N - M; i++) {            int j;            for (j = 0; j &lt; M; j++) {                if (needle.charAt(j) != haystack.charAt(i+j))                    break;            }            // 匹配成功            if (j == M) return i;        }        return -1;}</code></pre><p>对于暴力算法，如果出现不匹配字符，同时回退 haystack 和 needle 的指针，嵌套 for 循环，时间复杂度 O(MN)，空间复杂度O(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>KMP 算法的不同之处在于，它会花费空间来记录一些信息。KMP 算法永不回退 haystack 的指针 ，不走回头路（不会重复扫描 haystack），而是借助 dp 数组中储存的信息把 needle 移到正确的位置继续匹配，时间复杂度只需 O(N)，用空间换时间。</p><p>KMP 算法的难点在于，如何计算 dp 数组中的信息？如何根据这些信息正确地移动 needle 的指针？这个就需要确定有限状态自动机来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 dp 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。</p><p>还有一点需要明确的是：计算这个 dp 数组，只和 needle 串有关。意思是说，只要给我个 needle，我就能通过这个模式串计算出 dp 数组，然后你可以给我不同的 haystack，我都不怕，利用这个 dp 数组我都能在 O(N) 时间完成字符串匹配。</p><p>明白了 dp 数组只和 needle 有关，那么我们这样设计 KMP 算法就会比较漂亮：</p><pre><code>public class KMP {    private int[][] dp;    private String needle;    public KMP(String pat) {        this.needle = needle;        // 通过 needle 构建 dp 数组        // 需要 O(M) 时间    }    public int search(String haystack) {        // 借助 dp 数组去匹配 haystack        // 需要 O(N) 时间    }}</code></pre><p>这样，当我们需要用同一 needle 去匹配不同 haystack 时，就不需要浪费时间构造 dp 数组了。<br>更详细的原文解析请见原文<a href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/" target="_blank" rel="noopener">KMP算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: haystack = &amp;quot;hel
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 有效的括号</title>
    <link href="http://www.echodemo.cc/2020/02/29/LeetCode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://www.echodemo.cc/2020/02/29/LeetCode-有效的括号/</id>
    <published>2020-02-29T12:45:39.000Z</published>
    <updated>2020-02-29T12:55:02.079Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>1、左括号必须用相同类型的右括号闭合。2、左括号必须以正确的顺序闭合。注意：空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]{}&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;{[]}&quot;输出: true</code></pre><h3 id="题解-使用栈"><a href="#题解-使用栈" class="headerlink" title="题解(使用栈)"></a>题解(使用栈)</h3><pre><code>class Solution {    public boolean isValid(String s) {        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (int i = 0; i &lt; s.length(); i++) {            char c = s.charAt(i);            if (c == &apos;(&apos; || c == &apos;{&apos; || c == &apos;[&apos;) {                stack.push(c);                continue;            }            if (stack.isEmpty()) return false;            if (c == &apos;)&apos;) {                if (stack.peek() != &apos;(&apos;) break;                stack.pop();            } else if (c == &apos;}&apos;) {                if (stack.peek() != &apos;{&apos;) break;                stack.pop();            } else {                if (stack.peek() != &apos;[&apos;) break;                stack.pop();            }        }        return stack.isEmpty();    }}执行用时 :3 ms, 在所有 Java 提交中击败了56.70%的用户内存消耗 :37.5 MB, 在所有 Java 提交中击败了5.00%的用户</code></pre><h3 id="题解2-官方题解：增加一个map数据结构"><a href="#题解2-官方题解：增加一个map数据结构" class="headerlink" title="题解2(官方题解：增加一个map数据结构)"></a>题解2(官方题解：增加一个map数据结构)</h3><pre><code>class Solution {  private HashMap&lt;Character, Character&gt; mappings;  public Solution() {    this.mappings = new HashMap&lt;Character, Character&gt;();    this.mappings.put(&apos;)&apos;, &apos;(&apos;);    this.mappings.put(&apos;}&apos;, &apos;{&apos;);    this.mappings.put(&apos;]&apos;, &apos;[&apos;);  }  public boolean isValid(String s) {    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();    for (int i = 0; i &lt; s.length(); i++) {      char c = s.charAt(i);      if (this.mappings.containsKey(c)) {        char topElement = stack.empty() ? &apos;#&apos; : stack.pop();        if (topElement != this.mappings.get(c)) {          return false;        }      } else {        stack.push(c);      }    }    return stack.isEmpty();  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、左括号必须用相同类型的右括号闭合。

2、左括号必须以正确的顺序闭合。

注意：空字符串可被认为是有效字符串。
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 回文数</title>
    <link href="http://www.echodemo.cc/2020/02/29/LeetCode-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2020/02/29/LeetCode-回文数/</id>
    <published>2020-02-29T11:38:06.000Z</published>
    <updated>2020-02-29T12:15:37.611Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><pre><code>示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。</code></pre><h3 id="题解1（转字符串）"><a href="#题解1（转字符串）" class="headerlink" title="题解1（转字符串）"></a>题解1（转字符串）</h3><pre><code>class Solution {    public boolean isPalindrome(int x) {        if (x &lt; 0)            return false;        String str = String.valueOf(x);        int len = str.length();        int count = 0;        for (int i = 0; i &lt; len / 2;i++) {            if (str.charAt(i) == str.charAt(len -i - 1)) {                count++;                continue;            }            break;        }        return count == (len / 2);    }}执行用时 :13 ms, 在所有 Java 提交中击败了25.05%的用户内存消耗 :40.5 MB, 在所有 Java 提交中击败了5.00%的用户</code></pre><h3 id="题解2-不转字符串，使用栈"><a href="#题解2-不转字符串，使用栈" class="headerlink" title="题解2(不转字符串，使用栈)"></a>题解2(不转字符串，使用栈)</h3><pre><code>class Solution {    public boolean isPalindrome(int x) {        if (x &lt; 0)            return false;        if (x == 0)            return true;        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();        int i = 0, j =0, y = x;        while (true) {            if (x == 0) break;            s.push(x % 10);            x /= 10;            i++;        }        while (!s.isEmpty()) {            if (s.pop() == (y % 10)) {                j++;                y /= 10;                continue;            }            break;        }        return i == j;    }}执行用时 :22 ms, 在所有 Java 提交中击败了5.05%的用户内存消耗 :40.2 MB, 在所有 Java 提交中击败了5.00%的用户</code></pre><h3 id="题解3-官方题解"><a href="#题解3-官方题解" class="headerlink" title="题解3(官方题解)"></a>题解3(官方题解)</h3><pre><code>class Solution {    public boolean isPalindrome(int x) {        // 特殊情况：        // 如上所述，当 x &lt; 0 时，x 不是回文数。        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，        // 则其第一位数字也应该是 0        // 只有 0 满足这一属性        if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {            return false;        }        int revertedNumber = 0;        while(x &gt; revertedNumber) {            revertedNumber = revertedNumber * 10 + x % 10;            x /= 10;        }        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber || x == revertedNumber/10;    }}执行用时 :9 ms, 在所有 Java 提交中击败了98.74%的用户内存消耗 :40.2 MB, 在所有 Java 提交中击败了5.00%的用户</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 121
输出: true


示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 两数相加</title>
    <link href="http://www.echodemo.cc/2020/02/29/LeetCode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://www.echodemo.cc/2020/02/29/LeetCode-两数相加/</id>
    <published>2020-02-29T09:27:58.000Z</published>
    <updated>2020-02-29T09:33:51.837Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><pre><code>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h3 id="题解：（要考虑int、long等数据类型超长的情况）"><a href="#题解：（要考虑int、long等数据类型超长的情况）" class="headerlink" title="题解：（要考虑int、long等数据类型超长的情况）"></a>题解：（要考虑int、long等数据类型超长的情况）</h3><pre><code>class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        ListNode head = new ListNode(0);        ListNode cur = head;        int carry = 0;        while (l1 != null || l2 != null) {            int x = (l1 != null) ? l1.val : 0;            int y = (l2 != null) ? l2.val : 0;            int sum = carry + x + y;            carry = sum / 10;            cur.next = new ListNode(sum % 10);            cur = cur.next;            if (l1 != null) l1 = l1.next;            if (l2 != null) l2 = l2.next;        }        if (carry &gt; 0) {            cur.next = new ListNode(carry);        }        return head.next;    }    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;pre&gt;&lt;cod
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Docker的网络与容器互联</title>
    <link href="http://www.echodemo.cc/2020/02/25/Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>http://www.echodemo.cc/2020/02/25/Docker的网络与容器互联/</id>
    <published>2020-02-25T13:03:09.000Z</published>
    <updated>2020-02-25T13:21:55.357Z</updated>
    
    <content type="html"><![CDATA[<p>Docker允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>1、容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过“-P”或“-p”参数来指定端口映射。当使用“-P”标记时，Docker会随机映射一个端口到内部容器开放的网络端口。看下面这个例子：</p><pre><code>[root@localhost ~]# docker run -d -P training/webapp python app.py60f400b387ae5d54fc38788837c00f88b4e38c176b495fa28640c030b2071cf5[root@localhost ~]# docker container ls -lCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES60f400b387ae        training/webapp     &quot;python app.py&quot;     10 seconds ago      Up 5 seconds        0.0.0.0:32769-&gt;5000/tcp   zealous_bartik</code></pre><p>使用“docker container ls”可以看到，本地宿主机的32769被映射到了容器的5000端口。此时访问本机的32769端口即可访问容器内web应用提供的界面。同样的，可以通过 docker logs 命令来查看应用的信息。</p><pre><code>[root@localhost ~]# docker logs  60f400b387ae * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)172.16.213.132 - - [08/Dec/2018 14:29:51] &quot;GET / HTTP/1.1&quot; 200 -172.16.213.132 - - [08/Dec/2018 14:29:52] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</code></pre><p>2、另一个参数“-p”则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有：</p><pre><code>ip:hostPort:containerPort ip::containerPort hostPort:containerPort</code></pre><p>例如：使用“hostPort:containerPort”格式将宿主机的5000端口映射到容器的5000端口，可以执行如下命令：</p><pre><code>[root@localhost ~]# docker run -d -p 5000:5000 training/webapp python app.py</code></pre><p>此时默认会绑定宿主机本地所有网络接口上的所有地址。还可以映射到指定地址的指定端口，使用“ip:hostPort:containerPort”格式指定映射使用一个特定地址，比如localhost地址127.0.0.1,可以执行如下命令：</p><pre><code>[root@localhost ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</code></pre><p>也可以映射到指定地址的任意端口，使用“ip::containerPort”绑定“localhost”的任意端口到容器的5000端口，本地宿主机会自动分配一个端口。看下面这个例子：</p><pre><code>[root@localhost ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</code></pre><p>还可以使用udp标记来指定udp端口，例如：</p><pre><code>[root@localhost ~]# docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></pre><p>最后，如何查看映射端口配置呢，可以使用“docker port”命令来查看当前映射的端口配置，也可以查看绑定的地址，例如：</p><pre><code>[root@localhost ~]# docker port 60f400b387ae5000/tcp -&gt; 0.0.0.0:32769</code></pre><p>通过“-p”参数还可以多次使用来绑定多个端口，例如：</p><pre><code>[root@localhost ~]# docker run -d  -p 6000:5000 -p 3000:80  training/webapp   python app.py</code></pre><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>如果你之前有Docker使用经验，那么你对“–link”参数应该比较熟悉，它就是用来进行容器互联的。但是，随着Docker网络的完善和版本的升级，强烈建议大家将容器加入自定义的Docker网络来连接多个容器，而不是使用“–link”参数。</p><p>首先，新建一个docker网络，命令如下：</p><pre><code>[root@localhost ~]# docker network create -d bridge mynet</code></pre><p>其中，“-d”参数指定Docker网络类型，有bridge、overlay等。接着，新运行两个容器，先运行第一个容器并连接到新建的mynet网络，命令如下：</p><pre><code>[root@localhost ~]# docker run -it --rm --name busybox1 --network mynet busybox sh</code></pre><p>然后，打开一个新的终端，再运行一个容器并加入到mynet网络</p><pre><code>[root@localhost ~]# docker run -it --rm --name busybox2 --network mynet busybox sh</code></pre><p>继续打开第三个终端，查看容器信息：</p><pre><code>[root@localhost ~]# docker container ls</code></pre><p>最后，在第一个容器busybox1中ping第二个容器busybox2，看是否能通，如果可以通，那么说明这两个容器已经建立了互联关系。如果你有多个容器之间需要互相连接，推荐使用Docker Compose。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker允许通过外部访问容器或容器互联的方式来提供网络服务。&lt;/p&gt;
&lt;h3 id=&quot;外部访问容器&quot;&gt;&lt;a href=&quot;#外部访问容器&quot; class=&quot;headerlink&quot; title=&quot;外部访问容器&quot;&gt;&lt;/a&gt;外部访问容器&lt;/h3&gt;&lt;p&gt;1、容器中可以运行一些网络应
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 Dockerfile 定制镜像</title>
    <link href="http://www.echodemo.cc/2020/02/25/%E4%BD%BF%E7%94%A8%20Dockerfile%20%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F/"/>
    <id>http://www.echodemo.cc/2020/02/25/使用 Dockerfile 定制镜像/</id>
    <published>2020-02-25T11:30:09.000Z</published>
    <updated>2020-02-25T13:02:34.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编写一个简单的Dockerfile文件"><a href="#编写一个简单的Dockerfile文件" class="headerlink" title="编写一个简单的Dockerfile文件"></a>编写一个简单的Dockerfile文件</h3><p>Dockerfile是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>这里以定制nginx镜像为例，我们使用Dockerfile来定制。在一个空白目录中，建立一个文本文件，并命名为Dockerfile：</p><pre><code>$ mkdir mynginx$ cd mynginx$ touch Dockerfile</code></pre><p>其内容为：</p><pre><code>FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</code></pre><h4 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h4><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><pre><code>FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt;:&lt;digest&gt;</code></pre><h4 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h4><p>RUN指令是用来执行命令行命令的。由于命令行的强大能力，RUN指令在定制镜像时是最常用的指令之一。其格式有两种：</p><pre><code>1、 shell 格式：RUN &lt;命令&gt;2、 exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></pre><p>就像直接在命令行中输入的命令一样。刚才写的Dockerfile中的RUN指令就是shell格式。而exec格式这更像是函数调用中的格式。此命令只有在执行docker build 时才会执行，其他情况下不会执行。</p><p>由于Docker的镜像是分层结构，Dockerfile里面一个指令的操作就是一层。比如下面的操作，一条RUN命令包含了更新源缓存，安装openjdk，清理垃圾，这样的好处是最终这一层会很小，假设你分开写，三个命令三个RUN指令，但是只有第二条命令才是你想要的，那么第一条产生的缓存垃圾就无法删除掉。这也算是docker镜像优化的一部分。</p><pre><code>RUN yum update \&amp;&amp; yum install openjdk-8-jdk  -y \&amp;&amp; yum clean all </code></pre><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>编写好刚才的Dockerfile文件之后，在Dockerfile文件所在目录执行：</p><pre><code>$ docker build -t nginx:v3 .</code></pre><p>在这里我们指定了最终镜像的名称“-t nginx:v3”，构建成功后，我们就可以通过docker images看到nginx:v3这个镜像。如果你注意到上面的docker build命令最后，还有一个<strong>.</strong>，.表示当前目录，而Dockerfile文件就在当前目录，所以，这个点是在指定上下文路径。上面我们使用 docker build命令进行镜像构建。其格式为：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><h3 id="docker-build-的工作原理"><a href="#docker-build-的工作原理" class="headerlink" title="docker build 的工作原理"></a>docker build 的工作原理</h3><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD指令等。而 docker build命令构建镜像，其实并非在本地构建，而是在服务端，也就是Docker引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>实际上Dockerfile的文件名并不要求必须为Dockerfile，而且并不要求必须位于上下文目录中，比如可以用-f参数指定某个文件作为Dockerfile，当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h3 id="Dockerfile常用指令详解"><a href="#Dockerfile常用指令详解" class="headerlink" title="Dockerfile常用指令详解"></a>Dockerfile常用指令详解</h3><h4 id="COPY指令复制文件"><a href="#COPY指令复制文件" class="headerlink" title="COPY指令复制文件"></a>COPY指令复制文件</h4><pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></pre><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 的文件或者目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p><pre><code>COPY package.json /usr/src/app/</code></pre><p>其中源路径可以是多个，甚至可以是通配符，如：</p><pre><code>COPY hom* /mydir/COPY hom?.txt /mydir/</code></pre><p>目标路径：可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><h4 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h4><p>ADD指令和COPY的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。如果&lt;源路径&gt;为一个tar压缩文件的话，压缩格式为gzip, bzip2以及xz的情况下，ADD指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</p><p>Docker官方建议，尽可能的使用COPY，因为COPY的语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合使用ADD的场合，就是所提及的需要自动解压缩的场合。</p><p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p><h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h4><p>CMD指令的格式和RUN相似，也是两种格式：</p><pre><code>shell 格式：CMD &lt;命令&gt;exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></pre><p>注意：Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用于指定默认的容器主进程的启动命令的。在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。</p><p>如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</p><pre><code>CMD echo $HOME</code></pre><p>在实际执行中，会将其变更为：</p><pre><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</code></pre><p><strong>在这里我们不要把RUN和CMD搞混了。RUN是构件容器时就运行的命令以及提交运行结果。CMD是容器启动时执行的命令，在构件时并不运行，构件时仅仅指定了这个命令到底是个什么样子</strong></p><h4 id="VOLUME定义匿名卷"><a href="#VOLUME定义匿名卷" class="headerlink" title="VOLUME定义匿名卷"></a>VOLUME定义匿名卷</h4><pre><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;</code></pre><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><p>看这个例子：</p><pre><code>VOLUME  /data</code></pre><p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。</p><p>那么Dockerfile中的VOLUME指令跟docker run中的-v参数实现的是不是一样的功能呢？并不然，其实VOLUME指令只是起到声明容器中的目录作为匿名卷，但是并没有将匿名卷绑定到宿主机指定目录的功能。但是当我们生成镜像的Dockerfile中以Volume声明了匿名卷，并且我们以这个镜像run了一个容器的时候，docker会在安装目录下的指定目录下面生成一个目录来绑定容器的匿名卷（这个指定目录不同版本的docker会有所不同）。</p><p>也就是说当我们在Dockerfile中声明了匿名卷但是run的时候没有使用 -v绑定匿名卷的话，那么docker就会在/var/lib/docker/volumes这个目录下创建一个目录来绑定匿名卷。</p><h4 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h4><pre><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></pre><p>EXPOSE指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p><p>在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射EXPOSE的端口。要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。</p><p><strong>-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</strong></p><h4 id="WORKDIR指定工作目录"><a href="#WORKDIR指定工作目录" class="headerlink" title="WORKDIR指定工作目录"></a>WORKDIR指定工作目录</h4><pre><code>WORKDIR &lt;工作目录路径&gt;</code></pre><p>使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR会帮你建立目录。可以理解为shell的cd，启动容器的时候使用的意思为 docker run 启动容器时，默认进入到目录是WORKDIR 指定的。</p><h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h4><pre><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></pre><p>USER指令和WORKDIR相似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的执行RUN, CMD以及ENTRYPOINT这类命令的身份。当然，和WORKDIR一样，USER只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。如：</p><pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ &quot;redis-server&quot; ]</code></pre><h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h4><pre><code>ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></pre><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。如：</p><pre><code>ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \  &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \  &amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \  &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \  &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</code></pre><h4 id="HEALTHCHECK健康检查"><a href="#HEALTHCHECK健康检查" class="headerlink" title="HEALTHCHECK健康检查"></a>HEALTHCHECK健康检查</h4><pre><code>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</code></pre><p>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。HEALTHCHECK 支持下列选项：</p><pre><code>--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</code></pre><p><strong>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</strong></p><p>假设我们有个镜像是个最简单的Web服务，我们希望增加健康检查来判断其Web服务是否在正常工作，我们可以用curl来帮助判断，其Dockerfile的 HEALTHCHECK可以这么写：</p><pre><code>FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs http://localhost/ || exit 1</code></pre><p>这里我们设置了每5秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过3秒没响应就视为失败，并且使用“curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1”作为健康检查命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编写一个简单的Dockerfile文件&quot;&gt;&lt;a href=&quot;#编写一个简单的Dockerfile文件&quot; class=&quot;headerlink&quot; title=&quot;编写一个简单的Dockerfile文件&quot;&gt;&lt;/a&gt;编写一个简单的Dockerfile文件&lt;/h3&gt;&lt;p&gt;Do
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker数据管理</title>
    <link href="http://www.echodemo.cc/2020/02/09/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://www.echodemo.cc/2020/02/09/Docker数据管理/</id>
    <published>2020-02-09T12:19:08.000Z</published>
    <updated>2020-02-24T13:56:07.056Z</updated>
    
    <content type="html"><![CDATA[<p>在Docker中，要想实现数据的持久化（所谓docker的数据持久化即数据不随着Container的结束而结束），需要将数据从宿主机挂载到容器中。目前Docker提供了数据卷（Volumes）和挂载主机目录 (Bind mounts)的方式将数据从宿主机挂载到容器中。</p><h3 id="数据卷（Volumes）"><a href="#数据卷（Volumes）" class="headerlink" title="数据卷（Volumes）"></a>数据卷（Volumes）</h3><p>数据卷是Docker管理宿主机文件系统的一部分，它是最常用的docker数据持久化的方式。默认位于 /var/lib/docker/volumes 目录中，所有Container的数据在没有指定卷时都保存在了这个目录下边，所以Docker帮我们默认创建许多匿名（很长ID的名字）卷。数据卷具有如下特性：</p><pre><code>(1)对数据卷的修改会立马生效。(2)对数据卷的更新，不会影响镜像。(3)数据卷默认会一直存在，即使容器被删除。</code></pre><p>1、创建数据卷</p><p>这里是创建一个名为mynginx的容器，并加载一个数据卷到容器的/mynginx目录下，这个命令中可以使用“-v”或者“–mount”标记来将数据卷挂载到容器里。在一次 docker run中可以挂载多个数据卷。</p><pre><code>// 创建一个自定义容器卷docker volume create myvol// 查看所有容器卷docker volume ls// 查看指定容器卷详情信息docker volume inspect myvol// 启动挂载数据卷的容器docker run -d -it --name=mynginx -p 8800:80 -v myvol:/mynginx nginx /bin/bash或者docker run -d -it --name=mynginx -p 8800:80 --mount source=myvol,target=/mynginx nginx /bin/bash</code></pre><p>(1)<strong>-v或者–volume</strong>:由3部分参数组成，使用“:”间隔。顺序不能颠倒。</p><pre><code>(1)volumes的名字在宿主机上具有唯一性。匿名卷名字系统给出。(2)挂载到容器里的文件或文件夹路径。(3)可选项列表分隔符，例如“or”。</code></pre><p>(2)<strong>–mount选项：</strong>由多个键值对组成，<key>=<value>。–mount要比-v或者–volume命令更长，但是更容易理解。常用的键值对有如下几个：</value></key></p><pre><code>(1)type：可以是bind,volume或者tmpfs。type默认为volume。(2)source：volumes的名字，匿名volume可以省略。source可缩写为src。(3)destination：挂载到容器中的文件或目录路径。可也缩写为dst或者使用target。(4)readonly：指定挂载在容器中为只读。</code></pre><p>在主机里使用以下命令可以查看刚刚启动的 mynginx 容器的信息</p><pre><code>docker inspect web</code></pre><p>2、 清理数据卷</p><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用如下命令</p><pre><code>docker rm -v mynginx</code></pre><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>docker volume prune</code></pre><h3 id="挂载主机目录-Bind-mounts"><a href="#挂载主机目录-Bind-mounts" class="headerlink" title="挂载主机目录 (Bind mounts)"></a>挂载主机目录 (Bind mounts)</h3><p>挂载主机目录可以存储在宿主机系统的任意位置，它是比较常用的docker数据持久化的方式。但是，当使用bind mounts时，宿主机的目录或文件被挂载到容器中。容器将按照挂载目录或文件的绝对路径来使用或修改宿主机的中的数据。因此bind mounts在不同的宿主机系统时不可移植的，这也是为什么bind mounts不能出现在Dockerfile中的原因。</p><p>另外，使用bind mounts的容器可以在容器内部的进程中对主机文件系统进行修改，包括创建，修改和删除重要的系统文件和目录，这个功能虽然很强大，但显然也会造成安全方面的影响。所以还是推荐数据卷（Volumes）管理方式。</p><p>1、挂载宿主机目录</p><p>下面的命令加载宿主机的/src/myvol目录到容器的/opt/mynginx目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><pre><code>docker run -d -it --name=mynginx -p 8800:80 -v /src/mynginx:/opt/mynginx nginx /bin/bash或者docker run -d -it --name=mynginx -p 8800:80 --mount type=bind,source=/src/mynginx,target=/opt/mynginx nginx /bin/bash</code></pre><p>Docker挂载宿主机目录的默认权限是读写，用户也可以通过增加readonly指定为只读。这样加了readonly之后，/src/mynginx就挂载为只读了。如果你在容器内/opt/mynginx目录新建文件，会显示“Read-only file system“错误。</p><pre><code>docker run -d -it --name=mynginx -p 8800:80 --mount type=bind,source=/src/mynginx,target=/opt/mynginx,readonly nginx /bin/bash</code></pre><p>除了可以挂载一个宿主机目录，还是可以挂载宿主机的某个文件，例如：</p><pre><code>docker run --rm -it -v $HOME/.bash_history:/root/.bash_history nginx /bin/bash或者docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history nginx /bin/bash</code></pre><p>这样就可以在容器中记录输入过的命令了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Docker中，要想实现数据的持久化（所谓docker的数据持久化即数据不随着Container的结束而结束），需要将数据从宿主机挂载到容器中。目前Docker提供了数据卷（Volumes）和挂载主机目录 (Bind mounts)的方式将数据从宿主机挂载到容器中。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>搭建私有仓库</title>
    <link href="http://www.echodemo.cc/2020/02/09/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://www.echodemo.cc/2020/02/09/搭建私有仓库/</id>
    <published>2020-02-09T09:51:12.000Z</published>
    <updated>2020-02-09T10:18:44.192Z</updated>
    
    <content type="html"><![CDATA[<p>有时候使用 Docker Hub 这样的公共仓库可能不方便，那么，用户也可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。</p><h3 id="Registry的部署"><a href="#Registry的部署" class="headerlink" title="Registry的部署"></a>Registry的部署</h3><p>1、镜像下载与启动</p><pre><code>docker pull registry// 这里的 /opt/registry 是我们本地的目录，用于存储上传的镜象，/var/lib/registry是Registry服务默认的保存镜象目录docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</code></pre><p>2、镜像运行情况查看</p><pre><code>docker ps</code></pre><p>打开浏览器输入<a href="http://127.0.0.1:5000/v2，正常返回如下数据如下：" target="_blank" rel="noopener">http://127.0.0.1:5000/v2，正常返回如下数据如下：</a></p><blockquote><p>{}</p></blockquote><h3 id="上传镜像至私有仓库并验证"><a href="#上传镜像至私有仓库并验证" class="headerlink" title="上传镜像至私有仓库并验证"></a>上传镜像至私有仓库并验证</h3><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。</p><p>1、先在本机查看已有的镜像</p><pre><code>docker images</code></pre><p>2、镜像打标记</p><p>假设在客户机上有个hello-world的镜像，我们要通过docker tag将该镜像标志为要推送到私有仓库。这里的客户端就是服务端。</p><pre><code>// 打标记docker tag hello-world 127.0.0.1:5000/hello-world// 标记成功之后查看docker image ls 127.0.0.1:5000/hello-world</code></pre><p>3、上传标记镜像</p><pre><code>docker push 127.0.0.1:5000/hello-world</code></pre><p>4、查看客户端上传的镜像目录</p><p>在浏览器中输入<a href="http://127.0.0.1:5000/v2/_catalog，正常返回如下数据如下：" target="_blank" rel="noopener">http://127.0.0.1:5000/v2/_catalog，正常返回如下数据如下：</a></p><blockquote><p>{“repositories”:{hello-world}}</p></blockquote><p>5、删除本地标记和镜像</p><pre><code>docker rmi hello-worlddocker rmi 127.0.0.1:5000/hello-world</code></pre><p>6、从私有仓库中获取镜像</p><pre><code>docker pull 127.0.0.1:5000/hello-world</code></pre><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>可能会出现无法push镜像到私有仓库的问题。这是因为我们启动的registry服务不是安全可信赖的。我们可以通过Docker的配置选项来取消这个限制。对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><pre><code>{  &quot;registry-mirror&quot;: [    &quot;https://registry.docker-cn.com&quot;  ],  &quot;insecure-registries&quot;: [    &quot;172.16.213.230:5000&quot;  ]}</code></pre><p>添加完成，重启docker服务才能生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候使用 Docker Hub 这样的公共仓库可能不方便，那么，用户也可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。&lt;/p&gt;
&lt;h3 id=&quot;Registry的部署&quot;&gt;&lt;a href=&quot;#Registry的部
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper入门</title>
    <link href="http://www.echodemo.cc/2020/02/04/Zookeeper%E5%85%A5%E9%97%A8/"/>
    <id>http://www.echodemo.cc/2020/02/04/Zookeeper入门/</id>
    <published>2020-02-04T07:05:01.000Z</published>
    <updated>2020-02-04T08:14:34.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是ZooKeeper"><a href="#1、什么是ZooKeeper" class="headerlink" title="1、什么是ZooKeeper"></a>1、什么是ZooKeeper</h3><p>ZooKeeper 由 Yahoo 开发，后来捐赠给了 Apache ，现已成为 Apache 顶级项目。ZooKeeper 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 Paxos 算法的 ZAB 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。简单来说， ZooKeeper 是一个分布式协调服务框架。</p><p>(1)分布式和集群</p><p>有人说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— Cluster ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。</p><p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也一样提供秒杀服务，这个时候就是 Cluster 集群 。</p><p>但是，我现在换一种方式，我将一个秒杀服务 拆分成多个子服务 ，比如创建订单服务，增加积分服务，扣优惠券服务等等，然后我将这些子服务都部署在不同的服务器上 ，这个时候就是  Distributed 分布式 。</p><h3 id="2、ZooKeeper基本概念"><a href="#2、ZooKeeper基本概念" class="headerlink" title="2、ZooKeeper基本概念"></a>2、ZooKeeper基本概念</h3><p>(1)集群角色</p><pre><code>&gt; Master&gt; Follower&gt; Observer</code></pre><p>一个 ZooKeeper 集群同一时刻只会有一个 Master，其他都是 Follower 或 Observer。</p><p>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入:peerType=observer 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 :observer</p><p>(2)数据模型</p><p>zookeeper 数据存储结构与标准的 Unix 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 zookeeper 中没有文件系统中目录与文件的概念，而是 使用了 znode 作为数据节点 。znode 是 zookeeper 中的最小数据单元，每个 znode 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。</p><p>每个 znode 都有自己所属的 节点类型 和 节点状态。zookeeper的节点分两类：持久节点和临时节点</p><blockquote><p>持久节点：</p><blockquote><p>所谓持久节点是指一旦这个 树形结构上被创建了，除非主动进行对树节点的移除操作，否则这个节点将一直保存在 ZooKeeper 上。</p></blockquote><p>临时节点：</p><blockquote><p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p></blockquote></blockquote><p>(3)Watcher(事件监听器)</p><p>Watcher 为事件监听器，是 zookeeper 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端注册指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会 向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后执行相应的回调方法 。</p><p>(4)节点读写服务分工</p><p>ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。</p><p>Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><p>(5)Session</p><p>ZooKeeper 客户端和服务端是通过 TCP 长连接维持的会话机制，其实对于会话来说你可以理解为:保持连接状态 。</p><p>ZooKeeper 对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的 Watcher 事件通知。</p><h3 id="3、ZooKeeper应用的典型场景"><a href="#3、ZooKeeper应用的典型场景" class="headerlink" title="3、ZooKeeper应用的典型场景"></a>3、ZooKeeper应用的典型场景</h3><p>(1)数据发布与订阅（配置中心）</p><p>数据发布与订阅，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上,供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和动态更新。</p><p>(2)命名服务</p><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字。</p><p>其中较为常见的就是一些分布式服务框架（如RPC）中的服务地址列表。通过在ZooKeepr里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。ZooKeeper 的命名服务即生成全局唯一的ID。</p><p>(3)Master 选举</p><p>Master 选举可以说是 ZooKeeper 最典型的应用场景了。比如 HDFS 中 Active NameNode 的选举、YARN 中 Active ResourceManager 的选举和 HBase 中 Active HMaster 的选举等。</p><p>针对 Master 选举的需求，通常情况下，我们可以选择常见的关系型数据库中的主键特性来实现：希望成为 Master 的机器都向数据库中插入一条相同主键ID的记录，数据库会帮我们进行主键冲突检查，也就是说，只有一台机器能插入成功——那么，我们就认为向数据库中成功插入数据的客户端机器成为Master。</p><p>但是，如果当前选举出的 Master 挂了，那么该如何处理？谁来告诉我 Master 挂了呢？显然，关系型数据库无法通知我们这个事件。但是，ZooKeeper 可以做到！</p><p>利用 ZooKeepr 的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即 ZooKeeper 将会保证客户端无法创建一个已经存在的数据单元节点。也就是说，如果同时有多个客户端请求创建同一个临时节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行 Master 选举了。</p><p>成功创建该节点的客户端所在的机器就成为了 Master。同时，其他没有成功创建该节点的客户端，都会在该节点上注册一个子节点变更的 Watcher，用于监控当前 Master 机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会重新进行 Master 选举。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是ZooKeeper&quot;&gt;&lt;a href=&quot;#1、什么是ZooKeeper&quot; class=&quot;headerlink&quot; title=&quot;1、什么是ZooKeeper&quot;&gt;&lt;/a&gt;1、什么是ZooKeeper&lt;/h3&gt;&lt;p&gt;ZooKeeper 由 Yahoo 开发，后
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ZooKeeper" scheme="http://www.echodemo.cc/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://www.echodemo.cc/2020/02/04/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://www.echodemo.cc/2020/02/04/正向代理和反向代理/</id>
    <published>2020-02-04T02:41:07.000Z</published>
    <updated>2020-02-04T02:48:50.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是代理服务器（Proxy-Serve）？"><a href="#1、什么是代理服务器（Proxy-Serve）？" class="headerlink" title="1、什么是代理服务器（Proxy Serve）？"></a>1、什么是代理服务器（Proxy Serve）？</h3><pre><code>提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。</code></pre><h3 id="2、为什么使用代理服务器？"><a href="#2、为什么使用代理服务器？" class="headerlink" title="2、为什么使用代理服务器？"></a>2、为什么使用代理服务器？</h3><p>(1)提高访问速度</p><p>由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度。</p><p>(2)防火墙作用</p><p>由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</p><p>(3)突破访问限制</p><p>互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</p><h3 id="3、正向代理"><a href="#3、正向代理" class="headerlink" title="3、正向代理"></a>3、正向代理</h3><p>正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 </p><p>简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 </p><h3 id="4、反向代理"><a href="#4、反向代理" class="headerlink" title="4、反向代理"></a>4、反向代理</h3><p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 </p><p>理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 </p><h3 id="5、正向代理和反向代理的区别"><a href="#5、正向代理和反向代理的区别" class="headerlink" title="5、正向代理和反向代理的区别"></a>5、正向代理和反向代理的区别</h3><p>(1)位置不同</p><pre><code>正向代理，架设在客户机和目标主机之间； 反向代理，架设在服务器端；</code></pre><p>(2)代理对象不同 </p><pre><code>正向代理，代理客户端，服务端不知道实际发起请求的客户端； 反向代理，代理服务端，客户端不知道实际提供服务的服务端； </code></pre><p>(3)用途不同 </p><pre><code>正向代理，为在防火墙内的局域网客户端提供访问Internet的途径； 反向代理，将防火墙后面的服务器提供给Internet访问；</code></pre><p>(4)安全性不同 </p><pre><code>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务； 反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。</code></pre><h3 id="6、正向代理的应用"><a href="#6、正向代理的应用" class="headerlink" title="6、正向代理的应用"></a>6、正向代理的应用</h3><pre><code>1. 访问原来无法访问的资源 2. 用作缓存，加速访问速度3. 对客户端访问授权，上网进行认证4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</code></pre><h3 id="7、反向代理的应用"><a href="#7、反向代理的应用" class="headerlink" title="7、反向代理的应用"></a>7、反向代理的应用</h3><pre><code>1. 保护内网安全2. 负载均衡3. 缓存，减少服务器的压力</code></pre><p>Nginx作为较火的反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后台的服务器，决定哪台目标主机来处理当前请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是代理服务器（Proxy-Serve）？&quot;&gt;&lt;a href=&quot;#1、什么是代理服务器（Proxy-Serve）？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是代理服务器（Proxy Serve）？&quot;&gt;&lt;/a&gt;1、什么是代理服务器（Pro
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://www.echodemo.cc/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx(upstream机制)的几种负载均衡策略</title>
    <link href="http://www.echodemo.cc/2020/02/04/nginx(upstream%E6%9C%BA%E5%88%B6)%E7%9A%84%E5%87%A0%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://www.echodemo.cc/2020/02/04/nginx(upstream机制)的几种负载均衡策略/</id>
    <published>2020-02-04T02:28:29.000Z</published>
    <updated>2020-02-04T02:55:46.051Z</updated>
    
    <content type="html"><![CDATA[<p>upstream机制使得Nginx以反向代理的方式运行，因此Nginx接受客户端的请求，并根据客户端的请求，Nginx选择合适的后端服务器来处理改请求。</p><h3 id="1、轮询（默认）"><a href="#1、轮询（默认）" class="headerlink" title="1、轮询（默认）"></a>1、轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，会自动剔除；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="2、指定权重"><a href="#2、指定权重" class="headerlink" title="2、指定权重"></a>2、指定权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况；</p><pre><code>upstream test {    server 10.0.0.7:80 weight=2;    server 10.0.0.8:80 weight=1;}</code></pre><h3 id="3、ip-hash（客户端ip绑定）"><a href="#3、ip-hash（客户端ip绑定）" class="headerlink" title="3、ip_hash（客户端ip绑定）"></a>3、ip_hash（客户端ip绑定）</h3><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端的服务器，可以解决session问题；</p><pre><code>upstream test {    ip_hash;    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="4、least-conn（最少连接）"><a href="#4、least-conn（最少连接）" class="headerlink" title="4、least_conn（最少连接）"></a>4、least_conn（最少连接）</h3><p>下一个请求将被分配到活动连接数量最少的服务器；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;    least_conn;}</code></pre><h3 id="5、fair（第三方）"><a href="#5、fair（第三方）" class="headerlink" title="5、fair（第三方）"></a>5、fair（第三方）</h3><p>按后端服务器的响应时间来请求分配，响应时间短的优先分配；</p><pre><code>upstream test {    fair;    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="6、url-hash（第三方）"><a href="#6、url-hash（第三方）" class="headerlink" title="6、url_hash（第三方）"></a>6、url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，按每个url定向到同一个后端服务器，后端服务器为缓存时比较有效；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;    hash $request_uri;    hash_method crc32;}</code></pre><h3 id="7、综合使用"><a href="#7、综合使用" class="headerlink" title="7、综合使用"></a>7、综合使用</h3><pre><code>upstream test {    ip_hash;    server 10.0.0.7:80 weight=10;    server 10.0.0.8:80 down（表示当前的server暂时不参加负载）;    server 10.0.0.9:80;    server 10.0.0.10:80 backup（其他所有的非backup机器down或者忙的时候，请求backup机器）;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;upstream机制使得Nginx以反向代理的方式运行，因此Nginx接受客户端的请求，并根据客户端的请求，Nginx选择合适的后端服务器来处理改请求。&lt;/p&gt;
&lt;h3 id=&quot;1、轮询（默认）&quot;&gt;&lt;a href=&quot;#1、轮询（默认）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://www.echodemo.cc/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Git高级用法</title>
    <link href="http://www.echodemo.cc/2020/02/04/Git%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2020/02/04/Git高级用法/</id>
    <published>2020-02-04T00:21:29.000Z</published>
    <updated>2020-02-04T02:28:14.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/2/git工作流程图.png" alt="&quot;git工作流程图&quot;"></p><h3 id="1、跳到之前的分支"><a href="#1、跳到之前的分支" class="headerlink" title="1、跳到之前的分支"></a>1、跳到之前的分支</h3><pre><code>git checkout -</code></pre><h3 id="2、查看历史"><a href="#2、查看历史" class="headerlink" title="2、查看历史"></a>2、查看历史</h3><pre><code># 每个提交在一行内显示git log --oneline# 在所有提交日志中搜索包含「homepage」的提交git log --all --grep=&apos;homepage&apos;# 获取某人的提交日志git log --author=&quot;Maxence&quot;</code></pre><h3 id="3、之前重置了一个不想保留的提交，但是现在又想要回滚"><a href="#3、之前重置了一个不想保留的提交，但是现在又想要回滚" class="headerlink" title="3、之前重置了一个不想保留的提交，但是现在又想要回滚"></a>3、之前重置了一个不想保留的提交，但是现在又想要回滚</h3><pre><code># 获取所有操作历史git reflog# 重置到相应提交git reset HEAD@{4}# ……或者……git reset --hard &lt;提交的哈希值&gt;</code></pre><h3 id="4、我把本地仓库搞得一团糟，应该怎么清理？"><a href="#4、我把本地仓库搞得一团糟，应该怎么清理？" class="headerlink" title="4、我把本地仓库搞得一团糟，应该怎么清理？"></a>4、我把本地仓库搞得一团糟，应该怎么清理？</h3><pre><code>git fetch origingit checkout mastergit reset --hard origin/master</code></pre><h3 id="5、查看我的分支和-master-的不同"><a href="#5、查看我的分支和-master-的不同" class="headerlink" title="5、查看我的分支和 master 的不同"></a>5、查看我的分支和 master 的不同</h3><pre><code>git diff master..my-branch</code></pre><h3 id="6、定制提交"><a href="#6、定制提交" class="headerlink" title="6、定制提交"></a>6、定制提交</h3><pre><code># 编辑上次提交git commit --amend -m &quot;更好的提交日志&quot;# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit# 空提交 —— 可以用来重新触发 CI 构建git commit --allow-empty -m &quot;chore: re-trigger build&quot;</code></pre><h3 id="7、squash-提交"><a href="#7、squash-提交" class="headerlink" title="7、squash 提交"></a>7、squash 提交</h3><p>比方说我想要 rebase 最近 3 个提交：</p><pre><code>- git rebase -i HEAD~3- 保留第一行的 pick，剩余提交替换为 squash 或 s- 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）pick 64d26a1 feat: add index.jss 45f0259 fix: update index.jss 8b15b0a fix: typo in index.js</code></pre><h3 id="8、修正"><a href="#8、修正" class="headerlink" title="8、修正"></a>8、修正</h3><p>比方说想在提交 fed14a4c 加上一些内容。</p><p><img src="/images/2020/2/git提交分支.png" alt="&quot;git工作流程图&quot;"></p><pre><code>git add .git commit --fixup HEAD~1# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1git rebase -i HEAD~3 --autosquash# 保存并退出文件（VI 中输入 `:wq`）</code></pre><h3 id="9、rebase-的时候在每个提交上执行命令"><a href="#9、rebase-的时候在每个提交上执行命令" class="headerlink" title="9、rebase 的时候在每个提交上执行命令"></a>9、rebase 的时候在每个提交上执行命令</h3><p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase –exec 命令在每个提交上执行命令。</p><pre><code># 在最近 3 个提交上运行 `npm test` 命令git rebase HEAD~3 --exec &quot;npm test&quot;</code></pre><p><img src="/images/2020/2/在每个提交上执行命令.png" alt="&quot;git工作流程图&quot;"></p><h3 id="10、暂存"><a href="#10、暂存" class="headerlink" title="10、暂存"></a>10、暂存</h3><p>暂存不止是 git stash 和 git stash pop ;)</p><pre><code># 保存所有正在追踪的文件git stash save &quot;日志信息&quot;# 列出所有的暂存项git stash list# 获取并删除暂存项git stash apply stash@{1}git stash drop stash@{1}# ……或使用一条命令……git stash pop stash@{1}</code></pre><h3 id="11、清理"><a href="#11、清理" class="headerlink" title="11、清理"></a>11、清理</h3><pre><code># 移除远程仓库上不存在的分支git fetch -p# 移除所有包含 `greenkeeper` 的分支git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &apos;s/^.\{9\}//&apos; | xargs git push origin --delete</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2020/2/git工作流程图.png&quot; alt=&quot;&amp;quot;git工作流程图&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、跳到之前的分支&quot;&gt;&lt;a href=&quot;#1、跳到之前的分支&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 最长公共前缀</title>
    <link href="http://www.echodemo.cc/2020/01/18/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://www.echodemo.cc/2020/01/18/LeetCode-最长公共前缀/</id>
    <published>2020-01-18T02:20:19.000Z</published>
    <updated>2020-01-18T11:41:00.979Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><pre><code>示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h3 id="题解：一个字符一个字符比较"><a href="#题解：一个字符一个字符比较" class="headerlink" title="题解：一个字符一个字符比较"></a>题解：一个字符一个字符比较</h3><pre><code>class Solution {    public String longestCommonPrefix(String[] strs) {        int strsLen = strs.length;        if (strsLen == 0) {            return &quot;&quot;;        }        int str1Len = strs[0].length();        int i = 0;        String str1 = strs[0];        for (i = 0; i &lt; str1Len; i++) {            char c = str1.charAt(i);            int k = 1;            for (int j = 1; j &lt; strsLen; j++) {                if (strs[j].length() &lt;= i)                    break;                if (c == strs[j].charAt(i))                    k++;            }            if (k == strsLen) {                continue;            } else {                break;            }        }        if (i == 0) {            return &quot;&quot;;        } else {            return str1.substring(0, i);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]
输出
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 罗马数字转整型</title>
    <link href="http://www.echodemo.cc/2020/01/12/LeetCode-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2020/01/12/LeetCode-罗马数字转整型/</id>
    <published>2020-01-12T09:04:35.000Z</published>
    <updated>2020-01-13T13:17:50.336Z</updated>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><pre><code>示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h3 id="题解一：纯遍历（map）"><a href="#题解一：纯遍历（map）" class="headerlink" title="题解一：纯遍历（map）:"></a>题解一：纯遍历（map）:</h3><pre><code>class Solution {    public int romanToInt(String s) {        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(7);        map.put(&apos;I&apos;, 1);        map.put(&apos;V&apos;, 5);        map.put(&apos;X&apos;, 10);        map.put(&apos;L&apos;, 50);        map.put(&apos;C&apos;, 100);        map.put(&apos;D&apos;, 500);        map.put(&apos;M&apos;, 1000);        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = map.get(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = map.get(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }}</code></pre><h3 id="题解二-switch-："><a href="#题解二-switch-：" class="headerlink" title="题解二(switch)："></a>题解二(switch)：</h3><pre><code>class Solution {    public int romanToInt(String s) {        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = getValue(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = getValue(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }    private int getValue(char c) {        switch (c) {            case &apos;I&apos;: return 1;            case &apos;V&apos;: return 5;            case &apos;X&apos;: return 10;            case &apos;L&apos;: return 50;            case &apos;C&apos;: return 100;            case &apos;D&apos;: return 500;            case &apos;M&apos;: return 1000;            default : return 0;        }    }}(1)执行用时 :4 ms, 在所有 Java 提交中击败了99.96%的用户(2)内存消耗 :35.9 MB, 在所有 Java 提交中击败了99.59%的用户</code></pre><p>switch语句被编译后，对应得是jvm的tableswitch指令，执行起来也就几条指令就完成了;而HashMap的get操作源码如下:</p><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    int hash = hash(key.hashCode());    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];         e != null;         e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    return null;}</code></pre><p>所以map.get执行的jvm指令肯定是要比tableswitch要多的。但是如果JVM在执行的过程中进行JIT优化会发现，map的执行速度会大大加快，而使用switch实现的方法并不会被优化。</p><h4 id="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"><a href="#所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。" class="headerlink" title="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"></a>所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C      
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://www.echodemo.cc/2020/01/11/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2020/01/11/docker常用命令/</id>
    <published>2020-01-11T13:00:23.000Z</published>
    <updated>2020-02-24T14:17:38.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker镜像常用命令"><a href="#docker镜像常用命令" class="headerlink" title="docker镜像常用命令"></a>docker镜像常用命令</h3><h4 id="什么是docker镜像？"><a href="#什么是docker镜像？" class="headerlink" title="什么是docker镜像？"></a>什么是docker镜像？</h4><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root文件系统。比如官方镜像centos:latest 就包含了完整的一套centos:latest最小系统的root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p><p>镜像由多层文件系统联合组成。被称之为<strong>分层存储。</strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<strong>分层存储这一特点会在下载镜像的时候显现出来。</strong></p><h4 id="1、搜索镜像"><a href="#1、搜索镜像" class="headerlink" title="1、搜索镜像"></a>1、搜索镜像</h4><pre><code>docker search java</code></pre><h4 id="2、下载镜像"><a href="#2、下载镜像" class="headerlink" title="2、下载镜像"></a>2、下载镜像</h4><pre><code>// 由于docker search命令只能查找出是否有该镜像，不能找到该镜像支持的版本，所以我们需要通过docker hub来搜索支持的版本。进入docker hub的官网，地址：https://hub.docker.com。然后搜索需要的镜像，查看镜像支持的版本。docker pull java:8</code></pre><h4 id="3、列出镜像"><a href="#3、列出镜像" class="headerlink" title="3、列出镜像"></a>3、列出镜像</h4><pre><code>// 查看所有镜像docker images 或 docker image ls// 查看某一个指定镜像docker image ls nginx:1.14.2// 过滤匹配镜像(nginx:latest之后下载的镜像，之前用before)docker image ls -f since=nginx:latest</code></pre><h4 id="4、删除镜像"><a href="#4、删除镜像" class="headerlink" title="4、删除镜像"></a>4、删除镜像</h4><pre><code>// 指定名称删除镜像docker rmi java:8// 指定名称删除镜像（强制）docker rmi -f java:8// 强制删除所有镜像docker rmi -f $(docker images)// 删除所有未被 tag 标记和未被容器使用的镜像docker image prune// 删除所有未被容器使用的镜像docker image prune -a</code></pre><h3 id="docker容器常用命令"><a href="#docker容器常用命令" class="headerlink" title="docker容器常用命令"></a>docker容器常用命令</h3><h4 id="什么是docker容器-Container-？"><a href="#什么是docker容器-Container-？" class="headerlink" title="什么是docker容器(Container)？"></a>什么是docker容器(Container)？</h4><p>镜像（Image）和容器（Container）有紧密的关系，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</strong></p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h4 id="1、新建并启动容器"><a href="#1、新建并启动容器" class="headerlink" title="1、新建并启动容器"></a>1、新建并启动容器</h4><pre><code>docker run -it --rm -p 80:80 --name nginx -d nginx:1.17.0 /bin/bash-i: 以交互模式运行容器，通常与 -t 同时使用-t: 为容器重新分配一个伪输入终端，进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。使用 --rm 可以避免浪费空间。-p：指定端口映射，格式为：hostPort:containerPort--name：指定运行后容器的名字为nginx,之后可以通过名字来操作容器-d：表示后台运行/bin/bash:以交互模式启动一个容器,在容器内执行/bin/bash命令。</code></pre><h4 id="2、列出容器"><a href="#2、列出容器" class="headerlink" title="2、列出容器"></a>2、列出容器</h4><pre><code>// 列出运行中的容器docker ps// 列出所有容器docker ps -a</code></pre><h4 id="3、停止-启动容器"><a href="#3、停止-启动容器" class="headerlink" title="3、停止/启动容器"></a>3、停止/启动容器</h4><pre><code>// $ContainerName及$ContainerId可以用docker ps命令查询出来docker stop $ContainerName(或者$ContainerId)// 强制停止容器docker kill $ContainerName(或者$ContainerId)// 启动已停止的容器docker start $ContainerName(或者$ContainerId)// 重启容器docker restart $ContainerName(或者$ContainerId)</code></pre><h4 id="4、进入-导入-导出容器"><a href="#4、进入-导入-导出容器" class="headerlink" title="4、进入/导入/导出容器"></a>4、进入/导入/导出容器</h4><pre><code>// 进入容器（推荐）docker exec -it $ContainerId /bin/bash// 进入容器docker attach $ContainerId// 导出容器docker export $ContainerId &gt; filename.tar// 导入容器(生成镜像)cat filename.tar | docker import - $imagename:$tag</code></pre><h4 id="5、删除容器"><a href="#5、删除容器" class="headerlink" title="5、删除容器"></a>5、删除容器</h4><pre><code>// 删除指定容器docker rm $ContainerName(或者$ContainerID)// 强制删除所有容器docker rm -f $(docker ps -a -q)// 删除所有已退出或者终止的容器docker container prune</code></pre><h4 id="6、查看容器的日志"><a href="#6、查看容器的日志" class="headerlink" title="6、查看容器的日志"></a>6、查看容器的日志</h4><pre><code>docker logs $ContainerName(或者$ContainerId)</code></pre><h4 id="7、查看容器的IP地址"><a href="#7、查看容器的IP地址" class="headerlink" title="7、查看容器的IP地址"></a>7、查看容器的IP地址</h4><pre><code>docker inspect --format &apos;{{ .NetworkSettings.IPAddress }}&apos; $ContainerName(或者$ContainerId)</code></pre><h4 id="8、同步宿主机时间到容器"><a href="#8、同步宿主机时间到容器" class="headerlink" title="8、同步宿主机时间到容器"></a>8、同步宿主机时间到容器</h4><pre><code>docker cp /etc/localtime $ContainerName(或者$ContainerId):/etc/</code></pre><h4 id="9、在宿主机查看docker使用cpu、内存、网络、io情况"><a href="#9、在宿主机查看docker使用cpu、内存、网络、io情况" class="headerlink" title="9、在宿主机查看docker使用cpu、内存、网络、io情况"></a>9、在宿主机查看docker使用cpu、内存、网络、io情况</h4><pre><code>// 查看指定容器情况docker stats $ContainerName(或者$ContainerId)// 查看所有容器情况docker stats -a</code></pre><h4 id="10、进入Docker容器内部的bash"><a href="#10、进入Docker容器内部的bash" class="headerlink" title="10、进入Docker容器内部的bash"></a>10、进入Docker容器内部的bash</h4><pre><code>docker exec -it $ContainerName /bin/bash</code></pre><h3 id="修改Docker镜像的存放位置"><a href="#修改Docker镜像的存放位置" class="headerlink" title="修改Docker镜像的存放位置"></a>修改Docker镜像的存放位置</h3><h4 id="1、查看docker镜像的存放位置"><a href="#1、查看docker镜像的存放位置" class="headerlink" title="1、查看docker镜像的存放位置"></a>1、查看docker镜像的存放位置</h4><pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><h4 id="2、关闭Docker服务"><a href="#2、关闭Docker服务" class="headerlink" title="2、关闭Docker服务"></a>2、关闭Docker服务</h4><pre><code>systemctl stop docker</code></pre><h4 id="3、移动目录到目标路径"><a href="#3、移动目录到目标路径" class="headerlink" title="3、移动目录到目标路径"></a>3、移动目录到目标路径</h4><pre><code>mv /var/lib/docker /mydata/docker</code></pre><h4 id="4、建立软连接"><a href="#4、建立软连接" class="headerlink" title="4、建立软连接"></a>4、建立软连接</h4><pre><code>ln -s /mydata/docker /var/lib/docker</code></pre><h4 id="什么是docker仓库-Repository-？"><a href="#什么是docker仓库-Repository-？" class="headerlink" title="什么是docker仓库(Repository)？"></a>什么是docker仓库(Repository)？</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p><p>仓库名经常以两段式路径形式出现，比如jwilder/nginx-proxy，前者往往意味着Docker Registry多用户环境下的用户名，后者则是对应的软件名。</p><h3 id="镜像加速器配置"><a href="#镜像加速器配置" class="headerlink" title="镜像加速器配置"></a>镜像加速器配置</h3><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：Docker官方提供的中国registry mirror(<a href="https://registry.docker-cn.com);七牛云加速器(https://reg-mirror.qiniu.com/)" target="_blank" rel="noopener">https://registry.docker-cn.com);七牛云加速器(https://reg-mirror.qiniu.com/)</a></p><p>我们以 Docker 官方加速器 <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 为例进行介绍。对于使用systemd的系统（Debian 8+、CentOS 7），可以在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><pre><code>{  &quot;registry-mirrors&quot;: [    &quot;https://registry.docker-cn.com&quot;  ]}</code></pre><p><strong>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。之后重新启动服务。</strong></p><pre><code>[root@localhost ~]# systemctl daemon-reload[root@localhost ~]# systemctl restart docker</code></pre><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行docker info，如果从结果中看到了如下内容，说明配置成功。</p><pre><code>[root@localhost home]# docker info......Registry Mirrors:https://registry.docker-cn.com/Live Restore Enabled: falseProduct License: Community Engine</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker镜像常用命令&quot;&gt;&lt;a href=&quot;#docker镜像常用命令&quot; class=&quot;headerlink&quot; title=&quot;docker镜像常用命令&quot;&gt;&lt;/a&gt;docker镜像常用命令&lt;/h3&gt;&lt;h4 id=&quot;什么是docker镜像？&quot;&gt;&lt;a href=&quot;#什
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装MongoDB</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装MongoDB/</id>
    <published>2020-01-11T12:50:17.000Z</published>
    <updated>2020-01-11T12:51:41.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、搜索MongoDB镜像"><a href="#1、搜索MongoDB镜像" class="headerlink" title="1、搜索MongoDB镜像"></a>1、搜索MongoDB镜像</h3><pre><code>docker search mongodb</code></pre><h3 id="2、拉取MongoDB镜像"><a href="#2、拉取MongoDB镜像" class="headerlink" title="2、拉取MongoDB镜像"></a>2、拉取MongoDB镜像</h3><pre><code>docker pull mongo:4.0.14</code></pre><h3 id="3-查看本地的镜像"><a href="#3-查看本地的镜像" class="headerlink" title="3.查看本地的镜像"></a>3.查看本地的镜像</h3><pre><code>docker images mongo</code></pre><h3 id="4、启动mongo-27017为端口号"><a href="#4、启动mongo-27017为端口号" class="headerlink" title="4、启动mongo (27017为端口号)"></a>4、启动mongo (27017为端口号)</h3><pre><code>docker run -p 27017:27017 -td mongo</code></pre><h3 id="5、查看启动情况"><a href="#5、查看启动情况" class="headerlink" title="5、查看启动情况"></a>5、查看启动情况</h3><pre><code>docker ps</code></pre><h3 id="6、win10下载进行navicat连接"><a href="#6、win10下载进行navicat连接" class="headerlink" title="6、win10下载进行navicat连接"></a>6、win10下载进行navicat连接</h3><h3 id="7、进入到mongodb容器"><a href="#7、进入到mongodb容器" class="headerlink" title="7、进入到mongodb容器"></a>7、进入到mongodb容器</h3><pre><code>docker exec -it  371601d910b8  mongo admin (以管理员身份进入 371601d910b8 镜像运行id通过docker ps查看)容器停止退出，命令： exit</code></pre><h3 id="8、docker-exec进入Docker容器"><a href="#8、docker-exec进入Docker容器" class="headerlink" title="8、docker exec进入Docker容器"></a>8、docker exec进入Docker容器</h3><pre><code>sudo docker exec -it 775c7c9ee1e1 /bin/bash (-it 标准输入和关联伪终端，-it后跟容器ID，/bin/bash是命令，表示在该容器中运行该命令)</code></pre><h3 id="9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID"><a href="#9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID" class="headerlink" title="9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)"></a>9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;a href=&quot;#1、搜索MongoDB镜像&quot; class=&quot;headerlink&quot; title=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;/a&gt;1、搜索MongoDB镜像&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;docker search mong
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="MongoDB" scheme="http://www.echodemo.cc/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装RabbitMQ</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装RabbitMQ/</id>
    <published>2020-01-11T12:48:06.000Z</published>
    <updated>2020-01-11T12:50:15.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、访问：https-hub-docker-com"><a href="#1、访问：https-hub-docker-com" class="headerlink" title="1、访问：https://hub.docker.com/"></a>1、访问：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></h3><h3 id="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。"><a href="#2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。" class="headerlink" title="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。"></a>2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。</h3><h3 id="3、拉取镜像："><a href="#3、拉取镜像：" class="headerlink" title="3、拉取镜像："></a>3、拉取镜像：</h3><pre><code>docker pull rabbitmq:3.7.17-management</code></pre><h3 id="4、查看是否拉取成功"><a href="#4、查看是否拉取成功" class="headerlink" title="4、查看是否拉取成功"></a>4、查看是否拉取成功</h3><pre><code>docker images</code></pre><h3 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h3><pre><code>docker run -d -p 5672:5672 -p 15672:15672  --name rabbitmq  7601e834fa14-d：后台运行-p：映射端口-p 5672:5672 ：把主机的5672端口映射成rabbitMQ的5672端口-p 15672:15672 ： web管理界面的–name :起个名字7601e834fa14：镜像的id</code></pre><h3 id="测试是否访问成功"><a href="#测试是否访问成功" class="headerlink" title="测试是否访问成功:"></a>测试是否访问成功:</h3><pre><code>在浏览器中输入：http://安装RabbitMQ的主机IP:15672 (默认的账号密码皆为guest)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、访问：https-hub-docker-com&quot;&gt;&lt;a href=&quot;#1、访问：https-hub-docker-com&quot; class=&quot;headerlink&quot; title=&quot;1、访问：https://hub.docker.com/&quot;&gt;&lt;/a&gt;1、访问：&lt;a 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="RabbitMQ" scheme="http://www.echodemo.cc/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 整数反转</title>
    <link href="http://www.echodemo.cc/2020/01/11/LeetCode-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://www.echodemo.cc/2020/01/11/LeetCode-整数反转/</id>
    <published>2020-01-11T12:23:49.000Z</published>
    <updated>2020-01-11T12:42:15.257Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><pre><code>示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21</code></pre><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h3 id="题解-一-：转化为字符串，再转回整型"><a href="#题解-一-：转化为字符串，再转回整型" class="headerlink" title="题解(一)：转化为字符串，再转回整型"></a>题解(一)：转化为字符串，再转回整型</h3><pre><code>class Solution{    public static int reverse(int x) {        String str = String.valueOf(x);        String result = &quot;&quot;;        if (&apos;-&apos; == str.charAt(0)) {            result = result + &quot;-&quot;;            str = str.substring(1);        }        int strLen = str.length();        for (int i = strLen - 1; i &gt; -1; i--) {            result = result + str.charAt(i);        }        try {            int iResult = Integer.parseInt(result);            return iResult;        } catch (NumberFormatException e) {            return 0;        }    }}</code></pre><h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><pre><code>// pop operation:pop = x % 10;x /= 10;// push operation:temp = rev * 10 + pop;rev = temp;</code></pre><p>这种方法很危险，因为当 temp = rev * 10 + pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。为了便于解释，我们假设 rev 是正数。</p><pre><code>(1）如果 temp = rev * 10 + pop 导致溢出，那么一定有 rev ≥ INTMAX / 10。(2)如果 rev &gt; INTMAX / 10 ，那么 temp = rev * 10 + pop 一定会溢出。(3)如果 rev == INTMAX / 10，那么只要 pop &gt; 7，temp = rev * 10 + pop 就会溢出。当 rev 为负时可以应用类似的逻辑。class Solution {    public int reverse(int x) {        int rev = 0;        while (x != 0) {            int pop = x % 10;            x /= 10;            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0;            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0;            rev = rev * 10 + pop;        }        return rev;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 123
输出: 321

示例 2:

输入: -123
输出: -321

示例 3:

输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
</feed>
