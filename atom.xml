<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-07-13T16:20:29.037Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springmvc学习笔记(2)-非注解的处理器映射器和适配器</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-%E9%9D%9E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(2)-非注解的处理器映射器和适配器/</id>
    <published>2019-07-13T16:02:19.000Z</published>
    <updated>2019-07-13T16:20:29.037Z</updated>
    
    <content type="html"><![CDATA[<center>菡萏香销翠叶残，西风愁起绿波间。还与韶光共憔悴，不堪看。</center><br><center>细雨梦回鸡塞远，小楼吹彻玉笙寒。多少泪珠何限恨，倚栏干。</center><br><center>—-五代·李璟《摊破浣溪沙·菡萏香销翠叶残》</center><hr><h3 id="非注解的处理器映射器"><a href="#非注解的处理器映射器" class="headerlink" title="非注解的处理器映射器"></a>非注解的处理器映射器</h3><pre><code>&lt;!-- 配置Handler --&gt;&lt;bean id=&quot;itemsController&quot; name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)所有的映射器都实现HandlerMapping接口--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!-- 简单的url映射 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;    &lt;property name=&quot;mappings&quot;&gt;        &lt;props&gt;            &lt;!-- 对itemsController进行url映射，key表示访问的路径，itemsController表示Handler的id --&gt;            &lt;prop key=&quot;/queryItems1.action&quot;&gt;itemsController&lt;/prop&gt;            &lt;prop key=&quot;/queryItems2.action&quot;&gt;itemsController&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理。</p><h3 id="非注解的处理器适配器"><a href="#非注解的处理器适配器" class="headerlink" title="非注解的处理器适配器"></a>非注解的处理器适配器</h3><pre><code>&lt;!-- 配置处理器适配器，所有处理器适配器都实现了HandlerAdapter接口，编写的Handler实现Controller接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!-- 另一个处理器适配器，编写的Handler实现HttpRequestHandler接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;</code></pre><p>实现HttpRequestHandler接口的ItemsController1：</p><pre><code>package com.echodemo.ssm.controller;import com.echodemo.ssm.bean.Items;import org.springframework.web.HttpRequestHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class ItemsController1 implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {        //调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();        //向list中填充静态数据        Items items_1 = new Items();        items_1.setName(&quot;联想笔记本&quot;);        items_1.setPrice(6000f);        items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);        Items items_2 = new Items();        items_2.setName(&quot;苹果手机&quot;);        items_2.setPrice(5000f);        items_2.setDetail(&quot;iphone6苹果手机！&quot;);        itemsList.add(items_1);        itemsList.add(items_2);        // 设置模型数据        httpServletRequest.setAttribute(&quot;/WEB-INF/jsp/itemsList.jsp&quot;, itemsList);        // 设置转发的视图        httpServletRequest.getRequestDispatcher(&quot;items/itemsList&quot;)                .forward(httpServletRequest, httpServletResponse);        /*         *HttpRequestHandler适配器的handleRequest方法返回为void,         *没有返回ModelAndView，可通过response修改响应内容,比如返回json数据：         *///        httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//        httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;);//        httpServletResponse.getWriter().write(&quot;json串&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;菡萏香销翠叶残，西风愁起绿波间。还与韶光共憔悴，不堪看。&lt;/center&gt;&lt;br&gt;&lt;center&gt;细雨梦回鸡塞远，小楼吹彻玉笙寒。多少泪珠何限恨，倚栏干。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-五代·李璟《摊破浣溪沙·菡萏香销翠叶残》&lt;/center&gt;

&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(1)-框架原理和入门配置</title>
    <link href="http://www.echodemo.cc/2019/07/13/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2019/07/13/springmvc学习笔记(1)-框架原理和入门配置/</id>
    <published>2019-07-13T15:12:58.000Z</published>
    <updated>2019-07-13T16:13:44.057Z</updated>
    
    <content type="html"><![CDATA[<center>绿槐高柳咽新蝉。薰风初入弦。碧纱窗下水沉烟。棋声惊昼眠。</center><br><center>微雨过，小荷翻。榴花开欲然。玉盆纤手弄清泉。琼珠碎却圆。</center><br><center>—-宋·苏轼《阮郎归·初夏》</center><hr><p>本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p><hr><h3 id="springmvc框架原理"><a href="#springmvc框架原理" class="headerlink" title="springmvc框架原理"></a>springmvc框架原理</h3><p>官网示意图如下：</p><center><br><br><img src="/images/2019/7/springmvc.png" alt="&quot;Springmvc&quot;"><br><br></center><p>SpringMVC的核心架构：</p><center><br><br><img src="/images/2019/7/springmvc原理.png" alt="&quot;Springmvc原理&quot;"><br><br></center><p>组件及其作用：</p><pre><code>（1）前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度。（2）处理器映射器(HandlerMapping)：根据请求的url查找Handler。（3）Handler处理器：按照HandlerAdapter的要求编写。（4）处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。（5）视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View)。（6)视图(View)：View是一个接口实现类试吃不同的View类型（jsp,pdf等等）。</code></pre><p>具体流程：</p><pre><code>1.发起请求到前端控制器(DispatcherServlet)。2.前端控制器请求处理器映射器(HandlerMapping)查找Handler(可根据xml配置、注解进行查找)。3.处理器映射器(HandlerMapping)向前端控制器返回Handler。4.前端控制器调用处理器适配器(HandlerAdapter)执行Handler。5.处理器适配器(HandlerAdapter)去执行Handler。6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)。7.处理器适配器(HandlerAdapter)向前端控制器返回ModelAndView。8.前端控制器(DispatcherServlet)请求视图解析器(ViewResolver)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)。9.视图解析器(ViewResolver)向前端控制器(DispatcherServlet)返回View。10.前端控制器进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域。11.前端控制器向用户响应结果。</code></pre><hr><h3 id="springmvc入门程序"><a href="#springmvc入门程序" class="headerlink" title="springmvc入门程序"></a>springmvc入门程序</h3><p>一个展示商品列表的小页面</p><p>1、环境搭建</p><p>（1）new-&gt;project-&gt;maven-&gt;勾选create from archetype-&gt;选中webapp。</p><p>（2）在src/main下新建java文件夹，标记为Sources Root。在在src/main下新建resources文件夹，标记为Resources Root。</p><p>2、添加依赖</p><pre><code>&lt;properties&gt;  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;  &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;spring-base-version&gt;4.2.4.RELEASE&lt;/spring-base-version&gt;&lt;/properties&gt;&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.11&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>build标签的finalName要和Artifacts的output directory一致：</p><pre><code>&lt;finalName&gt;springmvcfirst&lt;/finalName&gt;</code></pre><p>3、配置文件</p><p>（1）配置前端控制器</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app  version=&quot;2.3&quot;          xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_3.xsd&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)    --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，            使用此种方式和实现RESTful风格的url    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，            不能根据jsp页面找到handler，会报错    --&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（2）创建springmvc.xml（springmvc.xml放在resources目录下）</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>（3）在springmvc.xml中配置Handler</p><pre><code>&lt;bean name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;</code></pre><p>(4)在springmvc.xml中配置处理器映射器</p><pre><code>&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)所有的映射器都实现HandlerMapping接口--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre><p>（5）在springmvc.xml中配置处理器适配器</p><pre><code>&lt;!-- 配置处理器适配器，所有处理器适配器都实现了HandlerAdapter接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</code></pre><p>源码：</p><pre><code>public boolean supports(Object handler) {        return handler instanceof Controller;}</code></pre><p>此适配器能执行实现Controller接口的Handler</p><p>（6）在springmvc.xml中配置视图解析器</p><pre><code>&lt;!-- 视图解析器解析jsp,默认使用jstl,classpath下要有jstl的包--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;</code></pre><p>在springmvc.xml中视图解析器配置前缀和后缀：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;</code></pre><p>程序中不用指定前缀和后缀：</p><pre><code>// 指定视图// 下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList// modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);// 下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀modelAndView.setViewName(&quot;items/itemsList&quot;);</code></pre><h3 id="部署调试"><a href="#部署调试" class="headerlink" title="部署调试"></a>部署调试</h3><p>Items类：</p><pre><code>package com.echodemo.ssm.bean;import java.util.Date;public class Items {    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name == null ? null : name.trim();    }    public Float getPrice() {        return price;    }    public void setPrice(Float price) {        this.price = price;    }    public String getPic() {        return pic;    }    public void setPic(String pic) {        this.pic = pic == null ? null : pic.trim();    }    public Date getCreatetime() {        return createtime;    }    public void setCreatetime(Date createtime) {        this.createtime = createtime;    }    public String getDetail() {        return detail;    }    public void setDetail(String detail) {        this.detail = detail == null ? null : detail.trim();    }}</code></pre><p>实现Controller接口的ItemsController:</p><pre><code>package com.echodemo.ssm.controller;import com.echodemo.ssm.bean.Items;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import java.util.ArrayList;import java.util.List;public class ItemsController implements Controller {    @Override    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception {        // 调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();        // 向list中填充静态数据        Items items_1 = new Items();        items_1.setName(&quot;联想笔记本&quot;);        items_1.setPrice(5000f);        items_1.setDetail(&quot;Think Pad T430联想笔记本&quot;);        Items items_2 = new Items();        items_2.setName(&quot;苹果手机&quot;);        items_2.setPrice(5000f);        items_2.setDetail(&quot;Iphone6苹果手机&quot;);        itemsList.add(items_1);        itemsList.add(items_2);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        // 相当于request的setAttribute，在JSP页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;, itemsList);        // 指定视图        modelAndView.setViewName(&quot;items/itemsList&quot;);        return modelAndView;    }}</code></pre><p>1、在idea中EditConfigurations，添加一个local的tomcat server。</p><p>2、设置tomcat启动路径，并且配置为修改自动更新（这样就不需要总是重启了）</p><center><br><img src="/images/2019/7/tomcat1.png" alt="&quot;Tomcat1&quot;"><br></center><p>3、需要相应设置application context为上一步默认url后加的/springmvcfirst</p><center><br><img src="/images/2019/7/tomcat2.png" alt="&quot;Tomcat2&quot;"><br></center><p>4、最后在tomcat的webapps目录下新建一个同名的文件夹，将output directory置为它。</p><center><br><img src="/images/2019/7/tomcat3.png" alt="&quot;Tomcat3&quot;"><br></center><p>5、相关问题</p><pre><code>HTTP Status 404 - 处理器映射器根据url找不到Handler,说明url错误HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp 处理器映射器根据url找到了Handler，转发的jsp页面找不到</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;绿槐高柳咽新蝉。薰风初入弦。碧纱窗下水沉烟。棋声惊昼眠。&lt;/center&gt;&lt;br&gt;&lt;center&gt;微雨过，小荷翻。榴花开欲然。玉盆纤手弄清泉。琼珠碎却圆。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《阮郎归·初夏》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习中碰到的的一些问题</title>
    <link href="http://www.echodemo.cc/2019/07/06/mybatis%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2019/07/06/mybatis学习中碰到的一些问题/</id>
    <published>2019-07-06T03:40:59.000Z</published>
    <updated>2019-07-06T04:12:23.927Z</updated>
    
    <content type="html"><![CDATA[<center>君不见走马川行雪海边，平沙莽莽黄入天。 </center><br><center>轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。</center><br><center>匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。</center><br><center>将军金甲夜不脱，半夜军行戈相拨，风头如刀面如割。</center><br><center>马毛带雪汗气蒸，五花连钱旋作冰，幕中草檄砚水凝。 </center><br><center>虏骑闻之应胆慑，料知短兵不敢接，车师西门伫献捷。</center><br><center>—-唐·岑参《走马川行奉送封大夫出师西征》</center><hr><pre><code>1、元素类型为 &quot;configuration&quot; 的内容必须匹配 &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;。org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession.### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 46; columnNumber: 17; 元素类型为 &quot;configuration&quot; 的内容必须匹配 &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;。</code></pre><p>mybatis-config.xml配置文件配置时，要注意节点顺序。</p><hr><pre><code>2、&lt;property name=&quot;username&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=utf-8&quot; /&gt;org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: java.sql.SQLNonTransientConnectionException: Cannot load connection class because of underlying exception: com.mysql.cj.exceptions.WrongArgumentException: Malformed database URL, failed to parse the connection string near &apos;;serverTimezone=UTC&apos;.</code></pre><p>这是时区问题，只需配置成下面这样就OK了（其中的&amp;表示的是XML的&amp;字符的转义符，所以当你在把这个配置放到db.properties中时就要将&amp;改回&amp;字符了，不然也会报错）：</p><pre><code>&lt;property name=&quot;username&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&quot; /&gt;</code></pre><hr><pre><code>3、org.apache.ibatis.binding.BindingException: Type interface com.echodemo.mybatislearning.mapper.UserMapper is not known to the MapperRegistry</code></pre><p>这个是因为xml文件没有被添加到mybatis的配置文件中扫描。在这里我的mapper当时是这样配置的，看到网上很多都是在前面加个mapper就OK了，but我的目录结构估计和他们不一样。那么如何优雅让工程找到我们的映射文件呢？</p><pre><code>&lt;!--我的--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;&lt;!--网上众多博客--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;</code></pre><p>我在pom文件的bulid里面添加了下面这个路径的指引，再也不怕找不到我的映射文件了，哈哈。</p><pre><code>&lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>当然如果说你是想要配置成批量加载的话，可以像下面这样：</p><pre><code>&lt;mappers&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;&lt;!--还是要在pom文件当中定义路径哈！--&gt;&lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;        &lt;include&gt;**/*.xml&lt;/include&gt;    &lt;/includes&gt;&lt;/resource&gt;</code></pre><hr><p>4、IDEA中使用Mybatis的逆向工程提示说找不到配置文件generatorConfig.xml的问题</p><p>网上很多的文章和博客在指定逆向工程配置文件的时候都是直接用的”generatorConfig.xml”的文件名，而没有前面的路径，虽然按住ctrl可以跳转到该文件，但是在运行main方法的时候却总是报”未找到该文件”的错。我是这样配置的就可以了：</p><pre><code>//指定逆向工程配置文件File configFile = new File(&quot;src\\main\\resources\\generatorConfig.xml&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;君不见走马川行雪海边，平沙莽莽黄入天。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。&lt;/center&gt;&lt;br&gt;&lt;center&gt;匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。&lt;/center&gt;&lt;br&gt;&lt;center&gt;将
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(18)-mybatis逆向工程</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(18)-mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(18)-mybatis逆向工程/</id>
    <published>2019-06-30T15:49:47.000Z</published>
    <updated>2019-07-06T03:59:50.850Z</updated>
    
    <content type="html"><![CDATA[<center>西风吹老洞庭波，一夜湘君白发多。</center><br><center>醉后不知天在水，满船清梦压星河。</center><br><center>—-元·唐珙《题龙阳县青草湖》</center><hr><p>mybaits需要程序员自己编写sql语句,mybatis官方提供逆向工程,可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..）企业实际开发中，常用的逆向工程方式：由数据库的表生成java代码。</p><blockquote></blockquote><p><a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">MyBatis Generator</a></p><blockquote></blockquote><p><a href="https://github.com/mybatis/generator" target="_blank" rel="noopener">A code generator for MyBatis and iBATIS. - GitHub</a></p><hr><h3 id="配置maven依赖"><a href="#配置maven依赖" class="headerlink" title="配置maven依赖"></a>配置maven依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;</code></pre><hr><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>（1）运行逆向工程</p><p>根据官网说的<a href="http://www.mybatis.org/generator/running/running.html" target="_blank" rel="noopener">Running MyBatis Generator</a>：</p><p><strong>Running MyBatis Generator</strong></p><p>MyBatis Generator (MBG) can be run in the following ways:</p><pre><code>From the command prompt with an XML configurationAs an Ant task with an XML configurationAs a Maven PluginFrom another Java program with an XML configurationFrom another Java program with a Java based configuration</code></pre><p>还可以通过eclipse的插件生成代码,建议使用java程序方式，不依赖开发工具。</p><p>(2)生成代码配置文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8&quot;             userId=&quot;root&quot;            password=&quot;123&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.iot.ssm.po&quot;            targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.iot.ssm.mapper&quot;             targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.iot.ssm.mapper&quot;             targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;items&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>需要注意的位置：</p><pre><code>javaModelGenerator,生成PO类的位置sqlMapGenerator,mapper映射文件生成的位置javaClientGenerator,mapper接口生成的位置table,指定数据库表</code></pre><p>(3)执行生成程序</p><pre><code>public class GeneratorSqlmap {    public void generator() throws Exception{        List&lt;String&gt; warnings = new ArrayList&lt;&gt;();        boolean overwrite = true;        // 指定逆向工程配置文件        File configFile = new File(&quot;src\\main\\resources\\generatorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,                callback, warnings);        myBatisGenerator.generate(null);    }    public static void main(String[] args) {        try {            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();            generatorSqlmap.generator();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p><strong>注：网上很多的文章和博客在指定逆向工程配置文件的时候都是直接用的”generatorConfig.xml”的文件名，而没有前面的路径，虽然按住ctrl可以跳转到该文件，但是在运行main方法的时候却总是报”未找到该文件”的错。</strong></p><hr><h3 id="使用生成的代码"><a href="#使用生成的代码" class="headerlink" title="使用生成的代码"></a>使用生成的代码</h3><pre><code>package com.iot.ssm.mapper;import static org.junit.Assert.*;import java.util.Date;import java.util.List;import com.iot.ssm.po.Items;import com.iot.ssm.po.ItemsExample;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ItemsMapperTest {    private ApplicationContext applicationContext;    private ItemsMapper itemsMapper;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);        itemsMapper = (ItemsMapper) applicationContext.getBean(&quot;itemsMapper&quot;);    }    //根据主键删除     @Test    public void testDeleteByPrimaryKey() {    }    //插入    @Test    public void testInsert() {        //构造 items对象        Items items = new Items();        items.setName(&quot;手机&quot;);        items.setPrice(999f);        items.setCreatetime(new Date());        itemsMapper.insert(items);    }    //自定义条件查询    @Test    public void testSelectByExample() {        ItemsExample itemsExample = new ItemsExample();        //通过criteria构造查询条件        ItemsExample.Criteria criteria = itemsExample.createCriteria();        criteria.andNameEqualTo(&quot;笔记本&quot;);        //可能返回多条记录        List&lt;Items&gt; list = itemsMapper.selectByExample(itemsExample);        System.out.println(list);    }    //根据主键查询    @Test    public void testSelectByPrimaryKey() {        Items items = itemsMapper.selectByPrimaryKey(1);        System.out.println(items);    }    //更新数据    @Test    public void testUpdateByPrimaryKey() {        //对所有字段进行更新，需要先查询出来再更新        Items items = itemsMapper.selectByPrimaryKey(1);        items.setName(&quot;手机&quot;);        itemsMapper.updateByPrimaryKey(items);        //如果传入字段不空为才更新，在批量更新中使用此方法，不需要先查询再更新        //itemsMapper.updateByPrimaryKeySelective(record);    }}</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778937" target="_blank" rel="noopener">mybatis学习笔记(18)-mybatis逆向工程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;西风吹老洞庭波，一夜湘君白发多。&lt;/center&gt;&lt;br&gt;&lt;center&gt;醉后不知天在水，满船清梦压星河。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-元·唐珙《题龙阳县青草湖》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;mybaits需要程序员自己编写sql语句,my
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(17)-spring和mybatis整合</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)-spring%E5%92%8Cmybatis%E6%95%B4%E5%90%88/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(17)-spring和mybatis整合/</id>
    <published>2019-06-30T08:38:43.000Z</published>
    <updated>2019-06-30T11:07:54.954Z</updated>
    
    <content type="html"><![CDATA[<center>西风吹老洞庭波，一夜湘君白发多。</center><br><center>醉后不知天在水，满船清梦压星河。</center><br><center>—-元·唐珙《题龙阳县青草湖》</center><hr><p>本文主要将如何将spring和mybatis整合，只是作简单的示例，没有使用Maven构建。并展示mybatis与spring整合后如何进行原始dao开发和mapper代理开发。</p><h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><p>需要spring通过单例方式管理SqlSessionFactory。spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成）持久层的mapper都需要由spring进行管理。</p><hr><h3 id="整合环境"><a href="#整合环境" class="headerlink" title="整合环境"></a>整合环境</h3><p>创建一个新的java工程（接近实际开发的工程结构）</p><p>（1）jar包</p><pre><code>1、mybatis3.2.7的jar包。2、spring3.2.0的jar包。3、mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供。</code></pre><p>（2）sqlSessionFactory</p><p>在applicationContext.xml配置sqlSessionFactory和数据源。sqlSessionFactory在mybatis和spring的整合包下。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis的配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h3 id="原始dao开发-和spring整合后"><a href="#原始dao开发-和spring整合后" class="headerlink" title="原始dao开发(和spring整合后)"></a>原始dao开发(和spring整合后)</h3><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.ssm.po.User&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;</code></pre><p></p><p>(2)在SqlMapconfig.xml中加载UserMapper.xml</p><pre><code>&lt;!-- 加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt; </code></pre><p>(3)dao(实现类继承SqlSessionDaoSupport)</p><pre><code>public interface UserDao {    //根据id查询用户信息    public User findUserById(int id) throws Exception;}</code></pre><p>(4)dao接口实现类注入SqlSessoinFactory</p><p>通过spring进行注入。这里spring声明配置方式，配置dao的bean。<strong>让UserDaoImpl实现类继承SqlSessionDaoSupport</strong></p><pre><code>public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao{    @Override    public User findUserById(int id) throws Exception {        //继承SqlSessionDaoSupport，通过this.getSqlSession()得到sqlSessoin        SqlSession sqlSession = this.getSqlSession();        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id);        return user;    }}</code></pre><p>(5)配置dao</p><p>在applicationContext.xml中配置dao:</p><pre><code>&lt;!-- 原始dao接口 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.iot.ssm.dao.UserDaoImpl&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>(6)测试程序</p><pre><code>public class UserDaoImplTest {    private ApplicationContext applicationContext;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testFindUserById() throws Exception {        // 创建UserDao的对象        UserDao userDao = (UserDao)applicationContext.getBean(&quot;userDao&quot;);        // 调用UserDao的方法        User user = userDao.findUserById(1);        System.out.println(user);    }}</code></pre><hr><h3 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h3><p>（1）UserMapper.java</p><pre><code>public interface UserMapper {    //根据id查询用户信息    User findUserById(int id) throws Exception;}</code></pre><p>（2）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;com.iot.ssm.mapper.UserMapper&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>（3）通过MapperFactoryBean创建代理对象</p><pre><code>&lt;!-- mapper配置    MapperFactoryBean：根据mapper接口生成代理对象    --&gt;&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        //mapperInterface指定mapper接口        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>此方法问题：需要针对每个mapper进行配置，麻烦。建议使用通过MapperScannerConfigurer进行mapper扫描。</p><pre><code>&lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册    遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中    自动扫描出来的mapper的bean的id为mapper类名（首字母小写）    --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 指定扫描的包名    如果扫描多个包，每个包中间使用半角逗号分隔    --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>（4）测试代码</p><pre><code>package com.iot.mybatis.mapper;import com.iot.ssm.mapper.UserMapper;import com.iot.ssm.po.User;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserMapperTest {    private ApplicationContext applicationContext;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testFindUserById() throws Exception {        UserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);        //调用userMapper的方法        User user = userMapper.findUserById(1);        System.out.println(user);    }}</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778934" target="_blank" rel="noopener">mybatis学习笔记(17)-spring和mybatis整合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;西风吹老洞庭波，一夜湘君白发多。&lt;/center&gt;&lt;br&gt;&lt;center&gt;醉后不知天在水，满船清梦压星河。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-元·唐珙《题龙阳县青草湖》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文主要将如何将spring和mybatis整合
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(16)-mybatis整合ehcache</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)-mybatis%E6%95%B4%E5%90%88ehcache/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(16)-mybatis整合ehcache/</id>
    <published>2019-06-30T08:25:30.000Z</published>
    <updated>2019-06-30T08:38:08.459Z</updated>
    
    <content type="html"><![CDATA[<center>夜来携手梦同游，晨起盈巾泪莫收。</center><br><center>漳浦老身三度病，咸阳宿草八回秋。</center><br><center>君埋泉下泥销骨，我寄人间雪满头。</center><br><center>阿卫韩郎相次去，夜台茫昧得知不？</center><br><center>—-唐·白居易《梦微之》</center><hr><p>ehcache是一个分布式缓存框架。</p><h3 id="分布缓存"><a href="#分布缓存" class="headerlink" title="分布缓存"></a>分布缓存</h3><p>通常系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。不使用分布缓存，缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><hr><h3 id="整合方法-掌握"><a href="#整合方法-掌握" class="headerlink" title="整合方法(掌握)"></a>整合方法(掌握)</h3><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。</p><pre><code>package org.apache.ibatis.cache;import java.util.concurrent.locks.ReadWriteLock;/** * SPI for cache providers. *  * One instance of cache will be created for each namespace. *  * The cache implementation must have a constructor that receives the cache id as an String parameter. *  * MyBatis will pass the namespace as id to the constructor. *  * &lt;pre&gt; * public MyCache(final String id) { *  if (id == null) { *    throw new IllegalArgumentException(&quot;Cache instances require an ID&quot;); *  } *  this.id = id; *  initialize(); * } * &lt;/pre&gt; * * @author Clinton Begin */public interface Cache {  /**   * @return The identifier of this cache   */  String getId();  /**   * @param key Can be any object but usually it is a {@link CacheKey}   * @param value The result of a select.   */  void putObject(Object key, Object value);  /**   * @param key The key   * @return The object stored in the cache.   */  Object getObject(Object key);  /**   * Optional. It is not called by the core.   *    * @param key The key   * @return The object that was removed   */  Object removeObject(Object key);  /**   * Clears this cache instance   */    void clear();  /**   * Optional. This method is not called by the core.   *    * @return The number of elements stored in the cache (not its capacity).   */  int getSize();  /**    * Optional. As of 3.2.6 this method is no longer called by the core.   *     * Any locking needed by the cache must be provided internally by the cache provider.   *    * @return A ReadWriteLock    */  ReadWriteLock getReadWriteLock();}</code></pre><p>mybatis默认实现cache类是：</p><pre><code>package org.apache.ibatis.cache.impl;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.cache.CacheException;/** * @author Clinton Begin */public class PerpetualCache implements Cache {  private String id;  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();  public PerpetualCache(String id) {    this.id = id;  }  public String getId() {    return id;  }  public int getSize() {    return cache.size();  }  public void putObject(Object key, Object value) {    cache.put(key, value);  }  public Object getObject(Object key) {    return cache.get(key);  }  public Object removeObject(Object key) {    return cache.remove(key);  }  public void clear() {    cache.clear();  }  public ReadWriteLock getReadWriteLock() {    return null;  }  public boolean equals(Object o) {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    if (this == o) return true;    if (!(o instanceof Cache)) return false;    Cache otherCache = (Cache) o;    return getId().equals(otherCache.getId());  }  public int hashCode() {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    return getId().hashCode();  }}</code></pre><hr><h3 id="整合ehcache"><a href="#整合ehcache" class="headerlink" title="整合ehcache"></a>整合ehcache</h3><p>加入ehcache包：</p><pre><code>1、ehcache-core-2.6.5.jar2、mybatis-ehcache-1.0.2.jar</code></pre><p>配置mapper中cache中的type为ehcache对cache接口的实现类型</p><pre><code>&lt;!-- 开启本mapper的namespace下的二级缓存type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache要和ehcache整合，需要配置type为ehcache实现cache接口的类型&lt;cache /&gt;--&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><hr><h3 id="加入ehcache的配置文件"><a href="#加入ehcache的配置文件" class="headerlink" title="加入ehcache的配置文件"></a>加入ehcache的配置文件</h3><p>在classpath下配置ehcache.xml：</p><pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt;    &lt;defaultCache         maxElementsInMemory=&quot;1000&quot;         maxElementsOnDisk=&quot;10000000&quot;        eternal=&quot;false&quot;         overflowToDisk=&quot;false&quot;         timeToIdleSeconds=&quot;120&quot;        timeToLiveSeconds=&quot;120&quot;         diskExpiryThreadIntervalSeconds=&quot;120&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778933" target="_blank" rel="noopener">mybatis学习笔记(16)-mybatis整合ehcache</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;夜来携手梦同游，晨起盈巾泪莫收。&lt;/center&gt;&lt;br&gt;&lt;center&gt;漳浦老身三度病，咸阳宿草八回秋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;君埋泉下泥销骨，我寄人间雪满头。&lt;/center&gt;&lt;br&gt;&lt;center&gt;阿卫韩郎相次去，夜台茫昧得知不？&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(15)-查询缓存之二级缓存</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%B9%8B%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(15)-查询缓存之二级缓存/</id>
    <published>2019-06-30T07:28:07.000Z</published>
    <updated>2019-06-30T08:21:50.000Z</updated>
    
    <content type="html"><![CDATA[<center>一上高城万里愁，蒹葭杨柳似汀洲。</center><br><center>溪云初起日沉阁，山雨欲来风满楼。</center><br><center>鸟下绿芜秦苑夕，蝉鸣黄叶汉宫秋。</center><br><center>行人莫问当年事，故国东来渭水流。</center><br><center>—-唐·许浑《咸阳城东楼》</center><hr><p>本文主要讲mybatis的二级缓存，二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>（1）二级缓存原理</p><p>首先开启mybatis的二级缓存。</p><pre><code>1、sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。2、如果SqlSession3去执行相同mapper下sql，执行commit提交，清空该mapper下的二级缓存区域的数据。3、sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</code></pre><p>二级缓存与一级缓存区别：<strong>二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。</strong></p><p>UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</p><hr><h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p><p>在核心配置文件SqlMapConfig.xml的settings标签中加入：</p><pre><code>// 对在此配置文件下的所有cache 进行全局性开/关设置。&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></pre><p>在UserMapper.xml中开启二缓存，UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap）:</p><pre><code>&lt;mapper namespace=&quot;com.iot.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- 开启本mapper的namespace下的二级缓存--&gt;&lt;cache /&gt;...&lt;/mapper&gt;</code></pre><hr><h3 id="调用pojo类实现序列化接口"><a href="#调用pojo类实现序列化接口" class="headerlink" title="调用pojo类实现序列化接口"></a>调用pojo类实现序列化接口</h3><pre><code>public class User implements Serializable{    ....}</code></pre><p>为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存。</p><hr><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><pre><code>// 二级缓存测试@Testpublic void testCache2() throws Exception {    SqlSession sqlSession1 = sqlSessionFactory.openSession();    SqlSession sqlSession2 = sqlSessionFactory.openSession();    SqlSession sqlSession3 = sqlSessionFactory.openSession();    // 创建代理对象    UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);    // 第一次发起请求，查询id为1的用户    User user1 = userMapper1.findUserById(1);    System.out.println(user1);    //这里执行关闭操作，将sqlsession中的数据写到二级缓存区域    sqlSession1.close();//      //使用sqlSession3执行commit()操作//      UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);//      User user  = userMapper3.findUserById(1);//      user.setUsername(&quot;张明明&quot;);//      userMapper3.updateUser(user);//      //执行提交，清空UserMapper下边的二级缓存//      sqlSession3.commit();//      sqlSession3.close();    UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);    // 第二次发起请求，查询id为1的用户    User user2 = userMapper2.findUserById(1);    System.out.println(user2);    sqlSession2.close();}</code></pre><p>无更新，输出：</p><pre><code>DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 103887628.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5User [id=1, username=测试用户22, sex=2, birthday=null, address=null]</code></pre><p>有更新，输出：</p><pre><code>DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 103887628.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Checked out connection 103887628 from pool.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt;  Preparing: update user set username=?,birthday=?,sex=?,address=? where id=? DEBUG [main] - ==&gt; Parameters: 张明明(String), null, 2(String), null, 1(Integer)DEBUG [main] - &lt;==    Updates: 1DEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.3333333333333333DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Checked out connection 103887628 from pool.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=张明明, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）useCache配置</p><p>在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p><pre><code>&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</code></pre><p>针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。</p><p>（2）刷新缓存（就是清空缓存）</p><p>刷新缓存就是清空缓存。在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。</p><p>设置statement配置中的flushCache=”true”属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。<strong>使用缓存时如果手动修改数据库表中的查询数据会出现脏读。</strong>如下：</p><pre><code>&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt;</code></pre><p>一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。</p><p>(3)应用场景和局限性</p><p>应用场景：</p><p>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。</p><p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p><p>局限性：</p><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778927" target="_blank" rel="noopener">mybatis学习笔记(15)-查询缓存之二级缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;一上高城万里愁，蒹葭杨柳似汀洲。&lt;/center&gt;&lt;br&gt;&lt;center&gt;溪云初起日沉阁，山雨欲来风满楼。&lt;/center&gt;&lt;br&gt;&lt;center&gt;鸟下绿芜秦苑夕，蝉鸣黄叶汉宫秋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;行人莫问当年事，故国东来渭水流。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(14)-查询缓存之一级缓存</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%B9%8B%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(14)-查询缓存之一级缓存/</id>
    <published>2019-06-30T07:02:26.000Z</published>
    <updated>2019-06-30T07:26:19.630Z</updated>
    
    <content type="html"><![CDATA[<center>一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。</center><br><center>惆怅孤帆连夜发，送行淡月微云。尊前不用翠眉颦。人生如逆旅，我亦是行人。</center><br><center>—-宋·苏轼《临江仙·送钱穆父》</center><hr><p>本文主要讲mybatis的一级缓存，一级缓存是SqlSession级别的缓存。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。mybaits提供一级缓存，和二级缓存。</p><p>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</p><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p><hr><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>（1）一级缓存工作原理</p><p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。</p><p>如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p><p>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p><p>（2）一级缓存测试</p><p>mybatis默认支持一级缓存，不需要在配置文件去配置。按照上边一级缓存原理步骤去测试。测试代码如下：</p><pre><code>// 一级缓存测试@Testpublic void testCache1() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    // 下边查询使用一个SqlSession    // 第一次发起请求，查询id为1的用户    User user1 = userMapper.findUserById(1);    System.out.println(user1);    // 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。    // 更新user1的信息    // user1.setUsername(&quot;测试用户22&quot;);    // userMapper.updateUser(user1);    // //执行commit操作去清空缓存    // sqlSession.commit();    // 第二次发起请求，查询id为1的用户    User user2 = userMapper.findUserById(1);    System.out.println(user2);    sqlSession.close();}</code></pre><p>不执行更新操作，输出:</p><pre><code>DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 110771485.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]User [id=1, username=王五, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Returned connection 110771485 to pool.</code></pre><p>取消测试代码中更新的的注释，输出：</p><pre><code>DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 110771485.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]DEBUG [main] - ==&gt;  Preparing: update user set username=?,birthday=?,sex=?,address=? where id=? DEBUG [main] - ==&gt; Parameters: 测试用户22(String), null, 2(String), null, 1(Integer)DEBUG [main] - &lt;==    Updates: 1DEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE id=? DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;==      Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Returned connection 110771485 to pool.</code></pre><p>（3）一级缓存应用</p><p>正式开发，是将mybatis和spring进行整合开发，事务控制在service中。一个service方法中包括很多mapper方法调用。</p><p>如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50774921" target="_blank" rel="noopener">mybatis学习笔记(14)-查询缓存之一级缓存</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。&lt;/center&gt;&lt;br&gt;&lt;center&gt;惆怅孤帆连夜发，送行淡月微云。尊前不用翠眉颦。人生如逆旅，我亦是行人。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《临江仙·送钱穆父》&lt;/ce
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(13)-延迟加载</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(13)-延迟加载/</id>
    <published>2019-06-30T00:03:09.000Z</published>
    <updated>2019-06-30T07:01:09.319Z</updated>
    
    <content type="html"><![CDATA[<center>一夕轻雷落万丝，霁光浮瓦碧参差。</center><br><center>有情芍药含春泪，无力蔷薇卧晓枝。</center><br><center>—-宋·秦观《春日》</center><hr><p>resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。</p><p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><p>需求：</p><p>如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。</p><hr><h3 id="使用association实现延迟加载"><a href="#使用association实现延迟加载" class="headerlink" title="使用association实现延迟加载"></a>使用association实现延迟加载</h3><p>（1）OrdersMapper.xml</p><p>需要定义两个mapper的方法对应的statement。</p><pre><code>// 只查询订单信息&lt;!-- 查询订单关联查询用户，用户信息需要延迟加载 --&gt;&lt;select id=&quot;findOrdersUserLazyLoading&quot; resultMap=&quot;OrdersUserLazyLoadingResultMap&quot;&gt;    SELECT * FROM orders&lt;/select&gt;// 关联查询用户信息&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.mybatis.po.User&quot;&gt;    SELECT * FROM  user  WHERE id=#{value}&lt;/select&gt;</code></pre><p>在查询订单的statement中使用association去延迟加载（执行）下边的satatement(关联查询用户信息)。通过上边查询到的订单信息中user_id去关联查询用户信息,使用UserMapper.xml中的findUserById。上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。</p><p>（2）延迟加载resultMap</p><pre><code>&lt;!-- 延迟加载的resultMap --&gt;&lt;resultMap type=&quot;com.iot.mybatis.po.Orders&quot; id=&quot;OrdersUserLazyLoadingResultMap&quot;&gt;    &lt;!--对订单信息进行映射配置  --&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 实现对用户信息进行延迟加载    select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）    要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace    column：订单信息中关联用户信息查询的列，是user_id    关联查询的sql理解为：    SELECT orders.*,    (SELECT username FROM USER WHERE orders.user_id = user.id)username,    (SELECT sex FROM USER WHERE orders.user_id = user.id)sex     FROM orders     --&gt;    &lt;association property=&quot;user&quot;  javaType=&quot;com.iot.mybatis.po.User&quot;                 select=&quot;com.iot.mybatis.mapper.UserMapper.findUserById&quot;                 column=&quot;user_id&quot;&gt;     &lt;!-- 实现对用户信息进行延迟加载 --&gt;    &lt;/association&gt;&lt;/resultMap&gt;</code></pre><p><strong>与非延迟加载的主要区别就在association标签属性多了select和column。</strong></p><p>(3)OrdersMapper.java</p><pre><code>//查询订单关联查询用户，用户信息是延迟加载public List&lt;Orders&gt; findOrdersUserLazyLoading()throws Exception;</code></pre><p>(4)延迟加载配置</p><p>mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置:lazyLoadingEnabled、aggressiveLazyLoading。</p><pre><code>lazyLoadingEnabled：全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。默认值为false。aggressiveLazyLoading：当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。默认为true。</code></pre><p>在SqlMapConfig.xml中配置：</p><pre><code>&lt;settings&gt;    &lt;!-- 打开延迟加载 的开关 --&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;!-- 将积极加载改为消极加载即按需要加载 --&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;!-- 开启二级缓存 --&gt;   &lt;!-- &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;--&gt;&lt;/settings&gt;</code></pre><p>（5）测试代码</p><pre><code>// 查询订单关联查询用户，用户信息使用延迟加载@Testpublic void testFindOrdersUserLazyLoading() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象    OrdersMapperCustom ordersMapperCustom = sqlSession            .getMapper(OrdersMapperCustom.class);    // 查询订单信息（单表）    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading();    // 遍历上边的订单列表    for (Orders orders : list) {        // 执行getUser()去查询用户信息，这里实现按需加载        User user = orders.getUser();        System.out.println(user);    }}</code></pre><hr><h3 id="延迟加载思考"><a href="#延迟加载思考" class="headerlink" title="延迟加载思考"></a>延迟加载思考</h3><p>不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？</p><p>定义两个mapper方法：</p><pre><code>1、查询订单列表。2、根据用户id查询用户信息。</code></pre><p>先去查询第一个mapper方法，获取订单信息列表；在程序中（service），按需去调用第二个mapper方法去查询用户信息。</p><p>总之，使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770050" target="_blank" rel="noopener">mybatis学习笔记(13)-延迟加载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;一夕轻雷落万丝，霁光浮瓦碧参差。&lt;/center&gt;&lt;br&gt;&lt;center&gt;有情芍药含春泪，无力蔷薇卧晓枝。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·秦观《春日》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;resultMap可以实现高级映射（使用associati
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(12)-多对多查询</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(12)-多对多查询/</id>
    <published>2019-06-29T23:06:01.000Z</published>
    <updated>2019-06-30T00:06:26.950Z</updated>
    
    <content type="html"><![CDATA[<center>无花无酒过清明，兴味萧然似野僧。</center><br><center>昨日邻家乞新火，晓窗分与读书灯。</center><br><center>—-宋·王禹偁《清明》</center><hr><p>本文实现多对多查询，查询用户及用户购买商品信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>（1）编写sql</p><pre><code>1、查询主表是：用户表。2、关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：orders、orderdetail、items。SELECT   orders.*,  user.username,  user.sex,  user.address,  orderdetail.id orderdetail_id,  orderdetail.items_id,  orderdetail.items_num,  orderdetail.orders_id,  items.name items_name,  items.detail items_detail,  items.price items_priceFROM  orders,  user,  orderdetail,  itemsWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id</code></pre><p>（2）映射思路</p><pre><code>1、将用户信息映射到user中。2、在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist3、在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetials，将订单的明细映射到orderdetials。4、在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items。</code></pre><p>（3）UserMapper.xml</p><pre><code>&lt;!-- 查询用户及购买的商品信息，使用resultmap --&gt;&lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;UserAndItemsResultMap&quot;&gt;   SELECT      orders.*,      user.username,      user.sex,      user.address,      orderdetail.id orderdetail_id,      orderdetail.items_id,      orderdetail.items_num,      orderdetail.orders_id,      items.name items_name,      items.detail items_detail,      items.price items_price    FROM      orders,      user,      orderdetail,      items    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id&lt;/select&gt;</code></pre><p>(4)resultMap</p><pre><code>&lt;!-- 查询用户及购买的商品 --&gt;&lt;resultMap type=&quot;com.iot.mybatis.po.User&quot; id=&quot;UserAndItemsResultMap&quot;&gt;    &lt;!-- 用户信息 --&gt;    &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;!-- 订单信息    一个用户对应多个订单，使用collection映射     --&gt;    &lt;collection property=&quot;ordersList&quot; ofType=&quot;com.iot.mybatis.po.Orders&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;        &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;        &lt;!-- 订单明细         一个订单包括 多个明细         --&gt;        &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.iot.mybatis.po.Orderdetail&quot;&gt;            &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;            &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;            &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;            &lt;!-- 商品信息             一个订单明细对应一个商品             --&gt;            &lt;association property=&quot;items&quot; javaType=&quot;com.iot.mybatis.po.Items&quot;&gt;                &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;                &lt;result column=&quot;items_name&quot; property=&quot;name&quot;/&gt;                &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;                &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;            &lt;/association&gt;        &lt;/collection&gt;    &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><p>(5)UserMapper.java</p><pre><code>//查询用户购买商品信息public List&lt;User&gt;  findUserAndItemsResultMap()throws Exception;</code></pre><hr><h3 id="多对多查询总结"><a href="#多对多查询总结" class="headerlink" title="多对多查询总结"></a>多对多查询总结</h3><p>一对多是多对多的特例，如下需求：</p><p>查询用户购买的商品信息，用户和商品的关系是多对多关系。</p><pre><code>需求1：查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)。企业开发中常见明细列表，用户购买商品明细列表。使用resultType将上边查询列映射到pojo输出。需求2：查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）使用resultMap将用户购买的商品明细列表映射到user对象中。</code></pre><p>总结：</p><p>使用resultMap是针对那些对查询结果映射有特殊要求的功能，比如特殊要求映射成list中包括多个list。</p><hr><h3 id="resultMap总结"><a href="#resultMap总结" class="headerlink" title="resultMap总结"></a>resultMap总结</h3><p>（1）resultType</p><p>作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。</p><p>场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</p><p>（2）resultMap</p><p>使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。</p><p>（3）association：</p><p>作用：将关联查询信息映射到一个pojo对象中。</p><p>场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。</p><p>使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。</p><p>（4）collection：</p><p>作用：将关联查询信息映射到一个list集合中。</p><p>场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770032" target="_blank" rel="noopener">mybatis学习笔记(12)-多对多查询</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;无花无酒过清明，兴味萧然似野僧。&lt;/center&gt;&lt;br&gt;&lt;center&gt;昨日邻家乞新火，晓窗分与读书灯。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·王禹偁《清明》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文实现多对多查询，查询用户及用户购买商品信息。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(11)-一对多查询</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)-%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(11)-一对多查询/</id>
    <published>2019-06-23T11:31:38.000Z</published>
    <updated>2019-06-23T15:19:07.397Z</updated>
    
    <content type="html"><![CDATA[<center>楼上谁将玉笛吹？山前水阔暝云低。劳劳燕子人千里，落落梨花雨一枝。</center><br><center>修禊近，卖饧时。故乡惟有梦相随。夜来折得江头柳，不是苏堤也皱眉。</center><br><center>—-宋·张炎《鹧鸪天·楼上谁将玉笛吹》</center><p>张炎（1248年－1320年），字叔夏，号玉田，晚年号乐笑翁。祖籍陕西凤翔。六世祖张俊，宋朝著名将领。父张枢，“西湖吟社”重要成员，妙解音律，与著名词人周密相交。张炎是勋贵之后，前半生居于临安，生活优裕，而宋亡以后则家道中落，晚年漂泊落拓。著有《山中白云词》，存词302首。张炎另一重要的贡献在于创作了中国最早的词论专著《词源》，总结整理了宋末雅词一派的主要艺术思想与成就，其中以“清空”，“骚雅”为主要主张。</p><hr><p>本文实现一对多查询，查询订单及订单明细的信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>（1）编写sql</p><pre><code>1、确定主查询表：订单表。2、确定关联查询表：订单明细表。3、在一对一查询基础上添加订单明细表关联即可。SELECT   orders.*,  user.username,  user.sex,  user.address,  orderdetail.id orderdetail_id,  orderdetail.items_id,  orderdetail.items_num,  orderdetail.orders_idFROM  orders,  user,  orderdetailWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id</code></pre><p><strong>注意上面的orderdetail.id (AS) orderdetail_id,这里需要取别名，否则由于orders表也有id字段，在后面映射时会冲突。这里需要加入orderdetail表id是因为在resultMap当中需要唯一标识的id标签。</strong></p><p>（2）映射思路</p><p>使用resultType将上边的查询结果映射到pojo中，订单信息的就是重复。但是对orders映射不能出现重复记录。</p><p>在orders.java类中添加List<orderdetail> orderDetails属性。<br>最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。映射成的orders记录数为两条（orders信息不重复）,每个orders中的orderDetails属性存储了该订单所对应的订单明细。</orderdetail></p><p>（3）在orders中添加list订单明细属性</p><pre><code>// 订单明细private List&lt;Orderdetail&gt; orderdetails;</code></pre><p>（4）OrderMapper.xml</p><pre><code>&lt;!-- 查询订单关联查询用户及订单明细，使用resultmap --&gt;&lt;select id=&quot;findOrdersAndOrderDetailResultMap&quot; resultMap=&quot;OrdersAndOrderDetailResultMap&quot;&gt;   SELECT      orders.*,      user.username,      user.sex,      user.address,      orderdetail.id orderdetail_id,      orderdetail.items_id,      orderdetail.items_num,      orderdetail.orders_id    FROM      orders,      user,      orderdetail    WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id&lt;/select&gt;</code></pre><p>(5)resultMap定义</p><pre><code>&lt;!-- 订单及订单明细的resultMap使用extends继承，不用再配置订单信息和用户信息的映射 --&gt;&lt;resultMap type=&quot;com.echodemo.mybatislearning.bean.Orders&quot; id=&quot;OrdersAndOrderDetailResultMap&quot; extends=&quot;OrdersUserResultMap&quot;&gt;    &lt;!-- 订单信息 --&gt;    &lt;!-- 用户信息 --&gt;    &lt;!-- 使用extends继承，不用再配置订单信息和用户信息的映射 --&gt;    &lt;!-- 订单明细信息    一个订单关联查询出了多条明细，要使用collection进行映射    collection：对关联查询到多条记录映射到集合对象中    property：将关联查询到多条记录映射到com.echodemo.mybatislearning.bean.Orders哪个属性    ofType：指定映射到list集合属性中pojo的类型     --&gt;    &lt;collection property=&quot;orderdetails&quot; ofType=&quot;com.echodemo.mybatislearning.bean.Orderdetail&quot;&gt;        &lt;!-- id：订单明细唯 一标识        property:要将订单明细的唯 一标识 映射到com.echodemo.mybatislearning.bean.Orderdetail的哪个属性          --&gt;        &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;        &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;        &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><p>（6）OrderMapper.java</p><pre><code>// 查询订单(关联用户)及订单明细public List&lt;Orders&gt;  findOrdersAndOrderDetailResultMap()throws Exception;</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。</p><p>（2）使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770026" target="_blank" rel="noopener">mybatis学习笔记(11)-一对多查询</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;楼上谁将玉笛吹？山前水阔暝云低。劳劳燕子人千里，落落梨花雨一枝。&lt;/center&gt;&lt;br&gt;&lt;center&gt;修禊近，卖饧时。故乡惟有梦相随。夜来折得江头柳，不是苏堤也皱眉。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·张炎《鹧鸪天·楼上谁将玉笛吹》&lt;/cente
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(10)-一对一查询</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(10)-一对一查询/</id>
    <published>2019-06-23T09:11:45.000Z</published>
    <updated>2019-06-23T11:09:14.494Z</updated>
    
    <content type="html"><![CDATA[<center>梅子留酸软齿牙，芭蕉分绿与窗纱。</center><br><center>日长睡起无情思，闲看儿童捉柳花。</center><br><center>—-宋·杨万里《闲居初夏午睡起·其一》</center><hr><p>本文使用两种方式(resultType和resultMap)实现一对一查询，查询订单信息，关联查询创建订单的用户信息。</p><h3 id="resultType实现"><a href="#resultType实现" class="headerlink" title="resultType实现"></a>resultType实现</h3><p>（1）sql语句</p><pre><code>1、确定查询的主表：订单表。2、确定查询的关联表：用户表。3、关联查询使用内连接？还是外连接？4、由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。</code></pre><p>sql语句如下：</p><pre><code>SELECT   orders.*,  user.username,  user.sex,  user.address FROM  orders,  user WHERE orders.user_id = user.id</code></pre><p>（2）创建pojo</p><pre><code>1、将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。2、原始的Orders.java不能映射全部字段，需要新创建的pojo。3、创建一个pojo继承包括查询字段较多的po类。4、对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类OrdersCustom的代码。</code></pre><p>pojo类如下：</p><pre><code>/** *  * &lt;p&gt;Title: OrdersCustom&lt;/p&gt; * &lt;p&gt;Description: 订单的扩展类&lt;/p&gt; *///通过此类映射订单和用户查询的结果，让此类继承包括字段较多的pojo类public class OrdersCustom extends Orders{    //添加用户属性    /*user.username,      user.sex,      user.address */    private String username;    private String sex;    private String address;    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }}</code></pre><p>（3）OrdersCustomMapper.xml</p><pre><code>&lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=&quot;findOrdersUser&quot;  resultType=&quot;com.echodemo.mybatislearning.bean.OrdersCustom&quot;&gt;  SELECT      orders.*,      user.username,      user.sex,      user.address    FROM      orders,      user    WHERE orders.user_id = user.id&lt;/select&gt;</code></pre><p>（4）OrdersCustomMapper.java</p><pre><code>// 查询订单关联查询用户信息public List&lt;OrdersCustom&gt; findOrdersUser()throws Exception;}</code></pre><hr><h3 id="resultMap实现"><a href="#resultMap实现" class="headerlink" title="resultMap实现"></a>resultMap实现</h3><p>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p>（1）定义resultMap</p><pre><code>&lt;!-- 订单查询关联用户的resultMap将整个查询的结果映射到com.echodemo.mybatislearning.bean.Orders中 --&gt;&lt;resultMap type=&quot;com.echodemo.mybatislearning.bean.Orders&quot; id=&quot;OrdersUserResultMap&quot;&gt;    &lt;!-- 配置映射的订单信息 --&gt;    &lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id        column：订单信息的唯一标识列        property：订单信息的唯一标识列所映射到Orders中哪个属性      --&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 配置映射的关联的用户信息 --&gt;    &lt;!-- association：用于映射关联查询单个对象的信息    property：要将关联查询的用户信息映射到Orders中哪个属性     --&gt;    &lt;association property=&quot;user&quot;  javaType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        &lt;!-- id：关联查询用户的唯 一标识        column：指定唯 一标识用户信息的列        javaType：映射到user的哪个属性         --&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;</code></pre><p>（2）statement定义</p><pre><code>&lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=&quot;findOrdersUserResultMap&quot; resultMap=&quot;OrdersUserResultMap&quot;&gt;    SELECT    orders.*,    user.username,    user.sex,    user.address    FROM    orders,    user    WHERE orders.user_id = user.id&lt;/select&gt;</code></pre><p>（3）OrdersMapper.java</p><pre><code>// 查询订单关联查询用户使用resultMappublic List&lt;Orders&gt; findOrdersUserResultMap()throws Exception;</code></pre><p>（4）测试代码</p><pre><code>@Testpublic void testFindOrdersUserResultMap() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    // 创建代理对象    OrdersMapperCustom ordersMapperCustom = sqlSession            .getMapper(OrdersMapperCustom.class);    // 调用maper的方法    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap();    System.out.println(list);    sqlSession.close();}</code></pre><hr><h3 id="resultType和resultMap实现一对一查询小结"><a href="#resultType和resultMap实现一对一查询小结" class="headerlink" title="resultType和resultMap实现一对一查询小结"></a>resultType和resultMap实现一对一查询小结</h3><p>（1）resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。</p><p>（2）resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。</p><p>（3）resultMap可以实现延迟加载，resultType无法实现延迟加载。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770023" target="_blank" rel="noopener">mybatis学习笔记(10)-一对一查询</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;梅子留酸软齿牙，芭蕉分绿与窗纱。&lt;/center&gt;&lt;br&gt;&lt;center&gt;日长睡起无情思，闲看儿童捉柳花。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·杨万里《闲居初夏午睡起·其一》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文使用两种方式(resultType和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(9)-订单商品数据模型分析</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)-%E8%AE%A2%E5%8D%95%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(9)-订单商品数据模型分析/</id>
    <published>2019-06-23T08:36:12.000Z</published>
    <updated>2019-06-23T09:10:14.994Z</updated>
    
    <content type="html"><![CDATA[<center>九月江南花事休, 芙蓉宛转在中洲。</center><br><center>美人笑隔盈盈水, 落日还生渺渺愁。</center><br><center>露洗玉盘金殿冷, 风吹罗带锦城秋。</center><br><center>相看未用伤迟暮, 别有池塘一种幽。</center><br><center>—-明·文徵明《钱氏池上芙蓉》</center><hr><p>本文对接下来几篇博客中用到的数据模型进行分析，并附上建表sql文件和测试数据文件。</p><h3 id="数据模型分析思路"><a href="#数据模型分析思路" class="headerlink" title="数据模型分析思路"></a>数据模型分析思路</h3><p>（1）每张表记录的数据内容</p><pre><code>分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。</code></pre><p>（2）每张表重要的字段设置</p><pre><code>非空字段、外键字段。</code></pre><p>（3）数据库级别表与表之间的关系</p><pre><code>外键关系。</code></pre><p>（4）表与表之间的业务关系</p><pre><code>在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析。</code></pre><hr><h3 id="数据模型分析"><a href="#数据模型分析" class="headerlink" title="数据模型分析"></a>数据模型分析</h3><pre><code>1、用户表user：记录了购买商品的用户信息。2、订单表orders：记录了用户所创建的订单（购买商品的订单）。3、订单明细表orderdetail：记录了订单的详细信息以及购买商品的信息。4、商品表items：记录了商品信息。</code></pre><p>表与表之间的业务关系<strong>（在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。先分析数据级别之间有关系的表之间的业务关系）</strong>：</p><p>（1）user和orders：</p><pre><code>user—&gt;orders：一个用户可以创建多个订单，一对多。orders—&gt;user：一个订单只由一个用户创建，一对一。</code></pre><p>（2）orders和orderdetail：</p><pre><code>orders—&gt;orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系。orderdetail—&gt; orders：一个订单明细只能包括在一个订单中，一对一。</code></pre><p>（3）orderdetail和items：</p><pre><code>orderdetail—&gt;itesms：一个订单明细只对应一个商品信息，一对一。items—&gt; orderdetail:一个商品可以存在于多个订单明细中，一对多。</code></pre><p>再分析数据库级别没有关系的表之间是否有业务关系：</p><p>（4）orders和items：</p><pre><code>orders和items之间可以通过orderdetail表建立关系。</code></pre><hr><h3 id="订单商品数据模型建表sql"><a href="#订单商品数据模型建表sql" class="headerlink" title="订单商品数据模型建表sql"></a>订单商品数据模型建表sql</h3><p>（1）商品信息表</p><pre><code>CREATE TABLE `items` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(32) NOT NULL COMMENT &apos;商品名称&apos;,  `price` float(10,1) NOT NULL COMMENT &apos;商品定价&apos;,  `detail` text COMMENT &apos;商品描述&apos;,  `pic` varchar(64) DEFAULT NULL COMMENT &apos;商品图片&apos;,  `createtime` datetime NOT NULL COMMENT &apos;生产日期&apos;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</code></pre><p>（2）用户信息表</p><pre><code>CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;,  `birthday` date DEFAULT NULL COMMENT &apos;生日&apos;,  `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;,  `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;</code></pre><p>（3）订单表</p><pre><code>CREATE TABLE `orders` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `user_id` int(11) NOT NULL COMMENT &apos;下单用户id&apos;,  `number` varchar(32) NOT NULL COMMENT &apos;订单号&apos;,  `createtime` datetime NOT NULL COMMENT &apos;创建订单时间&apos;,  `note` varchar(100) DEFAULT NULL COMMENT &apos;备注&apos;,  PRIMARY KEY (`id`),  KEY `FK_orders_1` (`user_id`),  CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre><p>（4）订单详情表</p><pre><code>CREATE TABLE `orderdetail` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `orders_id` int(11) NOT NULL COMMENT &apos;订单id&apos;,  `items_id` int(11) NOT NULL COMMENT &apos;商品id&apos;,  `items_num` int(11) DEFAULT NULL COMMENT &apos;商品购买数量&apos;,  PRIMARY KEY (`id`),  KEY `FK_orderdetail_1` (`orders_id`),  KEY `FK_orderdetail_2` (`items_id`),  CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</code></pre><hr><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>（1）商品信息表数据</p><pre><code>insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,&apos;台式机&apos;,3000.0,&apos;该电脑质量非常好！！！！&apos;,NULL,&apos;2015-02-03 13:22:53&apos;),(2,&apos;笔记本&apos;,6000.0,&apos;笔记本性能好，质量好！！！！！&apos;,NULL,&apos;2015-02-09 13:22:57&apos;),(3,&apos;背包&apos;,200.0,&apos;名牌背包，容量大质量好！！！！&apos;,NULL,&apos;2015-02-06 13:23:02&apos;);</code></pre><p>（2）用户信息表数据</p><pre><code>insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&apos;王五&apos;,NULL,&apos;2&apos;,NULL),(10,&apos;张三&apos;,&apos;2014-07-10&apos;,&apos;1&apos;,&apos;北京市&apos;),(16,&apos;张小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(22,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(24,&apos;张三丰&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(25,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(26,&apos;王五&apos;,NULL,NULL,NULL);</code></pre><p>（3）订单表数据</p><pre><code>insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,&apos;1000010&apos;,&apos;2015-02-04 13:22:35&apos;,NULL),(4,1,&apos;1000011&apos;,&apos;2015-02-03 13:22:41&apos;,NULL),(5,10,&apos;1000012&apos;,&apos;2015-02-12 16:13:23&apos;,NULL);</code></pre><p>（4）订单详情表数据</p><pre><code>insert  into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3);</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770013" target="_blank" rel="noopener">mybatis学习笔记(9)-订单商品数据模型分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;九月江南花事休, 芙蓉宛转在中洲。&lt;/center&gt;&lt;br&gt;&lt;center&gt;美人笑隔盈盈水, 落日还生渺渺愁。&lt;/center&gt;&lt;br&gt;&lt;center&gt;露洗玉盘金殿冷, 风吹罗带锦城秋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;相看未用伤迟暮, 别有池塘一种幽。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(8)-动态sql</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)-%E5%8A%A8%E6%80%81sql/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(8)-动态sql/</id>
    <published>2019-06-23T01:10:09.000Z</published>
    <updated>2019-06-23T01:35:00.634Z</updated>
    
    <content type="html"><![CDATA[<center>碧圆自洁。向浅洲远渚，亭亭清绝。犹有遗簪，不展秋心，能卷几多炎热。鸳鸯密语同倾盖，且莫与、浣纱人说。恐怨歌、忽断花风，碎却翠云千叠。 </center><br><center>回首当年汉舞，怕飞去、谩皱留仙裙折。恋恋青衫，犹染枯香，还叹鬓丝飘雪。盘心清露如铅水，又一夜、西风吹折。喜静看、匹练秋光，倒泻半湖明月。</center><br><center>—-宋·张炎《疏影·咏荷叶》</center><hr><p>mybatis核心,对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。</p><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>（1）UserMapper.xml</p><pre><code>&lt;!-- 用户信息综合查询    #{userCustom.sex}:取出pojo包装对象中性别值    ${userCustom.username}：取出pojo包装对象中用户名称 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot;        resultType=&quot;com.echodemo.mybatislearning.bean.UserCustom&quot;&gt;    SELECT * FROM user    &lt;where&gt;        &lt;if test=&quot;userCustom!=null&quot;&gt;            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt;               AND user.sex=#{userCustom.sex}            &lt;/if&gt;            &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt;               AND user.username LIKE &apos;%${userCustom.username}%&apos;            &lt;/if&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!-- 用户信息综合查询总数    parameterType：指定输入类型和findUserList一样    resultType：输出结果类型--&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) FROM user    &lt;where&gt;        &lt;if test=&quot;userCustom!=null&quot;&gt;            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt;                AND user.sex=#{userCustom.sex}            &lt;/if&gt;            &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt;                AND user.username LIKE &apos;%${userCustom.username}%&apos;            &lt;/if&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><hr><p>（2）测试结果</p><blockquote><p>a、注释掉testFindUserList()方法中的userCustom.setUsername(“张三”);</p></blockquote><pre><code>//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中userCustom.setSex(&quot;1&quot;);//userCustom.setUsername(&quot;张三&quot;);userQueryVo.setUserCustom(userCustom);</code></pre><p>输出</p><pre><code>DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapper matches criteria [is assignable to Object]DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapperTest matches criteria [is assignable to Object]DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 352359770.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1500955a]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE user.sex=? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;==      Total: 6[User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]</code></pre><p>可以看到sql语句为reparing: SELECT * FROM user WHERE user.sex=?，没有username的部分。</p><hr><blockquote><p>b、userQueryVo设为null,则userCustom为null</p></blockquote><pre><code>//List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);List&lt;UserCustom&gt; list = userMapper.findUserList(null);</code></pre><p>输出</p><pre><code>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;==      Total: 9[User [id=1, username=王五, sex=2, birthday=null, address=null], User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=26, username=王五, sex=null, birthday=null, address=null], User [id=27, username=王大军, sex=2, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]</code></pre><p>可以看到sql语句变为了SELECT * FROM user。</p><hr><h3 id="sql片段-重点"><a href="#sql片段-重点" class="headerlink" title="sql片段(重点)"></a>sql片段(重点)</h3><p>将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。</p><p>（1）定义sql片段</p><pre><code>&lt;!-- 定义sql片段id：sql片段的唯一标识经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高在sql片段中不要包括 where --&gt;&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;userCustom!=null&quot;&gt;        &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;            AND user.sex = #{userCustom.sex}        &lt;/if&gt;        &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;            AND user.username LIKE &apos;%${userCustom.username}%&apos;        &lt;/if&gt;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>（2）引用sql片段</p><pre><code>&lt;!-- 用户信息综合查询    #{userCustom.sex}:取出pojo包装对象中性别值    ${userCustom.username}：取出pojo包装对象中用户名称 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.iot.mybatis.po.UserQueryVo&quot;        resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt;    SELECT * FROM user    &lt;!--  where 可以自动去掉条件中的第一个and --&gt;    &lt;where&gt;        &lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;        &lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt;        &lt;!-- 在这里还要引用其它的sql片段  --&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><hr><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>向sql传递数组或List，mybatis使用foreach解析<br>在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，一个使用OR,一个使用IN。sql语句如下：</p><pre><code>SELECT * FROM USER WHERE id=1 OR id=10 OR id=16SELECT * FROM USER WHERE id IN(1,10,16)</code></pre><p>（1）在输入参数类型中添加List<integer> ids传入多个id</integer></p><pre><code>public class UserQueryVo {    //传入多个id    private List&lt;Integer&gt; ids;    getter、setter方法    。。。}</code></pre><p>（2）修改UserMapper.xml</p><pre><code>&lt;if test=&quot;ids!=null&quot;&gt;    &lt;!-- 使用 foreach遍历传入ids    collection：指定输入对象中集合属性    item：每个遍历生成的对象    open：开始遍历时拼接的串    close：结束遍历时拼接的串    separator：遍历的两个对象中需要拼接的串     --&gt;    &lt;!-- 使用实现下边的sql拼接：     AND (id=1 OR id=10 OR id=16)     --&gt;    &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;        &lt;!-- 每个遍历需要拼接的串 --&gt;        id=#{user_id}    &lt;/foreach&gt;    &lt;!-- 实现  “ and id IN(1,10,16)”拼接 --&gt;    &lt;!-- &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;and id IN(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;        每个遍历需要拼接的串        #{user_id}    &lt;/foreach&gt; --&gt;&lt;/if&gt;</code></pre><p>（3）测试代码</p><p>在testFindUserList中加入：</p><pre><code>//传入多个idList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();ids.add(1);ids.add(10);ids.add(16);//将ids通过userQueryVo传入statement中userQueryVo.setIds(ids);</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50766105" target="_blank" rel="noopener">mybatis学习笔记(8)-动态sql</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;碧圆自洁。向浅洲远渚，亭亭清绝。犹有遗簪，不展秋心，能卷几多炎热。鸳鸯密语同倾盖，且莫与、浣纱人说。恐怨歌、忽断花风，碎却翠云千叠。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;回首当年汉舞，怕飞去、谩皱留仙裙折。恋恋青衫，犹染枯香，还叹鬓丝飘雪。盘心清露如铅水，又
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(7)-输出映射</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)-%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(7)-输出映射/</id>
    <published>2019-06-22T03:14:53.000Z</published>
    <updated>2019-06-22T03:35:19.408Z</updated>
    
    <content type="html"><![CDATA[<center>涉江玩秋水，爱此红蕖鲜。</center><br><center>攀荷弄其珠，荡漾不成圆。</center><br><center>佳人彩云里，欲赠隔远天。</center><br><center>相思无因见，怅望凉风前。</center><br><center>—-唐·李白《折荷有赠》</center><hr><h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，<br>该列才可以映射成功。</p><p>2、如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。</p><p>3、只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。</p><hr><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>（1）UserMapper.xml</p><pre><code>&lt;!-- 用户信息综合查询总数        parameterType：指定输入类型和findUserList一样        resultType：输出结果类型    --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos;&lt;/select&gt;</code></pre><p>（2）UserMapper.java</p><pre><code>//用户信息综合查询总数@Testpublic void testFindUserCount() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建包装对象，设置查询条件    UserQueryVo userQueryVo = new UserQueryVo();    UserCustom userCustom = new UserCustom();    //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中    userCustom.setSex(&quot;1&quot;);    userCustom.setUsername(&quot;小&quot;);    userQueryVo.setUserCustom(userCustom);    //调用userMapper的方法    int count = userMapper.findUserCount(userQueryVo);    System.out.println(count);}</code></pre><p>注：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。</p><hr><h3 id="输出pojo对象和pojo列表"><a href="#输出pojo对象和pojo列表" class="headerlink" title="输出pojo对象和pojo列表"></a>输出pojo对象和pojo列表</h3><p>不管输出的pojo是单个对象还是一个列表（list中包括pojo），在UserMapper.xml中resultType指定的类型是一样的。</p><p>（1）输出单个pojo对象，方法返回值是单个对象类型</p><pre><code>//根据id查询用户信息public User findUserById(int id) throws Exception;</code></pre><p>（2）输出pojo对象list，方法返回值是List</p><pre><code>//根据用户名列查询用户列表public List&lt;User&gt; findUserByName(String name) throws Exception;</code></pre><p>生成的动态代理对象中是根据mapper方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList（返回集合对象调用 ）。</p><hr><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>mybatis中使用resultMap完成高级输出结果映射。(一对多，多对多)</p><h4 id="resultMap使用方法"><a href="#resultMap使用方法" class="headerlink" title="resultMap使用方法"></a>resultMap使用方法</h4><p>（1）如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。首先定义resultMap，然后使用resultMap作为statement的输出映射类型。</p><pre><code>&lt;!-- 定义resultMap    将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系    type：resultMap最终映射的java对象类型,可以使用别名    id：对resultMap的唯一标识     --&gt;     &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;        &lt;!-- id表示查询结果集中唯一标识         column：查询出来的列名        property：type指定的pojo类型中的属性名        最终resultMap对column和property作一个映射关系 （对应关系）        --&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--         result：对普通名映射定义        column：查询出来的列名        property：type指定的pojo类型中的属性名        最终resultMap对column和property作一个映射关系 （对应关系）         --&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt;</code></pre><p>（2）使用resultMap作为statement的输出映射类型</p><pre><code>&lt;!-- 使用resultMap进行输出映射    resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace    --&gt;&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    SELECT id id_,username username_ FROM USER WHERE id=#{value}&lt;/select&gt;</code></pre><p>（3）UserMapper.java</p><pre><code>//根据id查询用户信息，使用resultMap输出public User findUserByIdResultMap(int id) throws Exception;</code></pre><p>（4）测试代码</p><pre><code>@Testpublic void testFindUserByIdResultMap() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //调用userMapper的方法    User user = userMapper.findUserByIdResultMap(1);    System.out.println(user);}</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。</p><p>2、如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50765422" target="_blank" rel="noopener">mybatis学习笔记(7)-输出映射</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;涉江玩秋水，爱此红蕖鲜。&lt;/center&gt;&lt;br&gt;&lt;center&gt;攀荷弄其珠，荡漾不成圆。&lt;/center&gt;&lt;br&gt;&lt;center&gt;佳人彩云里，欲赠隔远天。&lt;/center&gt;&lt;br&gt;&lt;center&gt;相思无因见，怅望凉风前。&lt;/center&gt;&lt;br&gt;&lt;center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(6)-输入映射</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)-%E8%BE%93%E5%85%A5%E6%98%A0%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(6)-输入映射/</id>
    <published>2019-06-22T03:14:53.000Z</published>
    <updated>2019-06-22T03:27:28.429Z</updated>
    
    <content type="html"><![CDATA[<center>杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。</center><br><center>返照迎潮，行云带雨。依依似与骚人语。当年不肯嫁春风，无端却被秋风误。</center><br><center>—-宋·贺铸《芳心苦·杨柳回塘》</center><hr><p>通过parameterType指定输入参数的类型，类型可以是：</p><blockquote><p>简单类型</p><p>hashmap</p><p>pojo的包装类型（在实际的应用中，很多时候我们需要的查询条件都是一个综合的查询条件。比如进行连表查询时需要传入多个对象的数据）</p></blockquote><hr><h3 id="传递pojo的包装对象"><a href="#传递pojo的包装对象" class="headerlink" title="传递pojo的包装对象"></a>传递pojo的包装对象</h3><p>（1）定义包装类型pojo</p><pre><code>package com.echodemo.mybatislearning.bean;/** * Created by Brian on 2016/2/24. */public class UserQueryVo {    //在这里包装所需要的查询条件    //用户查询条件    private UserCustom userCustom;    public UserCustom getUserCustom() {        return userCustom;    }    public void setUserCustom(UserCustom userCustom) {        this.userCustom = userCustom;    }    //可以包装其它的查询条件，订单、商品    //....}</code></pre><p>其中，UserCustom类继承User：</p><pre><code>public class UserCustom extends User{}</code></pre><hr><p>（2）UserMapper.xml</p><p>在UserMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行复杂关联查询）。</p><pre><code>&lt;!-- 用户信息综合查询        #{userCustom.sex}:取出pojo包装对象中性别值        ${userCustom.username}：取出pojo包装对象中用户名称     --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot;        resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt;    SELECT * FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos;&lt;/select&gt;</code></pre><p>注意:不要将#{userCustom.sex}中的userCustom写成UserCustom,前者指属性名(由于使用IDE提示自动补全，所以只是把类型名首字母小写了)，后者指类型名，这里是UserQueryVo类中的userCustom属性，是属性名。写错会报如下异常：</p><pre><code>org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos;</code></pre><hr><p>（3）UserMapper.java</p><pre><code>//用户信息综合查询public List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception;</code></pre><hr><p>（4）测试代码</p><pre><code>//用户信息的综合查询@Testpublic void testFindUserList() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建包装对象，设置查询条件    UserQueryVo userQueryVo = new UserQueryVo();    UserCustom userCustom = new UserCustom();    //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中    userCustom.setSex(&quot;1&quot;);    userCustom.setUsername(&quot;张三&quot;);    userQueryVo.setUserCustom(userCustom);    //调用userMapper的方法    List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);    System.out.println(list);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。&lt;/center&gt;&lt;br&gt;&lt;center&gt;返照迎潮，行云带雨。依依似与骚人语。当年不肯嫁春风，无端却被秋风误。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·贺铸《芳心苦·杨柳回塘》&lt;/cent
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(5)-配置文件</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(5)-配置文件/</id>
    <published>2019-06-22T02:50:48.000Z</published>
    <updated>2019-06-22T03:13:51.012Z</updated>
    
    <content type="html"><![CDATA[<center>野有蔓草，零露漙兮。有美一人，清扬婉兮。邂逅相遇，适我愿兮。</center><br><center>野有蔓草，零露瀼瀼。有美一人，婉如清扬。邂逅相遇，与子偕臧。</center><br><center>—-先秦·佚名《国风·郑风·野有蔓草》</center><hr><h3 id="SqlMapConfig-xml中配置的内容和顺序"><a href="#SqlMapConfig-xml中配置的内容和顺序" class="headerlink" title="SqlMapConfig.xml中配置的内容和顺序"></a>SqlMapConfig.xml中配置的内容和顺序</h3><pre><code>1、properties（属性）2、settings（全局配置参数）3、typeAliases（类型别名）4、typeHandlers（类型处理器）5、objectFactory（对象工厂）6、plugins（插件）7、environments（环境集合属性对象）     &gt;environment（环境子属性对象）         &gt;transactionManager（事务管理）        &gt;dataSource（数据源）8、mappers（映射器）</code></pre><p>其中typeAliases（类型别名）和mappers（映射器）是重点。</p><hr><h3 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties(属性)"></a>properties(属性)</h3><p>将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。原因：方便对参数进行统一管理，其它xml也可以引用该db.properties。</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis?characterEncoding=utf-8&amp;amp;serverTimezonejdbc.username=rootjdbc.password=</code></pre><hr><p>在sqlMapConfig.xml加载属性文件：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;&gt;        &lt;!--properties中还可以配置一些属性名和属性值  --&gt;        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;&lt;/properties&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;        &lt;!-- 数据库连接池,由mybatis管理--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><hr><p>注意： MyBatis 将按照下面的顺序(优先级)来加载属性：</p><p>1、在properties元素体内定义的属性首先被读取。</p><p>2、然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。</p><p>3、最后读取parameterType传递的属性，它会覆盖已读取的同名属性。</p><p>建议：</p><p>1、不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。</p><p>2、在properties文件中定义属性名要有一定的特殊性，如：XXXXX.XXXXX.XXXX</p><hr><h3 id="settings-全局参数配置"><a href="#settings-全局参数配置" class="headerlink" title="settings(全局参数配置)"></a>settings(全局参数配置)</h3><p>mybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载…<br>全局参数将会影响mybatis的运行行为。具体参考官网：</p><p><a href="http://www.mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">MyBatis-settings</a></p><hr><h3 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h3><p>在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。</p><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>（1）mybatis默认支持别名</p><p><a href="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">MyBatis-typeAliases</a></p><p>（2）自定义别名</p><pre><code>1、单个别名定义2、批量定义别名（常用）&lt;!-- 别名定义 --&gt;&lt;typeAliases&gt;    &lt;!-- 针对单个别名定义    type：类型的路径    alias：别名     --&gt;    &lt;!-- &lt;typeAlias type=&quot;com.echodemo.mybatislearning.bean.User&quot; alias=&quot;user&quot;/&gt; --&gt;    &lt;!-- 批量别名定义    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名    （首字母大写或小写都可以）    --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.bean&quot;/&gt;&lt;/typeAliases&gt;</code></pre><hr><h3 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如：</p><pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        select * from user where id = #{id}&lt;/select&gt;</code></pre><p>mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。</p><pre><code>http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers</code></pre><hr><h3 id="mappers-映射配置"><a href="#mappers-映射配置" class="headerlink" title="mappers(映射配置)"></a>mappers(映射配置)</h3><p>（1）通过resource加载单个映射文件：</p><pre><code>&lt;mappers&gt;    &lt;!--通过resource方法一次加载一个映射文件 --&gt;    &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;&lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt;&lt;resources&gt;    &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>（2）通过mapper接口加载单个mapper：</p><pre><code>&lt;!-- 通过mapper接口加载单个映射文件        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，        且在一个目录中上边规范的前提是：使用的是mapper代理方法         --&gt;&lt;mapper class=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;/&gt;</code></pre><p>（3）目录示例：</p><pre><code>com.iot.mybatis.mapper------------------package包   |----UserMapper.java   |----UserMapper.xml</code></pre><p>（4）批量加载mapper(推荐使用)</p><pre><code>&lt;mappers&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;&lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt;&lt;resources&gt;    &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50759845" target="_blank" rel="noopener">mybatis学习笔记(5)-配置文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;野有蔓草，零露漙兮。有美一人，清扬婉兮。邂逅相遇，适我愿兮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;野有蔓草，零露瀼瀼。有美一人，婉如清扬。邂逅相遇，与子偕臧。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-先秦·佚名《国风·郑风·野有蔓草》&lt;/center&gt;


      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(4)-开发dao方法</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)-%E5%BC%80%E5%8F%91dao%E6%96%B9%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(4)-开发dao方法/</id>
    <published>2019-06-22T02:18:37.000Z</published>
    <updated>2019-06-22T03:13:19.940Z</updated>
    
    <content type="html"><![CDATA[<center>疏雨洗天清，枕簟凉生。井桐一叶做秋声。谁念客身轻似叶，千里飘零？</center><br><center>梦断古台城，月淡潮平。便须携酒访新亭。不见当时王谢宅，烟草青青。</center><br><center>—-宋·邓剡《浪淘沙·疏雨洗天清》</center><hr><h3 id="SqlSession使用范围"><a href="#SqlSession使用范围" class="headerlink" title="SqlSession使用范围"></a>SqlSession使用范围</h3><p>（1）SqlSessionFactoryBuilder</p><p>通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建SqlSessionFactory时候，只需要new一次SqlSessionFactoryBuilder即可。</p><p>（2）SqlSessionFactory</p><p>通过SqlSessionFactory创建SqlSession，使用单例模式管理sqlSessionFactory（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory。</p><p>（3）SqlSession</p><p>SqlSession是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法。如：selectOne(返回单个对象)、selectList（返回单个或多个对象）。</p><p>SqlSession是线程不安全的，在SqlSesion实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性（比如org.apache.ibatis.session.Configuration和java.sql.Connection）。SqlSession最佳应用场合在方法体内，定义成局部变量使用。</p><center><br><br><img src="/images/2019/6/SqlSession.png" alt="&quot;SqlSession&quot;"><br><br></center><hr><h3 id="原始dao开发方法"><a href="#原始dao开发方法" class="headerlink" title="原始dao开发方法"></a>原始dao开发方法</h3><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><pre><code>package com.echodemo.mybatislearning.dao;import com.echodemo.mybatislearning.bean.User;import java.util.List;public interface UserDao {    //根据id查询用户信息    public User findUserById(int id) throws Exception;    //根据用户名列查询用户列表    public List&lt;User&gt; findUserByName(String name) throws Exception;    //添加用户信息    public void insertUser(User user) throws Exception;    //删除用户信息    public void deleteUser(int id) throws Exception;}</code></pre><h4 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h4><pre><code>package com.echodemo.mybatislearning.dao.Impl;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.dao.UserDao;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao {    // 需要向dao实现类中注入SqlSessionFactory，这里通过构造方法注入    private SqlSessionFactory sqlSessionFactory;    public UserDaoImpl(SqlSessionFactory sqlSessionFactory){        this.sqlSessionFactory = sqlSessionFactory;    }    @Override    public User findUserById(int id) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id);        //释放资源        sqlSession.close();        return user;    }    @Override    public List&lt;User&gt; findUserByName(String name) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, name);        // 释放资源        sqlSession.close();        return list;    }    @Override    public void insertUser(User user) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行插入操作        sqlSession.insert(&quot;test.insertUser&quot;, user);        // 提交事务        sqlSession.commit();        // 释放资源        sqlSession.close();    }    @Override    public void deleteUser(int id) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行插入操作        sqlSession.delete(&quot;test.deleteUser&quot;, id);        // 提交事务        sqlSession.commit();        // 释放资源        sqlSession.close();    }}</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.dao.Impl.UserDaoImpl;import com.echodemo.mybatislearning.dao.UserDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;public class UserDaoImplTest {    private SqlSessionFactory sqlSessionFactory;    // 此方法是在执行testFindUserById之前执行    @Before    public void setUp() throws Exception {        // 创建sqlSessionFactory，mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    @Test    public void testFindUserById() throws Exception {        // 创建UserDao的对象        UserDao userDao = new UserDaoImpl(sqlSessionFactory);        // 调用UserDao的方法        User user = userDao.findUserById(3);        System.out.println(user.toString());    }}</code></pre><h4 id="总结原始dao开发问题"><a href="#总结原始dao开发问题" class="headerlink" title="总结原始dao开发问题"></a>总结原始dao开发问题</h4><p>1、dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。</p><p>2、调用sqlsession方法时将statement的id硬编码了</p><p>3、调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。</p><h3 id="mapper代理方法"><a href="#mapper代理方法" class="headerlink" title="mapper代理方法"></a>mapper代理方法</h3><pre><code>1、程序员只需要mapper接口（相当于dao接口）2、程序员还需要编写mapper.xml映射文件3、程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</code></pre><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><p>（1）在UserMapper.xml中namespace等于mapper接口地址</p><pre><code>&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址 --&gt;&lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt;</code></pre><p>1、UserMapper.java接口中的方法名和UserMapper.xml中statement的id一致</p><p>2、UserMapper.java接口中的方法输入参数类型和UserMapper.xml中statement的parameterType指定的类型一致。</p><p>3、UserMapper.java接口中的方法返回值类型和UserMapper.xml中statement的resultType指定的类型一致。</p><pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.mybatis.po.User&quot;&gt;    SELECT * FROM  user  WHERE id=#{value}&lt;/select&gt;//根据id查询用户信息public User findUserById(int id) throws Exception;//总结：以上开发规范主要是对类似下边代码进行统一生成：User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);sqlSession.insert(&quot;test.insertUser&quot;, user);</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;    &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条    resultType：指定就是单条记录所映射的java对象类型    ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。    使用${}拼接sql，引起 sql注入    ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value     --&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos;    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;        &lt;!--         将插入数据的主键返回，返回到user对象中         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序         resultType：指定SELECT LAST_INSERT_ID()的结果类型          --&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;integer&quot;&gt;            SELECT LAST_INSERT_ID()        &lt;/selectKey&gt;        INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address})        &lt;!--            使用mysql的uuid（）生成主键            执行过程：            首先通过uuid()得到主键，将主键设置到user对象的id属性中            其次在insert执行时，从user对象中取出id属性值             --&gt;        &lt;!--  &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;            SELECT uuid()        &lt;/selectKey&gt;        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt;    &lt;/insert&gt;    &lt;!-- 删除 用户        根据id删除用户，需要输入 id值         --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;integer&quot;&gt;        delete from user where id=#{id}    &lt;/delete&gt;    &lt;!-- 根据id更新用户    分析：    需要传入用户的id    需要传入用户的更新信息    parameterType指定user对象，包括 id和更新信息，注意：id必须存在    #{id}：从输入 user对象中获取id属性值     --&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;user&quot;&gt;        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}        where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>（2）在SqlMapConfig.xml中加载映射文件</p><pre><code>&lt;mappers&gt;    &lt;!--通过resource方法一次加载一个映射文件 --&gt;    &lt;!--&lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;--&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre><p>有两种方式，每种方式都要在pom文件中的build标签里面加入相应的路径指引：</p><pre><code>&lt;resources&gt;    &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt;    &lt;!--&lt;resource&gt;--&gt;        &lt;!--&lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;--&gt;        &lt;!--&lt;includes&gt;--&gt;            &lt;!--&lt;include&gt;**/*.xml&lt;/include&gt;--&gt;        &lt;!--&lt;/includes&gt;--&gt;    &lt;!--&lt;/resource&gt;--&gt;    &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>（3）UserMapper.java</p><pre><code>package com.echodemo.mybatislearning.mapper;import com.echodemo.mybatislearning.bean.User;import java.util.List;public interface UserMapper {    //根据id查询用户信息    public User findUserById(int id) throws Exception;    //根据用户名列查询用户列表    public List&lt;User&gt; findUserByName(String name) throws Exception;    //添加用户信息    public void insertUser(User user) throws Exception;    //删除用户信息    public void deleteUser(int id) throws Exception;    //更新用户    public void updateUser(User user)throws Exception;}</code></pre><p>（4）UserMapperTest.java</p><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.mapper.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;public class UserMapperTest {    private SqlSessionFactory sqlSessionFactory;    //注解Before是在执行本类所有测试方法之前先调用这个方法    @Before    public void setup() throws Exception{        //创建SqlSessionFactory        String resource=&quot;SqlMapConfig.xml&quot;;        //将配置文件加载成流        InputStream inputStream = Resources.getResourceAsStream(resource);        //创建会话工厂，传入mybatis配置文件的信息        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testFindUserById() throws Exception{        SqlSession sqlSession = sqlSessionFactory.openSession();        //创建UserMapper代理对象        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //调用userMapper的方法        User user = userMapper.findUserById(3);        System.out.println(user.getUsername());    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）代理对象内部调用selectOne或selectList</p><pre><code>1、如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。2、如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。</code></pre><p>（2）mapper接口方法参数只能有一个是否影响系统开发</p><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护?系统框架中，dao层的代码是被业务层公用的。即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p><strong>注意：持久层方法的参数可以包装类型、map…等，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</strong></p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50756808" target="_blank" rel="noopener">mybatis学习笔记(4)-开发dao方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;疏雨洗天清，枕簟凉生。井桐一叶做秋声。谁念客身轻似叶，千里飘零？&lt;/center&gt;&lt;br&gt;&lt;center&gt;梦断古台城，月淡潮平。便须携酒访新亭。不见当时王谢宅，烟草青青。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·邓剡《浪淘沙·疏雨洗天清》&lt;/center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(3)-入门程序</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E4%B8%80/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(3)-入门程序一/</id>
    <published>2019-06-22T01:52:40.000Z</published>
    <updated>2019-06-22T02:17:35.683Z</updated>
    
    <content type="html"><![CDATA[<center>燎沉香，消溽暑。鸟雀呼晴，侵晓窥檐语。叶上初阳干宿雨、水面清圆，一一风荷举。</center><br><center>故乡遥，何日去。家住吴门，久作长安旅。五月渔郎相忆否。小楫轻舟，梦入芙蓉浦。</center><br><center>—-宋·周邦彦《苏幕遮·燎沉香》</center><hr><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>（1）log4j.properties</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>（2）SqlMapConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 和spring整合后 environments配置将废除--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据库连接池,由mybatis管理--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;    &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条    resultType：指定就是单条记录所映射的java对象类型    ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。    使用${}拼接sql，引起 sql注入    ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value     --&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos;    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        &lt;!--         将插入数据的主键返回，返回到user对象中         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序         resultType：指定SELECT LAST_INSERT_ID()的结果类型          --&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;            SELECT LAST_INSERT_ID()        &lt;/selectKey&gt;        INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address})        &lt;!--            使用mysql的uuid（）生成主键            执行过程：            首先通过uuid()得到主键，将主键设置到user对象的id属性中            其次在insert执行时，从user对象中取出id属性值             --&gt;        &lt;!--  &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;            SELECT uuid()        &lt;/selectKey&gt;        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt;    &lt;/insert&gt;    &lt;!-- 删除 用户        根据id删除用户，需要输入 id值         --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;        delete from user where id=#{id}    &lt;/delete&gt;    &lt;!-- 根据id更新用户    分析：    需要传入用户的id    需要传入用户的更新信息    parameterType指定user对象，包括 id和更新信息，注意：id必须存在    #{id}：从输入 user对象中获取id属性值     --&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}        where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>（2）在sqlMapConfig.xml中加载User.xml</p><pre><code>&lt;!-- 加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><p>（1）po类User.java</p><p>package com.echodemo.mybatislearning.bean;</p><p>import lombok.ToString;</p><pre><code>@ToStringpublic class User {    //属性名要和数据库表的字段对应    private int id;    private String username;// 用户姓名    private String sex;// 性别    private String birthday;// 生日    private String address;// 地址    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    public String getBirthday() {        return birthday;    }    public void setBirthday(String birthday) {        this.birthday = birthday;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }}</code></pre><p>（2）测试代码</p><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.util.DateUtil;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserTest {    @Test    public void findUserByIdTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream =  Resources.getResourceAsStream(resource);        //创建会话工厂，传入mybatis配置文件的信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 通过SqlSession操作数据库        // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id        // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数        // sqlSession.selectOne结果是与映射文件中所匹配的resultType类型的对象        // selectOne查询出一条记录        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);        System.out.println(user);        // 释放资源        sqlSession.close();    }    // 根据用户名称模糊查询用户列表    @Test    public void findUserByNameTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // list中的user和映射文件中resultType所指定的类型一致        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, &quot;小明&quot;);        System.out.println(list);        sqlSession.close();    }    // 添加用户信息    @Test    public void insertUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 插入用户对象        User user = new User();        user.setId(5);        user.setUsername(&quot;王小军&quot;);        user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;));        user.setSex(&quot;男&quot;);        user.setAddress(&quot;河南郑州&quot;);        sqlSession.insert(&quot;test.insertUser&quot;, user);        // 提交事务        sqlSession.commit();        // 获取用户信息主键        System.out.println(user.getId());        // 关闭会话        sqlSession.close();    }    // 根据id删除 用户信息    @Test    public void deleteUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 传入id删除 用户        sqlSession.delete(&quot;test.deleteUser&quot;, 1);        // 提交事务        sqlSession.commit();        // 关闭会话        sqlSession.close();    }    // 更新用户信息    @Test    public void updateUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 更新用户信息        User user = new User();        //必须设置id        user.setId(5);        user.setUsername(&quot;王大军&quot;);        user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;));        user.setSex(&quot;2&quot;);        user.setAddress(&quot;河南郑州&quot;);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();        // 关闭会话        sqlSession.close();    }}</code></pre><p>改文章转载自：</p><p><a href="https://blog.csdn.net/h3243212/article/details/50756631" target="_blank" rel="noopener">mybatis学习笔记(3)-入门程序一</a></p><p><a href="https://blog.csdn.net/h3243212/article/details/50756635" target="_blank" rel="noopener">mybatis学习笔记(3)-入门程序二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;燎沉香，消溽暑。鸟雀呼晴，侵晓窥檐语。叶上初阳干宿雨、水面清圆，一一风荷举。&lt;/center&gt;&lt;br&gt;&lt;center&gt;故乡遥，何日去。家住吴门，久作长安旅。五月渔郎相忆否。小楫轻舟，梦入芙蓉浦。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·周邦彦《苏幕遮·燎沉
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(2)-mybatis概述</title>
    <link href="http://www.echodemo.cc/2019/06/19/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-mybatis%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.echodemo.cc/2019/06/19/mybatis学习笔记(2)-mybatis概述/</id>
    <published>2019-06-19T13:47:20.000Z</published>
    <updated>2019-06-21T16:51:09.601Z</updated>
    
    <content type="html"><![CDATA[<center>一尺深红胜曲尘，天生旧物不如新。</center><br><center>合欢桃核终堪恨，里许元来别有人。</center><br><center>井底点灯深烛伊，共郎长行莫围棋。</center><br><center>玲珑骰子安红豆，入骨相思知不知。</center><br><center>—-唐·温庭筠《新添声杨柳枝词》</center><hr><h3 id="mybatis-介绍"><a href="#mybatis-介绍" class="headerlink" title="mybatis 介绍"></a>mybatis 介绍</h3><p>（1）mybatis是一个持久层的框架，是apache下的顶级项目。</p><p>（2）mybatis托管到goolecode下，再后来托管到github(<a href="https://github.com/mybatis/mybatis-3/releases)。" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases)。</a></p><p>（3）mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p><p>（4）mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）。</p><hr><h3 id="mybatis框架执行过程"><a href="#mybatis框架执行过程" class="headerlink" title="mybatis框架执行过程"></a>mybatis框架执行过程</h3><p>（1）配置mybatis的配置文件，SqlMapConfig.xml（名称不固定）。</p><p>（2）通过配置文件，加载mybatis运行环境（environment标签），创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式) 。</p><p>（3）通过SqlSessionFactory创建SqlSession。<strong>SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。 </strong></p><p>（4）调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。 </p><p>（5）释放资源，关闭SqlSession。</p><center><br><br><img src="/images/2019/6/SqlSession.png" alt="&quot;SqlSession&quot;"><br><br></center><hr><h3 id="mybatis开发dao的方法"><a href="#mybatis开发dao的方法" class="headerlink" title="mybatis开发dao的方法"></a>mybatis开发dao的方法</h3><p>（1）原始dao 的方法</p><pre><code>a、需要程序员编写dao接口和实现类b、需要在dao实现类中注入一个SqlSessionFactory工厂</code></pre><p>（2）mapper代理开发方法（建议使用）</p><p>只需要程序员编写mapper接口（就是dao接口）。 程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范：</p><pre><code>a、mapper.xml中namespace就是mapper.java的类全路径。b、mapper.xml中statement的id和mapper.java中方法名一致。c、mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致。d、mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。</code></pre><p>SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。</p><hr><h3 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h3><p>（1）输入映射：</p><pre><code>a、parameterType：指定输入参数类型可以简单类型、pojo、hashmap。b、对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。</code></pre><p>（2）输出映射：</p><pre><code>a、resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。b、reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。 </code></pre><p>（3）高级映射： </p><pre><code>a、将关联查询的列映射到一个pojo属性中。（一对一）b、将关联查询的列映射到一个List中。（一对多）</code></pre><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><blockquote><p>动态sql：（重点） </p><blockquote><p>if判断（掌握）</p></blockquote><blockquote><p>where</p></blockquote><blockquote><p>foreach</p></blockquote><blockquote><p>sql片段（掌握）</p></blockquote></blockquote><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50756622" target="_blank" rel="noopener">mybatis学习笔记(2)-mybatis概述</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;一尺深红胜曲尘，天生旧物不如新。&lt;/center&gt;&lt;br&gt;&lt;center&gt;合欢桃核终堪恨，里许元来别有人。&lt;/center&gt;&lt;br&gt;&lt;center&gt;井底点灯深烛伊，共郎长行莫围棋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;玲珑骰子安红豆，入骨相思知不知。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
</feed>
