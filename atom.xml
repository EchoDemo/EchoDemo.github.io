<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-01-30T09:29:08.805Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://www.echodemo.cc/2019/01/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2019/01/30/Linux常用命令/</id>
    <published>2019-01-30T09:26:32.000Z</published>
    <updated>2019-01-30T09:29:08.805Z</updated>
    
    <content type="html"><![CDATA[<p>1、查看当前在线用户</p><pre><code>[root@jaja ~]# w</code></pre><p>2、查看Linux版本</p><pre><code>[root@jaja ~]# lsb_release -a</code></pre><p>3、查看进程树</p><pre><code>[root@jaja docker]# pstree -p</code></pre><p>4、使用ZMODEM进行文件传输</p><pre><code>从Windows上传至Linux：[root@jaja docker]# rz从Linux下载至Windows：[root@jaja docker]# sz</code></pre><p>5、查看内存使用情况</p><pre><code>[root@jaja docker]# free -m</code></pre><p>6、查看磁盘剩余空间</p><pre><code>[root@jaja docker]# df -h</code></pre><p>7、查看Linux内核版本</p><pre><code>[root@jaja docker]# uname -r </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、查看当前在线用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja ~]# w
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、查看Linux版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja ~]# lsb_release -a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、查看进
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://www.echodemo.cc/2019/01/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2019/01/20/Docker常用命令/</id>
    <published>2019-01-20T04:16:40.000Z</published>
    <updated>2019-01-30T09:26:43.577Z</updated>
    
    <content type="html"><![CDATA[<p>1、查看所有的容器</p><pre><code>[root@jaja docker]# docker ps -a</code></pre><p>2、查看正在运行的容器</p><pre><code>[root@jaja docker]# docker ps</code></pre><p>3、启动已终止的容器</p><pre><code>[root@jaja docker]# docker start (container id)</code></pre><p>4、终止已启动的容器</p><pre><code>[root@jaja docker]# docker stop (container id)</code></pre><p>5、重启容器</p><pre><code>[root@jaja docker]# docker restart (container id)</code></pre><p>6、进入容器交互式环境</p><pre><code>[root@jaja docker]# docker exec -it (container id) /bin/bash</code></pre><p>7、退出容器交互式环境</p><pre><code>[root@jaja docker]# exit 或者使用快捷键 Ctrl + D</code></pre><p>8、导出容器</p><pre><code>[root@jaja docker]# docker export (container id) &gt; (filename).tar</code></pre><p>9、导入容器</p><pre><code>[root@jaja docker]# cat (filename).tar | docker import - (image name):(tag)</code></pre><p>10、查看当前宿主机上的镜像列表</p><pre><code>[root@jaja docker]# docker image ls 或者 docker images</code></pre><p>11、删除处于终止状态的容器</p><pre><code>(1)直接终止容器：[root@jaja docker]# docker rm (container id)(2)如果正在运行则要先终止：[root@jaja docker]# docker stop (container id)</code></pre><p>12、删除所有处于终止状态的容器</p><pre><code>[root@jaja docker]# docker container prune</code></pre><p>13、打印容器的标准输出</p><pre><code>[root@jaja docker]# docker logs</code></pre><p>14、删除镜像(在删除镜像之前需要先停止容器，再删除容器)</p><pre><code>[root@jaja docker]# docker rmi (image id)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、查看所有的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja docker]# docker ps -a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、查看正在运行的容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@jaja docker]# docker ps
&lt;/code
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>醒来</title>
    <link href="http://www.echodemo.cc/2019/01/20/%E9%86%92%E6%9D%A5/"/>
    <id>http://www.echodemo.cc/2019/01/20/醒来/</id>
    <published>2019-01-20T02:16:34.000Z</published>
    <updated>2019-01-20T04:07:40.437Z</updated>
    
    <content type="html"><![CDATA[<p>来呀，将我从一场忧伤的梦中惊醒</p><p>把我的沉睡赶走</p><p>这该死的虚无</p><p><br><br>昨夜的大雨</p><p>无尽的黑夜</p><p>喧嚣的逼仄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来呀，将我从一场忧伤的梦中惊醒&lt;/p&gt;
&lt;p&gt;把我的沉睡赶走&lt;/p&gt;
&lt;p&gt;这该死的虚无&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;昨夜的大雨&lt;/p&gt;
&lt;p&gt;无尽的黑夜&lt;/p&gt;
&lt;p&gt;喧嚣的逼仄&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 买卖股票的最佳时机 II</title>
    <link href="http://www.echodemo.cc/2019/01/19/LeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <id>http://www.echodemo.cc/2019/01/19/LeetCode-买卖股票的最佳时机-II/</id>
    <published>2019-01-19T15:49:20.000Z</published>
    <updated>2019-01-19T16:29:19.452Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><pre><code>示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;pre&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之通过XML装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配Bean之通过XML装配Bean/</id>
    <published>2019-01-12T08:27:20.000Z</published>
    <updated>2019-01-27T06:44:14.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建XML配置规范"><a href="#1、创建XML配置规范" class="headerlink" title="1、创建XML配置规范"></a>1、创建XML配置规范</h3><p>在使用XML为Spring装配bean之前，需要创建一个新的配置规范。在使用JavaConfig的时候，这意味着要创建一个带有@Configuration注解的类，而在XML配置中，这意味着要创建一个XML文件，并且要以beans元素为根。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- ... --&gt;&lt;/beans&gt;</code></pre><h3 id="2、声明一个简单的bean"><a href="#2、声明一个简单的bean" class="headerlink" title="2、声明一个简单的bean"></a>2、声明一个简单的bean</h3><p>要在基于XML的Spring配置中声明一个bean，我们要使用spring-beans模式中的另外一个元素：bean。bean元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明CompactDisc bean：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt;</code></pre><p>当Spring发现这个bean元素时，它将会调用SgtPeppers的默认构造器来创建bean。</p><h3 id="3、借助构造器注入初始化的bean"><a href="#3、借助构造器注入初始化的bean" class="headerlink" title="3、借助构造器注入初始化的bean"></a>3、借助构造器注入初始化的bean</h3><h4 id="1-构造器注入bean的引用"><a href="#1-构造器注入bean的引用" class="headerlink" title="(1)构造器注入bean的引用"></a>(1)构造器注入bean的引用</h4><p>1)使用constructor-arg元素：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;constructor-arg ref=&quot;compactDisc&quot;/&gt;&lt;/bean&gt;</code></pre><p>2)使用Spring3.0所引入的c-命名空间：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;     c:cd-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>属性名以c:开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后”-ref”，告诉Spring正在装配的是一个bean的引用。</p><p>在这里它直接引用构造器参数的名称即上面的”cd”，如果参数的名称修改了，此处的配置也要进行修改，因此可以使用参数在整个参数列表中的位置来替代：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;      c:_0-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>如果只有一个构造器参数则可以使用下面的方案：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;      c:_-ref=&quot;compactDisc&quot;/&gt;</code></pre><h5 id="注：使用c-命名空间需要先在XML的顶部声明其模式："><a href="#注：使用c-命名空间需要先在XML的顶部声明其模式：" class="headerlink" title="注：使用c-命名空间需要先在XML的顶部声明其模式："></a>注：使用c-命名空间需要先在XML的顶部声明其模式：</h5><pre><code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></pre><h4 id="2-将字面量注入到构造器中"><a href="#2-将字面量注入到构造器中" class="headerlink" title="(2)将字面量注入到构造器中"></a>(2)将字面量注入到构造器中</h4><pre><code>package soundsystem;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    public BlankDisc(String title, String artist) {        this.title = title;        this.artist = artist;    }}</code></pre><p>1) 使用constructor-arg元素：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;&lt;/bean&gt;</code></pre><p>2)使用c-命名空间：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_title=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;      c:_artist=&quot;The Beatles&quot;/&gt;</code></pre><p>或</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_0=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;      c:_1=&quot;The Beatles&quot;/&gt;</code></pre><p>如果只有一个构造器参数：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;      c:_=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;</code></pre><h4 id="3-装配集合"><a href="#3-装配集合" class="headerlink" title="(3)装配集合"></a>(3)装配集合</h4><pre><code>package soundsystem;import java.util.List;import soundsystem.CompactDisc;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    private List&lt;String&gt; tracks;    public BlankDisc(String title, String artist, List&lt;String&gt; tracks) {        this.title = title;        this.artist = artist;        this.tracks = tracks;    }}</code></pre><p>1)使用list元素将其声明为一个列表(目前，使用c-命名空间的属性无法实现装配集合的功能)。</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/list&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><p>或</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;set&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/set&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><p>2)使用ref元素替代value,从而实现bean引用列表的装配。</p><p>假设现在有一个Discography类,它的构造器如下：</p><pre><code>public Discography(String artist, List&lt;CompactDisc cds) { ... }</code></pre><p>那么可以以如下的方式配置它的bean：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;The Beatles&quot;/&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;ref bean=&quot;sgtPeppers&quot;/&gt;            &lt;ref bean=&quot;whiteAlbum&quot;/&gt;            ...            &lt;ref bean=&quot;revolver&quot;/&gt;        &lt;/list&gt;    &lt;constructor-arg/&gt;&lt;/bean&gt;</code></pre><h4 id="4-设置属性"><a href="#4-设置属性" class="headerlink" title="(4)设置属性"></a>(4)设置属性</h4><p>(1)setter方法注入bean的引用：</p><pre><code>package soundsystem;import soundsystem.CompactDisc;import soundsystem.MediaPalyer;import org.springframework.beans.factory.annotation.Autowired;public class CDPlayer implements MediaPalyer {    private CompactDisc compactDisc;    @Autowired    public void setCompactDisc(CompactDisc compactDisc) {        this.compactDisc = compactDisc;    }}</code></pre><p>在这之前都是通过构造器来进行注入的，没有使用属性的setter方法，现在我们来看一下如何使用spring XML实现属性的注入。property元素为属性的setter方法所提供的功能与constructor-arg元素为构造器所提供的功能是一样的。</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt;    &lt;property name=&quot;compactDisc&quot; ref=&quot;compaceDisc&quot; /&gt;&lt;/bean&gt;</code></pre><p>(2)setter方法将字面量注入到属性中：</p><pre><code>package soundsystem;import java.util.List;import soundsystem.CompactDisc;public class BlankDisc implements CompactDisc {    private String title;    private String artist;    private List&lt;String&gt; tracks;    public void setTitle(String title) {        this.title = title;    }    public void setArtist(String artist) {        this.artist = artist;    }    public void setTracks(List&lt;String&gt; tracks) {        this.tracks = tracks;    }}</code></pre><p>这里和先前的constructor-arg装配tracks是完全一样的：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt;    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; /&gt;    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;    &lt;property name=&quot;tracks&quot;&gt;        &lt;list&gt;            &lt;value&gt;one&lt;/value&gt;            &lt;value&gt;two&lt;/value&gt;            &lt;value&gt;three&lt;/value&gt;            ...            &lt;value&gt;n&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、创建XML配置规范&quot;&gt;&lt;a href=&quot;#1、创建XML配置规范&quot; class=&quot;headerlink&quot; title=&quot;1、创建XML配置规范&quot;&gt;&lt;/a&gt;1、创建XML配置规范&lt;/h3&gt;&lt;p&gt;在使用XML为Spring装配bean之前，需要创建一个新的配置规范
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之通过Java代码装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配Bean之通过Java代码装配Bean/</id>
    <published>2019-01-12T07:37:41.000Z</published>
    <updated>2019-01-12T08:29:53.196Z</updated>
    
    <content type="html"><![CDATA[<p>尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。此时，你必须采取显式装配的方式，在进行显式配置的时候，有两种可选的方案：Java和XML。下面主要是学习如何使用Java来进行配置。在读这篇文章之前，建议先阅读我的上一篇文章<strong><big><a href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/">装配bean之自动化装配Bean</a><big></big></big></strong></p><h3 id="1、创建配置类"><a href="#1、创建配置类" class="headerlink" title="1、创建配置类"></a>1、创建配置类</h3><pre><code>@Configurationpublic class CDPlayerConfig{    ...}</code></pre><p>创建 JavaConfig 的关键在于为其添加@Configuration注解，此外，该类应该包含在Spring应用上下文中创建bean的细节。</p><h3 id="2、声明简单的bean"><a href="#2、声明简单的bean" class="headerlink" title="2、声明简单的bean"></a>2、声明简单的bean</h3><p>(1)要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解，下面的代码声明了CompactDisc bean:</p><pre><code>@Beanpublic CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><p>@Bean注解会告诉Spring这个方法会返回一个对象，该对象需要注册为Spring应用上下文中的bean，方法体中包含了最终产生bean实例的逻辑。</p><p>(2)默认情况下，bean的ID与带有@Bean注解的方法名是一样的。如果你想为其设置一个不同的名字的话，你可以重命名该方法，或者通过name属性指定一个不同的名字。如下：</p><pre><code>@Bean(name=&quot;lonelyHeartsClubBand&quot;)public CompactDisc sgtPeppers(){    return new SgtPeppers();}</code></pre><h3 id="3、借助JavaConfig注入"><a href="#3、借助JavaConfig注入" class="headerlink" title="3、借助JavaConfig注入"></a>3、借助JavaConfig注入</h3><p>(1)我们前面所声明的CompactDisc bean是非常简单的，其自身没有其他的依赖。现在，我们需要声明CDPlayer bean，它依赖于CompactDisc，在JavaConfig中要像下面那样将它们装配到一起：</p><pre><code>@Beanpublic CDPlayer cdPlayer(){    return new CDPlayer(sgtPeppers());}</code></pre><p>看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此，在默认情况下，Spring中的bean都是单例的，因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。即对sgtPeppers()方法的调用返回的是Spring本身在调用sgtPeppers()时所创建的CompactDisc bean。</p><p>(2)可以看到，通过方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：</p><pre><code>@Beanpublic CDPlyer cdPlayer(CompactDisc compactDisc) {    return new CDPlayer(compactDisc);}</code></pre><p>通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowir
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>装配Bean之自动化装配Bean</title>
    <link href="http://www.echodemo.cc/2019/01/12/%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/"/>
    <id>http://www.echodemo.cc/2019/01/12/装配bean之自动化装配Bean/</id>
    <published>2019-01-12T04:21:32.000Z</published>
    <updated>2019-01-12T07:26:36.783Z</updated>
    
    <content type="html"><![CDATA[<p>Spring从两个角度来实现自动化装配：</p><p>(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。</p><p>(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。</p><h3 id="1、创建可被发现的Bean"><a href="#1、创建可被发现的Bean" class="headerlink" title="1、创建可被发现的Bean"></a>1、创建可被发现的Bean</h3><p>(1)创建一个接口CompactDisc：</p><pre><code>package soundsystem;public interface CompactDisc{    void play();}</code></pre><p>(2)创建带有@Component注解的CompactDisc接口的一个实现类：</p><pre><code>package soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc{    private String title = &quot;Sgt, Pepper&apos;s Lonely Hearts Club Band&quot;;    private String artist = &quot;The Beatles&quot;;    public void play(){        System.out.println(&quot;Playing &quot; + title + &quot; By &quot; + artist);    }}</code></pre><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><h5 id="Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。"><a href="#Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有-Component注解的类，并为其创建bean。" class="headerlink" title="@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。"></a>@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。</h5><p>(3)创建配置类:</p><pre><code>package soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig{    ...}</code></pre><h5 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h5><h5 id="ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"><a href="#ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有-Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。" class="headerlink" title="@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。"></a>@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。</h5><p>(4)当然我们也可以使用XML配置的方式来启动组件扫描：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt;&lt;/beans&gt;</code></pre><p>(5)Junit测试：</p><pre><code>package soundsystem;import org.junit.Test;import static org.junit.Assert.*;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest {    @Autowired    private CompactDisc cd;    @Test    public void cdShuldNotBeNull(){        assertNotNull(cd);    }}</code></pre><h5 id="注：-2"><a href="#注：-2" class="headerlink" title="注："></a>注：</h5><h5 id="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"><a href="#a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。" class="headerlink" title="a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。"></a>a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。</h5><h5 id="b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"><a href="#b、-ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了-ComponentScan注解、SgtPeppers当中包含了-Component注解，因此最终的应用上下文就会包含CompactDisc的bean。" class="headerlink" title="b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。"></a>b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。</h5><h5 id="c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。"><a href="#c、-Autowired注解用于将CompactDisc的bean注入到测试代码当中。" class="headerlink" title="c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。"></a>c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。</h5><h3 id="2、为组件扫描的bean命名"><a href="#2、为组件扫描的bean命名" class="headerlink" title="2、为组件扫描的bean命名"></a>2、为组件扫描的bean命名</h3><p>(1)Spring上下文中所有的bean都会给定一个ID，若直接使用 @Component 注解来声明一个 bean，其bean 的名字默认为类名首字母小写。例如，如上 SgtPeppers 类的默认 bean 名称为 sgtPeppers。当然我们可以在 @Component 注解中说明此 bean 的名称。</p><pre><code>@Component(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><p>也可以使用另外一种为bean命名的方式：</p><pre><code>@Named(&quot;lonelyHeartClub&quot;)public class SgtPeppers implements CompactDisc{    ...}</code></pre><h5 id="注：-3"><a href="#注：-3" class="headerlink" title="注："></a>注：</h5><h5 id="Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。"><a href="#Named是Java依赖注入规范-Java-Dependency-Injection-中所提供的为bean设置ID的注解。Spring支持将-Named作为-Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于-Named其本身并无法表明它是干什么的，因此人们常常会选择使用-Component注解来命名。" class="headerlink" title="@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。"></a>@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。</h5><h3 id="3、设置组件扫描的基础包"><a href="#3、设置组件扫描的基础包" class="headerlink" title="3、设置组件扫描的基础包"></a>3、设置组件扫描的基础包</h3><p>在之前的案列中，我们没有为 @ComponentScan注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件。但是有个原因会促使我们要明确的设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。</p><p>(1)为了指定不同的包，只需要在 @ComponentScan的value属性中指明包的名称:</p><pre><code>@Configuration@ComponentScan(&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(2)如果你想更加明确的表名你所设置的是基础包，那么你可以通过basePackages属性进行配置:</p><pre><code>@Configuration@ComponentScan(basePackages=&quot;soundsystem&quot;)public class CDPlayerConfig{    ...}</code></pre><p>(3)如果你想扫描多个包，只需要将basePackages属性的值设置为要扫描包的一个数组即可:</p><pre><code>@Configuration@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})public class CDPlayerConfig{    ...}</code></pre><p>(4)在上面的例子当中，basePackages属性的值是一个String类型的数组，这样配置没有问题，但却是类型不安全的，如果要重构代码的话，这些包的名字可能会被修改，从而导致包扫描出现错误，除了将包设置为简单的String类型之外，@ComponentScan 还提供了另一种方法，那就是将其指定为要扫描包中所含的类或接口。</p><pre><code>@Configuration@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})public class CDPlayerConfig{    ...}</code></pre><h5 id="注：-4"><a href="#注：-4" class="headerlink" title="注："></a>注：</h5><h5 id="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"><a href="#你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。" class="headerlink" title="你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。"></a>你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。</h5><h3 id="4、通过为bean添加注解实现自动装配"><a href="#4、通过为bean添加注解实现自动装配" class="headerlink" title="4、通过为bean添加注解实现自动装配"></a>4、通过为bean添加注解实现自动装配</h3><p>在你的应用程序当中，如果所有的对象都是独立的，彼此之间没有任何的依赖，就像ShtPeppers的bean一样，那么你所需要的可能就是组件的扫描而已。但是很多对象会依赖其他的对象才能完成任务。如此一来，我们就需要有一种方法将组件扫描得到的bean和它们的依赖装配在一起。这就涉及到Spring的自动装配。自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean，这里借助@Autowired注解来声明自动装配。</p><p>(1)以下示例的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器进行实例化并传入一个CompactDisc类型的 bean。<strong><big>@Autowired 注解可以用在类的任何方法上。</big></strong></p><pre><code>@Componentpublic class CDPlayer implements MediaPlayer{    private CompactDisc cd;    @Autowired    public CDPlayer(CompacrDisc cd){        this.cd = cd;    }    public void play(){        cd.play();    }}</code></pre><p>(2)不管是构造器、Setter 方法还是其他方法，Spring 都会尝试满足方法参数上所声明的依赖，假如有且仅有一个bean依赖需求的话，那么这个bean就会被装填进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：</p><pre><code>@Autowired(required=false)public CDPlayer(CompactDisc cd){    this.cd = cd;}</code></pre><h5 id="注：-5"><a href="#注：-5" class="headerlink" title="注："></a>注：</h5><h5 id="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"><a href="#但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。" class="headerlink" title="但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。"></a>但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。</h5><p>(3)如果有多个bean都能满足依赖关系的话，Spring也将会抛出一个异常，表明没有明确指定要选择那个bean进行装配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring从两个角度来实现自动化装配：&lt;/p&gt;
&lt;p&gt;(1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。&lt;/p&gt;
&lt;p&gt;(2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.echodemo.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发中遇到的几个问题</title>
    <link href="http://www.echodemo.cc/2018/11/30/SpringBoot%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/11/30/SpringBoot开发中遇到的几个问题/</id>
    <published>2018-11-30T04:42:21.000Z</published>
    <updated>2018-11-30T06:51:48.235Z</updated>
    
    <content type="html"><![CDATA[<p>1、java.net.MalformedURLException: no protocol 异常</p><p>在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、java.net.MalformedURLException: no protocol 异常&lt;/p&gt;
&lt;p&gt;在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中的FastJson</title>
    <link href="http://www.echodemo.cc/2018/11/29/SpringBoot%E4%B8%AD%E7%9A%84FastJson/"/>
    <id>http://www.echodemo.cc/2018/11/29/SpringBoot中的FastJson/</id>
    <published>2018-11-29T12:59:47.000Z</published>
    <updated>2018-11-29T13:54:29.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.37&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、导入包和主要的方法"><a href="#2、导入包和主要的方法" class="headerlink" title="2、导入包和主要的方法"></a>2、导入包和主要的方法</h3><p>1、导入包</p><pre><code>import com.alibaba.fastjson.JSON;</code></pre><p>2、将JSONObject转化为String</p><pre><code>String jsonStr = JSONObject.toJsonString(jsonObject);</code></pre><p>3、将String转化为JSONObject</p><pre><code>JSONObject jsonObject = JSONObject.parseObject(jsonStr);</code></pre><p>4、将String转化为JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(jsonStr);</code></pre><p>5、将JSONArray转化为JSONObject</p><pre><code>JSONObject jsonObject = new JOSNObject();for (int i; i &lt; jsonArray.length(); i++) {    jsonObject = jsonArray.getJSONObject[i];}</code></pre><p>6、将JSONObject转化为JOSNArray</p><pre><code>JSONArray jsonObject = JSONObject.get(&quot;key&quot;);</code></pre><p>7、将List转JSONArray</p><pre><code>JSONArray jsonArray = JSONArray.parseArray(JSON.toJSONString(list))；</code></pre><p>8、将JSONArray转化为List</p><pre><code>List&lt;EventColAttr&gt; list = JSONObject.parseArray(jsonArray.toJSONString(), EventColAttr.class);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/gr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Log4j</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88Log4j/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合Log4j/</id>
    <published>2018-11-20T14:43:58.000Z</published>
    <updated>2018-11-20T14:54:15.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><pre><code>&lt;!-- spring boot start --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- 排除自带的logback依赖 --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- springboot-log4j --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;    &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2、Log4j配置文件-建立在和application文件同级的目录下"><a href="#2、Log4j配置文件-建立在和application文件同级的目录下" class="headerlink" title="2、Log4j配置文件(建立在和application文件同级的目录下)"></a>2、Log4j配置文件(建立在和application文件同级的目录下)</h3><pre><code># Log4j配置log4j.rootCategory=INFO,stdout#控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n</code></pre><p>注：该文件里的stdout全部替换成CONSOLE也是没有问题的。当然你也可以在文件中配置file,error,debug等其他的日志信息。</p><h3 id="3、使用Log4j"><a href="#3、使用Log4j" class="headerlink" title="3、使用Log4j"></a>3、使用Log4j</h3><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author EchoDemo * @ClassName cn.aduu.web.HelloController * @Description */@RestControllerpublic class HelloController{    private static final Logger logger = LoggerFactory.getLogger(HelloController.class);    @RequestMapping(&quot;hello&quot;)    public String hello() throws JsonProcessingException {        logger.info(&quot;Hello World！&quot;);        return &quot;hello world&quot;;    }}</code></pre><p>注：启动之后在浏览器访问就好了。</p><h3 id="4、日志打印效果"><a href="#4、日志打印效果" class="headerlink" title="4、日志打印效果"></a>4、日志打印效果</h3><pre><code>十一月 20, 2018 10:42:10 下午 org.apache.catalina.core.ApplicationContext log2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization started信息: Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 23 ms2018-11-20-22-42 [http-nio-8080-exec-1] [com.echodemo.girl.web.UserController] [INFO] - Hello World!</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、依赖&quot;&gt;&lt;a href=&quot;#1、依赖&quot; class=&quot;headerlink&quot; title=&quot;1、依赖&quot;&gt;&lt;/a&gt;1、依赖&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!-- spring boot start --&amp;gt;
&amp;lt;dependency&amp;gt;
  
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合MyBatis</title>
    <link href="http://www.echodemo.cc/2018/11/20/SpringBoot%E6%95%B4%E5%90%88MyBatis/"/>
    <id>http://www.echodemo.cc/2018/11/20/SpringBoot整合MyBatis/</id>
    <published>2018-11-20T13:51:36.000Z</published>
    <updated>2018-11-20T14:11:18.179Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/saytime/article/details/74783296" target="_blank" rel="noopener">CSDN学习链接</a></p><p>1、无配置文件注解版</p><p>(1)@MapperScan(“com.echodemo.girl.mapper”)这里是包名。</p><p>(2)注意到以下两个SQL语句，insert当中没有user.username是因为当它只有一个对象作为参数传递时本身进行了处理，而update当中，有两个参数传递进来，此时需要@Param的协助，并且需要以user.username的形式把值传给SQL语句当中。而单个的id则直接传递。</p><pre><code>@Insert(&quot;INSERT INTO tb_user(username, age, ctm) VALUES(#{username}, #{age}, now())&quot;)int add(User user);@Update(&quot;UPDATE tb_user SET username = #{user.username}, age = #{user.age} WHERE id = #{id}&quot;)int update(@Param(&quot;id&quot;) Integer id, @Param(&quot;user&quot;) User user);</code></pre><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p><p>2、配置文件注解版</p><p>(1)在userMapper.xml文件当中，resultMap部分，里面的jdbcType类型都需要大写，当时INTEGER只有首字母大写了，然后找bug找了好久。</p><p>(2)在UserMapper当中要加上@Repository注解，不然在UserServiceImpl.java文件中会提示bean不存在。</p><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/MybatisConfigAnnotation-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/saytime/article/details/74783296&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN学习链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、无配置文件注解版&lt;/p&gt;
&lt;p&gt;(1)
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《了不起的盖茨比》</title>
    <link href="http://www.echodemo.cc/2018/11/17/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94%E3%80%8B/"/>
    <id>http://www.echodemo.cc/2018/11/17/《了不起的盖茨比》/</id>
    <published>2018-11-17T14:43:39.000Z</published>
    <updated>2018-11-17T14:57:37.478Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片陌生的天空；他一定感到毛骨悚然，当他发现玫瑰是多么丑恶，而阳光照在刚刚露头的小草上又是多么残忍。这是一个新世界，物质的世界，没有真实可言，可怜的鬼魂呼吸着空气一般的梦想，四处飘荡……就像那个灰蒙蒙的怪人穿过杂乱的树林悄悄向他走来一样。”可以这样说：盖茨比梦想、希望和肉体的覆灭是黛西和汤姆两个人共同的杰作，当然也因为他的纯真和勇敢。但归根究底他是被残酷的社会现实活生生地扼杀的，过去是这样，现在在依然是这样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>洪水猛兽</title>
    <link href="http://www.echodemo.cc/2018/11/14/%E6%B4%AA%E6%B0%B4%E7%8C%9B%E5%85%BD/"/>
    <id>http://www.echodemo.cc/2018/11/14/洪水猛兽/</id>
    <published>2018-11-14T04:59:52.000Z</published>
    <updated>2018-11-14T05:08:25.442Z</updated>
    
    <content type="html"><![CDATA[<p>我已经老了</p><p>在那汹涌的时光之河中逆流而上的</p><p>是我焦急的等待和对幸福的憧憬</p><p>那些孤独、失眠并痛苦着的夜晚</p><p>我是多么渴望</p><p>有一天能够在某个幽静的花园里</p><p>在黄色的落叶铺满整个季节的时候</p><p>坐在一棵干枯杏树下的长凳上</p><p>再为你读一首浪漫动情的诗篇</p><p>因为只有这样</p><p>才能缓解我无法避免地从思念的村庄路过时的情绪</p><p>而你并不知道我始终身陷囹圄、画地为牢</p><p>在无穷无尽的深渊里甘为囚徒、难以自拔</p><p>染上了名为爱情的霍乱</p><h6 id="注：此诗因读《霍乱时期的爱情》有感而写"><a href="#注：此诗因读《霍乱时期的爱情》有感而写" class="headerlink" title="注：此诗因读《霍乱时期的爱情》有感而写"></a>注：此诗因读《霍乱时期的爱情》有感而写</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我已经老了&lt;/p&gt;
&lt;p&gt;在那汹涌的时光之河中逆流而上的&lt;/p&gt;
&lt;p&gt;是我焦急的等待和对幸福的憧憬&lt;/p&gt;
&lt;p&gt;那些孤独、失眠并痛苦着的夜晚&lt;/p&gt;
&lt;p&gt;我是多么渴望&lt;/p&gt;
&lt;p&gt;有一天能够在某个幽静的花园里&lt;/p&gt;
&lt;p&gt;在黄色的落叶铺满整个季节的时候&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合JdbcTemplate</title>
    <link href="http://www.echodemo.cc/2018/11/14/SpringBoot%E6%95%B4%E5%90%88JdbcTemplate/"/>
    <id>http://www.echodemo.cc/2018/11/14/SpringBoot整合JdbcTemplate/</id>
    <published>2018-11-14T04:24:48.000Z</published>
    <updated>2018-11-14T04:53:54.629Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/saytime/article/details/74783294" target="_blank" rel="noopener">CSDN学习链接</a></p><p>下面是这篇博客当中一些需要注意的问题：</p><pre><code>1、在yml文件当中，注意空格问题。2、在UserDaoImpl.java文件当中，类需要加上@Repository注解。3、在UserServiceimpl.java文件当中，类需要加上@Service注解。4、在UserController.java文件当中，类需要加上@RestController注解。5、JsonResult实体类需要生成get和set方法。*另外，自己的项目里面的controller路径有所改变。</code></pre><p><a href="https://github.com/EchoDemo/SpringBoot/tree/master/JdbcTemplate-src" target="_blank" rel="noopener">自己敲的GitHub代码链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/saytime/article/details/74783294&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN学习链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是这篇博客当中一些需要注意的问题：&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中Controller的使用</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E4%B8%ADController%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot中Controller的使用/</id>
    <published>2018-11-05T13:02:28.000Z</published>
    <updated>2018-11-06T12:58:39.483Z</updated>
    
    <content type="html"><![CDATA[<p>1、Controller方法和类的注解</p><p><img src="/images/2018/11/9.png" alt="&quot;1&quot;"></p><p>其中@RequestMapping可以给整个Controller类设置注解。还可以通过如下的设置让不同的链接参数来进行访问：</p><pre><code>@RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;}, method = RequestMethod.GET)public String say(){    return &quot;Hello SpringBoot!&quot;;}</code></pre><p><img src="/images/2018/11/10.png" alt="&quot;2&quot;"><br><img src="/images/2018/11/11.png" alt="&quot;3&quot;"></p><p>当然为了让代码更加得简洁，可以使用@GetMapping(value = “/hello”)和@PostMapping(value = “/hello”)来替代@RequestMapping(value = “/hello”, method = RequestMethod.GET)和@RequestMapping(value = “/hello”, method = RequestMethod.POST)的。</p><p>2、Controller当中的参数传递</p><p><img src="/images/2018/11/12.png" alt="&quot;4&quot;"></p><p>（1）@PathVariable</p><pre><code>@RequestMapping(value = &quot;/hello/{id}&quot;,method = RequestMethod.GET)public String say(@PathVariable(&quot;id&quot;) Integer id){    return &quot;id: &quot; + id;}</code></pre><p><img src="/images/2018/11/13.png" alt="&quot;5&quot;"></p><p>（2）@RequestParam(可以设置默认值)</p><pre><code>@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)public String say(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) Integer id){    return &quot;id: &quot; + id;}</code></pre><p><img src="/images/2018/11/14.png" alt="&quot;6&quot;"><br><img src="/images/2018/11/15.png" alt="&quot;7&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Controller方法和类的注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/11/9.png&quot; alt=&quot;&amp;quot;1&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中@RequestMapping可以给整个Controller类设置注解。还可以通过如下的设置让
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot的第一个入门程序/</id>
    <published>2018-11-05T12:34:41.000Z</published>
    <updated>2018-11-05T15:10:50.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK"><a href="#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK" class="headerlink" title="1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)"></a>1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)</h3><p><img src="/images/2018/11/1.png" alt="&quot;1&quot;"></p><p><img src="/images/2018/11/2.png" alt="&quot;2&quot;"></p><p><img src="/images/2018/11/3.png" alt="&quot;3&quot;"></p><p><img src="/images/2018/11/4.png" alt="&quot;4&quot;"></p><h3 id="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。"><a href="#2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。" class="headerlink" title="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。"></a>2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。</h3><p><img src="/images/2018/11/5.png" alt="&quot;打开GirlApplication.java文件&quot;"></p><p><img src="/images/2018/11/6.png" alt="&quot;创建HelloController.java文件&quot;"></p><h3 id="3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。"><a href="#3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。" class="headerlink" title="3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。"></a>3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。</h3><p><img src="/images/2018/11/7.png" alt="&quot;在浏览器查看&quot;"></p><h3 id="4、项目属性配置-创建配置文件和配置文件属性类"><a href="#4、项目属性配置-创建配置文件和配置文件属性类" class="headerlink" title="4、项目属性配置(创建配置文件和配置文件属性类)"></a>4、项目属性配置(创建配置文件和配置文件属性类)</h3><p><img src="/images/2018/11/8.png" alt="&quot;文件分布&quot;"></p><p>（1）生产、测试环境以及主配置文件内容</p><pre><code>//测试环境内容server:  port: 8080girl:  cupSize: B  age: 18//生产环境内容server:  port: 8081girl:  cupSize: F  age: 18//调用配置文件的主配置文件内容spring:  profiles:    active: prod</code></pre><p>（2）创建配置文件属性类</p><pre><code>package com.echodemo.girl;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;//获取前缀是girl的配置，注入配置需要加Component注解@Component@ConfigurationProperties(prefix = &quot;girl&quot;)public class GirlProperties {    private String cupSize;    private Integer age;    public String getCupSize() {        return cupSize;    }    public void setCupSize(String cupSize) {        this.cupSize = cupSize;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><p>（3）HelloController文件内容</p><pre><code>package com.echodemo.girl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {/*    //通过注解的方式获取配置文件值(Value注解太low了)    @Value(&quot;${server.cupSize}&quot;)    private String cupSize;    @Value(&quot;${server.age}&quot;)    private Integer age;*/    //通过创建配置文件属性类来获取配置文件中的值    @Autowired    private GirlProperties girlProperties;    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)    public String say(){        return girlProperties.getCupSize();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK&quot;&gt;&lt;a href=&quot;#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-ma
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(二)/</id>
    <published>2018-10-06T15:12:32.000Z</published>
    <updated>2018-10-06T15:18:23.483Z</updated>
    
    <content type="html"><![CDATA[<p>1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想要得到什么、实现什么。</p><p>2、关系要获得成长，首先是处在关系中的人要成长。比如，有的女人婚后成了全职太太，将个人成长的停滞归咎于操持家庭，和先生在阅历和思想上逐渐脱节，渐行渐远。又比如，有的男性一直保持着学生时期的心态，沉迷于游戏和其他娱乐活动，拒绝面对自己的成长，也不愿认真思考未来。</p><p>3、我们不知道自己想要什么，是因为有太多担心和顾虑，眼前的问题阻碍了我们看清自己的方向。</p><p>4、怎样知道你对一件事情有激情？你每天早上醒来和晚上临睡前都会忍不住去想、去做的，就是让你充满激情的事情。如果连开始一件事情都缺少决断力，那么之后一旦遇到困难或者冲突，必然会很快选择放弃。所以，如果你已经发现自己的激情所在，想要去做一件事情，那么现在就开始！</p><p>5、你可以试试把自己关在一个空房间里，5分钟，10分钟，半小时。不带手机，不看电脑，你可以观察自己在寂寞时会有什么反应，会做什么，这样可以很好地帮助你了解自己。</p><p>6、喜欢把工作忙、圈子小、性格内向、不善交际这些说辞挂在嘴边的人并没有想过，他们提出的每一点理由都只是一种暂时的状态，而非不可改变的现实。那些成功者与你起点相同，但最终获得成功，这才是你和他们的本质区别。</p><p>7、走出自卑，是一条重新审视自己的生活、重新定义自我价值、重新设计自我行为的漫长之路。走出自卑，需要你对客观现实和自我认知有强烈的渴望，这样才能够打破长久以来的自我偏见；走出自卑，意味着要学会忍耐自卑带来的不适感，将更多精力放在优化自己的实际行为上。</p><p>8、愤怒的表达是本能，对愤怒带来的伤害的修复比表达更为重要，但是许多人都把更多注意力放在了调整和弱化表达上面。（压抑自己的情绪）如果我们懂得如何在伤害产生后修复关系，表达我们的歉意、关怀和爱，那么伤害反而成了拉近关系和建立信任的机会。使用回避、沉默、逃避、疏远以及终止关系来表达愤怒。其结果就是，情绪得不到合理表达，引发更深层的抑郁，同时也失去了建立信任感和亲密关系的机会，在人际关系中越发感到被孤立。</p><h2 id="9、“想要”和“需要”"><a href="#9、“想要”和“需要”" class="headerlink" title="9、“想要”和“需要”"></a>9、“想要”和“需要”</h2><p>关于是否足够了解自己的情感需求这个话题，我会用一个简单的问题来测试：“你为什么要恋爱、结婚？”对此，我得到的常见答案是：自己到了一定年纪应该稳定下来了，家里人也比较着急，看到周围的同事、朋友也都结婚了，所以就结婚了。在我看来，这就是不了解自己情感需求的表现，因为这里给出的是一个人想要却未必需要的东西。关于人的想要和需要，我们要进行一下区分。你可以将这两者的关系理解为路径和目标，我们通过得到想要的东西，来满足根本的需要。想要的东西往往是某些具体的事物，而需要很多时候则是主观的体验和感受。比如，我想要很多钱，因为有了钱别人就会尊重我，所以我需要的其实是尊重；我想要先生对我很专一，这会让我感觉他很重视我，所以我需要的是重视；我想要很多漂亮的衣服和包，因为我打扮漂亮了，别人才会认可我，所以我需要的是认可。当一个人告诉我她走进一段感情是因为年龄、家人和社会压力时，她的真正需要可能是自信、安全感、归属感，以及被认可、被尊重、被接纳等。更进一步说，一个人得到了想要的东西，是否就一定能满足自己的需要？很多人在这两者的关系认知上存在着很大的偏差。比如走入婚姻，需要的是被别人认可和尊重，但是满足了家人和社会的期望，就一定能被别人认可和尊重吗？</p><p>如果无法区分想要和需要，便会把生命浪费在肤浅的、想要的事物上。而人只有当需要被满足时，才会感到发自内心的满意。</p><h2 id="10、划分人生阶段"><a href="#10、划分人生阶段" class="headerlink" title="10、划分人生阶段"></a>10、划分人生阶段</h2><p>将自己的人生划分为8个阶段，这个数字没有特定的含义，只是一个结构上的要求。每个阶段用一个重要的事件或者时间节点来界定。第一个阶段从出生开始，最后一个阶段一直持续到当下。</p><h3 id="罗列重要事件"><a href="#罗列重要事件" class="headerlink" title="罗列重要事件"></a>罗列重要事件</h3><p>从每个阶段里找出10件对你影响重大的事件，这个数字也仅是一个结构上的要求而已。这些事件应该对你的情感、性格、生活轨迹、人际关系产生过比较大的影响。我建议你关注这样一些事件：让你的生活轨迹发生变化的转折点，重大的失败或意外，重要的决定，对情感造成较大冲击的事件，记忆深刻的事件。另外这些事件多半与他人有关，我建议你重点关注你的父母或者其他亲近的人。罗列这80件事情本身就是个挑战，有的需要努力回忆，有的需要去询问他人。你可以先定义好一个阶段，去搜罗事件，进行分析，然后再进入下一个阶段。</p><h3 id="分析事件"><a href="#分析事件" class="headerlink" title="分析事件"></a>分析事件</h3><p>每一个事件下面，你都需要回答以下几个问题：</p><pre><code>（1）这件事给你带来了哪些认知和想法上的变化？（2）这件事给你带来了哪些情感上的冲击或者影响？（3）这件事和现在的你有什么关系？换句话说，这件事如何塑造了今天的你？</code></pre><p>内容上没有太多要求，每个人都有权利以自己喜欢的方式写一部自己的个人史。唯一需要你坚持的是8个阶段，总共80件事情，每件事情3个问题，这样写出来的东西才能足够细化。每个问题你可以随便回答，或者详细地描述。要花多少时间，要写多少，由你自己决定。你的收获完成这份“作业”可能需要花费很多时间，多到远远超出你的预期。写的过程中你可能会哭、会笑、会感慨。你可能需要他人帮助你回忆某些事。我介绍身边的一些人尝试过这种方法，包括我的长辈。我没有看他们写的东西（你最好不给别人看，这样才能保证内容最真实）。但是大家给我的反馈一致：做这样一件事对自己有太多益处。这个练习是我大学时期的一位心理学教授布置的期末论文题目。当时的我花费两个月的时间，写下一万多字。它开启了我对自我认知的探寻之路，是我到目前为止做过的最重要的几件事情之一。最终的效果因人而异。但对我来说，写作的过程已让我受益匪浅，一边写一边思考，看清了很多以往忽略或者误解的问题。写完之后，整个人有一种“觉醒”的感觉，它带来的思考，也会持续影响自己。同时，你会更理解自己，会看到所处的环境对自己的影响，而不再把所有事情都归因于自己或者身边的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(一)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(一)/</id>
    <published>2018-10-06T15:07:21.000Z</published>
    <updated>2018-10-06T15:10:51.268Z</updated>
    
    <content type="html"><![CDATA[<p>1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。</p><p>2、在深入了解双方的想法时，例如聊到和前任的关系或者异性朋友这类比较敏感的话题时，建议你平和而又诚恳地邀请对方表达，让对方感到安全：“我知道这个话题对你来说可能比较敏感，或许你可以试着说说看，我很想了解你，也向你保证，我不会在没有完全理解你的时候给你贴标签或者批判你。”</p><p>3、矛盾冲突永远存在，但是高质量的关系可以保障亲密关系中的满意度更持久。很多人在亲密关系中所犯的错误就是为了争论对错、分出输赢、掌握控制权，宁可牺牲亲密关系，因为我们往往习惯了以强制的方式使对方接受。</p><p>4、你可能习惯了不说话，在人群里永远保持沉默，有着很强的戒备心理，对异性充满恐惧。你可能有很多情结、障碍、缺点，但你必须要走出自己熟悉的舒适区，做以前没做过的事情。浪漫的事情，都多少带些不寻常甚至是冒险。在恐惧、焦虑、不确定的时候，你习惯了逃避，那么，多半也会错过那些美好奇妙的邂逅。</p><p>5、许多人总要求对方要与自己有精神共鸣、有生活情趣、要浪漫、要体贴入微。要求别人之前先看看自己，你是个爱读书、爱思考的人吗？你的生活是不是充满了各种趣味？你是否有自己独特的手艺和爱好可以用来营造浪漫？你是否习惯于帮助他人和奉献自我？长久积累的品质才能产生魅力，而平庸和平淡的你，拿什么吸引心仪的人，拿什么让亲密关系保鲜？</p><p>6、我极力推荐大家去看看《摩登家庭》，此剧一个重要的看点就是学习剧中人物在处理家庭关系时如何用积极的、有建设性的语言沟通彼此的感受。</p><p>7、我希望用文字鼓励那些心有所向的人，不要因为可能被拒绝就患得患失，不要因为希望渺茫就放弃。感情不能用得失、成败来衡量，因为感情中的失败其实是一种提示，是在告诉你且行且珍惜，你完全没必要和失败过不去。</p><p>8、我真心希望每一个恋爱中的人，都不要只顾着享受对方带给你的感动和温暖，要多想想自己可以为他做些什么。在你感到最幸福、最满足的时候，记得问问自己：他是否和我一样幸福？</p><p>9、任何形式的失败，其实都是生活在提示我们：你的方法不对，需要调整。拒绝分手或者离婚，找各种理由说服自己死扛，本质就是拒绝承认错误。当你忽视生活给你的提示时，获得的只能是更多更激烈和强硬的提示，直到你被彻底打垮。</p><p>10、每当你和伴侣之间出现矛盾的时候，你需要先思考以下两个问题：对方怎么改变能够让你感到满意？如果有人要让你做出这样的改变，激励你的最好方式是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。&lt;/p&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《自控力》摘句</title>
    <link href="http://www.echodemo.cc/2018/09/08/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2018/09/08/《自控力》摘句/</id>
    <published>2018-09-08T13:23:43.000Z</published>
    <updated>2018-09-08T13:33:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。</p><p>2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。</p><p>3、从每章挑选一个策略，选和你的挑战最相关的一个，而不是一次尝试10种策略。</p><p>4、人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学数学，它就会越来越擅长数学。如果你让它忧虑，它就会越来越忧虑。如果你让它专注，它就会越来越专注。</p><p>5、如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</p><p>6、人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</p><p>7、如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。</p><p>8、如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。</p><p>9、自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。</p><p>10、道德许可：当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p><p>11、只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。</p><p>12、当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？·你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？·你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？</p><p>13、我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。</p><p>14、你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？</p><p>15、这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？</p><p>16、如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。</p><p>17、你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。）</p><p>18、是什么让你的多巴胺神经元不停燃烧？你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？</p><p>19、谁在控制你的多巴胺神经元？让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。&lt;/p&gt;
&lt;p&gt;2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。&lt;/p&gt;
&lt;p&gt;3、从每章挑选一个策略，选和你的挑战最相关的一个，而
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>故乡</title>
    <link href="http://www.echodemo.cc/2018/08/22/%E6%95%85%E4%B9%A1/"/>
    <id>http://www.echodemo.cc/2018/08/22/故乡/</id>
    <published>2018-08-22T13:29:58.000Z</published>
    <updated>2018-08-27T10:55:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专程看望和问询；郑愁予的故乡是始终心系的祖国；还有一个人的故乡是他十年来力排众议在艰难的环境和地形下修筑的几十公里的山路。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一辆Hello共享单车，在幽暗的路上漫无目的地游荡。想起考研未果的日子，我知道，那时候选择找工作而不是二战，是因为自己在逃避，害怕再一次的失败，不知道自己的退路在哪。如今来到偌大的城市里，繁华是你。刚来的日子里满心欢喜，为自己能够来到这座城市而庆幸，把冥冥中的注定看作美好的开始。但此刻自己的内心是茫然的，故乡对我而言意味着什么，一个人需要怎样的经历和过去才能够看清？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立在公交站台旁的我，用手机写着这段文字的时候，抬头望着夜空中笼罩在云里的月，顿下来，目光又顺着车流望向灯火斑斓的远方，好像知道了点什么，转身往回走去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
