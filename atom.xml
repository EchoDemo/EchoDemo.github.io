<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-07T08:45:27.936Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT A1020 Tree Traversals</title>
    <link href="http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/"/>
    <id>http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/</id>
    <published>2018-04-07T08:14:39.000Z</published>
    <updated>2018-04-07T08:45:27.936Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><pre><code>Sample Input:72 3 1 5 7 6 41 2 3 4 5 6 7Sample Output:4 1 6 3 5 7 2</code></pre><p>题目大意：给出二叉树的后序和中序序列，输出这棵二叉树的层序序列。(所有的二叉树节点的数据都是互不相等的正整数)</p><p>分析：根据二叉树的后序和中序序列可以重建二叉树，再对重建好的二叉树进行层序遍历。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;queue&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void layerorder(node* root) {    queue&lt;node*&gt; q;//存储节点地址的队列    q.push(root);//根节点入队    while (!q.empty()) {        node* n = q.front();        q.pop();//将队首元素出队        cout &lt;&lt; n-&gt;data &lt;&lt;&quot; &quot;;//访问队首元素        if (n-&gt;lchild != NULL) q.push(n-&gt;lchild);//如果左子树不空，将左子树入队        if (n-&gt;rchild != NULL) q.push(n-&gt;rchild);//如果右子树不空，将左子树入队    }}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    layerorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存空间    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are s
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>由中序和后序序列输出先序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由中序和后序序列输出先序序列/</id>
    <published>2018-04-07T07:55:20.000Z</published>
    <updated>2018-04-07T08:40:36.703Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void preorder(node* root) {//先序遍历二叉树    if (root == NULL) {        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    preorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由先序和中序序列输出后序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由先序和中序序列输出后序序列/</id>
    <published>2018-04-07T06:58:11.000Z</published>
    <updated>2018-04-07T08:39:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int pre[],int in[],int preL, int preR, int inL, int inR) {//根据先序序列和中序序列重建二叉树    if (preL&gt;preR) return NULL;//如果先序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = pre[preL];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == pre[preL]) {//在中序序列中找到根节点            break;        }    }    int numLeft = k - inL;//左子树的节点个数    //左子树的先序序列区间为[preL+1,preL+numLeft],中序序列区间为[inL,k-1]    root-&gt;lchild = create(pre,in,preL + 1, preL + numLeft, inL, k - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的先序序列区间为[preL+numLeft+1,preR],中序序列区间为[k+1,inR]    root-&gt;rchild = create(pre,in,preL + numLeft + 1, preR, k + 1, inR);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void postorder(node* root) {//后序遍历二叉树    if (root == NULL) {        return;//递归边界    }    postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *pre = new int[n];//new一个变长的int型数组    int *in = new int[n];    for (int i = 0;i &lt; n;i++) {//输入先序序列        cin &gt;&gt; pre[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int preL = 0,inL = 0, preR = n - 1, inR = n - 1;    postorder(create(pre,in,preL, preR, inL, inR));    delete[] in;//释放内存    delete[] pre;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.echodemo.cc/2018/04/07/二叉树的基本操作/</id>
    <published>2018-04-07T04:01:09.000Z</published>
    <updated>2018-04-07T08:39:29.646Z</updated>
    
    <content type="html"><![CDATA[<p>1、二叉树的存储结构</p><pre><code>struct node {    typename data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};</code></pre><p>2、新建一个二叉树节点</p><pre><code>node* newNode(int n) {    node* Node = new node;//申请一个node型变量的地址空间    Node-&gt;data = n;//节点权值为n    Node-&gt;lchild = Node-&gt;rchild = NULL;//初始状态下左右孩子为空    return Node;//返回新建节点的地址}</code></pre><p>3、查找二叉树中节点数据域为x的节点，并将他们的数据域修改为newdata</p><pre><code>void search(node* root, int x, int newdata) {    if (root == NULL) {        return;//空树，死胡同(递归边界)    }    if (root-&gt;data == x) {        root-&gt;data = newdata;    }    search(root-&gt;lchild, x, newdata);//往左子树搜索x    search(root-&gt;rchild, x, newdata);//往右子树搜索x}</code></pre><p>4、二叉树节点的插入(二叉树节点的插入位置就是数据域在二叉树中查找失败的位置)</p><pre><code>void insert(node* &amp;root, int x) {    if (root == NULL) {        root = newNode(x);//空树，说明查找失败，也即插入的位置(递归边界)        return;    }    if (由二叉树的性质，x应该插在左子树) {        insert(root-&gt;lchild, x);//往左子树搜索(递归式)    }    else {        insert(root-&gt;rchild, x);//往右子树搜索(递归式)    }}</code></pre><p>这里的根节点指针root需要使用引用&amp;，这样才能直接修改原变量的值。与search函数不同的是，search函数中修改的是指针root指向的内容，而不是root本身，而对指针指向的节点内容的修改是不需要加引用的。一般来说，如果函数中需要新建节点，即对二叉树的结构做出修改，就需要加引用；如果只是修改当前已有节点的内容，或仅仅是遍历树，就不需要加引用。</p><p>5、二叉树的创建(其实就是二叉树节点的插入过程)</p><pre><code>node* create(int data[], int n) {    node* root = NULL;//新建空根节点    for (int i = 0;i &lt; n;i++) {        insert(root, data[i]);    }    return root;//返回根节点}</code></pre><p>6、二叉树的先序遍历(递归)</p><pre><code>void preorder(node* root){    if(root==NULL){        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}</code></pre><p>7、二叉树的中序遍历(递归)</p><pre><code>void inorder(node* root){    if(root==NULL){        return;//递归边界    }        inorder(root-&gt;lchild);//访问左子树    cout&lt;&lt;root-&gt;data;//访问根节点    inorder(root-&gt;rchild);//访问右子树}</code></pre><p>8、二叉树的后序遍历(递归)</p><pre><code>void postorder(node* root){    if(root==NULL){        return;//递归边界    }        postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}</code></pre><p>9、二叉树的层序遍历</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL) q.push(now-&gt;lchild);//左子树非空        if(now-&gt;rchild!=NULL) q.push(now-&gt;rchild);//右子树非空    }}</code></pre><p>如果需要计算每个节点所处的层次，二叉树节点的定义如下：</p><pre><code>struct node{    typename data;//数据域    int layer;//层次    node* lchild;//左指针域    node* rchild;//右指针域}</code></pre><p>此时的层序遍历为：</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    root-&gt;layer=1;//根节点的层数为1    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL){//左子树非空            now-&gt;lchild-&gt;layer=now-&gt;layer+1;//左孩子的层数为当前层数加1            q.push(now-&gt;lchild);        }        if(now-&gt;rchild!=NULL){//右子树非空            now-&gt;rchild-&gt;layer=now-&gt;layer+1;//右孩子的层数为当前层数加1            q.push(now-&gt;rchild);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、二叉树的存储结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct node {
    typename data;//数据域
    node* lchild;//指向左子树根节点的指针
    node* rchild;//指向右子树根节点的指针
};
&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(四)</title>
    <link href="http://www.echodemo.cc/2018/04/07/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E5%9B%9B)/"/>
    <id>http://www.echodemo.cc/2018/04/07/C++中的问题整理(四)/</id>
    <published>2018-04-07T00:45:34.000Z</published>
    <updated>2018-04-07T01:03:04.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C-中的BSS、数据段、代码段、堆、栈"><a href="#1、C-中的BSS、数据段、代码段、堆、栈" class="headerlink" title="1、C++中的BSS、数据段、代码段、堆、栈"></a>1、C++中的BSS、数据段、代码段、堆、栈</h2><p>(1)BSS(Block Started by Symbol)通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p><p>(2)数据段：数据段(data segment)通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</p><p>(3)代码段：代码段(code segment/text segment)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>(4)堆(heap)：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)</p><p>(5)栈(stack)：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><h2 id="2、C-中的左值和右值"><a href="#2、C-中的左值和右值" class="headerlink" title="2、C++中的左值和右值"></a>2、C++中的左值和右值</h2><p>在C中，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。通常等号左边表示引用，实质上就是内存地址。等号右边表示数据，从内存取的数据，直接给的数据，或者计算出来的数据。内存地址本身也是数据，也可以放到内存中。相当于C++中说的指针。因为等号左边表示地址，变量映射成地址值，也就等号左边不能是常数。</p><h2 id="3、volatile关键字"><a href="#3、volatile关键字" class="headerlink" title="3、volatile关键字"></a>3、volatile关键字</h2><p>如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。当然了，volatile还能让你在编译时期捕捉到非线程安全的代码。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。以下是使用场景：</p><pre><code>(1)中断服务程序中修改的供其它程序检测的变量需要加volatile。(2)多任务环境下各任务间共享的标志应该加volatile。(3)存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。*可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。*除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。*volatile像const一样会从类传递到它的成员。</code></pre><h2 id="4、枚举类型"><a href="#4、枚举类型" class="headerlink" title="4、枚举类型"></a>4、枚举类型</h2><pre><code>(1)定义：enum Suit { Diamonds, Hearts, Clubs, Spades };或enum Suit { Diamonds, Hearts, Clubs, Spades }a,b,c;(2)对于枚举类型来说，只定义了赋值运算符，没有为枚举定义算术运算。(3)能够将枚举量赋给非枚举变量，因为枚举量是符号常量，赋值编译器会自动把枚举量转换为int类型。(4)在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，也就是说可以通过强制转换将其他类型值赋给枚举变量。(5)可以显式的设置枚举量的值(指定的值必须是整数)，也可以只显式的定义一部分枚举量的值。(6)未被初始化的枚举量的值默认比其前面的枚举量的值大1。当然，枚举量的值可以相同。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、C-中的BSS、数据段、代码段、堆、栈&quot;&gt;&lt;a href=&quot;#1、C-中的BSS、数据段、代码段、堆、栈&quot; class=&quot;headerlink&quot; title=&quot;1、C++中的BSS、数据段、代码段、堆、栈&quot;&gt;&lt;/a&gt;1、C++中的BSS、数据段、代码段、堆、栈
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>诗词入门(二)</title>
    <link href="http://www.echodemo.cc/2018/04/05/%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/04/05/诗词入门(二)/</id>
    <published>2018-04-05T11:35:50.000Z</published>
    <updated>2018-04-06T01:08:20.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、拗救"><a href="#1、拗救" class="headerlink" title="1、拗救"></a>1、拗救</h2><p>(1)拗：不符合诗律的一般规律(出律了)</p><p>(2)救：在拗的前提下调节平仄使音感和谐。</p><h2 id="2、拗救的常见形式"><a href="#2、拗救的常见形式" class="headerlink" title="2、拗救的常见形式"></a>2、拗救的常见形式</h2><p>以下皆以五言作为例句进行说明，那么也就是说七言的后五字同样适用于这些情况。</p><p>(1)本句自救(准律句)：平平平仄仄=》平平仄平仄</p><p>例：</p><pre><code>凉风起天末，君子意如何。平平仄平仄，平仄仄平平。</code></pre><p>根据诗律的原则，这里的“凉风起天末”句明显出律了。那么是“风”字出律还是“天”字出律呢？我们可以通过“君子意如何”句的平仄来判断。在这一联当中，对句的二四字的平仄为仄、平，那么就可以推出出句的二四字的平仄就为平、仄。也就是说是“天”字出律了(当仄为平时)，那么为什么明明“天”字出律了还会认为是对的呢？这种情况就是属于拗救中的本句自救。我们先来看一下出句的正确的平仄：“平平平仄仄”。这里有这样的规定：如果在诗的创作过程中碰到了“平平平仄仄”这种情况，可以使用另外一种格式，即：把五言的第三四字的平仄位置互换(七言当中第五六字的平仄位置互换)，此时规定五言的第一字必须用平声(七言的第三字必须用平声)，不再是可平可仄的，也就变成了“平平仄平仄”。我们可以发现，这种形式只能出现在出句当中(因为对句必须是押韵的，而近体诗当中是不能压仄声韵的)，同时又由于诗律中的相对和相粘原则，出句之中也只有两句才能出现这种情况。</p><p>若首字为仄，则是特例，初学者不建议使用。如：昔闻洞庭水(仄平仄平仄)。虽然说首字为仄的情况也是存在的，但毕竟与首字为平相比还是及其少见的。老杜虽是及其注重格律之人，但他活在格律成形的那个年代，那个时候的格律还是处于可以推敲的阶段，当然也就不能说他是错的。(这里只是希望初学者不要钻牛角尖，只要记住这种拗救的形式就行)</p><p>又例：</p><pre><code>遥怜小儿女，未解忆长安。平平仄平仄，仄仄仄平平。何时倚虚晃，双照泪痕干。平平仄平仄，平仄仄平平。西望瑶池降王母(平仄平平仄平仄)</code></pre><p>(2)对句相救：出句第四字当平为仄时，对句第三字只能是平声。</p><p>例：</p><pre><code>向晚意不适，驱车登古原。仄仄仄仄仄，平平平仄平。*在诗词当中，“不”字几乎可以说是只能为仄声。但也不是绝对的，当“不”字通“否”字时且作为韵脚时，它是平声的。如果它位于句中就一定是仄声。</code></pre><p>同样，这里根据对句的平仄可以判断出，是出句当中的第四字“不”字出律了(当平为仄时)。此时，可以通过对句的第三字(此时必为平声)来救，也就是例句中的“登”字。按照“一三五不论”的原则，“登”字本是可平可仄的，但是在这种情况之下就只能为平声了。因为是出句由对句来救，所以这种情况只能发生在出句当中。</p><p>又例：</p><pre><code>野火烧不尽，春风吹又生。仄仄平仄仄，平平平仄平。*吹字是可平可仄的，作名词的时候为仄声(歌吹是扬州)，作动词的时候为平声。</code></pre><h2 id="3、“一三五不论”需要排除的三种情况"><a href="#3、“一三五不论”需要排除的三种情况" class="headerlink" title="3、“一三五不论”需要排除的三种情况"></a>3、“一三五不论”需要排除的三种情况</h2><pre><code>(1)三平尾：在已经确定倒数第一和倒数第二字为平声的情况之下，如果仍然令倒数第三字为平声的话，就会变成“平平平”。三平尾是写诗的大忌。(2)三仄尾：在已经确定倒数第一和倒数第二字为仄声的情况之下，如果仍然令倒数第三字为仄声的话，就会变成“仄仄仄”。三仄尾也是写诗的大忌。(3)孤平：就是“仄平仄仄平”。孤平同样是写诗的大忌。这里可以将第三字改为平声来补偿，以免犯孤平。</code></pre><h2 id="4、根据平仄判断律句，若非律句再判断是否可救的步骤"><a href="#4、根据平仄判断律句，若非律句再判断是否可救的步骤" class="headerlink" title="4、根据平仄判断律句，若非律句再判断是否可救的步骤"></a>4、根据平仄判断律句，若非律句再判断是否可救的步骤</h2><pre><code>(1)先判断二四六字是否是平仄交替的。如果是则说明暂时是一个律句，进行第二步；否则说明此句不是一个标准的律句，进行第三步。(2)是否出现了三平尾、三仄尾或者是孤平。如果出现了其中一种，则必定是错误的。若没有，则说明是可以用的。(3)判断是否符合拗救的两种基本形式。如果符合其中之一说明是可以用的；如果都不符合则说明是错误的。</code></pre><h2 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h2><p>如果是本句自救(准律句)，打半钩；如果是对句自救，则标记出其对句该如何。如果最终不符合格律则打叉，符合则打钩。若有学有余力，为正确的律句查找相应的诗句。</p><p><img src="/images/2018/4/1.jpg" alt="&quot;作业&quot;"></p><p><img src="/images/2018/4/2.jpg" alt="&quot;作业&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、拗救&quot;&gt;&lt;a href=&quot;#1、拗救&quot; class=&quot;headerlink&quot; title=&quot;1、拗救&quot;&gt;&lt;/a&gt;1、拗救&lt;/h2&gt;&lt;p&gt;(1)拗：不符合诗律的一般规律(出律了)&lt;/p&gt;
&lt;p&gt;(2)救：在拗的前提下调节平仄使音感和谐。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/05/MySQL%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/05/MySQL中的问题整理/</id>
    <published>2018-04-05T01:45:49.000Z</published>
    <updated>2018-04-05T02:33:56.808Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、mysql共享锁和排他锁</code></pre><p>(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排它锁。</p><p>(2)共享锁也叫读锁，简称S锁，原理：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改。</p><p>(3)排他锁也叫写锁，简称x锁，原理：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁(排他锁或者共享锁)，即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改。但是获取排他锁的事务是可以对数据进行读取和修改。</p><p>(4)设置共享锁：SELECT … LOCK IN SHARE MODE;设置排他锁：SELECT … FOR UPDATE;</p><p>(5)对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。 对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。</p><pre><code>2、MySQL几种备份方式</code></pre><p>(1)逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。</p><p>优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。</p><p>缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。</p><p>(2)物理备份：直接拷贝mysql的数据目录。直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。</p><p>缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。</p><p>(3)双机热备份。mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备)。</p><p>优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。</p><pre><code>3、数据库范式：一张数据表的表结构所符合的某种设计标准的级别</code></pre><p>(1)第一范式(1NF)</p><p>在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。<br>所谓第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>(2)第二范式(2NF)</p><p>第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是消除了非主属性对于码的部分函数依赖。</p><p>(3)第三范式(3NF)</p><p>满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是消除了非主属性对于码的传递函数依赖。</p><pre><code>4、SQL语句优化</code></pre><p>(1)应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>(2)应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</code></pre><p>(3)很多时候用 exists 代替 in 是一个好的选择。</p><p>(4)用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过。</p><pre><code>5、存储过程与触发器的区别</code></pre><p>(1)触发器与存储过程非常相似，它是一种特殊类型的存储过程。触发器也是SQL语句集，他们都像是数据库中运行的方法。两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发(激活)执行。</p><p>(2)触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p><p>(3)触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p><pre><code>6、union 与union all的区别</code></pre><p>union 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all 则会显示重复结果,只是简单的两个结果合并并返回.所以效率比union高,在保证没有重复数据的情况下用union all。</p><pre><code>7、MyISAM和InnoDB区别</code></pre><p>(1)InnoDB支持外键，而MyISAM不支持。</p><p>(2)InnoDB不支持全文索引，而MyISAM支持。</p><p>(3)InnoDB支持行级锁，而MyISAM支持表级锁。</p><p>(4)MyISAM不提供事务支持。InnoDB提供事务支持。</p><p>(5)MyISAM保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p>(6)MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p>(7)MyISAM可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p>(8)如果执行大量的SELECT，MyISAM是更好的选择。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p>(9)每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><pre><code>8、MySQL的三级模式</code></pre><p>(1)模式(逻辑模式)：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><p>(2)外模式(用户模式)：是数据库用户的数据视图，是局部数据的逻辑结构和特征的描述。</p><p>(3)内模式(存储模式)：一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p><pre><code>9、mysql中视图和表的区别以及联系</code></pre><p>区别：</p><p>(1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。</p><p>(2)视图没有实际的物理记录，而表有。</p><p>(3)视图是窗口，表是内容。</p><p>(4)视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。</p><p>(5)表可以及时对它进行修改；而视图只能用创建语句来修改。</p><p>(6)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。</p><p>(7)从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。</p><p>(8)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</p><p>(9)视图的建立和删除只影响视图本身，不影响对应的表。</p><p>联系：</p><p>(1)视图是在表之上建立的虚表，它的结构(所定义的列)和内容(所有记录)都来自表，视图依据表存在而存在。一个视图可以对应多个表。视图是表的抽象和在逻辑意义上建立的新关系。</p><p>(2)删除视图中的数据,数据库中表的数据会一起被删除。</p><pre><code>10、存储过程(procedure)和函数(function)区别</code></pre><p>(1)本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。</p><p>(2)函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。</p><p>(3)函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、mysql共享锁和排他锁
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="http://www.echodemo.cc/2018/04/04/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.echodemo.cc/2018/04/04/MySQL事务/</id>
    <published>2018-04-04T15:46:14.000Z</published>
    <updated>2018-04-05T02:34:05.226Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><pre><code>(1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。(2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。(3)事务用来管理 insert,update,delete 语句</code></pre><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><p>(1)原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>(2)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>(3)隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><pre><code>a、未提交读（RU）：最弱的隔离级别，事务中的修改即使没有提交，对其他事务也都是可见的。（即脏读）b、不可重复读（RC）：大多数数据库系统的默认隔离级别。解决了脏读的问题，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。一个事务两次执行同样的查询，可能会得到不一样的结果。c、可重复读（RR）：mysql默认隔离级别。解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。该级无法解决幻读的问题，幻读是当某个事务在读取某个范围内的记录时，一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。innodb和xtradb存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。d、可串行化：该级是最高的级别，通过强制事务串行执行，避免了幻读的问题，该级会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题，</code></pre><p>(4)持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务必使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><p>事务控制语句：</p><pre><code>(1)BEGIN或START TRANSACTION；显式地开启一个事务；(2)COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；(3)ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；(4)SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；(5)RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(6)ROLLBACK TO identifier；把事务回滚到标记点；(7)SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</code></pre><p>MYSQL 事务处理主要有两种方法：</p><pre><code>1、用 BEGIN, ROLLBACK, COMMIT来实现(1)BEGIN 开始一个事务(2)ROLLBACK 事务回滚(3)COMMIT 事务确认2、直接用 SET 来改变 MySQL 的自动提交模式:(1)SET AUTOCOMMIT=0 禁止自动提交(2)SET AUTOCOMMIT=1 开启自动提交</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)在 MySQL 中只有使用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.echodemo.cc/2018/04/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.echodemo.cc/2018/04/04/红黑树/</id>
    <published>2018-04-04T01:50:20.000Z</published>
    <updated>2018-04-05T00:01:48.845Z</updated>
    
    <content type="html"><![CDATA[<p>1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次递减时，它会不断地插在节点的左子树)。此时的二叉查找树的查找性能几乎变成了线性。那么如何解决二叉查找树多次插入新节点而导致的不平衡呢？红黑树也就应运而生了。</p><pre><code>二叉查找树的性质：a、左子树上所有结点的值均小于或等于它的根结点的值。b、右子树上所有结点的值均大于或等于它的根结点的值。c、左、右子树也分别为二叉排序树。</code></pre><p>2、红黑树(Red Black Tree)是一种平衡的二叉查找树(但不是一个完美的平衡二叉树)。它的应用有很多，Java中的TreeSet和TreeMap数据结构，Java8中的HashMap也用到了红黑树；在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。</p><font color="#8A2BE2">(1)性质</font><pre><code>a、节点是红色或黑色。b、根节点是黑色。c、每个叶子节点都是黑色的空节点（NIL节点）。d、每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)e、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</code></pre><p>以上这些限制强化了红黑树的关键属性：从根节点到最远叶节点的路径不超过从根到最近叶节点的路径的两倍(最短的路径是:全部都是黑色节点，最长的路径是:在红色和黑色节点之间交替)。这也是红黑树和二叉查找树之间最大的不同。</p><font color="#8A2BE2">(2)左旋转和右旋转</font><p>a、左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子树取代，而父节点自己成为自己右子树(现在已经是父节点了)的左子树。现在已经是父节点的的左子树成为曾经的父节点的右子树。</p><p>b、右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子树取代，而父节点自己成为自己左子树(现在已经是父节点了)的右子树。现在已经是父节点的的右子树成为曾经的父节点的左子树。</p><font color="#8A2BE2">(3)插入节点</font><p>a、当前节点位于树的根部。为了满足（根节点是黑色），将其颜色变成黑色。由于这会向每条路径都添加一个黑色节点，所以（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）不会被违反。</p><p>b、当前节点的父节点是黑色的。所以（每个红色节点的两个子节点都是黑色）不会失效。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）没有受到威胁，因为当前节点有两个黑色节点，但由于当前节点是红色，所以到达其每个叶子节点路径上的黑色节点的数量与它所替换的叶子节点路径上的黑色节点的数量是相同的。</p><p>c、如果父节点和父节点的兄弟节点都是红色的，那么可以将他们的颜色都变成黑色，并且将祖父母节点的颜色变成红色以维持（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）。由于通过父节点和父节点的兄弟节点的任何路径必须经过祖父母节点，所以这些路径上的黑色节点的数目并没有改变。然而，祖父母节点现在可能违反了（根节点是黑色），如果它是根或（每个红色节点的两个子节点都是黑色），如果它具有红色的父母节点。为了解决这个问题，树上的红黑修复程序在祖父母节点上重新运行。</p><p>d、父节点是红色的，但是父节点的兄弟节点是黑色的。最终目标是将当前节点旋转到祖父母节点的位置，但如果当前节点位于祖父母节点下子树的“内部” （即，如果当前节点是祖父母节点的右子节点的左子节点或者是祖父母节点的左子节点的右子节点）。在这种情况下，可以在父节点上执行左旋转以切换当前节点及其父节点的位置。由于父节点和当前的插入节点都是红色的，所以旋转这两个节点不会使（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）受到旋转的影响。这一步完成后（每个红色节点的两个子节点都是黑色）仍然被违反。此时，当前节点现在肯定位于祖父母节点的子树的外部（左子节点或右子节点）。在这种情况下，执行祖父母节点上的右旋转;其中前父母节点现在是当前节点和前祖父母节点的父母节点。此时前父母节点和前祖父母节点的颜色互换，结果树满足（每个红色节点的两个子节点都是黑色）。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）也依然不满足，再将前祖父母节点和其右子节点的颜色互换即可。</p><p>*具体的红黑树中插入和删除出现的有关旋转和变色的情况，请自行跳转至维基百科查看：<a href="https://en.m.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">维基百科红黑树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>柴</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%9F%B4/"/>
    <id>http://www.echodemo.cc/2018/03/31/柴/</id>
    <published>2018-03-31T08:03:52.000Z</published>
    <updated>2018-03-31T08:06:39.689Z</updated>
    
    <content type="html"><![CDATA[<p>你本是泥土里的种子</p><p>春雨下来，便破土而出，发芽又抽绿</p><p>阳光透过乔木和灌木的叶子漏下来</p><p>照耀着你微弱的身体</p><p><br><br>后来呀，雨露下来，寒风穿过</p><p>土壤也时而干燥</p><p>根在土里生长</p><p>叶在空气里徜徉</p><p>向着更广阔的空间里延伸</p><p>春夏秋冬地过去，轮回。</p><p><br><br>那一日，我手持柴刀独自上山</p><p>无意间来到你的身旁</p><p>此时的你已巍然成木</p><p>在多少次的手起刀落后</p><p>在洁白的木屑四散飞溅后</p><p>你轰然倒下</p><p>倒在你无比熟悉的地点</p><p>我残忍地脱去你的外衣，卸下你的臂膀</p><p>甚至头颅。</p><p><br><br>你已经死了</p><p>你的尸体跟随我下了山</p><p>你永远地离开了生生世世守护的这方土地</p><p>被我丢弃在陌生的沙土之上</p><p>无情的斧子借着外力将你的尸体大卸八块</p><p>陈列在清灰色瓦片盖的土坯房子里</p><p>静静等候与烈火的相遇</p><p>化为炊烟又化为尘土</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你本是泥土里的种子&lt;/p&gt;
&lt;p&gt;春雨下来，便破土而出，发芽又抽绿&lt;/p&gt;
&lt;p&gt;阳光透过乔木和灌木的叶子漏下来&lt;/p&gt;
&lt;p&gt;照耀着你微弱的身体&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;后来呀，雨露下来，寒风穿过&lt;/p&gt;
&lt;p&gt;土壤也时而干燥&lt;/p&gt;
&lt;p&gt;根在土里生长&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>文字</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%96%87%E5%AD%97/"/>
    <id>http://www.echodemo.cc/2018/03/31/文字/</id>
    <published>2018-03-31T07:29:11.000Z</published>
    <updated>2018-03-31T07:34:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全文”的扩展链接，你会知道自己在某天的某个时间段做了什么。可能是有关学习的知识点，可能是有关生活的感悟或自己的思考，又或者仅仅是记录了一件事情的发生。所有这些，过后回望的确会有及其深刻的意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(三)</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/31/《眠空》摘句(三)/</id>
    <published>2018-03-31T07:13:57.000Z</published>
    <updated>2018-04-07T00:55:58.793Z</updated>
    
    <content type="html"><![CDATA[<p>1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。</p><p>2、经过提纯的内心空间，不是不懂，不知，而是不问，不计较，不介意，不追究。愿意把别人想得好一些，不把人想得复杂，考虑到对方的立场。可说，可不说时，不如选择不说。</p><p>4、不存在无可救药的人、感情、生活。一切终究有变化。如果你认为它无可救药，不过是沉溺。我们可以选择完全的放下，或者完全的承担。唯独不能伪装成一个懒怠的理所当然的姿势。你尽可拖延和故作不知，企图获得其他妥协。命运静静等待一侧，旁观你辗转煎熬，最终会逼迫你把脚步移向注定的一格。实践一旦进行，错误和方式就会自动调整和归位。出发时首要的。</p><p>5、跪拜只是一个仪式，为了让心恭敬谦卑平和柔顺，在毫无杂念从事这一重复举动时训练和观照自己。调伏这颗充满傲慢我执的刚硬的心。这是一个修行的任务。</p><p>6、不应在原地等待，要一边前行一边等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。&lt;/p&gt;
&lt;p&gt;2、经过提纯的内心空间，不是不懂，不
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的抽象类和接口</title>
    <link href="http://www.echodemo.cc/2018/03/31/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.echodemo.cc/2018/03/31/Java中的抽象类和接口/</id>
    <published>2018-03-31T07:01:20.000Z</published>
    <updated>2018-03-31T07:02:41.750Z</updated>
    
    <content type="html"><![CDATA[<p>1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是GeometricObject类型的数组，然后创建一个GeometricObject的实例，并将它的引用赋值给数组是可以的。虽然不能使用new操作符创建它的实例，但仍然可以定义它的构造方法，抽象类的构造方法定义为protected，因为它只被子类使用。抽象方法只有定义而没有实现。它的实现由子类提供。</p><p>2、抽象方法不能包含在非抽象类中，也就是说一个包含抽象方法的类必须声明为抽象类。但是，可以定义一个不包含抽象方法的抽象类(同样不能使用new操作符创建它的实例)，这种类是用来定义新子类的基类的。如果抽象父类的子类不能实现所有的抽象方法，那么这个子类也必须定义为抽象的。另外，抽象方法是非静态的。</p><p>3、即使子类的父类是具体的，这个子类也可以是抽象的。比如：object类是具体的，但继承于它的类却可以是抽象的。子类可以覆盖父类的方法并将它定义为abstract(这是很少见的)，但是它在当父类的方法实现在子类中变得不合法时是很有用的。在这种情况下，子类必须为abstract。</p><p>4、接口是一种与类相似的结构，只包含常量和抽象方法。它和抽象类相似，不能使用new操作创建接口的实例。由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以java允许忽略这些修饰符。</p><p>5、Java只允许为类的扩展做单一继承，但是允许使用接口做多重继承。用关键字extends，接口可以继承其他接口，但是不可扩展类。一个类可以扩展它的父类同时实现多个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是Ge
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>画地为牢</title>
    <link href="http://www.echodemo.cc/2018/03/28/%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2/"/>
    <id>http://www.echodemo.cc/2018/03/28/画地为牢/</id>
    <published>2018-03-28T12:25:39.000Z</published>
    <updated>2018-03-28T12:28:30.244Z</updated>
    
    <content type="html"><![CDATA[<p>人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一双发现美的眼睛，同时也需要有伸向外界的触角和勇气。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Strcpy函数的实现</title>
    <link href="http://www.echodemo.cc/2018/03/28/Strcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.echodemo.cc/2018/03/28/Strcpy函数的实现/</id>
    <published>2018-03-28T10:54:17.000Z</published>
    <updated>2018-03-28T10:57:39.608Z</updated>
    
    <content type="html"><![CDATA[<p>(1)strcpy函数的代码实现</p><pre><code>char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。    assert(dst != NULL &amp;&amp; src != NULL);//检查指针的有效性，如果它的条件返回错误，则终止程序执行。    char *ret = dst;    while ((*dst++=*src++)!=&apos;\0&apos;);    return ret;}</code></pre><p>(2)为什么要返回char *?</p><pre><code>返回dst的原始值使函数能够支持链式表达式。链式表达式的形式如：int l=strlen(strcpy(strA,strB));又如：char * strA=strcpy(new char[10],strB);返回strSrc的原始值是错误的。其一，源字符串肯定是已知的，返回它没有意义。其二，不能支持形如第二例的表达式。其三，把const char *作为char *返回，类型不符，编译报错。</code></pre><p>(3)考虑dst和src内存重叠的情况</p><p>所谓重叠，就是src未处理的部分已经被dst给覆盖了，只有一种情况：src&lt;=dst&lt;=src+strlen(src)。C函数memcpy自带内存重叠检测功能，下面给出memcpy的实现my_memcpy。</p><pre><code>char *strcpy(char *dst,const char *src){    assert(dst != NULL &amp;&amp; src != NULL);    char *ret = dst;    my_memcpy(dst, src, strlen(src)+1);    return ret;}</code></pre><p>my_memcpy的实现：</p><pre><code>char *my_memcpy(char *dst, const char* src, int cnt){    assert(dst != NULL &amp;&amp; src != NULL);    char *ret = dst;     if(dst &gt;= src &amp;&amp; dst &lt;= src+cnt-1){//内存重叠，从高地址开始复制        dst = dst+cnt-1;        src = src+cnt-1;        while (cnt--)            *dst-- = *src--;    }else{//正常情况，从低地址开始复制        while (cnt--)            *dst++ = *src++;    }    return ret;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(1)strcpy函数的代码实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。
    assert(dst != NULL &amp;amp;&amp;amp; src 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>三月二十七号</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E4%B8%89%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8F%B7/"/>
    <id>http://www.echodemo.cc/2018/03/27/三月二十七号/</id>
    <published>2018-03-27T11:51:27.000Z</published>
    <updated>2018-03-27T11:54:38.037Z</updated>
    
    <content type="html"><![CDATA[<p>奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量的传递与引导，人与自然需要一定的联结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/27/《眠空》摘句(二)/</id>
    <published>2018-03-27T11:29:09.000Z</published>
    <updated>2018-03-27T11:30:11.879Z</updated>
    
    <content type="html"><![CDATA[<p>1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。仿佛一种强悍的无法屈服的意愿。</p><p>2、我们最终所得到的训练无非是，面对无所知、无常、虚妄，时时抚平心绪，保持警惕、平静、坚强、有方向地活下去。并且静观这个世间所有破落的碎片擦身而过。</p><p>3、人的生活需要公园。它为日常生活提供一处停顿。停顿意味暂时没有心念，没有目标，略作小憩，与己共存。</p><p>4、如果要做到不伤害他人，前提是不要对他人抱有期待。同时也不让他人抱有对你的期待。做到后一条更为困难。这意味着在某些时刻，你必须显示你自己真实的立场，而没有一丝自私的隐藏或者造作。</p><p>5、有时，我们爱人，是取悦自己渴望被爱的欲求；对他人的提供，是试图填补内在匮乏的需求；憎恶或攻击他人，是被对方提醒了不愿意被揭示的遮蔽的暗处；愤恨或者狂躁，联结着内心长期积累的软弱和无力。。。自我战争不过是冲突于牢笼之中。</p><p>6、时间很重要，物证很重要。它们会使某些曾经被蒙蔽或忽略的情感，在很久之后被澄清和浮出。我也会手写书信给生命中真正重要的人。只为了让他或她，在以后某天终会明白我的心。</p><p>7、摘完杏，和农夫闲聊。他说果实在树上，阳光的温度或突降的暴雨都会给予它影响。每一天它的内在都在发生变化，都在面临无常。所以，及时地摘下并享用它即是最好的方式。</p><p>8、人由自我限制而生发的对他人的狭窄念头，毫发无损于对方，只使自己捉襟见肘。若能置身事外，才不会画地为牢。</p><p>9、当下享受是最好的态度。接受无常，接纳完整的存在，而不试图重新塑造，也不扭曲自己和他人。关系第一原则，应是允许他人以独立和自愿的方式存在。期望是自以为是的权力。</p><p>10、在一本书里，读者感受到作者的精神方式、观念、特质，觉得与之契合，有共鸣，遂在心里把他当作一个知己。他们之间的关系，有时会比生活中实际相处的人抵达更为深邃的心灵限度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(三)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(三)/</id>
    <published>2018-03-26T10:10:23.000Z</published>
    <updated>2018-03-31T07:00:52.662Z</updated>
    
    <content type="html"><![CDATA[<p>1、define与const的区别</p><p>(1)define在预处理阶段进行替换;const在编译时确定其值。</p><p>(2)用define可以定义一些简单的函数，const是不可以定义函数的。</p><p>(3)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的。</p><p>(4)define无类型，不进行类型安全检查，可能会产生意想不到的错误;const有数据类型,编译时会进行类型检查。</p><p>(5)define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大;const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。</p><p>(6)宏定义的作用范围仅限于当前文件;而const对象在默认状态下，只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字(在声明和定义时都要加。</p><p>2、构造函数不能为虚函数，而析构函数可以且常常是虚函数</p><p>(1)如果构造函数是虚函数，那么就需要通过vtable来调用，但此时面对一块raw memeory是找不到vtable的，vtable是在构造函数中才初始化的，而不是在其之前。因此构造函数不能为虚函数。</p><p>(2)析构函数可以是虚函数,此时vtable已经初始化了,况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p><p>3、虚函数和纯虚函数的作用与区别</p><p>(1)虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不重写基类中的此函数。</p><p>(2)纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数。它不能直接实例化，需要派生类来实现函数定义。</p><p>4、面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。他们之间的共同点是抽象和创建可重用代码，但它们的理念决然不同。泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板，模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型，它们都是STL通用方法的重要组成部分。</p><p>5、头文件中的#ifndef/#define/#endif的作用</p><p>其作用是防止该头文件被重复引用。”被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include “c.h”而此时b.cpp文件导入了#include”a.h”和#include”c.h”此时就会造成c.h重复引用。有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些。但是对于大工程而言编译效率低下就会是一件很痛苦的事情了。</p><p>6、动态内存分配的初始化问题</p><p>1)malloc函数：void *malloc(unsigned int size)</p><p>在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。</p><p>2)calloc函数： void *calloc(unsigned int num, unsigned int size)</p><p>按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。</p><p>3)realloc函数：void <em>realloc(void </em>ptr, unsigned int size)</p><p>动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。申请的内存空间不会进行初始化。</p><p>4)new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。</p><p>7、指针和const</p><pre><code>int * const x = &amp;y;       //指针所指向的内存不可变，内存中的值可以改变。const int *x = &amp;y;        //指针所指向的内存可变，但内存中的值不能通过指针改变。int const *x = &amp;y;        //指针所指向的内存可变，但内存中的值不能通过指针改变。const int const *x = &amp;y;  //指针所指向的内存不可变，内存中的值也不能通过指针改变。const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。当const在*的左边，则表示指针所指向的空间的内容不能通过改变*p的值来修改，或者说指针所指向空间的值不能被修改。当const在*的右边，则表示指针的地址不能被修改，或者说指针的指向不能被修改。</code></pre><p>8、无论是整型数组还是字符数组，数组名作为右值的时候都代表数组首元素的首地址。数组发生降级(数组名退化为数组首元素的地址)的情况：数组传参、数组名参与运算。数组名不会发生降级的情况：sizeof(数组名)、取地址数组名(取到的是整个数组的地址而不是首元素的地址)。</p><p>9、重载、覆盖和隐藏</p><pre><code>(1)成员函数被重载的特征：a、相同的范围(在同一个类中)；b、函数名字相同；c、参数不同；d、virtual关键字可有可无。(2)覆盖是指派生类函数覆盖基类函数，只作用于派生类函数，特征是：a、不同的范围(分别位于派生类与基类)；b、函数名字相同；c、参数相同；d、基类函数必须有virtual关键字。实际上虚函数的作用，就是实现覆盖。(3)“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：a、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)。b、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)。</code></pre><p>10、类模板与模板类的概念</p><p>(1)类模板:一个类模板(也称为类属类或类生成类)允许用户为类定义一种模式，使得类中的某些数据成员、默认成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。</p><p>(2)模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。<br>类模板的重点是模板，表示的是一个模板，专门用于产生类的模子。模板类的重点是类，表示的是由一个模板生成而来的类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、define与const的区别&lt;/p&gt;
&lt;p&gt;(1)define在预处理阶段进行替换;const在编译时确定其值。&lt;/p&gt;
&lt;p&gt;(2)用define可以定义一些简单的函数，const是不可以定义函数的。&lt;/p&gt;
&lt;p&gt;(3)用define定义的常量是不可以用指针变量去
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(二)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(二)/</id>
    <published>2018-03-26T07:12:01.000Z</published>
    <updated>2018-03-31T07:07:25.739Z</updated>
    
    <content type="html"><![CDATA[<p>1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。</p><p>2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。</p><p>3、构造函数初始化时必须采用初始化列表的一共有三种情况</p><pre><code>(1)需要初始化的数据成员是对象(继承时调用基类构造函数)(2)需要初始化const修饰的类成员(3)需要初始化引用成员数据*由于static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的。static const成员也不在初始化列表中。*static属于类，它在未实例化的时候就已经存在了，而构造函数的初始化列表，只有在实例化的时候才执行。*static成员不属于对象。我们在调用构造函数自然是创建对象，一个跟对象没直接关系的成员没有必要初始化。</code></pre><p>4、实参可以是任何类型（可以是常量，变量或表达式），但是形参却不能是表达式。C语言中最简单的数据类型包括整型、实型(实型又称浮点数或者实数)、字符型。在C语言中，没有专门的逻辑型数据类型，而是用0和1来表示逻辑值。</p><p>5、类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐。基类中存在虚函数时，派生类会继承基类的虚函数(虚函数也是类的成员函数)，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。(指向虚函数的指针为4个字节)</p><p>6、fork()与clone的区别</p><p>函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；clone()函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可以通过参数设定选择的，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。</p><p>7、关于浅复制和深复制</p><p>所谓浅复制，就是在构造函数当中直接为复制的对象的数据成员赋值。在很多情况下，这是可以的。创建新的对象，要为对象的数据成员分配存储空间，直接赋值就将值保存在相应的空间中。但是如果在构造函数当中出现了指针类型的数据成员时，也按照上面那样直接赋值而未经过地址的分配就会在调试的时候出错，这种指针被称为“野指针”。解决这样的问题的方法，就是在构造函数中，为指针类型的成员，分配专门的空间。以这条规则构建的复制，称作为深复制。</p><p>8、C语言中的未定义行为(Undefined Behavior)</p><p>未定义行为是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。</p><p>9、C++面向对象的三个基本特征(封装、继承和多态)</p><p>(1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行。封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p><p>(2)继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>(3)多态：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上。同时又有这些多态的形式，参数多态：指参数方面，包含函数模板与类模板；包含多态：含有virtual关键字；重载多态：函数名相同，但函数参数的个数或类型不同构成多态；强制多态：通过强制类型转换形成；重载多态和强制多态是指特定多态。参数多态和包含多态是指通用多态。</p><p>*封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现接口重用！</p><p>10、虚函数如何实现的</p><pre><code>(1)虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针。(2)在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。(3)实际上在编译的时候，编译器会自动加上虚表。(4)虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函数重新定义。(5)虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。(6)必须通过基类类型的引用或指针进行函数调用才会发生多态。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。&lt;/p&gt;
&lt;p&gt;2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Windows中个人常用快捷键</title>
    <link href="http://www.echodemo.cc/2018/03/26/Windows%E4%B8%AD%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.echodemo.cc/2018/03/26/Windows中个人常用快捷键/</id>
    <published>2018-03-26T03:10:27.000Z</published>
    <updated>2018-03-26T03:13:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ctrl类</p><pre><code>(1)撤消操作：Ctrl+Z(2)复制选定文本：Ctrl+C(3)粘贴选定文本：Ctrl+V(4)剪切选定文本：Ctrl+X(5)打开新窗口：Ctrl+N(6)关闭当前所在窗口：Ctrl+W(7)恢复关闭的窗口：ctrl+shift+T(8)新建文件夹：Ctrl+Shift+N(9)选择文档或窗口中的所有项目：Ctrl+A(10)在本应用下的窗口之间进行切换：Ctrl+Tab</code></pre><p>2、Windows类</p><pre><code>(1)电脑锁屏：Windows+L(2)显示和隐藏桌面：Windows+D(3)打开任务视图：Windows+Tab(4)打开“运行”对话框：Windows+R(5)打开文件资源管理器：Windows+E(6)添加虚拟桌面：Windows+Ctrl+D(7)关闭你正在使用的虚拟桌面：Windows+Ctrl+F4(8)在你于右侧创建的虚拟桌面之间切换：Windows+Ctrl+向右键(9)在你于左侧创建的虚拟桌面之间切换：Windows+Ctrl+向左键    </code></pre><p>3、其他</p><pre><code>(1)刷新当前窗口：F5(2)在所有打开的应用之间进行切换：Alt+Tab</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Ctrl类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)撤消操作：Ctrl+Z

(2)复制选定文本：Ctrl+C

(3)粘贴选定文本：Ctrl+V

(4)剪切选定文本：Ctrl+X


(5)打开新窗口：Ctrl+N

(6)关闭当前所在窗口：Ctrl+W

(7)恢复关
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="http://www.echodemo.cc/tags/Windows/"/>
    
  </entry>
  
</feed>
