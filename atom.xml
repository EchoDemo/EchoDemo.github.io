<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-08-01T09:27:10.387Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT B1023 组个最小数</title>
    <link href="http://www.echodemo.cc/2018/08/01/PAT-B1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/08/01/PAT-B1023-组个最小数/</id>
    <published>2018-08-01T09:21:29.000Z</published>
    <updated>2018-08-01T09:27:10.387Z</updated>
    
    <content type="html"><![CDATA[<p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。</p><p>输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。</p><p>输出格式：在一行中输出能够组成的最小的数。</p><pre><code>输入样例：2 2 0 0 0 3 0 0 1 0输出样例：10015558</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a[10];    int t = 0;    for (int i = 0;i &lt; 10;i++) {        cin &gt;&gt; a[i];    }    for (int i = 1;i &lt; 10;i++) {//查找第一个不包括零在内的个数不为零的数并输出一个        if (a[i] != 0) {            cout &lt;&lt; i;            t = i;            break;        }    }    for (int i = 0;i &lt; a[0];i++) {        cout &lt;&lt; 0;    }    for (int i = 0;i &lt; a[t] - 1;i++) {        cout &lt;&lt; t;    }    for (int i = t + 1;i &lt; 10;i++) {        for (int j = 0;j &lt; a[i];j++) {            cout &lt;&lt; i;        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的过滤流</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的过滤流/</id>
    <published>2018-08-01T00:18:39.000Z</published>
    <updated>2018-08-01T00:19:53.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、过滤流介绍"><a href="#1、过滤流介绍" class="headerlink" title="1、过滤流介绍"></a>1、过滤流介绍</h3><p>(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装。这些流一般由普通类的方法(即过滤流的一个父类)访问。</p><p>(2)过滤字节流FilterInputStream和FilterOutputStream，它们不是抽象类，它们提供的方法和InputStream和OutputStream类的方法相同。构造方法有：</p><pre><code>FilterOutputStream(OutputStream os);FilterInputstream(InputStream is);</code></pre><p>常用的过滤流有BufferedInputStream和BufferedOutputStream(带缓冲区)，DataInputStream和DataOutputStream(对基本数据类型进行读写操作)。</p><h3 id="2、过滤流举例说明"><a href="#2、过滤流举例说明" class="headerlink" title="2、过滤流举例说明"></a>2、过滤流举例说明</h3><p>(1)BufferedInputStream和BufferedOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class BufferedInputOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        BufferedInputStream bis = new BufferedInputStream(fileInputStream);        BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream);        long time1 = System.currentTimeMillis();        int data = 0;        while((data = bis.read())!=-1){//从缓冲区里面读，而不是直接从输入流里面读。            bos.write(data);//先写到缓冲区，当缓冲区满的时候再一次性写到输出流里面去。        }        bis.close();        bos.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><p>(2)DataInputStream和DataOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DataInputOutputStream {    public static void main(String[] args) throws IOException {        /*String name = &quot;zhangsan&quot;;        int age = 10;        boolean flag = true;        char set = &apos;男&apos;;        double money = 100.56;        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;f:\\test\\b.txt&quot;));        dos.writeUTF(name);        dos.writeInt(age);        dos.writeBoolean(flag);        dos.writeChar(set);        dos.writeDouble(money);        dos.close();*/        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;f:\\test\\b.txt&quot;));        //读的顺序必须和写的顺序一致        System.out.println(dis.readUTF());        System.out.println(dis.readInt());        System.out.println(dis.readBoolean());        System.out.println(dis.readChar());        System.out.println(dis.readDouble());        dis.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、过滤流介绍&quot;&gt;&lt;a href=&quot;#1、过滤流介绍&quot; class=&quot;headerlink&quot; title=&quot;1、过滤流介绍&quot;&gt;&lt;/a&gt;1、过滤流介绍&lt;/h3&gt;&lt;p&gt;(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的输入输出流</title>
    <link href="http://www.echodemo.cc/2018/07/31/Java%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/07/31/Java中的输入输出流/</id>
    <published>2018-07-31T12:14:08.000Z</published>
    <updated>2018-07-31T12:15:51.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、流的概念和分类"><a href="#1、流的概念和分类" class="headerlink" title="1、流的概念和分类"></a>1、流的概念和分类</h3><p>(1)流的概念</p><p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件、内存或是网络连接。同理，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据就好像在这其中“流动”一样。</p><p>(2)流的分类</p><p>a、流按其流向分为“输入流”和“输出流”。</p><p>b、流按数据传输单位分为“字节流”和“字符流”。“字节流”用来读写8位二进制的字节，“字符流”用来读写16位二进制字符。</p><p>c、流按功能分为“节点流”和“过滤流”。“节点流”用于直接操作目标设备的流，例如：磁盘或一块内存区域。“过滤流”是对一个已存在的流的链接和封装，通过对数据进行处理，为程序提供功能强大、灵活的读写功能。</p><h3 id="2、InputStream和Outputstream抽象类"><a href="#2、InputStream和Outputstream抽象类" class="headerlink" title="2、InputStream和Outputstream抽象类"></a>2、InputStream和Outputstream抽象类</h3><p>字节流类用于向字节流读写8位二进制的字节。一般的，字节流类主要用于读写诸如图像或声音等的二进制数据。字节流类以InputStream和OutputStream为顶层类。他们都是抽象类。InputStream中定义的方法有：</p><pre><code>public abstract int read();//从输入流中读取数据的下一个字节public int read(byte[] b);//从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中public int read(byte[] b ,int off ,int len);//将输入流中最多len个数据字节读入byte数组public long skip(long n);//跳过或者丢弃此输入流中数据的n个字节public int available();//返回从该输入流中可以读取的字节数的估计值，而不会被下一次调用此输入流的方法阻塞public void close();//关闭输入流并释放与该流关联的所有系统资源</code></pre><p>OutputStream抽象类所有方法返回void值，在出错情况下抛IOException异常。需要定义OutputStream子类的应用,OutputStream必须至少提供一个写入一个字节输出的方法。OutputStream中定义的方法：</p><pre><code>public abstract void write(int b);//将指定的字节写入此输出流。 public void write(byte[] b);//将b.length个字节从指定的byte数组写入此输出流public void write(byte[] ,int off ,int len);//从指定的字节数组写入len个字节，从偏移off开始输出到此输出流。public void flush();//刷新此输出流并强制任何缓冲的输出字节被写出。public void close();//关闭输出流并释放与该流关联的所有系统资源</code></pre><h3 id="3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类"><a href="#3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类" class="headerlink" title="3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)"></a>3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)</h3><p>(1)每个抽象类都有多个具体的子类，这些子类对不同的外设进行处理，例如磁盘文件，网络连接，甚至是内存缓冲区。FileInputStream类表示能从文件读取字节的InputStream类。其常用的构造方法有：FileInputStream(String filepath);FileInputStream(File fileObj);FileOutputStream类表示能向文件写入字节的OutputStream类。其常用的构造方法有：FileOutputStream(String filepath);FileOutputStream(File fileObj);FileOutputStream(String filePath,boolean append);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileInputStreamOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileCopyUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileCopyUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        long time1 = System.currentTimeMillis();        /*int data = -1;        while((data = fileInputStream.read())!=-1){            fileOutputStream.write(data);        }*/        byte[] buf = new byte[1024*1024];//创建一个1M大小的缓冲区，用来存放输入流中的字节数据        int len = 0;//用来保存实际读到的字节数        while((len = fileInputStream.read(buf))!=-1){            fileOutputStream.write(buf, 0, len);//使用缓冲区对文件的进行读写操作会大大提高读写的速度        }        fileOutputStream.close();        fileInputStream.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><h3 id="4、ByteArrayInputStream和ByteArrayOutputStream"><a href="#4、ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="4、ByteArrayInputStream和ByteArrayOutputStream"></a>4、ByteArrayInputStream和ByteArrayOutputStream</h3><p>(1)ByteArrayInputStream是把字节数组当成源的输入流，其内部包含一个内部缓冲区，且调用close()方法关闭ByteArrayInputStream无效。它有两个构造方法，每个都需要一个字节数组提供数据源：ByteArrayInputStream(byte array[]);ByteArrayInputStream(byte array[],int start,int numBytes);ByteArrayOutputStream是把字节数组当作目标的输出流，它也有两个构造方法：ByteArrayInputStream();ByteArrayOutputStream(int numBytes);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class ByteArrayInputOutputStream {    public static void main(String[] args) throws IOException {        /*String string = &quot;Hello,shanghai!&quot;;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(string.getBytes());        int data = -1;        while((data=byteArrayInputStream.read())!=-1){            System.out.print((char)data);        }        byteArrayInputStream.close();//这里的关闭时无效的，因为没有调用操作系统底层的函数。*/        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        byteArrayOutputStream.write(97);        byteArrayOutputStream.write(65);        byteArrayOutputStream.write(&quot;hello,world!&quot;.getBytes());        byte[] buff = byteArrayOutputStream.toByteArray();        for(byte b:buff){            System.out.print((char)b);        }        FileOutputStream fileOutputStream = new FileOutputStream(&quot;f:\\test\\a.txt&quot;,true);//true表示可以追加        byteArrayOutputStream.writeTo(fileOutputStream);//把ByteArrayOutputStream内部缓冲区中的数据写到对应的文件输出流中        byteArrayOutputStream.close();//这里的关闭同上    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、流的概念和分类&quot;&gt;&lt;a href=&quot;#1、流的概念和分类&quot; class=&quot;headerlink&quot; title=&quot;1、流的概念和分类&quot;&gt;&lt;/a&gt;1、流的概念和分类&lt;/h3&gt;&lt;p&gt;(1)流的概念&lt;/p&gt;
&lt;p&gt;流是一个很形象的概念，当程序需要读取数据的时候，就会开
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vim入门</title>
    <link href="http://www.echodemo.cc/2018/07/31/Vim%E5%85%A5%E9%97%A8/"/>
    <id>http://www.echodemo.cc/2018/07/31/Vim入门/</id>
    <published>2018-07-31T08:39:27.000Z</published>
    <updated>2018-07-31T08:46:40.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Vim的模式介绍"><a href="#1、Vim的模式介绍" class="headerlink" title="1、Vim的模式介绍"></a>1、Vim的模式介绍</h3><p>(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p><p>(2)插入模式(Insert mode):在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</p><p>(3)可视模式(Visual mode):这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p><p>(4)选择模式(Select mode):这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p><p>(5)命令行模式(Command line mode):在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p><p>(6)Ex模式(Ex mode):这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。这其中我们常用到就是普通模式、插入模式和命令行模式。</p><p>vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[(这在vim课程环境中不管用)即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</p><h3 id="2、Vim常用命令"><a href="#2、Vim常用命令" class="headerlink" title="2、Vim常用命令"></a>2、Vim常用命令</h3><p>(1)移动</p><pre><code>1)h 左移一个字符；2)l 右移一个字符；3)j 下移一行；4)k 上移一行；5)w 移动到下一个单词；6)b 移动到上一个单词；</code></pre><p>(2)插入</p><pre><code>1)i 在当前光标处进行编辑；2)I 在当前行首插入；3)a 在光标后插入；4)A 在当前行末插入；5)o 在下面新建一行插入；6)O 在上面新建一行插入；</code></pre><p>(3)保存</p><pre><code>1):wq 保存并退出；2):w 保存修改；3):q 退出；4):saveas newfilename 另存为；5):q! 强制退出，不保存；6):wq! 强制保存并退出；</code></pre><p>(4)删除</p><pre><code>1)x 删除游标所在的字符2)X 删除游标所在前一个字符3)dd 删除整行4)dw 删除一个单词（不适用中文）5)d$或D 删除至行尾6)d^ 删除至行首7)dG 删除到文档结尾处8)d1G 删至文档首部</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Vim的模式介绍&quot;&gt;&lt;a href=&quot;#1、Vim的模式介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Vim的模式介绍&quot;&gt;&lt;/a&gt;1、Vim的模式介绍&lt;/h3&gt;&lt;p&gt;(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java中IO框架之File</title>
    <link href="http://www.echodemo.cc/2018/07/30/Java%E4%B8%ADIO%E6%A1%86%E6%9E%B6%E4%B9%8BFile/"/>
    <id>http://www.echodemo.cc/2018/07/30/Java中IO框架之File/</id>
    <published>2018-07-30T12:26:33.000Z</published>
    <updated>2018-07-31T04:38:35.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、I-O框架介绍"><a href="#1、I-O框架介绍" class="headerlink" title="1、I/O框架介绍"></a>1、I/O框架介绍</h3><p>I/O(Input/Output)是计算机输入/输出的接口。Java的核心库java.io提供了全方面的I/O接口，包括：文件系统的操作，文件读写，标准设备输出等等。</p><h3 id="2、File类及使用"><a href="#2、File类及使用" class="headerlink" title="2、File类及使用"></a>2、File类及使用</h3><p>(1)一个File类的对象，表示了磁盘上的文件或者目录。File类提供了与平台无关的方法来对磁盘上的文件或者目录进行操作。File类直接处理文件和文件系统。比如删除文件，获取文件长度大小等信息。File类没有提供方法从文件读取或者向文件存储信息。其构造方法有：File(String directoryPath);File(String directoryPath,String filename);File(File dirObj,String filename);</p><p>(2)File定义了获取File对象标准属性的方法：</p><pre><code>public String getName();获取文件或目录的名字public String getParent();获取父目录的路径字符串public File getParentFile();获取父目录的File对象public String getAbsolutePath();获取文件或目录的绝对路径public boolean exists();判断文件或目录是否存在public String[] list();获得目录里面的文件名和目录名。public boolean isDirectory();判断是否是目录public boolean isFile();判断是否是文件public long length();获取文件的大小public boolean delete();删除目录或者文件夹public boolean mkdir();创建文件夹......</code></pre><h3 id="3、IO方法举例"><a href="#3、IO方法举例" class="headerlink" title="3、IO方法举例"></a>3、IO方法举例</h3><pre><code>package com.iotek.file;import java.io.File;import java.io.FileFilter;import java.io.FilenameFilter;import java.io.IOException;public class FileDemo {    public static void main(String[] args) {        File file = new File(&quot;f:\\hehe&quot;);        System.out.println(file.getAbsolutePath());//获得绝对路径        System.out.println(file.getParent());//获得父目录的路径字符串        System.out.println(file.isDirectory());//判断是否为目录        System.out.println(file.isFile());//判断是否为文件        System.out.println(file.exists());//判断是否存在        System.out.println(file.length());//获取长度        File myFile = new File(&quot;f:\\hehe&quot;);        System.out.println(myFile.mkdir());//新建一个目录        File myFile1 = new File(&quot;f:/hehe/hehe.txt&quot;);        try {            System.out.println(myFile1.createNewFile());//新建一个文件        } catch (IOException e) {            e.printStackTrace();        }        /*String[] filesStrings = file.list();//获取当前目录下的所有文件名和目录名        for(String f:filesStrings){            System.out.println(f);        }*/        /*String[] filesString = myFile.list(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名            }        });        for(String f:filesString){            System.out.println(f);        }*/            /*File[] files = myFile.listFiles();        for(File f:files){            System.out.println(f.getName() + &quot;--&quot; + f.length());//打印文件或目录的名字和大小        }*/        /*File[] filesString = myFile.listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名            }        });        for(File f:filesString){            System.out.println(f.getName() + &quot;--&quot; + f.length());        }*/        File[] files = myFile.listFiles(new FileFilter() {            @Override            public boolean accept(File pathname) {                return pathname.getName().endsWith(&quot;.gif&quot;);            }        });        for(File f:files){            System.out.println(f.getName() + &quot;--&quot; + f.length());        }    }}</code></pre><h3 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h3><p>(1)案例说明：给定一个目录要求按层次显示目录结构信息，文件名后面加上*或者\来表示文件夹。</p><p>(2)案例分析：使用递归算法，使用File类中的ListFile方法来遍历文件夹，使用List集合。</p><p>(3)案例实现</p><pre><code>package com.iotek.file;import java.io.File;import java.util.ArrayList;import java.util.List;public class IteratorDirDemo {    public static void main(String[] args) {        IteratorUtil.IteratorDir(new File(&quot;f:/git&quot;));    }}class IteratorUtil{    private static int level = 0;    public static void IteratorDir(File file){        if(null!=file){            /*             * 找到递归的出口，如果是文件或者是空文件夹就触碰到边界             */            if(file.isFile()||file.listFiles().length==0){                return;            }else{                File[] files = file.listFiles();                 files = sortFiles(files);                for(File f:files){                    StringBuilder sBuilder = new StringBuilder();                    sBuilder.append(getTab(level));                    sBuilder.append(f.getName());                    if(!f.isFile()){                        sBuilder.append(&quot;\\&quot;);                    }                    System.out.println(sBuilder.toString());                    if(f.isDirectory()){//如果是文件夹，进入目录遍历，层级自增1                        level++;                        IteratorDir(f);                        level--;//目录自减1，返回上一级目录                    }                }            }        }    }    private static File[] sortFiles(File[] files) {//对File类型的数组进行先目录后文件的排列        List&lt;File&gt; fList = new ArrayList&lt;File&gt;();        for(File f:files){//先存放文件夹            if(f.isDirectory()){                fList.add(f);            }        }        for(File f:files){//再存放文件            if(f.isFile()){                fList.add(f);            }        }        return fList.toArray(new File[fList.size()]);//把集合中的元素转化成指定大小的和指定类型的数组    }    private static String getTab(int level) {//根据层级数来得到制表符的个数        StringBuilder stringBuilder = new StringBuilder();        for(int i=0;i&lt;level;i++){            stringBuilder.append(&quot;\t&quot;);        }        return stringBuilder.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、I-O框架介绍&quot;&gt;&lt;a href=&quot;#1、I-O框架介绍&quot; class=&quot;headerlink&quot; title=&quot;1、I/O框架介绍&quot;&gt;&lt;/a&gt;1、I/O框架介绍&lt;/h3&gt;&lt;p&gt;I/O(Input/Output)是计算机输入/输出的接口。Java的核心库java
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中线程的单例模式</title>
    <link href="http://www.echodemo.cc/2018/07/30/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.echodemo.cc/2018/07/30/Java中线程的单例模式/</id>
    <published>2018-07-29T23:31:12.000Z</published>
    <updated>2018-07-30T00:24:47.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>单例模式有饿汉式和懒汉式之分，懒汉式即延迟初始化单例。在多线程环境下，简单的懒汉式会有线程安全的困扰。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>使用双重检查加锁机制解决线程安全问题。单例模式还有更好的解决方案，即使用静态类方式。</p><h3 id="3、案例实现"><a href="#3、案例实现" class="headerlink" title="3、案例实现"></a>3、案例实现</h3><pre><code>package com.iotek.synchronize;public class SingleTonDemo {    public static void main(String[] args) {        /*SingleTon.getInstance();        SingleTon.getInstance();//单例模式只产生一个对象*/            SThread sThread = new SThread();        Thread t1 = new Thread(sThread);        t1.start();        Thread t2 = new Thread(sThread);        t2.start();    }}class SThread implements Runnable{    @Override    public void run(){        SingleTon.getInstance();    }}class SingleTon{    private static SingleTon singleTon = null;    private SingleTon(){        System.out.println(&quot;单例模式&quot;);    }    public static SingleTon getInstance(){        if(singleTon == null){            synchronized (SingleTon.class) {                if(singleTon == null){                    //第一个线程进来                    //第二个线程也进来了                    singleTon = new SingleTon();                }            }        }        return singleTon;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;单例模式有饿汉式和懒汉式之分，懒汉式即延迟初始化单例。在多线程环境下，简单的懒汉式会有线程安全的困扰。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程通信</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的线程通信/</id>
    <published>2018-07-28T09:06:29.000Z</published>
    <updated>2018-07-28T09:07:15.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、线程通信相关方法"><a href="#1、线程通信相关方法" class="headerlink" title="1、线程通信相关方法"></a>1、线程通信相关方法</h3><p>Java提供了三个重要的方法巧妙地解决线程间的通信问题。这三个方法分别是：wait()、notify()和notifyAll()。</p><p>(1)调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。</p><p>(2)调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的进程，并使该线程退出等待队列，进入可运行态。</p><p>(3)调用notifyAll()方法可以使所有正在等待队列中共享同一资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><pre><code>package com.iotek.synchronize;import java.util.LinkedList;public class ProductorConsumerDemo {    public static void main(String[] args) {        Basket basket = new Basket();        Productor productor = new Productor(basket);        Consumer consumer = new Consumer(basket);        productor.start();        consumer .start();    }}class Apple{//苹果类    private int id;    public Apple(int id){        this.id = id;    }    @Override    public String toString() {        return &quot;Apple:&quot; + (id+1);    }}class Basket{//篮子类    private LinkedList&lt;Apple&gt; basket = new LinkedList&lt;Apple&gt;();    public synchronized void pushApple(){//放四轮苹果        for(int i=0;i&lt;20;i++){            Apple apple = new Apple(i);            push(apple);        }    }    public synchronized void popApple(){//取四轮苹果        for(int i=0;i&lt;20;i++){            pop();        }    }    private void push(Apple apple){//向篮子放苹果，当存放了五个苹果就等待并通知消费者来取苹果。        if(basket.size()==5){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }//等待并释放当前对象的锁        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }        basket.addFirst(apple);//每隔500毫秒放一个苹果进篮子里面        System.out.println(&quot;存放&quot;+apple.toString());        notify();//通知消费者来消费    }    private void pop(){//向篮子取苹果，当篮子当中苹果数为零的时候，就等待并通知生产者来生产。        if(basket.size()==0){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }//等待并释放当前对象的锁        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }        Apple apple = basket.removeFirst();//每隔500毫秒从篮子里面取一个苹果        System.out.println(&quot;吃掉&quot;+apple.toString());        notify();//通知生产者来生产    }}class Productor extends Thread{//生产者    private Basket basket = null;    public Productor(Basket basket) {        super();        this.basket = basket;    }    @Override    public void run(){        basket.pushApple();    }}class Consumer extends Thread{//消费者    private Basket basket = null;    public Consumer(Basket basket) {        super();        this.basket = basket;    }    @Override    public void run(){        basket.popApple();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、线程通信相关方法&quot;&gt;&lt;a href=&quot;#1、线程通信相关方法&quot; class=&quot;headerlink&quot; title=&quot;1、线程通信相关方法&quot;&gt;&lt;/a&gt;1、线程通信相关方法&lt;/h3&gt;&lt;p&gt;Java提供了三个重要的方法巧妙地解决线程间的通信问题。这三个方法分别是：w
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的多线程编程</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的多线程编程/</id>
    <published>2018-07-28T03:41:33.000Z</published>
    <updated>2018-07-28T08:32:26.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、线程同步"><a href="#1、线程同步" class="headerlink" title="1、线程同步"></a>1、线程同步</h3><p>线程同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。它是保证多线程安全访问竞争资源的一种手段。</p><p>(1)同步和锁：Java中的每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例(this实例)有关的锁；当程序运行到synchronized同步代码块时，自动获得锁定对象的锁。一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放锁。这也意味着任何其他线程都不能进入synchronized方法或者代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或者代码块。</p><p>(2)对于同步，一般而言在Java中需要完成两个操作：把竞争访问的资源表示为private；同步那些访问资源的代码，使用synchronized关键字修饰方法或者代码块。当synchronized方法执行完或者发生异常时会自动释放锁。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><p>(1)案例介绍</p><p>某银行账号上有500元存款，一个人拿着存折去取钱，同时另一个人拿着银行卡去ATM机上取钱，各自取钱400元。要求取钱的过程中不能出现资源竞争：比如400元被取出两次、银行卡的账目不能小于0等。</p><p>(2)案例实现</p><pre><code>package com.iotek.synchronize;public class BankDemo {    public static void main(String[] args) {        Bank bank1 = new Bank();        BankThread bankThread = new BankThread(bank1);        bankThread.start();//柜台取钱        BankThread bankThread2 = new BankThread(bank1);        bankThread2.start();//ATM机取钱    }}class Bank{    private int money = 500;    private Object object = new Object();//锁这个对象也可以实现，因为任何对象都只有一个锁。    /*取钱的方法，返回取钱的数目    当一个线程去调用同步方法的时候，这个线程就调用了当前对象的锁。其他线程则等待*/    public int getMoney(int number) throws InterruptedException{        synchronized(this){            if(number &lt; 0)                return -1;            else if(money &lt; 0)                return -2;            else if(number - money &gt;0)                return -3;            else{                Thread.sleep(1000);                money-=number;                System.out.println(&quot;账户余额：&quot; + money);            }            return number;        }    }}class BankThread extends Thread{    private Bank bank = null;    public BankThread(Bank bank){        this.bank = bank;    }    @Override    public void run(){        try {            System.out.println(&quot;取钱：&quot;+bank.getMoney(400));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="3、同步产生死锁"><a href="#3、同步产生死锁" class="headerlink" title="3、同步产生死锁"></a>3、同步产生死锁</h3><p>(1)同步产生死锁的原因：当一个线程已经获取了对象1的锁，同时又想获取对象二的锁。而此时另一个线程当前已经持有了对象二的锁，而又想获取对象一的锁。这中相互等待对方释放锁的过程，会导致“死锁”。</p><p>(2)死锁举例</p><pre><code>package com.iotek.synchronize;public class DieThreadDemo {    public static void main(String[] args) throws InterruptedException {        Example example = new Example();        DieThread thread1 = new DieThread(example);        thread1.start();        DieThread1 thread2 = new DieThread1(example);        thread2.start();    }}class Example{    private Object obj1 = new Object();    private Object obj2 = new Object();    public void method1() throws InterruptedException{//先占用对象1，再请求对象2.        synchronized (obj1) {            Thread.sleep(1000);            synchronized (obj2) {                System.out.println(&quot;method1&quot;);            }        }    }    public void method2() throws InterruptedException{//先占用对象2，再请求对象1.        synchronized (obj2) {            Thread.sleep(1000);            synchronized (obj1) {                System.out.println(&quot;method2&quot;);            }        }    }}class DieThread extends Thread{//死亡进程1    private Example example = null;    public DieThread(Example example) {        super();        this.example = example;    }    @Override    public void run(){        try {            example.method1();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}class DieThread1 extends Thread{//死亡进程2    private Example example = null;    public DieThread1(Example example) {        super();        this.example = example;    }    @Override    public void run(){        try {            example.method2();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、线程同步&quot;&gt;&lt;a href=&quot;#1、线程同步&quot; class=&quot;headerlink&quot; title=&quot;1、线程同步&quot;&gt;&lt;/a&gt;1、线程同步&lt;/h3&gt;&lt;p&gt;线程同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。它是保证多线程安全访问竞争资源的一种手段。&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中线程的生命周期</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中线程的生命周期/</id>
    <published>2018-07-28T01:01:21.000Z</published>
    <updated>2018-07-28T01:02:48.356Z</updated>
    
    <content type="html"><![CDATA[<p>与人的生老病死一样，线程也同样要经历新建、就绪、运行、阻塞和死亡五种不同的状态。这五种状态都可以通过Thread类中的方法进行控制。</p><p>(1)新建状态(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。线程处于创建状态时，可通过Thread类的方法来设置线程各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</p><p>(2)就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</p><p>(3)运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占用CPU并转为运行状态。此时，系统真正执行线程的run()方法。可以通过Thread类的isAlive()方法来判断线程是否处于就绪状态：当线程处于就绪/运行状态时，isAlive()方法返回true；否则的话，线程可能处于阻塞状态也可能是处于停止状态。</p><p>(4)阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞状态。包括以下原因：</p><pre><code>a、当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集(Blocked Pool)内，等待超时而自动苏醒。b、当多个线程试图进入某个同步区域(synchronized)时，没能进入该同步区域的线程会被置入锁定集(Lock Pool)，直到获得该同步区域的锁，进入就绪状态。c、当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集(Wait Pool)中，直到执行了该对象的notify()方法，wait()/notify()方法的执行要求线程首先获取到该对象的锁。</code></pre><p>(5)死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。</p><p>(6)终止线程的三种方法</p><pre><code>a、使用退出标志，使线程正常退出，也就是run()方法完成后线程终止，推荐使用。b、使用stop()方法强行终止线程(这个方法不推荐使用，因为stop()和suspend()、resume()一样，也可能发生不可预料的后果)。c、使用interrupt()方法中断线程。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;与人的生老病死一样，线程也同样要经历新建、就绪、运行、阻塞和死亡五种不同的状态。这五种状态都可以通过Thread类中的方法进行控制。&lt;/p&gt;
&lt;p&gt;(1)新建状态(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程模型</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的线程模型/</id>
    <published>2018-07-27T16:04:49.000Z</published>
    <updated>2018-07-27T16:17:45.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念了解"><a href="#1、概念了解" class="headerlink" title="1、概念了解"></a>1、概念了解</h3><p>(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。</p><p>(2)进程是运行中的程序，是动态的概念。每个进程有独立的资源空间。</p><p>(3)线程是轻量级的进程，是程序执行流的最小单位，是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。</p><p>(4)多线程是在单个程序中可以同时运行多个不同的线程执行不同的任务。一个进程可以包含一个或者多个线程。一个程序实现多个代码同时交替运行就需要产生多个线程。线程本身不拥有系统资源，与同属一个进程的其他线程共享所在进程所拥有的资源。同一进程中的多个线程之间可以并发执行。CPU会随机抽出时间，让我们的程序一会做这件事，一会做另外一件事情。多线程的目的在于，最大限度地利用CPU资源，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p><p>(5)Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。Java是纯面向对象语言，Java的线程模型也是面向对象的。</p><p>(6)创建线程的方式有两种：第一，通过继承Thread类创建线程，普通Java类如继承自Thread类，就成为一个线程类，并可通过该类的start方法来启动线程，执行线程代码。Thread子类可直接实例化，但在子类中必须覆盖run方法才能真正运行线程的代码。第二，通过实现Runnable接口创建线程，实现Runnable接口的类必须借助Thread类才能创建线程(本质上还是通过继承Thread来实现)。通过Runnable接口创建线程分为两步：创建实现Runnable接口的类的实例；创建一个Thread类对象，将第一步实例化得到的Runnable对象作为参数传入Thread类的构造方法。最后通过Thread类的start方法启动线程。</p><h3 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h3><p>(1)举例一：通过继承Thread类创建线程</p><pre><code>package com.iotek.threadtest;public class HelloThreadDemo {    public static void main(String[] args) {        HelloThread h1HelloThread = new HelloThread(&quot;A&quot;);        //h1HelloThread.setName(&quot;线程1&quot;);//自定义线程名字        h1HelloThread.start();//启动线程就会调用run方法        HelloThread h2HelloThread = new HelloThread(&quot;B&quot;);        //h1HelloThread.setName(&quot;线程2&quot;);        h2HelloThread.start();    }}class HelloThread extends Thread{    public HelloThread(String name) {        super(name);    }    @Override    public void run(){        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(2)举例二：通过实现Runnable接口创建线程</p><pre><code>package com.iotek.threadtest;public class HelloRunnableDemo {    public static void main(String[] args) {        HelloRunnable helloRunnable = new HelloRunnable();        Thread thread = new Thread(helloRunnable,&quot;A&quot;);        thread.start();        Thread thread2 = new Thread(helloRunnable,&quot;B&quot;);        thread2.start();    }}/** * Runnable接口优于Thread的地方 * 1、避免单继承的局限，一个类可以实现多个接口，但只能继承一个类。 * 2、适合资源的共享。 * @author 紫苏半夏 * */class HelloRunnable implements Runnable{    @Override    public void run() {        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(3)举例三：Runnable接口适合资源的共享</p><pre><code>package com.iotek.threadtest;public class SharedDataThreadDemo {    public static void main(String[] args) {        /*TicketThread ticketThread1 = new TicketThread(&quot;一号窗口&quot;);        ticketThread1.start();        TicketThread ticketThread2 = new TicketThread(&quot;二号窗口&quot;);        ticketThread2.start();*/        TicketRunnable ticketRunnable = new TicketRunnable();        Thread thread = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread.start();        Thread thread1 = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread1.start();    }}/*class TicketThread extends Thread{    private int ticket = 5;    public TicketThread(String name){        super(name);    }    @Override    public void run(){        while (true) {            System.out.println(this.getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}*/class TicketRunnable implements Runnable{    private int ticket = 5;    @Override    public void run(){        while (true) {            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、概念了解&quot;&gt;&lt;a href=&quot;#1、概念了解&quot; class=&quot;headerlink&quot; title=&quot;1、概念了解&quot;&gt;&lt;/a&gt;1、概念了解&lt;/h3&gt;&lt;p&gt;(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。&lt;/p&gt;
&lt;p&gt;(2)进程是运行中的程序，是动态的概
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(二)</title>
    <link href="http://www.echodemo.cc/2018/07/26/Java%E5%8F%8D%E5%B0%84API(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/07/26/Java反射API(二)/</id>
    <published>2018-07-26T09:59:35.000Z</published>
    <updated>2018-07-27T00:26:16.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student对象。通过反射复制此Student对象。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>通过反射机制来获取类的属性和方法。通过反射来生成对象，并通过反射来调用其set方法来对属性进行赋值以达到复制对象的目的。最后对复制成功的对象信息进行打印。</p><h3 id="3、方案实施"><a href="#3、方案实施" class="headerlink" title="3、方案实施"></a>3、方案实施</h3><pre><code>(1)创建Student类。(2)创建一个Student对象。(3)获取Student对象所属类型的Class对象。(4)通过调用class.newInstance方法来构建一个目标对象。(5)获取class对象中的get和set方法。(6)调用源对象的get方法获取属性值。(7)调用目标对象的set方法来设置属性值。(8)打印目标对象的数据。</code></pre><h3 id="4、案例实现"><a href="#4、案例实现" class="headerlink" title="4、案例实现"></a>4、案例实现</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import javax.activation.FileDataSource;import org.omg.CORBA.portable.ValueBase;public class ReflectionExampleDemo {    public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        Student student = new Student(1, &quot;EchoDemo&quot;, 22);        Student student2 = (Student) ObjectCopyUtil.copyObj(student);        System.out.println(&quot;复制对象成功&quot;);        System.out.println(student2.toString());    }}/** * 这是一个拷贝对象的工具类，内部提供了一个拷贝对象的方法，接收源对象。 * @author 紫苏半夏 * */class ObjectCopyUtil{    public static Object copyObj(Object obj) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        //获取student对象所对应类型的Class对象(也就是Student类所对应的对象)        Class&lt;?&gt; classType = obj.getClass();        //通过class对象的newInstance方法来构建一个目标对象        Object objCopy = classType.newInstance();        //获取Class对象的get和set方法        for(Field field : classType.getDeclaredFields()){            /*//得到属性所对应的get和set方法            String getMethodName = &quot;get&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            String setMethodName = &quot;set&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            //调用源对象的get方法获取属性值            Method getMethod = classType.getDeclaredMethod(getMethodName, new Class[]{});            Object value = getMethod.invoke(obj, new Object[]{});            //调用源对象的set方法给属性赋值            Method setMethod = classType.getDeclaredMethod(setMethodName, new Class[]{field.getType()});            setMethod.invoke(obj, new Object[]{value});*/            //直接获取源对象的值            field.setAccessible(true);            Object value = field.get(obj);            field.set(objCopy, value);        }        return objCopy;    }}//声明一个学生类class Student{    private int id;    private String name;    private int age;    public Student(){    }    public Student(int id, String name, int age) {        super();        this.id = id;        this.name = name;        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(一)</title>
    <link href="http://www.echodemo.cc/2018/07/24/Java%E5%8F%8D%E5%B0%84API(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/07/24/Java反射API(一)/</id>
    <published>2018-07-24T10:18:29.000Z</published>
    <updated>2018-07-26T10:04:53.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-lang-reflect库"><a href="#1、Java-lang-reflect库" class="headerlink" title="1、Java.lang.reflect库"></a>1、Java.lang.reflect库</h3><p>Class类和java.lang.reflect类库一起对反射的概念进行支持。在java.lang包下：Class<t>:表示一个正在运行的Java应用程序中的类和接口，是Reflection的起源。在java.lang.reflect包下：Field类：代表类的成员变量(也称之为类的属性)；Method类：代表类的方法；Constructor类：代表类的构造方法；Array类：提供动态创建数组，以及访问数组的元素的静态方法。</t></p><h3 id="2、通过反射实例化对象"><a href="#2、通过反射实例化对象" class="headerlink" title="2、通过反射实例化对象"></a>2、通过反射实例化对象</h3><p>(1)平常情况我们通过new Object来生成一个类的实例，但有时候我们没法直接new，只能通过反射动态生成。</p><p>(2)实例化无参构造函数的对象，两种方式：</p><pre><code>Class.newInstace();Class.getConstructor(new Class[]{}).newInstance(new Object[]{});</code></pre><p>(3)实例化带参构造函数的对象</p><pre><code>Class.getConstructor(Class&lt;?&gt;...parameterTypes).newInstance(Object...initargs);</code></pre><h3 id="3、通过反射获取并调用方法"><a href="#3、通过反射获取并调用方法" class="headerlink" title="3、通过反射获取并调用方法"></a>3、通过反射获取并调用方法</h3><p>(1)获得当前类以及超类的public Method</p><pre><code>Method[] arrMethods=classType.getMethods();</code></pre><p>(2)获得当前类申明的所有Method</p><pre><code>Method[] arrMethods=classTyep.getDeclaredMethods();</code></pre><p>(3)获得当前类以及超类指定的public Method</p><pre><code>Method method=classType.getMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(4)获得当前类申明的指定的Method</p><pre><code>Method method=classType.getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(5)通过反射动态运行指定Method</p><pre><code>Object  obj=method.invoke(Object obj,Object...args);</code></pre><h3 id="4、通过反射获取并调用属性"><a href="#4、通过反射获取并调用属性" class="headerlink" title="4、通过反射获取并调用属性"></a>4、通过反射获取并调用属性</h3><p>(1)获得当前类以及超类的public Field</p><pre><code>Field[] arrFields=classType.getFields();</code></pre><p>(2)获得当前类申明的所有Field</p><pre><code>Field[] arrFields=classFields=classType.getDeclaredFields();</code></pre><p>(3)获得当前类以及超类指定的public Field</p><pre><code>Field field=classType.getField(String name);</code></pre><p>(4)获得当前类申明的指定的Field</p><pre><code>Field field=classType.getDeclaredField(String name);</code></pre><p>(5)通过反射动态设定Field的值</p><pre><code>field.set(Object obj,Object value);</code></pre><p>(6)通过反射动态获取Field的值</p><pre><code>Object obj=field.get(Object obj);</code></pre><h3 id="5、举例"><a href="#5、举例" class="headerlink" title="5、举例"></a>5、举例</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionAPIDemo {    public static void main(String[] args) throws Exception{        /**         * 只要用到反射，先获得Class对象。没有方法能够获得当前类的超类的private方法和属性，         * 你必须通过getSuperclass()找到超类以后再去尝试获得。通常情况下，即使是当前类，         * private属性或者方法也是不能访问的，你需要设置压制权限setAccessible(true)来         * 取得private的访问权。但这样的话，就破坏了面向对象的规则，所以除非万不得已，尽量少用。         */        //获取Emploee这个类所关联的class对象        Class&lt;?&gt; classType=Class.forName(&quot;com.iotek.reflect.Emploee&quot;);        //通过反射机制来构造一个Emploee的实例对象(默认调用无参的构造方法)        Emploee emploee=(Emploee)classType.newInstance();        //调用指定的构造方法来实例化对象        Constructor&lt;?&gt; constructor=classType.getConstructor(new Class[]{});        Emploee emploee2=(Emploee)constructor.newInstance(new Object[]{});        System.out.println(emploee);        System.out.println(emploee2);        //调用指定的构造方法来实例化对象(调用带参数的构造方法)        Constructor&lt;?&gt; constructor1=classType.getConstructor(new Class[]{String.class,int.class});        Emploee emploee3=(Emploee)constructor1.newInstance(new Object[]{&quot;zhangsan&quot;,30});        System.out.println(emploee3);        //获取class对象指定的方法，包括私有的        Method method=classType.getDeclaredMethod(&quot;toString&quot;, new Class[]{});        System.out.println(method.getName());        //方法的调用        String desc=(String) method.invoke(emploee, new Object[]{});        System.out.println(desc);        //获取class对象指定的所有方法，包括私有的(私有的是默认不能被访问的)        Method[] methods = classType.getDeclaredMethods();        for(Method method2 : methods){            method2.setAccessible(true);//私有的可以访问了            System.out.println(method2.getName()+&quot;--&gt;&quot;+method2.getModifiers());        }        //获取Class对象所指定的属性，包括私有的(私有的默认是不能被访问的)        Field field = classType.getDeclaredField(&quot;nameString&quot;);        field.setAccessible(true);//可访问了        field.set(emploee, &quot;李四&quot;);        System.out.println(field.get(emploee));    }}class Emploee{    private String nameString;    private int age;    public Emploee(){        System.out.println(&quot;无参构造法方法&quot;);    }    public Emploee(String nameString, int age) {        super();        this.nameString = nameString;        this.age = age;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Emploee [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="6、使用反射机制来创建一维数组和二维数组"><a href="#6、使用反射机制来创建一维数组和二维数组" class="headerlink" title="6、使用反射机制来创建一维数组和二维数组"></a>6、使用反射机制来创建一维数组和二维数组</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Array;public class ReflectionArrayDemo {    public static void main(String[] args) throws ClassNotFoundException {        //创建一个一维数组(String)        Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);        Object obj = Array.newInstance(classType,5);        Array.set(obj, 3, &quot;abc&quot;);        System.out.println(Array.get(obj, 3));        //创建二维数组(3行3列)        int[] dimens={3,3};        Object obj1 = Array.newInstance(int.class, dimens);        Object obj2 = Array.get(obj1, 2);//获取第三行(它是一个一维数组)        Array.setInt(obj2, 2, 5);//给指定位置赋值        int[][] obj3 = (int[][])obj1;        System.out.println(obj3[2][2]);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Java-lang-reflect库&quot;&gt;&lt;a href=&quot;#1、Java-lang-reflect库&quot; class=&quot;headerlink&quot; title=&quot;1、Java.lang.reflect库&quot;&gt;&lt;/a&gt;1、Java.lang.reflect库&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的反射</title>
    <link href="http://www.echodemo.cc/2018/07/23/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2018/07/23/Java中的反射/</id>
    <published>2018-07-23T13:22:33.000Z</published>
    <updated>2018-07-23T13:24:10.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h3><p>(1)反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>(2)JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。包括其访问修饰符、父类、实现的接口、属性和方法的所有信息，并可在运行时创建对象、修改属性(包括私有的)、调用方法(包括私有的)。</p><h3 id="2、反射机制"><a href="#2、反射机制" class="headerlink" title="2、反射机制"></a>2、反射机制</h3><p>(1)直接创建对象不就行了吗？为什么要用反射机制？这里涉及动态和静态的概念。</p><pre><code>静态编译：在编译时确定类型，绑定对象，如：Student stu=new Student(&quot;zhangsan&quot;,30);动态编译：在运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现类多态的应用，用以降低类之间的耦合性。Class.forName(&quot;com.mysql.Driver.class&quot;).newInstance();</code></pre><p>(2)优缺点</p><pre><code>优点：反射机制可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中缺点：反射机制对性能有影响，使用反射机制基本上是一种解释操作，这类操作总是慢于直接执行的相同操作。</code></pre><p>(3)功能</p><pre><code>a、在运行时判断任意一个对象所属的类。b、在运行时构造任意一个类的对象。c、在运行时判断任意一个类所具有的成员变量和方法。d、在运行时调用任意一个对象的方法。</code></pre><h3 id="3、Class对象"><a href="#3、Class对象" class="headerlink" title="3、Class对象"></a>3、Class对象</h3><p>Class对象是Reflection故事的起源。要想操纵类中的属性和方法，都必须从获取Class对象开始。</p><p>(1)类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译一个新类，就会产生与之对应的一个Class对象。</p><p>(2)Class类没有公共构造方法。Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的方法自动构造的，因此不能显示地声明一个Class对象。</p><p>(3)获取Class对象的方式</p><p><img src="/images/2018/7/5.jpg" alt="&quot;获取class对象的方式&quot;"></p><p>(4)举例</p><pre><code>package com.iotek.classtype;public class ClassDemo {    public static void main(String[] args) {        //通过对象名.getClass()        Employee employee=new Employee(&quot;zhangsan&quot;, 30);        Class&lt;?&gt; classTypeClass=employee.getClass();//问号代表可以接收任意类型的Class对象        System.out.println(classTypeClass.getName());//获取Class对象的名字        System.out.println(classTypeClass.getSuperclass().getName());//获取父类的Class对象的名字        //类名.class        Class&lt;?&gt; classTypeClass2=Employee.class;        System.out.println(classTypeClass2.getName());//获取Class对象的名字        System.out.println(classTypeClass2.getSuperclass().getName());//获取父类的Class对象的名字        //使用Class.forName()        try {            Class&lt;?&gt; classTypeClass3=Class.forName(&quot;com.iotek.classtype.Employee&quot;);            System.out.println(classTypeClass3.getName());//获取Class对象的名字            System.out.println(classTypeClass3.getSuperclass().getName());//获取父类的Class对象的名字        } catch (Exception e) {            e.printStackTrace();        }        //获取基本数据类型的Class对象(基本数据类型没有父类)        Class&lt;?&gt; classTypeClass4=int.class;        System.out.println(classTypeClass4.getName());//获取Class对象的名字        //通过基本数据类型的包装类来获取对应的基本数据类型所对应的Class对象        Class&lt;?&gt; classTypeClass5=Double.TYPE;        System.out.println(classTypeClass5.getName());//获取Class对象的名字        //获取基本数据类型的包装类的Class对象        Class&lt;?&gt; classTypeClass6=Double.class;        System.out.println(classTypeClass6.getName());//获取Class对象的名字        System.out.println(classTypeClass6.getSuperclass().getName());//获取父类的Class对象的名字    }}class Employee{    private String nameString;    private int age;    public Employee(String nameString, int age) {        super();        this.nameString = nameString;        this.age = age;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、反射概述&quot;&gt;&lt;a href=&quot;#1、反射概述&quot; class=&quot;headerlink&quot; title=&quot;1、反射概述&quot;&gt;&lt;/a&gt;1、反射概述&lt;/h3&gt;&lt;p&gt;(1)反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的观察者模式和Swing</title>
    <link href="http://www.echodemo.cc/2018/07/23/Java%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8CSwing/"/>
    <id>http://www.echodemo.cc/2018/07/23/Java中的观察者模式和Swing/</id>
    <published>2018-07-23T11:20:45.000Z</published>
    <updated>2018-07-23T12:17:24.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、观察者模式定义"><a href="#1、观察者模式定义" class="headerlink" title="1、观察者模式定义"></a>1、观察者模式定义</h3><p>对象间的一种一对多的依赖关系。当一方的对象改变状态时，所有的依赖者都会得到通知并被自动更新。也称之为依赖(Dependents)、发布-订阅(Publish-Subscribe)模式。</p><h3 id="2、观察者模式意图"><a href="#2、观察者模式意图" class="headerlink" title="2、观察者模式意图"></a>2、观察者模式意图</h3><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使得各个类紧密耦合，导致可重用性的降低。观察者模式是使得任意数目的观察者不必知道彼此的存在，且主题发生变化时都可以得到主题的通知，而同步改变状态。是一种松散耦合，具有更好的可重用性。</p><h3 id="3、观察者模式组成"><a href="#3、观察者模式组成" class="headerlink" title="3、观察者模式组成"></a>3、观察者模式组成</h3><p><img src="/images/2018/7/3.jpg" alt="&quot;观察者模式&quot;"></p><pre><code>a、主题(Subject)：知道它的观察者(观察者必须实现特定接口)，可以有任意多观察者。提供注册和注销观察者的接口。b、观察者(Observer)：为那些在主题发生变化时需要获得通知的对象定义一个更新(update)接口。c、ConcreteSubject(具体主题)：保持实际状态数据，当状态发生变化时通知各观察者。d、ConcreteObserver(具体观察者)：维持一个指向具体主题对象的引用。</code></pre><h3 id="4、观察者模式示例"><a href="#4、观察者模式示例" class="headerlink" title="4、观察者模式示例"></a>4、观察者模式示例</h3><p>(1)男朋友接口</p><pre><code>package com.iotek.observer;public interface IBoyFriend {    void update(String msg);//更新信息}</code></pre><p>(2)女生接口</p><pre><code>package com.iotek.observer;public interface IGirl {    void attachBoyFriend(IBoyFriend boyFriend);//注册一个男朋友    void deleteBoyFriend(IBoyFriend boyFriend);//删除一个男朋友    void notifyBoyFriend();//通知所有男朋友}</code></pre><p>(3)女生实现类</p><pre><code>package com.iotek.observer;import java.util.ArrayList;import java.util.List;public class PrettyGirl implements IGirl {    private List&lt;IBoyFriend&gt; boyList=new ArrayList&lt;IBoyFriend&gt;();    private String msg=&quot;我生病了&quot;;    @Override    public void attachBoyFriend(IBoyFriend boyFriend) {        boyList.add(boyFriend);    }    @Override    public void deleteBoyFriend(IBoyFriend boyFriend) {        if(boyList.size()&gt;0){            boyList.remove(boyFriend);        }    }    @Override    public void notifyBoyFriend() {        for(int i=0;i&lt;boyList.size();i++){            IBoyFriend boyFriend=boyList.get(i);            boyFriend.update(msg);        }    }}</code></pre><p>(4)三个男朋友实现类</p><pre><code>package com.iotek.observer;public class LiBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;我现在没空&quot;);        }    }}package com.iotek.observer;public class WangBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;和我无关，我不认识你！&quot;);        }    }}package com.iotek.observer;public class ZhangBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;我马上过来&quot;);        }    }}</code></pre><p>(5)测试类</p><pre><code>package com.iotek.observer;public class Test {    public static void main(String[] args) {        //实例化三个男朋友        ZhangBoyFriend zhnagBoyFriend=new ZhangBoyFriend();        LiBoyFriend liBoyFriend=new LiBoyFriend();        WangBoyFriend wangBoyFriend=new WangBoyFriend();        //实例化女生类，并且添加三个男朋友，删除一个男朋友        PrettyGirl girl=new PrettyGirl();        girl.attachBoyFriend(wangBoyFriend);        girl.attachBoyFriend(zhnagBoyFriend);        girl.attachBoyFriend(liBoyFriend);        girl.deleteBoyFriend(wangBoyFriend);        //女生发出信息        girl.notifyBoyFriend();    }}</code></pre><h3 id="5、Swing介绍"><a href="#5、Swing介绍" class="headerlink" title="5、Swing介绍"></a>5、Swing介绍</h3><p>(1)Java1.2引入称为Swing的新的GUI组件库。它是一个用于开发Java应用程序用户界面的开发工具包。</p><p>(2)Swing控件是用纯Java语言编写而成的，不依赖于本地操作系统的GUI，Swing控件可以跨平台运行。独立于本地平台的Swing控件被称为轻量级控件，而依赖于本地的AWT控件被称为重量级控件。</p><p>(3)它以抽象窗口工具包(AWT)为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。</p><p>(4)工具包中所有的包都是以Swing作为名称，例如：javax.swing，javax.swing.event。</p><h3 id="6、Swing框架"><a href="#6、Swing框架" class="headerlink" title="6、Swing框架"></a>6、Swing框架</h3><p><img src="/images/2018/7/4.jpg" alt="&quot;观察者模式&quot;"></p><h3 id="7、开发Swing图形界面主要步骤"><a href="#7、开发Swing图形界面主要步骤" class="headerlink" title="7、开发Swing图形界面主要步骤"></a>7、开发Swing图形界面主要步骤</h3><pre><code>导入Swing包--&gt;设置顶层容器--&gt;设置按钮和标签等Swing组件--&gt;将组件添加至容器中--&gt;处理事件。</code></pre><h3 id="8、简单示例"><a href="#8、简单示例" class="headerlink" title="8、简单示例"></a>8、简单示例</h3><pre><code>package com.iotek.observer;import javax.swing.JFrame;import javax.swing.JLabel;public class SwingTest {    public static void main(String[] args) {        JFrame frame=new JFrame(&quot;Hello Swing&quot;);//设置一个顶级容器        JLabel label=new JLabel(&quot;你好，Swing&quot;);//创建一个Swing组件        frame.getContentPane().add(label);//将组件添加到容器内容窗格        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//单击关闭按钮时可以关闭窗口        frame.setSize(300,200);        frame.setVisible(true);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、观察者模式定义&quot;&gt;&lt;a href=&quot;#1、观察者模式定义&quot; class=&quot;headerlink&quot; title=&quot;1、观察者模式定义&quot;&gt;&lt;/a&gt;1、观察者模式定义&lt;/h3&gt;&lt;p&gt;对象间的一种一对多的依赖关系。当一方的对象改变状态时，所有的依赖者都会得到通知并被自
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的AWT事件处理</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT事件处理/</id>
    <published>2018-07-22T14:57:37.000Z</published>
    <updated>2018-07-22T15:05:46.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、AWT事件处理基本概念"><a href="#1、AWT事件处理基本概念" class="headerlink" title="1、AWT事件处理基本概念"></a>1、AWT事件处理基本概念</h3><p>AWT事件的处理过程中，主要涉及三类对象。</p><p>(1)Event(事件)：用户对组件的一个操作，称之为一个事件，以类的形式出现，例如，键盘操作对应的事件类是KeyEvent。其实例在该事件发生时由系统自动产生。每一种事件都对应专门的监听者。</p><p>(2)Event Source(事件源)：事件发生的场所，通常就是各个组件，例如按钮Button。事件源自己不处理事件，而是把在其自身所有可能发生的事件委托给事件监听器来处理。</p><p>(3)Event Monitor(事件监听器)：接收事件对象并对其进行处理的类的对象，通常其中某个成员方法对事件进行相应的处理。</p><h3 id="2、事件"><a href="#2、事件" class="headerlink" title="2、事件"></a>2、事件</h3><p>AWT的相关事件继承于java.awt.AWTEvent类，这些事件分为两大类：低级事件和高级事件。</p><p>(1)低级事件是指基于<strong>组件和容器</strong>的事件，当一个组件发生事件，如鼠标进入、点击、拖放或组件的窗口开关等时，触发了组件事件。如：组件事件、容器事件、窗口事件、焦点事件、键盘事件、鼠标事件。</p><p>(2)高级事件是基于<strong>语义</strong>的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类。比如，按下按钮和在TextField中按Enter键会触发ActionEvent事件，滑动滚动条会触发AdjustmentEvent事件，选中项目列表的某一条会触发ItemEvent事件。</p><h3 id="3、事件监听器"><a href="#3、事件监听器" class="headerlink" title="3、事件监听器"></a>3、事件监听器</h3><p>事件监听器通常是一个类，该类必须实现与该事件类型相对应的接口。对应的接口被称之为事件监听器接口。事件监听器接口类的名称与事件类的名称相对应，例如：MouseEvent事件类的监听器接口名为MouseListener。</p><h3 id="4、事件适配器类"><a href="#4、事件适配器类" class="headerlink" title="4、事件适配器类"></a>4、事件适配器类</h3><p>Java语言为一些事件监听提供了适配器(Adapter)。我们可以通过继承事件对应的Adapter类，重写所需要的方法，无关的方法则不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序代码。java.awt.event包中定义的事件适配器类包括以下7个：MouseAdapter(鼠标适配器)、MouseMotionAdapter(鼠标运动适配器)、KeyAdapter(键盘适配器)、WindowAdapter(窗口适配器)、ComponentAdapter(组件适配器)、ComtainerAdapter(容器适配器)、FocusAdapter(焦点适配器)。</p><h3 id="5、示例"><a href="#5、示例" class="headerlink" title="5、示例"></a>5、示例</h3><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class ListenerDemo {    public static void main(String[] args) {        MyFrame7 frame7=new MyFrame7(&quot;Listener&quot;);    }}class MyFrame7 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame7(String title){        super(title);        init();        registerListener();    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }    private void registerListener(){        /*         * 产生一个事件监听器对象，给四个按钮注册同一个事件监听器。         */        BtnListener btnListener=new BtnListener();        btn_1.addActionListener(btnListener);        btn_2.addActionListener(btnListener);        btn_3.addActionListener(btnListener);        btn_4.addActionListener(btnListener);        lb_1.addMouseMotionListener(new MouseMotionAdapter() {            @Override            public void mouseMoved(MouseEvent e) {                lb_1.setText(e.getX()+&quot;:&quot;+e.getY());            }        });        lb_2.addMouseListener(new MouseAdapter() {            @Override            public void mouseExited(MouseEvent e) {                System.out.println(&quot;鼠标移出&quot;);            }            @Override            public void mouseEntered(MouseEvent e) {                System.out.println(&quot;鼠标移入&quot;);            }        });        tf_contentField.addKeyListener(new KeyAdapter() {            @Override            public void keyPressed(KeyEvent e) {                System.out.println(e.getKeyChar());            }        });        this.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });    }    class BtnListener implements ActionListener{        @Override        public void actionPerformed(ActionEvent e) {            /*System.out.println(e.getActionCommand());            System.out.println(e.getSource());*/            Object object=e.getSource();//获得当前点击的事件源            if(object==btn_1){                cardLayout.first(card_panel);//获得第一张            }else if(object==btn_2){                cardLayout.previous(card_panel);//获得前一张            }else if(object==btn_3){                cardLayout.next(card_panel);//获得下一张            }else{                cardLayout.last(card_panel);//获得最后一张            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;a href=&quot;#1、AWT事件处理基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;/a&gt;1、AWT事件处理基本概念&lt;/h3&gt;&lt;p&gt;AWT事件的处理过程中，主要涉及三类对象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的布局管理器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的布局管理器/</id>
    <published>2018-07-22T05:30:27.000Z</published>
    <updated>2018-07-22T06:26:27.868Z</updated>
    
    <content type="html"><![CDATA[<p>1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、<br>GridBagLayout网格包布局管理器。</p><p>2、容器中组件的布局通常由布局管理器控制。每个Container(比如一个Panel或一个Frame)都有一个与它相关的缺省布局管理器，Panel容器默认是FlowLayout，Frame容器默认是BorderLayout，我们可以通过调用setLayout()来改变布局管理器。</p><p>3、我们可以通过设置空布局管理器，来控制组件的大小和位置。可以调用setLayout(null)。在设置空布局管理器之后，必须对所有的组件调用setLocation()，setSize()或者setBounds()，将它们定位在容器中。</p><p>4、FlowLayout布局管理器：流程布局通常用于布置面板中的按钮。 它可以水平排列按钮，直到不再有按钮在同一行上。 线对齐由align属性确定。 可能的值是：LEFT、RIGHT、CENTER、LEADING、TRAILING。</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class FlowLayoutDemo {    public static void main(String[] args) {        MyFrame3 frame3=new MyFrame3(&quot;FlowLayout&quot;);        frame3.init();    }}class MyFrame3 extends Frame{    public MyFrame3(String title){        super(title);    }    public void init(){        //FlowLayout layout=new FlowLayout();//构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。         //FlowLayout layout=new FlowLayout(FlowLayout.LEFT);//构造一个新的 FlowLayout左对齐和默认的5单位水平和垂直间隙。         FlowLayout layout=new FlowLayout(FlowLayout.RIGHT,50,50);//构造一个新的 FlowLayout右对齐和默认的5单位水平和垂直间隙均为50。         this.setLayout(layout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));//添加按钮        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.add(new Button(&quot;btn8&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>5、BorderLayout布局管理器：边界布局设置了一个容器，安排和调整其组件，以适应五个区域：北，南，东，西和中心。 每个区域可以含有不超过一个部件，并且通过相应的常数确定： NORTH ， SOUTH ， EAST ， WEST和CENTER 。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class BorderLayoutDemo {    public static void main(String[] args) {        MyFrame4 frame4=new MyFrame4(&quot;BorderLayout&quot;);        frame4.init();    }}class MyFrame4 extends Frame{    public MyFrame4(String title){        super(title);    }    public void init(){        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;),BorderLayout.EAST);//添加按钮在东边        this.add(new Button(&quot;btn2&quot;),BorderLayout.WEST);        this.add(new Button(&quot;btn3&quot;),BorderLayout.NORTH);        this.add(new Button(&quot;btn4&quot;),BorderLayout.SOUTH);        this.add(new Button(&quot;btn5&quot;),BorderLayout.CENTER);        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>6、GridLayout布局管理器：它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。当行数和列数都被设置为非零值时，无论是通过构造函数还是setRows和setColumns方法，都会忽略指定的列数。而是从指定的行数和布局中的组件总数确定列的数量。因此，例如，如果已经指定了三行和两列，并且将九个组件添加到布局，则它们将显示为三列三列。仅当行数设置为零时，才指定列数影响布局。 </p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.GridLayout;public class GridLayoutDemo {    public static void main(String[] args) {        MyFrame5 frame5=new MyFrame5(&quot;GridLayout&quot;);        frame5.init();    }}class MyFrame5 extends Frame{    public MyFrame5(String title){        super(title);    }    public void init(){        //GridLayout gridLayout=new GridLayout();//在单个行中创建一个每个组件的默认值为一列的网格布局。         //GridLayout gridLayout=new GridLayout(3,2);//创建具有指定行数和列数的网格布局。        GridLayout gridLayout=new GridLayout(3,2,10,10);//创建具有指定行数和列数的网格布局，且指定水平和垂直间隔。        this.setLayout(gridLayout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>7、 CardLayout布局管理器：它将容器中的每个组件视为一张卡。 一次只能看到一张卡片，容器就是一堆卡片。添加到CardLayout对象的第一个组件是首次显示容器时的可见组件。卡片的顺序由容器自己的组件对象的内部顺序决定。CardLayout定义了一组允许应用程序顺序翻转这些卡片或显示指定卡片的方法。 addLayoutComponent(java.awt.Component, java.lang.Object)方法可用于将字符串标识符与给定卡相关联，以便快速随机访问。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;public class CardLayoutDemo {    public static void main(String[] args) {        MyFrame6 frame6=new MyFrame6(&quot;CardLayout&quot;);        frame6.init();    }}class MyFrame6 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame6(String title){        super(title);    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、&lt;br&gt;G
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的AWT框架和容器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT框架和容器/</id>
    <published>2018-07-22T03:47:02.000Z</published>
    <updated>2018-07-23T00:27:14.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、GUI概述"><a href="#1、GUI概述" class="headerlink" title="1、GUI概述"></a>1、GUI概述</h3><p>(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通过GUI能方便友好地进行交互。在Java语言中，JFC(Java Foundation Classed)是开发GUI的API集，它主要包括以下几个部分：</p><pre><code>a、AWT(抽象窗口工具包)：Java开发用户界面最初的工具包，是建立JFC的主要基础。b、Swing组件：建立在AWT之上，新的，功能更强大的图形组件包。c、JAVA2D：实现高质量的二维图形。......</code></pre><h3 id="2、AWT框架"><a href="#2、AWT框架" class="headerlink" title="2、AWT框架"></a>2、AWT框架</h3><p>(1)在java.awt包中包含了一个完整的类集以支持GUI程序的设计。awt所提供的控件一般称之为重量级控件，因为awt主要依靠本地方法(操作系统所提供的图形库)来实现其功能，基于此Java为了实现一次编译到处运行的概念，awt就不得不通过牺牲功能来实现(取各个操作系统的交集)。其中的类及相互关系可以用下图来描述。</p><p><img src="/images/2018/7/2.jpg" alt="&quot;类的相互关系&quot;"></p><p>(2)Component类是最核心的类，它是构成Java图形用户界面的基础，大部分组件都是有该类派生出来的。Component类主要由基本组件和容器(Container)组件组成。容器组件组要分为Window容器和Panel容器。</p><p>(3)Frame容器</p><p>a、Window是能独立存在的容器，它有一个子类Frame，它是一个带有标题和缩放角的窗口。</p><p>b、Frame有一个构造方法Frame(String title)。</p><p>c、你可以通过add()方法，在Frame容器中加入其它的组件。</p><p>d、Frame容器有默认的布局管理器。</p><p>e、Frame被创建后，是不可见的。</p><p>f、示例</p><pre><code>package com.iotek.awt;import java.awt.Color;import java.awt.Frame;public class FrameDemo1 {    public static void main(String[] args) {        MyFrame1 myFrame1=new MyFrame1(&quot;标题&quot;);        myFrame1.init();    }}class MyFrame1 extends Frame{    public MyFrame1(String title){        super(title);    }    public void init(){        //this.setSize(300,300);//设置窗体的宽和高        this.setBounds(100, 100, 300, 300);//移动并调整此组件的大小。         this.setBackground(Color.GREEN);//给窗体设置背景颜色        this.setVisible(true);//设置窗体可见    }}</code></pre><p>(4)Panel容器</p><p>a、Panel只能存在于其它的容器(Window或者其子类)中才能显示出来。</p><p>b、通过Panel的默认构造方法Panel()可以创建一个Panel。</p><p>c、示例</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.Panel;public class FrameDemo2 {    public static void main(String[] args) {        MyFrame2 myFrame2=new MyFrame2(&quot;我的窗体&quot;);        myFrame2.init();    }}class MyFrame2 extends Frame{    public MyFrame2(String title){        super(title);    }    public void init(){        this.setSize(300, 300);        this.setBackground(Color.GREEN);        this.setLayout(null);//去掉窗体的默认布局管理器        Panel panel=new Panel();        panel.setLayout(null);//去掉panel容器的默认布局管理器        panel.setBackground(Color.blue);        panel.setBounds(0, 0, 200, 200);//移动并调整此组件的大小。         Button btn1=new Button(&quot;clickMe&quot;);        btn1.setBounds(0, 0, 100, 100);        btn1.setBackground(Color.red);        panel.add(btn1);//添加按钮到面板中        this.add(panel);//把panel加到窗体中        this.setVisible(true);//让窗体显示    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、GUI概述&quot;&gt;&lt;a href=&quot;#1、GUI概述&quot; class=&quot;headerlink&quot; title=&quot;1、GUI概述&quot;&gt;&lt;/a&gt;1、GUI概述&lt;/h3&gt;&lt;p&gt;(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>雨中漫步</title>
    <link href="http://www.echodemo.cc/2018/07/22/%E9%9B%A8%E4%B8%AD%E6%BC%AB%E6%AD%A5/"/>
    <id>http://www.echodemo.cc/2018/07/22/雨中漫步/</id>
    <published>2018-07-22T01:42:05.000Z</published>
    <updated>2018-07-24T10:51:59.826Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下着小雨的清晨，去楼下吃一碗汤粉，和着鲜红的辣酱，调至自己喜欢的口味，把汤都喝完。在幽深的小巷子里面一个人缓慢地走着，两旁是高大的法国梧桐。想起当年的蒋中正因为宋美龄的一句话，便在六朝古都的金陵广种法国梧桐。或许这是政治手段的表现手法，亦或许这只是传言、是虚假的。但此刻的我宁愿相信他对她的渴慕是真实的，是带着恋人之间的浪漫的。树叶上汇聚的雨点滴落在伞上，发出清脆的轻响，日光暗淡幽然，小巷仍然向前延伸。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下着小雨的清晨，去楼下吃一碗汤粉，和着鲜红的辣酱，调至自己喜欢的口味，把汤都喝完。在幽深的小巷子里面一个人缓慢地走着，两旁是高大的法国梧桐。想起当年的蒋中正因为宋美龄的一句话，便在六朝古都的
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Collections</title>
    <link href="http://www.echodemo.cc/2018/07/21/Java%E4%B8%AD%E7%9A%84Collections/"/>
    <id>http://www.echodemo.cc/2018/07/21/Java中的Collections/</id>
    <published>2018-07-21T11:33:19.000Z</published>
    <updated>2018-07-21T11:34:33.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Collections类及常用API"><a href="#1、Collections类及常用API" class="headerlink" title="1、Collections类及常用API"></a>1、Collections类及常用API</h3><p>(1)Collections类集工具类，定义了若干用于类集和映射(Map)的算法，这些算法被定义为静态方法。</p><p>(2)常用方法：public static void sort(List<t> list);public static int binarySearch(List<t> list,T key);public static void reverse(List&lt;?&gt; list);public static void shuffle(List&lt;?&gt; list);public static vodi swap(List&lt;?&gt; list,int i,int j);public static <t> void fill(List&lt;? super T&gt; list,T obj);</t></t></t></p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CollectionsDemo1 {    public static void main(String[] args) {        List&lt;String&gt; nList=new ArrayList&lt;String&gt;();        nList.add(&quot;chenhao&quot;);        nList.add(&quot;zhangsan&quot;);        nList.add(&quot;lisi&quot;);        nList.add(&quot;wangwu&quot;);        nList.add(&quot;rose&quot;);        nList.add(&quot;mary&quot;);        System.out.println(&quot;操作前&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;交换顺序后&quot;);        Collections.swap(nList, 1, 2);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;自然排序后&quot;);        Collections.sort(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;打乱顺序后&quot;);        Collections.shuffle(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;填充后&quot;);        Collections.fill(nList, &quot;chenhao&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }    }}</code></pre><h3 id="2、对ArrayList容器中的内容进行排序"><a href="#2、对ArrayList容器中的内容进行排序" class="headerlink" title="2、对ArrayList容器中的内容进行排序"></a>2、对ArrayList容器中的内容进行排序</h3><p>(1)案例介绍</p><p>ArrayList中存储了多个person对象，(此对象包含，名字，年龄，ID)要求按年龄从小到大排序，年龄相等的话再按名字的大小来排序输出。</p><p>(2)案例设计</p><p>使用ArrayList来存储Person对象，使用Collections类所提供的静态sort方法来按要求对ArrayList进行排序，最终输出排好序的结果信息。(这里需要重写Comparator方法。)</p><p>(3)代码实现</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class CollectionsDemo2 {    public static void main(String[] args) {        ArrayList&lt;Person&gt; nList=new ArrayList&lt;Person&gt;();        nList.add(new Person(&quot;zhangsan&quot;, 17, 0));        nList.add(new Person(&quot;lisi&quot;, 18, 1));        nList.add(new Person(&quot;xiaohong&quot;, 19, 2));        nList.add(new Person(&quot;chenhao&quot;, 20, 3));        nList.add(new Person(&quot;mary&quot;, 17, 4));        Collections.sort(nList,new Comparator&lt;Person&gt;(){//匿名内部类            @Override            public int compare(Person o1, Person o2) {                int x=o1.getAge()-o2.getAge();                if(x&gt;0) return 1;                else if(x&lt;0) return -1;                else{                    return o1.getNameString().compareTo(o2.getNameString());                }            }        });        for(Person person:nList){            System.out.println(person.toString());        }    }}class Person{     private String nameString;     private int age;     private int id;    public Person(String nameString, int age, int id) {        super();        this.nameString = nameString;        this.age = age;        this.id = id;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    @Override    public String toString() {        return &quot;Person [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &quot;]&quot;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Collections类及常用API&quot;&gt;&lt;a href=&quot;#1、Collections类及常用API&quot; class=&quot;headerlink&quot; title=&quot;1、Collections类及常用API&quot;&gt;&lt;/a&gt;1、Collections类及常用API&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Set</title>
    <link href="http://www.echodemo.cc/2018/07/20/Java%E4%B8%AD%E7%9A%84Set/"/>
    <id>http://www.echodemo.cc/2018/07/20/Java中的Set/</id>
    <published>2018-07-20T15:50:08.000Z</published>
    <updated>2018-07-20T15:51:07.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Set容器的特点"><a href="#1、Set容器的特点" class="headerlink" title="1、Set容器的特点"></a>1、Set容器的特点</h3><p>Set容器是一个不包含重复元素的Collection，并且最多包含一个null元素，它和List容器相反，Set容器不能保证其元素的顺序。最常用的两个Set接口的实现类是HashSet和TreeSet。</p><h3 id="2、HashSet及常用API"><a href="#2、HashSet及常用API" class="headerlink" title="2、HashSet及常用API"></a>2、HashSet及常用API</h3><p>(1)HashSet扩展AbstractSet并实现Set接口，HashSet使用散列表(又称之为哈希表)进行存储。<strong>(HashSet底层实际上维护了一个HashMap，只是我们操作的是HashMap的key，而HashMap底层维护了哈希表)</strong></p><p>(2)构造方法：HashSet();HashSet(Collection c);HashSet(int capacity);HashSet(int capacity,float fillRatio)。</p><p>(3)HashSet没有定义任何超过它的父类和接口提供的其他方法，散列集合没有确保其元素的顺序，因为散列处理通常不参与排序。</p><p>(4)举例</p><pre><code>package com.iotech.set;import java.util.HashSet;public class HashSetDemo1 {    public static void main(String[] args) {        /*HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;();        hashSet.add(&quot;zhangsan&quot;);        hashSet.add(&quot;lisi&quot;);        hashSet.add(&quot;jay&quot;);        hashSet.add(&quot;jack&quot;);        System.out.println(hashSet.add(&quot;jay&quot;));        System.out.println(hashSet);*/        HashSet&lt;Student&gt; hashSet=new HashSet&lt;Student&gt;();         System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.add(new Student(&quot;李四&quot;, 30)));        System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.size());    }}class Student{    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="3、TreeSet及常用API"><a href="#3、TreeSet及常用API" class="headerlink" title="3、TreeSet及常用API"></a>3、TreeSet及常用API</h3><p>(1)TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储，访问和检索很快。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择。<strong>(事实上，TreeSet的底层就是TreeMap实现的，只是我们操作的是TreeMap的Key)</strong></p><p>(2)构造方法：TreeSet();TreeSet(Collection c);TreeSet(Comparator comp);TreeSet(SortedSet ss)。</p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.Iterator;import java.util.TreeSet;public class TreeSetDemo1 {    public static void main(String[] args) {        TreeSet&lt;Person&gt; treeSet=new TreeSet&lt;Person&gt;();        treeSet.add(new Person(&quot;chenhao&quot;, 30));        treeSet.add(new Person(&quot;lisi&quot;, 20));        treeSet.add(new Person(&quot;wangwu&quot;, 10));        treeSet.add(new Person(&quot;rose&quot;, 40));        Iterator&lt;Person&gt; iterator=treeSet.iterator();        while(iterator.hasNext()){            Person person=iterator.next();            System.out.println(person.getName()+&quot;--&gt;&quot;+person.getAge());        }    }}class Person implements Comparable&lt;Person&gt;{    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int compareTo(Person o) {        int x=this.age-o.age;        if(x&gt;0) return 1;        else if(x&lt;0) return -1;        return 0;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Set容器的特点&quot;&gt;&lt;a href=&quot;#1、Set容器的特点&quot; class=&quot;headerlink&quot; title=&quot;1、Set容器的特点&quot;&gt;&lt;/a&gt;1、Set容器的特点&lt;/h3&gt;&lt;p&gt;Set容器是一个不包含重复元素的Collection，并且最多包含一个nul
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
</feed>
