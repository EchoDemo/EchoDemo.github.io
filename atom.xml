<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-11-05T15:11:22.670Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot的Controller的使用</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E7%9A%84Controller%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot的Controller的使用/</id>
    <published>2018-11-05T13:02:28.000Z</published>
    <updated>2018-11-05T15:11:22.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/11/05/SpringBoot%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/11/05/SpringBoot的第一个入门程序/</id>
    <published>2018-11-05T12:34:41.000Z</published>
    <updated>2018-11-05T15:10:50.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK"><a href="#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK" class="headerlink" title="1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)"></a>1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK)</h3><p><img src="/images/2018/11/1.png" alt="&quot;1&quot;"></p><p><img src="/images/2018/11/2.png" alt="&quot;2&quot;"></p><p><img src="/images/2018/11/3.png" alt="&quot;3&quot;"></p><p><img src="/images/2018/11/4.png" alt="&quot;4&quot;"></p><h3 id="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。"><a href="#2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController-java文件并创建一个方法。" class="headerlink" title="2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。"></a>2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。</h3><p><img src="/images/2018/11/5.png" alt="&quot;打开GirlApplication.java文件&quot;"></p><p><img src="/images/2018/11/6.png" alt="&quot;创建HelloController.java文件&quot;"></p><h3 id="3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。"><a href="#3、在GirlApplication-java文件中启动该项目。成功之后在浏览器当中输入127-0-0-1-8080-hello。" class="headerlink" title="3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。"></a>3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。</h3><p><img src="/images/2018/11/7.png" alt="&quot;在浏览器查看&quot;"></p><h3 id="4、项目属性配置-创建配置文件和配置文件属性类"><a href="#4、项目属性配置-创建配置文件和配置文件属性类" class="headerlink" title="4、项目属性配置(创建配置文件和配置文件属性类)"></a>4、项目属性配置(创建配置文件和配置文件属性类)</h3><p><img src="/images/2018/11/8.png" alt="&quot;文件分布&quot;"></p><p>（1）生产、测试环境以及主配置文件内容</p><pre><code>//测试环境内容server:  port: 8080girl:  cupSize: B  age: 18//生产环境内容server:  port: 8081girl:  cupSize: F  age: 18//调用配置文件的主配置文件内容spring:  profiles:    active: prod</code></pre><p>（2）创建配置文件属性类</p><pre><code>package com.echodemo.girl;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;//获取前缀是girl的配置，注入配置需要加Component注解@Component@ConfigurationProperties(prefix = &quot;girl&quot;)public class GirlProperties {    private String cupSize;    private Integer age;    public String getCupSize() {        return cupSize;    }    public void setCupSize(String cupSize) {        this.cupSize = cupSize;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><p>（3）HelloController文件内容</p><pre><code>package com.echodemo.girl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {/*    //通过注解的方式获取配置文件值(Value注解太low了)    @Value(&quot;${server.cupSize}&quot;)    private String cupSize;    @Value(&quot;${server.age}&quot;)    private Integer age;*/    //通过创建配置文件属性类来获取配置文件中的值    @Autowired    private GirlProperties girlProperties;    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)    public String say(){        return girlProperties.getCupSize();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-maven-3-3-9以及1-8版本的JDK&quot;&gt;&lt;a href=&quot;#1、在intellij-idea2018上创建一个maven项目-在这里我使用的是apache-ma
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="http://www.echodemo.cc/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(二)/</id>
    <published>2018-10-06T15:12:32.000Z</published>
    <updated>2018-10-06T15:18:23.483Z</updated>
    
    <content type="html"><![CDATA[<p>1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想要得到什么、实现什么。</p><p>2、关系要获得成长，首先是处在关系中的人要成长。比如，有的女人婚后成了全职太太，将个人成长的停滞归咎于操持家庭，和先生在阅历和思想上逐渐脱节，渐行渐远。又比如，有的男性一直保持着学生时期的心态，沉迷于游戏和其他娱乐活动，拒绝面对自己的成长，也不愿认真思考未来。</p><p>3、我们不知道自己想要什么，是因为有太多担心和顾虑，眼前的问题阻碍了我们看清自己的方向。</p><p>4、怎样知道你对一件事情有激情？你每天早上醒来和晚上临睡前都会忍不住去想、去做的，就是让你充满激情的事情。如果连开始一件事情都缺少决断力，那么之后一旦遇到困难或者冲突，必然会很快选择放弃。所以，如果你已经发现自己的激情所在，想要去做一件事情，那么现在就开始！</p><p>5、你可以试试把自己关在一个空房间里，5分钟，10分钟，半小时。不带手机，不看电脑，你可以观察自己在寂寞时会有什么反应，会做什么，这样可以很好地帮助你了解自己。</p><p>6、喜欢把工作忙、圈子小、性格内向、不善交际这些说辞挂在嘴边的人并没有想过，他们提出的每一点理由都只是一种暂时的状态，而非不可改变的现实。那些成功者与你起点相同，但最终获得成功，这才是你和他们的本质区别。</p><p>7、走出自卑，是一条重新审视自己的生活、重新定义自我价值、重新设计自我行为的漫长之路。走出自卑，需要你对客观现实和自我认知有强烈的渴望，这样才能够打破长久以来的自我偏见；走出自卑，意味着要学会忍耐自卑带来的不适感，将更多精力放在优化自己的实际行为上。</p><p>8、愤怒的表达是本能，对愤怒带来的伤害的修复比表达更为重要，但是许多人都把更多注意力放在了调整和弱化表达上面。（压抑自己的情绪）如果我们懂得如何在伤害产生后修复关系，表达我们的歉意、关怀和爱，那么伤害反而成了拉近关系和建立信任的机会。使用回避、沉默、逃避、疏远以及终止关系来表达愤怒。其结果就是，情绪得不到合理表达，引发更深层的抑郁，同时也失去了建立信任感和亲密关系的机会，在人际关系中越发感到被孤立。</p><h2 id="9、“想要”和“需要”"><a href="#9、“想要”和“需要”" class="headerlink" title="9、“想要”和“需要”"></a>9、“想要”和“需要”</h2><p>关于是否足够了解自己的情感需求这个话题，我会用一个简单的问题来测试：“你为什么要恋爱、结婚？”对此，我得到的常见答案是：自己到了一定年纪应该稳定下来了，家里人也比较着急，看到周围的同事、朋友也都结婚了，所以就结婚了。在我看来，这就是不了解自己情感需求的表现，因为这里给出的是一个人想要却未必需要的东西。关于人的想要和需要，我们要进行一下区分。你可以将这两者的关系理解为路径和目标，我们通过得到想要的东西，来满足根本的需要。想要的东西往往是某些具体的事物，而需要很多时候则是主观的体验和感受。比如，我想要很多钱，因为有了钱别人就会尊重我，所以我需要的其实是尊重；我想要先生对我很专一，这会让我感觉他很重视我，所以我需要的是重视；我想要很多漂亮的衣服和包，因为我打扮漂亮了，别人才会认可我，所以我需要的是认可。当一个人告诉我她走进一段感情是因为年龄、家人和社会压力时，她的真正需要可能是自信、安全感、归属感，以及被认可、被尊重、被接纳等。更进一步说，一个人得到了想要的东西，是否就一定能满足自己的需要？很多人在这两者的关系认知上存在着很大的偏差。比如走入婚姻，需要的是被别人认可和尊重，但是满足了家人和社会的期望，就一定能被别人认可和尊重吗？</p><p>如果无法区分想要和需要，便会把生命浪费在肤浅的、想要的事物上。而人只有当需要被满足时，才会感到发自内心的满意。</p><h2 id="10、划分人生阶段"><a href="#10、划分人生阶段" class="headerlink" title="10、划分人生阶段"></a>10、划分人生阶段</h2><p>将自己的人生划分为8个阶段，这个数字没有特定的含义，只是一个结构上的要求。每个阶段用一个重要的事件或者时间节点来界定。第一个阶段从出生开始，最后一个阶段一直持续到当下。</p><h3 id="罗列重要事件"><a href="#罗列重要事件" class="headerlink" title="罗列重要事件"></a>罗列重要事件</h3><p>从每个阶段里找出10件对你影响重大的事件，这个数字也仅是一个结构上的要求而已。这些事件应该对你的情感、性格、生活轨迹、人际关系产生过比较大的影响。我建议你关注这样一些事件：让你的生活轨迹发生变化的转折点，重大的失败或意外，重要的决定，对情感造成较大冲击的事件，记忆深刻的事件。另外这些事件多半与他人有关，我建议你重点关注你的父母或者其他亲近的人。罗列这80件事情本身就是个挑战，有的需要努力回忆，有的需要去询问他人。你可以先定义好一个阶段，去搜罗事件，进行分析，然后再进入下一个阶段。</p><h3 id="分析事件"><a href="#分析事件" class="headerlink" title="分析事件"></a>分析事件</h3><p>每一个事件下面，你都需要回答以下几个问题：</p><pre><code>（1）这件事给你带来了哪些认知和想法上的变化？（2）这件事给你带来了哪些情感上的冲击或者影响？（3）这件事和现在的你有什么关系？换句话说，这件事如何塑造了今天的你？</code></pre><p>内容上没有太多要求，每个人都有权利以自己喜欢的方式写一部自己的个人史。唯一需要你坚持的是8个阶段，总共80件事情，每件事情3个问题，这样写出来的东西才能足够细化。每个问题你可以随便回答，或者详细地描述。要花多少时间，要写多少，由你自己决定。你的收获完成这份“作业”可能需要花费很多时间，多到远远超出你的预期。写的过程中你可能会哭、会笑、会感慨。你可能需要他人帮助你回忆某些事。我介绍身边的一些人尝试过这种方法，包括我的长辈。我没有看他们写的东西（你最好不给别人看，这样才能保证内容最真实）。但是大家给我的反馈一致：做这样一件事对自己有太多益处。这个练习是我大学时期的一位心理学教授布置的期末论文题目。当时的我花费两个月的时间，写下一万多字。它开启了我对自我认知的探寻之路，是我到目前为止做过的最重要的几件事情之一。最终的效果因人而异。但对我来说，写作的过程已让我受益匪浅，一边写一边思考，看清了很多以往忽略或者误解的问题。写完之后，整个人有一种“觉醒”的感觉，它带来的思考，也会持续影响自己。同时，你会更理解自己，会看到所处的环境对自己的影响，而不再把所有事情都归因于自己或者身边的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《假性亲密关系》摘句(一)</title>
    <link href="http://www.echodemo.cc/2018/10/06/%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/10/06/《假性亲密关系》摘句(一)/</id>
    <published>2018-10-06T15:07:21.000Z</published>
    <updated>2018-10-06T15:10:51.268Z</updated>
    
    <content type="html"><![CDATA[<p>1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。</p><p>2、在深入了解双方的想法时，例如聊到和前任的关系或者异性朋友这类比较敏感的话题时，建议你平和而又诚恳地邀请对方表达，让对方感到安全：“我知道这个话题对你来说可能比较敏感，或许你可以试着说说看，我很想了解你，也向你保证，我不会在没有完全理解你的时候给你贴标签或者批判你。”</p><p>3、矛盾冲突永远存在，但是高质量的关系可以保障亲密关系中的满意度更持久。很多人在亲密关系中所犯的错误就是为了争论对错、分出输赢、掌握控制权，宁可牺牲亲密关系，因为我们往往习惯了以强制的方式使对方接受。</p><p>4、你可能习惯了不说话，在人群里永远保持沉默，有着很强的戒备心理，对异性充满恐惧。你可能有很多情结、障碍、缺点，但你必须要走出自己熟悉的舒适区，做以前没做过的事情。浪漫的事情，都多少带些不寻常甚至是冒险。在恐惧、焦虑、不确定的时候，你习惯了逃避，那么，多半也会错过那些美好奇妙的邂逅。</p><p>5、许多人总要求对方要与自己有精神共鸣、有生活情趣、要浪漫、要体贴入微。要求别人之前先看看自己，你是个爱读书、爱思考的人吗？你的生活是不是充满了各种趣味？你是否有自己独特的手艺和爱好可以用来营造浪漫？你是否习惯于帮助他人和奉献自我？长久积累的品质才能产生魅力，而平庸和平淡的你，拿什么吸引心仪的人，拿什么让亲密关系保鲜？</p><p>6、我极力推荐大家去看看《摩登家庭》，此剧一个重要的看点就是学习剧中人物在处理家庭关系时如何用积极的、有建设性的语言沟通彼此的感受。</p><p>7、我希望用文字鼓励那些心有所向的人，不要因为可能被拒绝就患得患失，不要因为希望渺茫就放弃。感情不能用得失、成败来衡量，因为感情中的失败其实是一种提示，是在告诉你且行且珍惜，你完全没必要和失败过不去。</p><p>8、我真心希望每一个恋爱中的人，都不要只顾着享受对方带给你的感动和温暖，要多想想自己可以为他做些什么。在你感到最幸福、最满足的时候，记得问问自己：他是否和我一样幸福？</p><p>9、任何形式的失败，其实都是生活在提示我们：你的方法不对，需要调整。拒绝分手或者离婚，找各种理由说服自己死扛，本质就是拒绝承认错误。当你忽视生活给你的提示时，获得的只能是更多更激烈和强硬的提示，直到你被彻底打垮。</p><p>10、每当你和伴侣之间出现矛盾的时候，你需要先思考以下两个问题：对方怎么改变能够让你感到满意？如果有人要让你做出这样的改变，激励你的最好方式是什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。&lt;/p&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《自控力》摘句</title>
    <link href="http://www.echodemo.cc/2018/09/08/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2018/09/08/《自控力》摘句/</id>
    <published>2018-09-08T13:23:43.000Z</published>
    <updated>2018-09-08T13:33:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。</p><p>2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。</p><p>3、从每章挑选一个策略，选和你的挑战最相关的一个，而不是一次尝试10种策略。</p><p>4、人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学数学，它就会越来越擅长数学。如果你让它忧虑，它就会越来越忧虑。如果你让它专注，它就会越来越专注。</p><p>5、如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</p><p>6、人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</p><p>7、如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。</p><p>8、如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。</p><p>9、自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。</p><p>10、道德许可：当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p><p>11、只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。</p><p>12、当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？·你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？·你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？</p><p>13、我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。</p><p>14、你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？</p><p>15、这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？</p><p>16、如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。</p><p>17、你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。）</p><p>18、是什么让你的多巴胺神经元不停燃烧？你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？</p><p>19、谁在控制你的多巴胺神经元？让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。&lt;/p&gt;
&lt;p&gt;2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。&lt;/p&gt;
&lt;p&gt;3、从每章挑选一个策略，选和你的挑战最相关的一个，而
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>故乡</title>
    <link href="http://www.echodemo.cc/2018/08/22/%E6%95%85%E4%B9%A1/"/>
    <id>http://www.echodemo.cc/2018/08/22/故乡/</id>
    <published>2018-08-22T13:29:58.000Z</published>
    <updated>2018-08-27T10:55:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专程看望和问询；郑愁予的故乡是始终心系的祖国；还有一个人的故乡是他十年来力排众议在艰难的环境和地形下修筑的几十公里的山路。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一辆Hello共享单车，在幽暗的路上漫无目的地游荡。想起考研未果的日子，我知道，那时候选择找工作而不是二战，是因为自己在逃避，害怕再一次的失败，不知道自己的退路在哪。如今来到偌大的城市里，繁华是你。刚来的日子里满心欢喜，为自己能够来到这座城市而庆幸，把冥冥中的注定看作美好的开始。但此刻自己的内心是茫然的，故乡对我而言意味着什么，一个人需要怎样的经历和过去才能够看清？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立在公交站台旁的我，用手机写着这段文字的时候，抬头望着夜空中笼罩在云里的月，顿下来，目光又顺着车流望向灯火斑斓的远方，好像知道了点什么，转身往回走去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>音乐诗人</title>
    <link href="http://www.echodemo.cc/2018/08/19/%E9%9F%B3%E4%B9%90%E8%AF%97%E4%BA%BA/"/>
    <id>http://www.echodemo.cc/2018/08/19/音乐诗人/</id>
    <published>2018-08-19T02:46:32.000Z</published>
    <updated>2018-08-27T10:53:03.803Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，动听的曲，美的无与伦比。台上的他，于言谈举止之间无时无刻不透露着温文儒雅的气质。近来知晓他与其妻子的爱情，从两小无猜的年纪到同是清华的学子，彼此之间缘深缘浅，自是懂得，这一切都是最好的安排。据说在李健的每一张专辑里都有一首歌是写给孟小蓓的，他对她说：和你在一起的日子才叫时光。他爱咖啡，也爱清茶，更爱读书，这也是他随口而出的词句里文化深厚的原因。他的音乐如诗，爱情如诗，更是把生活过成了一首诗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>萤火虫</title>
    <link href="http://www.echodemo.cc/2018/08/18/%E8%90%A4%E7%81%AB%E8%99%AB/"/>
    <id>http://www.echodemo.cc/2018/08/18/萤火虫/</id>
    <published>2018-08-18T06:39:59.000Z</published>
    <updated>2018-08-27T10:51:45.655Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种做法，想想都是美的。以前小时候在故乡，秋天的夜晚，带着随意的瓶子跑到屋子外面去捕萤火虫，满天的星光下，是我们奔跑的身影和不尽的欢笑。那时候小，把一只又一只的萤火虫都塞进瓶中，第二天一大早起来，见到的就是它们的躯体，自己伤心极了，便下定决心不再捕捉，只是远观这些闪烁着的精灵就足够了。如今年岁见长，到远离故乡的城市里读书，再到现在的新入职场，一切都变得遥远。大概现在已经有好几年没有见到过萤火虫了。一方面是人类发展导致的环境恶化，另一方面是自己在这样的时节里和故乡难以靠近。昨天七夕，不禁想起唐代诗人杜牧那首《秋夕》“银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星”，给此时的自己又增添了一份美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺&lt;/p&gt;
&lt;p&gt;&amp;nbsp
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的XML配置</title>
    <link href="http://www.echodemo.cc/2018/08/16/MyBatis%E4%B8%AD%E7%9A%84XML%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2018/08/16/MyBatis中的XML配置/</id>
    <published>2018-08-16T07:11:29.000Z</published>
    <updated>2018-08-16T08:05:20.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、properties"><a href="#1、properties" class="headerlink" title="1、properties"></a>1、properties</h3><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。首先在同级目录下新建一个db.properties文件。</p><pre><code>&lt;!-- db.properties文件 --&gt;driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root&lt;!-- properties配置 --&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;&lt;!-- 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，如下所示： --&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;&lt;!--     1、在properties元素体内指定的属性首先被读取。    2、然后根据properties元素中的resource属性读取类路径下属性文件或根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性。    3、最后读取作为方法参数(parameterType)传递的属性，并覆盖已读取的同名属性。    4、通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。--&gt;</code></pre><h3 id="2、Setting"><a href="#2、Setting" class="headerlink" title="2、Setting"></a>2、Setting</h3><p>它们会修改MyBatis在运行时的行为方式，ibatis的全局配置参数，包括很多的性能参数(最大线程数、最大等待时间等)，通过调用这些性能参数使用ibatis达到高性能的运行。MyBatis运行时调整全局参数，相当于软件运行时的参数。(需要小心配置，配置参数会影响MyBatis的执行)</p><h3 id="3、typeAlias"><a href="#3、typeAlias" class="headerlink" title="3、typeAlias"></a>3、typeAlias</h3><pre><code>&lt;!--    1、类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。     2、自定义别名:alias别名；type类型。如果指定包中所有类都有别名，使用类名作为别名(大小写不敏感)。--&gt;&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;user&quot; type=&quot;com.entity.User&quot;/&gt;    &lt;package name=&quot;com.entity&quot;/&gt;&lt;/typeAliases&gt;</code></pre><h3 id="4、environments"><a href="#4、environments" class="headerlink" title="4、environments"></a>4、environments</h3><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。</p><pre><code>&lt;!-- 可以接受环境配置的两个方法签名 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);&lt;!-- 如果忽略了环境参数，那么默认环境将会被加载 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 在MyBatis中有两种类型的事务管理器：1、JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。2、MANAGED这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 --&gt;&lt;transactionManager type=&quot;MANAGED&quot;&gt;      &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><h3 id="5、mappers"><a href="#5、mappers" class="headerlink" title="5、mappers"></a>5、mappers</h3><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、properties&quot;&gt;&lt;a href=&quot;#1、properties&quot; class=&quot;headerlink&quot; title=&quot;1、properties&quot;&gt;&lt;/a&gt;1、properties&lt;/h3&gt;&lt;p&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Jav
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/08/15/MyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/08/15/MyBatis第一个入门程序/</id>
    <published>2018-08-15T07:37:43.000Z</published>
    <updated>2018-08-16T08:58:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>2、写一个mybatis的入门程序</p><p>(1)在Myeclipse上新建一个Java项目。首先导入jar包，在该项目下新建一个lib目录，将下列的jar包导入到lib目录下。</p><p><img src="/images/2018/8/1.jpg" alt="&quot;jar包&quot;"></p><p>(2)在该项目下创建一个与src同级的source folder，取名为config。在这其中存放xml配置文件。</p><p>1)sqlMapConfig.xml(名字是自行定义的):其中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。如下所示：这里要注意DOCTYPE首部最好是在mybatis文档当中复制粘贴，不要自己手打。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- 全局配置文件 --&gt;&lt;configuration&gt;    &lt;!-- 环境变量 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 事务管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据源 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;!-- 以下的数据库以及密码需要配置自己的 --&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射定义信息) --&gt;        &lt;mapper resource=&quot;Usermapper.xml&quot; /&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>2)Usermapper.xml(和上面的配置文件中的mappers当中的mapper是一一对应的):这个配置文件主要用于进行SQL的配置。同时记得在数据库当中创建users表，且添加数据。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml(配置SQL) --&gt;&lt;!-- namespace命名空间，为了对SQL语句进行隔离，方便管理 mapper开发dao方式，有特殊的作用。 --&gt;&lt;mapper namespace=&quot;mappertest&quot;&gt;    &lt;!--     mapper.xml文件配置的SQL语句，执行每一个SQL，都将封装为mapperStatement对象。    mapper.xml以statement为单位管理SQL语句 。    --&gt;    &lt;!-- ID唯一标识Statement --&gt;    &lt;!-- parameterType：输入参数类型，通过#{}，#{}中名称任意 --&gt;    &lt;!-- resultType：输出结果的类型，返回单条或者多条记录，指明类型 --&gt;    &lt;!-- #{}表示占位符，如果参数给出String，自动添加&apos;&apos;；${value}表示SQL语句拼接，不会自动添加&apos;&apos;。 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where id=#{id}    &lt;/select&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username=#{username}    &lt;/select&gt;    &lt;select id=&quot;findUserByName1&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username like &apos;%${value}%&apos;    &lt;/select&gt;    &lt;!-- 添加用户,传参时将大括号中填写的是属性名 --&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        &lt;!--         order设置是取SQL语句执行之前还是之后的值 。        resultType：返回类型。        keyProperty：将主键设置到属性。        last_insert_id()：获得刚插入的记录自动编号的值。        --&gt;        &lt;selectKey order=&quot;AFTER&quot; resultType=&quot;int&quot; keyProperty=&quot;id&quot;&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into users(username,age) values(#{username},#{age})    &lt;/insert&gt;    &lt;!-- 删除用户 --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from users where id=#{id}    &lt;/delete&gt;    &lt;!-- 修改用户 ，用户的ID一定需要有值--&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        update users set username=#{username},age=#{age} where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>(3)创建一个com.entity包，在此包下新建User.java文件。</p><pre><code>package com.entity;public class User {    private int id;    private String username;    private int age;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public User(){        super();    }    public User(String username, int age) {        super();        this.username = username;        this.age = age;    }    public User(int id, String username, int age) {        super();        this.id = id;        this.username = username;        this.age = age;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><p>(4)最后创建一个com.test包，创建一个APPTest.java文件，用于junit测试(记得导入junit的jar包)。</p><pre><code>package com.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.entity.User;public class AppTest {    SqlSessionFactory sqlSessionFactory = null;    @Before    public void Init() throws IOException{        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testSelectUser() {//查找数据        SqlSession sqlSession = sqlSessionFactory.openSession();        //第一个参数是Statement的id,第二个参数是SQL语句中所需要的值。        /*User user = (User)sqlSession.selectOne(&quot;findUserById&quot;, 2);        System.out.println(user.toString());*/        //List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName&quot;, &quot;EchoDemo&quot;);        List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName1&quot;, &quot;Echo&quot;);        for(User user:list){            System.out.println(user.toString());        }        sqlSession.close();    }    @Test    public void testInsertUser(){//插入数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(&quot;落叶物语&quot;,24);        sqlSession.insert(&quot;addUser&quot;, user);        sqlSession.commit();//提交        sqlSession.close();        System.out.println(&quot;当前插入用户的ID:&quot; + user.getId());    }    @Test    public void testDeleteUser(){//删除数据        SqlSession sqlSession = sqlSessionFactory.openSession();        sqlSession.delete(&quot;deleteUser&quot;,2);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testUpdateUser(){//更新数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(3,&quot;紫苏半夏&quot;,22);        sqlSession.update(&quot;updateUser&quot;, user);        sqlSession.commit();        sqlSession.close();    }}</code></pre><p>1)每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。</p><p>2)SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在以保证所有的XML解析资源开放给更重要的事情。</p><p>3)SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p>4)每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Pl
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML</title>
    <link href="http://www.echodemo.cc/2018/08/07/Java%E4%B8%AD%E7%9A%84XML/"/>
    <id>http://www.echodemo.cc/2018/08/07/Java中的XML/</id>
    <published>2018-08-07T08:50:21.000Z</published>
    <updated>2018-08-07T08:51:40.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、XML定义"><a href="#1、XML定义" class="headerlink" title="1、XML定义"></a>1、XML定义</h3><p>(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输，类似HTML，不同的是它的设计宗旨是传输数据，而非显示数据。</p><p>(2)XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。XML标签没有被预定义，开发者根据需要自行定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。</p><h3 id="2、XML文档结构"><a href="#2、XML文档结构" class="headerlink" title="2、XML文档结构"></a>2、XML文档结构</h3><p>(1)XML声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p>(2)XML根元素定义：XML文档的树形结构要求必须有一个根元素。根元素的起始标记要放在所有其他元素起始标记之前，根元素的结束标记放在其他元素的结束标记之后。</p><p>(3)XML元素：元素的基本结构由开始标记，数据内容，结束标记组成。</p><h3 id="3、XML语法规则"><a href="#3、XML语法规则" class="headerlink" title="3、XML语法规则"></a>3、XML语法规则</h3><pre><code>(1)所有XML元素都须有关闭标签。(2)XML标签对大小写敏感。(3)XML必须正确地嵌套。(4)XML文档必须有根元素。(5)XML的属性以名值对方式组成，值须加引号。(6)XML可编写注释。(7)在XML中，空格会被保留，文档中的空格不会被删节。</code></pre><h3 id="4、举例说明"><a href="#4、举例说明" class="headerlink" title="4、举例说明"></a>4、举例说明</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;    &lt;book bookno=&quot;001&quot;&gt;        &lt;title&gt;Java语言编程&lt;/title&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;80&lt;/price&gt;    &lt;/book&gt;    .    .    .&lt;/bookstore&gt;</code></pre><h3 id="5、XML-SAX解析器"><a href="#5、XML-SAX解析器" class="headerlink" title="5、XML SAX解析器"></a>5、XML SAX解析器</h3><p>(1)SAX(Simple API For XML)是一个公共的基于事件的XML文档解析标准，能够通过一个简单的、快速的方法来对XML文档进行处理，和DOM相比它所占用的系统资源更少。</p><p>(2)SAX既是一个接口，也是一个软件包。作为接口，SAX是事件驱动型XML解析的一个标准接口，对文档进行顺序扫描，当扫描到文档(document)开始、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</p><h3 id="6、SAX解析器API"><a href="#6、SAX解析器API" class="headerlink" title="6、SAX解析器API"></a>6、SAX解析器API</h3><p>(1)事件类型，大多数的SAX会产生以下类型的事件：</p><pre><code>1)在文档的开始时和结束时触发文档处理事件。2)在文档内每一XML元素接受解析的前后触发元素事件。3)任何的元数据通常由单独的事件处理。</code></pre><p>(2)举例说明</p><pre><code>&lt;doc&gt;    &lt;para&gt;Hello,iotek!&lt;/para&gt;&lt;doc&gt;其解析过程为：1)start document;2)start element:doc;3)start element.para;4)characters:Hello,iotek!;5)end element:para;6)end element:doc;7)end document;</code></pre><p>(3)解析步骤</p><pre><code>1)创建事件处理程序(即编写ContentHandler的实现类，一般继承自DefaultHandler类，采用adapter模式)2)创建SAX解析器3)将事件处理程序分配到解析器。4)对文档进行解析，将每个事件发送至事件处理程序。</code></pre><p>(4)常用接口：ContentHandler接口</p><p>1)ContentHandler是Java类包中一个特殊的SAX接口。该接口封装了一些对事件处理的方法，当XML解析器开始解析XML输入文档时，他会遇到某些特殊的事件，比如文档的开头和结束、元素开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法(回调方法)来响应该事件。</p><p>2)ContentHandler接口常用方法：</p><pre><code>void startDocument();//文档解析开始的处理。void endDocument();//文档解析结束的处理。void startElement(String uri,String localName,String qName,Attributes atts);//ElementNode开始的处理。void endElement(String uri,String localName,String qName);//ElementNode结束的处理。void character(char[] ch,int start,int length);//具体在某一节点中的处理。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、XML定义&quot;&gt;&lt;a href=&quot;#1、XML定义&quot; class=&quot;headerlink&quot; title=&quot;1、XML定义&quot;&gt;&lt;/a&gt;1、XML定义&lt;/h3&gt;&lt;p&gt;(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中反射与Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%8EAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中反射与Annotation/</id>
    <published>2018-08-06T11:41:30.000Z</published>
    <updated>2018-08-06T11:42:10.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、MetaAnnotation概念"><a href="#1、MetaAnnotation概念" class="headerlink" title="1、MetaAnnotation概念"></a>1、MetaAnnotation概念</h3><p>(1)MetaAnnotation也称为元Annotation，也是一种Annotation，可以对其他的Annotation进行注释。</p><p>(2)Java5.0提供了一些标准的MetaAnnotation：</p><pre><code>1)@Retention2)@Target3)@Documented4)@Inherited</code></pre><p>(3)@Retention:控制被Retention注释的Annotation信息的保留时间长短。</p><pre><code>@Retention(SOURCE/CLASS/RUNTIME)public/default @interface Annotation名称{...}a、SOURCE:Annotation信息在编译阶段被丢弃，仅保留在java源文件中。b、CLASS(默认):Annotation信息在编译阶段被保留，保留到class文件中，但是运行阶段不存在。c、RUNTIME:Annotation信息一直保存到运行阶段，直到退出虚拟机才被丢弃。以上三个值是java.lang.annotation.RetentionPolicy这个类所提供的枚举值。</code></pre><p>(4)@Target:表示一个Annotation的使用范围。</p><pre><code>@Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD,...})public/defalut @interface Annotation名字{...}a、TYPE:只能在类或接口或枚举上使用。b、METHOD:在方法中使用。c、FIELD:在成员变量使用。d、PARAMETER:在参数上使用。e、CONSTRUCTOR:在构造中使用。f、LOCAL_VARIABLE:在局部变量上使用。g、ANNOTATION_TYPE:只能在Annotation中使用。h、PACKAGE:只能在包中使用。</code></pre><p>(5)@Documented:想要在使用者制作JavaDoc文件的同时，也一并将Annotation的讯息加入至API文件中。</p><pre><code>@Documentedpublic/default @interface Annotation名称{...}</code></pre><p>(4)@Inherited:表示一个Annotation是否允许被其子类继承下来。</p><pre><code>@Inheritedpublic/default @inherited Annotation名称{...}</code></pre><h3 id="2、反射与Annotation"><a href="#2、反射与Annotation" class="headerlink" title="2、反射与Annotation"></a>2、反射与Annotation</h3><p>(1)一个Annotation真正起作用，必须结合反射机制，在java.lang.reflect反射包中提供AccessibleObject类来对Annotation进行操作，最常用的方法如下：</p><pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);//判断是否使用时指定的Annotation。public Annotation[] getAnnotation();//得到全部的Annotation。注：无反射，不注解。</code></pre><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;public class ReflectAnnotationDemo {    public static void main(String[] args) throws Exception {        Class&lt;?&gt; classType = Class.forName(&quot;com.iotek.annotation.AnnotationTest&quot;);        boolean flag = classType.isAnnotationPresent(Description.class);        if(flag){            Description description = classType.getAnnotation(Description.class);            System.out.println(&quot;AnnotationTest&apos;s description--&gt;&quot; + description.value());            Method[] methods = classType.getDeclaredMethods();            for(Method method:methods){                if(method.isAnnotationPresent(Author.class)){                    Author author = method.getAnnotation(Author.class);                    System.out.println(&quot;AnnotationTest&apos;s author--&gt;&quot; + author.name() + &quot; from &quot;+author.group());                }            }        }    }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documented@interface Author{    String name();    String group();}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@interface Description{    String value();}@Description(&quot;这是一个用于测试的类&quot;)class AnnotationTest{    @Author(name=&quot;EchoDemo&quot;,group=&quot;com.iotek&quot;)    public void test(){        System.out.println(&quot;test over!&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、MetaAnnotation概念&quot;&gt;&lt;a href=&quot;#1、MetaAnnotation概念&quot; class=&quot;headerlink&quot; title=&quot;1、MetaAnnotation概念&quot;&gt;&lt;/a&gt;1、MetaAnnotation概念&lt;/h3&gt;&lt;p&gt;(1)Met
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%ADAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中Annotation/</id>
    <published>2018-08-06T10:25:49.000Z</published>
    <updated>2018-10-09T14:19:49.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Annotation简介"><a href="#1、Annotation简介" class="headerlink" title="1、Annotation简介"></a>1、Annotation简介</h3><p>(1)Annotation是Java5开始引入的新特性。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素(类、方法、成员变量等)进行关联。更通俗的意思就是为程序的元素(类、方法、成员变量)加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类、构造方法、方法、成员变量、参数及本地变量的声明语句中。按照运行机制划分包括源码注解、编译时注解和运行时注解；按照来源来划分的话包括JDK注解、第三方注解和自定义注解。</p><p>(2)Annotation的原理</p><p>1)Annotation其实是一种接口。通过Java反射机制中的相关API来访问annotation信息。相关类(框架或工具的类)根据这些信息来决定如何使用该程序元素或者改变他们的行为。Annotation是不会影响程序代码的执行的，无论Annotation怎么变化，代码都始终如一地执行。</p><p>2)Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。Annotation的工具统称APT(Annotation Processing Tool)。</p><h3 id="2、常见的标准Annotation-也称之为JDK注解，它们属于编译时注解"><a href="#2、常见的标准Annotation-也称之为JDK注解，它们属于编译时注解" class="headerlink" title="2、常见的标准Annotation(也称之为JDK注解，它们属于编译时注解)"></a>2、常见的标准Annotation(也称之为JDK注解，它们属于编译时注解)</h3><p>(1)@Override:@Override就是用来指定方法重写的，他可以强调一个子类必须要覆盖父类的方法。</p><p>(2)@Deprecated:@deprecated用于表示某个程序元素(类、方法等)已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</p><p>(3)@SuppressWarning：@SuppressWarning指示被Annotation标识的程序元素(以及在该程序元素中的所有子元素)取消显示指定的编译器警告。</p><p>(4)举例说明</p><p>1)@Override:可以防止方法名写错。</p><pre><code>package com.iotek.annotation;public class OVerrideDemo {    public static void main(String[] args) {        Apple apple = new Apple();        apple.info();    }}class Fruit{    public void info(){        System.out.println(&quot;描述水果的信息！&quot;);    }}class Apple extends Fruit{    @Override    public void info() {        System.out.println(&quot;我是苹果！&quot;);    }}</code></pre><p>2)@Deprecated:提示程序员不推荐使用</p><pre><code>package com.iotek.annotation;public class DeprecatedDemo {    public static void main(String[] args) {        Person person = new Person();        person.showInfo();    }}class Person{    @Deprecated    public void showInfo(){        System.out.println(&quot;hello person!&quot;);    }}</code></pre><p>3)@Suppresswarning:去除警告信息</p><pre><code>package com.iotek.annotation;public class SuppresswarningDemo {    public static void main(String[] args) {    }}class Container&lt;T&gt;{    private Object[] obj = null;    public Container(){        obj = new Object[10];    }    @SuppressWarnings(&quot;unchecked&quot;)    public T[] toArray(){        return (T[])obj;    }}</code></pre><h3 id="3、自定义Annotation"><a href="#3、自定义Annotation" class="headerlink" title="3、自定义Annotation"></a>3、自定义Annotation</h3><p>(1)语法</p><pre><code>访问修饰符 @interface Annotation名称{    返回类型 method() [默认值];}</code></pre><p>1)Annotation类型的方法必须声明为无参数、无异常抛出的。这些方法定义了Annotation的成员：方法名成为了成员名，而方法返回值成为了成员的类型。方法的返回类型必须要为基本数据类型、String类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一维数组。</p><p>2)方法的后面可以使用default和一个默认数值来声明成员的默认值来声明成员的默认值，null不能作为成员的默认值。在定义Annotation型态时，不能继承其他的Annotation型态或是接口。</p><p>(2)举例说明</p><pre><code>package com.iotek.annotation;//可以修饰类@MyAnnotation1public class MyAnnotation {    //可以修饰方法    @MyAnnotation1    @MyAnnotation3    public static void main(String[] args) {        //可以修饰成员变量，可以有多个注解        @MyAnnotation1        @MyAnnotation2(name=&quot;zhangsan&quot;)        @MyAnnotation3(&quot;haha&quot;)        @MyAnnotation4(sex=&quot;男&quot;,age=10)        @MyAnnotation5({&quot;haah&quot;,&quot;hehe&quot;,&quot;ee&quot;})        @MyAnnotation6(color=Color.RED)        int number = 10;    }}@interface MyAnnotation1{}@interface MyAnnotation2{    String name();}@interface MyAnnotation3{//value和默认值    String value() default &quot;lisi&quot;;//只有为value时才可以省略&quot;value=&quot;，有默认值时可以不给值。}@interface MyAnnotation4{//两个元素    String sex();    int age();}@interface MyAnnotation5{//数组    String[] value();}enum Color{    RED,BLUE,YELLOW;}@interface MyAnnotation6{//枚举类型    Color color();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Annotation简介&quot;&gt;&lt;a href=&quot;#1、Annotation简介&quot; class=&quot;headerlink&quot; title=&quot;1、Annotation简介&quot;&gt;&lt;/a&gt;1、Annotation简介&lt;/h3&gt;&lt;p&gt;(1)Annotation是Java5开始引
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中URL类的使用</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%ADURL%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中URL类的使用/</id>
    <published>2018-08-05T08:43:08.000Z</published>
    <updated>2018-08-05T08:48:25.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、URL概念"><a href="#1、URL概念" class="headerlink" title="1、URL概念"></a>1、URL概念</h3><p>URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。它由五个部分组成：</p><pre><code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#&lt;引用&gt;</code></pre><h3 id="2、URL编程"><a href="#2、URL编程" class="headerlink" title="2、URL编程"></a>2、URL编程</h3><p>(1)为了表示URL，java.net包中实现了类URL。我们可以通过下面的构造方法来初始化一个URL对象：</p><pre><code>URL(String url);//URL代表了一个绝对地址，URL对象直接指向这个资源。URL(URL baseURL,String relativeURL);//其中baseURL代表绝对地址，realtiveURL代表相对地址。URL(String protocol,String host,String file);//protocol代表通信协议，host代表主机名，file代表文件名。URL(String protocol,String host,int port,String file);</code></pre><p>(2)获取URL对象的属性：</p><pre><code>getFile();//获得URL指定资源的完整文件名。getHost();//返回主机名。getPath();//返回指定资源的文件目录和文件名。getPort();//返回端口号。getProtocol();//返回表示URL中协议的字符串对象。getRef();//返回URL的HTML文档标记，即#号标记。getUserInfo();//返回用户信息。</code></pre><p>(3)URL有两种方法可以用来访问Internet上的资源：</p><p>1)使用URL的openConnection()方法创建一个URLConnection类对象。再通过URLConnection对象获取相应的输入流和输出流。</p><p>2)利用URL类的openStream()方法。openStream()方法与指定的URL建立连接并返回InputStream类的对象。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.url;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class URLDemo {    public static void main(String[] args) throws IOException {        DownloadUtil.download(&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot;, &quot;baidu.jpg&quot;, &quot;f:\\test&quot;);        System.out.println(&quot;下载结束！&quot;);    }}class DownloadUtil{    public static void download(String urlString,String fileName,String savePath) throws IOException{        URL url = new URL(urlString);        /*URLConnection conn = url.openConnection();        InputStream inputStream = conn.getInputStream();*/        InputStream inputStream = url.openStream();        byte[] buff = new byte[1024*1024];        int len = 0;        File file = new File(savePath);        if(!file.exists()){            file.mkdirs();        }        OutputStream outputStream = new FileOutputStream(file.getAbsolutePath()+&quot;\\&quot;+fileName);        while((len = inputStream.read(buff))!=-1){            outputStream.write(buff, 0, len);        }        inputStream.close();        outputStream.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、URL概念&quot;&gt;&lt;a href=&quot;#1、URL概念&quot; class=&quot;headerlink&quot; title=&quot;1、URL概念&quot;&gt;&lt;/a&gt;1、URL概念&lt;/h3&gt;&lt;p&gt;URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于UDP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于UDP协议的Socket编程/</id>
    <published>2018-08-05T07:25:21.000Z</published>
    <updated>2018-08-05T08:47:04.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建发送端"><a href="#1、创建发送端" class="headerlink" title="1、创建发送端"></a>1、创建发送端</h3><p>(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可以手动指定。</p><p>(2)将数据进行packet包的封装，必须要指定目的地地址和端口。</p><p>(3)通过socket服务的send()方法将该包发出。</p><p>(4)将socket关闭。</p><h3 id="2、创建接收端"><a href="#2、创建接收端" class="headerlink" title="2、创建接收端"></a>2、创建接收端</h3><p>(1)建立DatagramSocket对象。要监听一个端口。</p><p>(2)通过socket的receive方法将数据存入数据包中。</p><p>(3)通过数据包dp的方法getData()、getAddress()、getPort()等方法获取包中的指定信息。</p><p>(4)将socket关闭。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)接收端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDPDemo2 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket(8000);        byte[] buff = new byte[100];        DatagramPacket packet = new DatagramPacket(buff, 100);        socket.receive(packet);//接收传来的数据包        System.out.println(new String(buff,0,packet.getLength()));        String string = &quot;Me too!&quot;;        DatagramPacket packet2 = new DatagramPacket(string.getBytes(), string.length(),packet.getAddress(),packet.getPort());        socket.send(packet2);        socket.close();    }}</code></pre><p>(2)发送端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPDemo1 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket();        String string = &quot;I Love You!&quot;;        //将数据进行封装，封装到数据包当中        DatagramPacket packet = new DatagramPacket(string.getBytes(), string.length(),InetAddress.getByName(&quot;localhost&quot;),8000);        socket.send(packet);//发送        byte[] buff = new byte[100];        DatagramPacket packet2 = new DatagramPacket(buff, 100);        socket.receive(packet2);        System.out.println(new String(buff,0,packet2.getLength()));        socket.close();    }}</code></pre><p>(3)为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . UDP*.java//开启接收端java com.iotek.tcpsocket.UDPDemo2//开启发送端，这里另外开启一个窗口java com.iotek.tcpsocket.UDPDemo1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、创建发送端&quot;&gt;&lt;a href=&quot;#1、创建发送端&quot; class=&quot;headerlink&quot; title=&quot;1、创建发送端&quot;&gt;&lt;/a&gt;1、创建发送端&lt;/h3&gt;&lt;p&gt;(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于TCP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于TCP协议的Socket编程/</id>
    <published>2018-08-05T03:38:19.000Z</published>
    <updated>2018-08-05T08:53:09.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Socket概述"><a href="#1、Socket概述" class="headerlink" title="1、Socket概述"></a>1、Socket概述</h3><p>(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。它是连接运行在网络上的两个程序间的双向通讯的端点。</p><p>(2)网络通讯其实指的就是socket间的通讯。通讯的两端都有socket，数据在两个socket之间通过IO来进行传输。</p><p>(3)使用socket进行网络通信的过程</p><pre><code>1)服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求。2)客户程序根据服务器程序所在的主机名和端口号发出连接请求。3)如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。4)客户和服务器通过读、写套接字进行通讯。</code></pre><h3 id="2、基于TCP协议的socket编程"><a href="#2、基于TCP协议的socket编程" class="headerlink" title="2、基于TCP协议的socket编程"></a>2、基于TCP协议的socket编程</h3><p>(1)创建TCP服务端步骤：</p><pre><code>1)创建一个ServerSocket对象2)调用accept()方法接受客户端请求3)从socket中获取IO流4)对IO流进行读写操作，完成与客户端的交互。5)关闭IO流和Socket</code></pre><p>(2)创建TCP客户端步骤：</p><pre><code>1)创建一个Socket对象2)从Socket中获取IO流3)对IO流进行读写操作，完成与服务端的交互4)关闭IO流和Socket</code></pre><p>注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。</p><p>(3)举例说明</p><p>1)服务器端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class TCPServer {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(8888);//创建一个ServerSocket对象        Socket socket = serverSocket.accept();//调用accept()方法来接受客户端的请求        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has connected!&quot;);        //获取socket对象的输入输出流        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        String line = null;        while((line = bReader.readLine())!=null){//读取客户端传过来的数据            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(line);            /*bWriter.write(line.toUpperCase());//把转换成大写的字符串传给客户端            bWriter.newLine();//换行，这样客户端才能知道输入什么时候结束的            bWriter.flush();*/            pWriter.println(line.toUpperCase());        }        //bWriter.close();        pWriter.close();        bReader.close();        socket.close();        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has disconnected!&quot;);    }}</code></pre><p>2)客户端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class TCPClient {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        BufferedReader bw = new BufferedReader(new InputStreamReader(socket.getInputStream()));        while(true){            String line = bReader.readLine();//获取键盘所输入的字符串            /*bWriter.write(line);            bWriter.newLine();//换行，这样服务端才能识别一行的结束            bWriter.flush();*/            pWriter.println(line);            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(bw.readLine());//获取服务端传来的大写字符串        }        bReader.close();        bw.close();        //bWriter.close();        pWriter.close();        socket.close();    }}</code></pre><p>为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . *.java//开启服务器java com.iotek.tcpsocket.TCPServer//开启客户端，这里另外开启一个窗口java com.iotek.tcpsocket.TCPClient</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Socket概述&quot;&gt;&lt;a href=&quot;#1、Socket概述&quot; class=&quot;headerlink&quot; title=&quot;1、Socket概述&quot;&gt;&lt;/a&gt;1、Socket概述&lt;/h3&gt;&lt;p&gt;(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中网络编程基础知识和通讯要素</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中网络编程基础知识和通讯要素/</id>
    <published>2018-08-05T02:25:36.000Z</published>
    <updated>2018-08-05T03:41:58.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、网络基础知识"><a href="#1、网络基础知识" class="headerlink" title="1、网络基础知识"></a>1、网络基础知识</h3><p>(1)计算机网络</p><p>计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能性强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p><p>(2)网络体系结构</p><p>网络体系结构定义计算机设备和其他设备如何连接在一起以形成一个允许用户共享信息和资源的通信系统。国际标准化组织ISO于1978年提出“开放系统互连参考模型”，即著名的OSI(Open System Interconnection)模型。OSI模型保证了各类设备生产厂家的产品兼容性。该模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>(3)TCP/IP协议</p><p>TCP/IP协议是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络接口层、网络层、传输层和应用层。</p><h3 id="2、网络通信要素"><a href="#2、网络通信要素" class="headerlink" title="2、网络通信要素"></a>2、网络通信要素</h3><p>(1)网络编程的目的</p><p>网络编程的目的就是指直接或者间接地通过网络协议与其他计算机进行通讯。网络编程中有两个主要问题，一个是如何准确的定位网络上一台或者多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。</p><p>(2)IP地址</p><p>网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。对应的类-InetAddress。</p><p>(3)端口号</p><p>端口号用来表示该计算机上的应用程序，代表此应用程序逻辑地址。端口号使用一个16位的数字来表示，它的范围是0~65535,1024以下的端口号保留给预定义的服务。例如：http使用80端口。</p><p>(4)协议</p><p>为计算机网络中进行数据交互而建立的规则、标准或约定的集合。</p><pre><code>TCP是一种面向连接的保证可靠传输的协议。UDP是一种无连接的且不可靠的传输协议。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、网络基础知识&quot;&gt;&lt;a href=&quot;#1、网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、网络基础知识&quot;&gt;&lt;/a&gt;1、网络基础知识&lt;/h3&gt;&lt;p&gt;(1)计算机网络&lt;/p&gt;
&lt;p&gt;计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的RandomAccessFile</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84RandomAccessFile/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的RandomAccessFile/</id>
    <published>2018-08-04T08:47:03.000Z</published>
    <updated>2018-08-04T08:47:37.658Z</updated>
    
    <content type="html"><![CDATA[<p>1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。</p><p>2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，随着对字节的写入而前移此文件指针。</p><p>3、写入该隐含数组末尾之后的输出操作导致该数组扩展。该文件指针可以通过getFilePointer方法读取，通过seek方法设置该文件指针的位置。</p><p>4、RandomAccessFile举例</p><pre><code>package com.iotek.otherio;import java.io.IOException;import java.io.RandomAccessFile;import java.util.Scanner;public class RandomAccessFileDemo {    public static void main(String[] args) throws IOException {        Person[] persons = {new Person(&quot;chenhao&quot;,90),                new Person(&quot;justin&quot;,30),new Person(&quot;bush&quot;,80),                new Person(&quot;lisi&quot;,20)};        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;f:\\test\\3.txt&quot;, &quot;rw&quot;);        /*for(int i=0;i&lt;persons.length;i++){//写入数据到RandomAccessFile这个对象中            randomAccessFile.writeChars(persons[i].getName());            randomAccessFile.writeInt(persons[i].getAge());        }*/        //读取指定位置上的Person对象        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;读取第几个Person对象数据&quot;);        int num = scanner.nextInt();        //使用seek方法来操作存取位置        randomAccessFile.seek((num-1)*Person.size());        Person person = new Person();        person.setName(readName(randomAccessFile));        person.setAge(randomAccessFile.readInt());        System.out.println(&quot;姓名:&quot;+person.getName());        System.out.println(&quot;年龄:&quot;+person.getAge());        randomAccessFile.close();    }    private static String readName(RandomAccessFile randomAccessFile) throws IOException{        char[] name = new char[15];        for(int i=0;i&lt;name.length;i++){            name[i] = randomAccessFile.readChar();         }        return new String(name).replace(&apos;\u0000&apos;, &apos; &apos;);    }}class Person{    private String name;    private int age;    public Person(){    }    public Person(String name, int age) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //每个对象所占的字节数    public static int size(){        return 34;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。&lt;/p&gt;
&lt;p&gt;2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中其他的IO流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84IO%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中其他的IO流/</id>
    <published>2018-08-04T07:45:54.000Z</published>
    <updated>2018-08-04T07:46:30.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、ObjectInputStream和ObjectOutputStream"><a href="#1、ObjectInputStream和ObjectOutputStream" class="headerlink" title="1、ObjectInputStream和ObjectOutputStream"></a>1、ObjectInputStream和ObjectOutputStream</h3><p>ObjectInputStream和ObjectOutputStream分别与FileInputStream和FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。我们把对象以某种特定的编码格式写入称之为“序列化”。把写入的编码格式内容还原成对象称之为“反序列化”。被序列化的对象必须实现Serializable接口。</p><pre><code>package com.iotek.otherio;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectInputOutputDemo {    public static void main(String[] args) throws IOException {        /*Student student = new Student(&quot;zhangsan&quot;, 30);        FileOutputStream fos = new FileOutputStream(&quot;f:\\test\\1.txt&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);        objectOutputStream.writeObject(student);//把对象序列化到指定的文件输出流中        objectOutputStream.close();//释放资源*/            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;f:\\test\\1.txt&quot;));        try {            Student student = (Student)objectInputStream.readObject();            System.out.println(student);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class Student implements Serializable{//需要实现Serializable接口    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="2、InputStreamReader和OutputStreamWriter"><a href="#2、InputStreamReader和OutputStreamWriter" class="headerlink" title="2、InputStreamReader和OutputStreamWriter"></a>2、InputStreamReader和OutputStreamWriter</h3><p>转换流是指将字节流与字符流之间进行转换。转换流的出现方便了对文件的读写，它在字符流与字节流之间架起了一座桥梁，使原本毫无关联的两种操作能够进行转化，提高了程序的灵活性。字节流中的数据都是字符时，转化成字符流操作更高效。如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式的参数，而FileReader与FileWriter是默认编码的文本文件。</p><pre><code>package com.iotek.otherio;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputStreamWriterReaderDemo {    public static void main(String[] args) throws IOException {        /*OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;f:\\test\\2.txt&quot;), &quot;utf-8&quot;);        BufferedWriter bw = new BufferedWriter(osw);        bw.write(&quot;您好&quot;);        bw.close();*/        /*BufferedReader br = new BufferedReader(new FileReader(&quot;f:\\test\\2.txt&quot;));        String line = null;        while((line = br.readLine())!=null){            System.out.println(line);        }        br.close();*/        BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;f:\\test\\2.txt&quot;),&quot;utf-8&quot;));        String line = null;        while((line = bReader.readLine())!=null){            System.out.println(line);        }        bReader.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、ObjectInputStream和ObjectOutputStream&quot;&gt;&lt;a href=&quot;#1、ObjectInputStream和ObjectOutputStream&quot; class=&quot;headerlink&quot; title=&quot;1、ObjectInputStr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的字符流/</id>
    <published>2018-08-04T06:03:29.000Z</published>
    <updated>2018-08-04T06:32:10.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Reader和Writer抽象类"><a href="#1、Reader和Writer抽象类" class="headerlink" title="1、Reader和Writer抽象类"></a>1、Reader和Writer抽象类</h3><p>字节流提供处理任何类型输入输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。字符流层次结构的顶层是Reader和Writer抽象类，它们的顶层仍然是字节流。Reader是定义Java的流式字符输入模式的抽象类。Reader抽象类中的方法和InputStream类似。Writer是定义Java的流式字符输出模式的抽象类。该类的方法都返回void值并在出错条件下抛IOException异常。Writer抽象类中的方法和OutputStream类似。</p><h3 id="2、FileReader和FileWriter"><a href="#2、FileReader和FileWriter" class="headerlink" title="2、FileReader和FileWriter"></a>2、FileReader和FileWriter</h3><p>FileReader类表示可以读取文件内容的Reader类，构造方法有：</p><pre><code>FileReader(String filePath)FileReader(File fileObj)</code></pre><p>FileWriter表示可以写文件的Writer类，构造方法有：</p><pre><code>FileWriter(String filePath)FileWriter(String filePath,boolean append)FileWriter(File fileObj)</code></pre><h3 id="3、FileReader和FileWriter举例"><a href="#3、FileReader和FileWriter举例" class="headerlink" title="3、FileReader和FileWriter举例"></a>3、FileReader和FileWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        char[] buffer = new char[100];        FileWriter fWriter = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        int len = 0;//实际读到的字符个数        while((len = fr.read(buffer))!=-1){            fWriter.write(buffer,0,len);        }        fr.close();        fWriter.close();    }}</code></pre><h3 id="4、BufferedReader和BufferedWriter"><a href="#4、BufferedReader和BufferedWriter" class="headerlink" title="4、BufferedReader和BufferedWriter"></a>4、BufferedReader和BufferedWriter</h3><p>BufferedReader通过缓冲区提高输入性能。BufferedWriter则通过缓冲区提高输出性能。类似于BufferedInputStream和BufferedOutputStream。分别都具有两个构造方法：</p><pre><code>BufferedReader(Reader inputStream)BufferedReader(Reader inputStream,int bufSize)BufferedWriter(Writer ouputStream)BufferedWriter(Writer outputStream,int bufSize)</code></pre><h3 id="5、BufferedReader和BufferedWriter举例"><a href="#5、BufferedReader和BufferedWriter举例" class="headerlink" title="5、BufferedReader和BufferedWriter举例"></a>5、BufferedReader和BufferedWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class BufferedReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        FileWriter fw = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        BufferedReader bReader = new BufferedReader(fr);        BufferedWriter bWriter = new BufferedWriter(fw);        String line = null;        while((line=bReader.readLine())!=null){            System.out.println(line);            bWriter.write(line);//写入一行            bWriter.newLine();//换行            //bWriter.flush();//不使用close()方法时需要使用此方法        }        bReader.close();        bWriter.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;a href=&quot;#1、Reader和Writer抽象类&quot; class=&quot;headerlink&quot; title=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;/a&gt;1、Reader和Writer抽象类&lt;/h3&gt;&lt;p&gt;字节流提供处
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
</feed>
