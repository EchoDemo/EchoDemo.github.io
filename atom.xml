<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-07-28T13:58:29.224Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springmvc学习笔记(16)-异常处理器</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(16)-异常处理器/</id>
    <published>2019-07-28T13:47:57.000Z</published>
    <updated>2019-07-28T13:58:29.224Z</updated>
    
    <content type="html"><![CDATA[<center>窗间梅熟落蒂，墙下笋成出林。</center><br><center>连雨不知春去，一晴方觉夏深。</center><br><center>—-宋·范成大《喜晴》</center><hr><p>本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置。</p><hr><h3 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h3><p>系统中异常包括两类：</p><pre><code>1、预期异常。2、运行时异常RuntimeException。</code></pre><p>前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。</p><p><strong>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</strong></p><hr><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>对不同的异常类型定义异常类，继承Exception。</p><pre><code>public class CustomException  extends  Exception{    //异常信息    public String message;    public CustomException(String message){        super(message);        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }}</code></pre><hr><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>思路：</p><p>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</p><p>全局异常处理器处理思路：</p><p>解析出异常类型</p><pre><code>1、如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示。2、如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）。</code></pre><p>springmvc提供一个HandlerExceptionResolver接口：</p><pre><code>public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        //handler就是处理器适配器要执行Handler对象（只有method）        //解析出异常类型        //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示        //String message = null;        //if(ex instanceof CustomException){            //message = ((CustomException)ex).getMessage();        //}else{            ////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）            //message=&quot;未知错误&quot;;        //}        //上边代码变为        CustomException customException;        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            customException = new CustomException(&quot;未知错误&quot;);        }        //错误信息        String message = customException.getMessage();        ModelAndView modelAndView = new ModelAndView();        //将错误信息传到页面        modelAndView.addObject(&quot;message&quot;, message);        //指向错误页面        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><hr><h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Brian  Date: 2016/3/4  Time: 10:51  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${message}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="在springmvc-xml配置全局异常处理器"><a href="#在springmvc-xml配置全局异常处理器" class="headerlink" title="在springmvc.xml配置全局异常处理器"></a>在springmvc.xml配置全局异常处理器</h3><pre><code>&lt;!-- 全局异常处理器只要实现HandlerExceptionResolver接口就是全局异常处理器--&gt;&lt;bean class=&quot;com.iot.learnssm.firstssm.exception.CustomExceptionResolver&quot;&gt;&lt;/bean&gt;</code></pre><p><strong>全局异常处理器只有一个，配置多个也没用。</strong></p><hr><h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。</p><p>(1)在商品修改的controller方法中抛出异常</p><pre><code>public String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {    //调用service根据商品id查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);    //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在    if(itemsCustom == null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //通过形参中的model将model数据传到页面    //相当于modelAndView.addObject方法    model.addAttribute(&quot;items&quot;, itemsCustom);    return &quot;items/editItems&quot;;}</code></pre><p>(2)在service接口中抛出异常</p><pre><code>public ItemsCustom findItemsById(Integer id) throws Exception {    Items items = itemsMapper.selectByPrimaryKey(id);    if(items==null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //中间对商品信息进行业务处理    //....    //返回ItemsCustom    ItemsCustom itemsCustom = null;    //将items的属性值拷贝到itemsCustom    if(items!=null){        itemsCustom = new ItemsCustom();        BeanUtils.copyProperties(items, itemsCustom);    }    return itemsCustom;}</code></pre><p>1、如果与业务功能相关的异常，建议在service中抛出异常。</p><p>2、与业务功能没有关系的异常，建议在controller中抛出。</p><p>上边的功能，建议在service中抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;窗间梅熟落蒂，墙下笋成出林。&lt;/center&gt;&lt;br&gt;&lt;center&gt;连雨不知春去，一晴方觉夏深。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·范成大《喜晴》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文主要介绍springmvc中异常处理的思路，并展示如何自定义
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(15)-数据回显</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)-%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(15)-数据回显/</id>
    <published>2019-07-28T13:33:23.000Z</published>
    <updated>2019-07-28T13:46:51.460Z</updated>
    
    <content type="html"><![CDATA[<center>阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。</center><br><center>待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。</center><br><center>—-近代·王国维《蝶恋花·阅尽天涯离别苦》</center><hr><p>本文介绍springmvc中数据回显的几种实现方法</p><p>数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。</p><hr><h3 id="pojo数据回显方法"><a href="#pojo数据回显方法" class="headerlink" title="pojo数据回显方法"></a>pojo数据回显方法</h3><p>（1）springmvc默认对pojo数据进行回显。</p><p>pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）。使用@ModelAttribute(“items”)指定pojo回显到页面在request中的key。这里的items对应的是前端页面里面的input中的name=”items.name”中的items。</p><p>（2）@ModelAttribute还可以将方法的返回值传到页面。在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。（请注意，这里并没有指定RequestMapping）</p><pre><code>// 商品分类// itemtypes表示最终将方法返回值放在request中的key@ModelAttribute(&quot;itemtypes&quot;)public Map&lt;String, String&gt; getItemTypes() {    Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;();    itemTypes.put(&quot;101&quot;, &quot;数码&quot;);    itemTypes.put(&quot;102&quot;, &quot;母婴&quot;);    return itemTypes;}</code></pre><p>页面上可以得到itemTypes数据。</p><pre><code>&lt;td&gt;    商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt;    商品类型：    &lt;select name=&quot;itemtype&quot;&gt;        &lt;c:forEach items=&quot;${itemtypes}&quot; var=&quot;itemtype&quot;&gt;            &lt;option value=&quot;${itemtype.key }&quot;&gt;${itemtype.value }&lt;/option&gt;        &lt;/c:forEach&gt;    &lt;/select&gt;&lt;/td&gt;</code></pre><p>（3）使用最简单方法:使用model，可以不用@ModelAttribute，(对应的是小标题（1）哦！)</p><pre><code>// 可以直接使用model将提交pojo回显到页面// model.addAttribute(&quot;items&quot;, itemsCustom);</code></pre><hr><h3 id="简单类型数据回显"><a href="#简单类型数据回显" class="headerlink" title="简单类型数据回显"></a>简单类型数据回显</h3><p>使用最简单方法使用model：</p><pre><code>model.addAttribute(&quot;id&quot;, id);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-近代·王国维《蝶恋花·阅尽天涯离别苦
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(14)-springmvc校验</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)-springmvc%E6%A0%A1%E9%AA%8C/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(14)-springmvc校验/</id>
    <published>2019-07-28T11:31:31.000Z</published>
    <updated>2019-07-28T12:35:08.839Z</updated>
    
    <content type="html"><![CDATA[<center>病起萧萧两鬓华，卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。</center><br><center>枕上诗书闲处好，门前风景雨来佳。终日向人多酝藉，木犀花。</center><br><center>—-宋·李清照《摊破浣溪沙·病起萧萧两鬓华》</center><hr><p>本文主要介绍springmvc校验，包括环境准备，校验器配置，pojo张添加校验规则，捕获和显示检验错误信息以及分组校验简单示例。</p><hr><h3 id="校验理解"><a href="#校验理解" class="headerlink" title="校验理解"></a>校验理解</h3><p>项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。</p><p>服务端校验：</p><pre><code>1、控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）。2、业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。3、持久层dao：一般是不校验的。</code></pre><hr><h3 id="springmvc校验需求"><a href="#springmvc校验需求" class="headerlink" title="springmvc校验需求"></a>springmvc校验需求</h3><p>springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。</p><p>校验思路：</p><p>页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。</p><p>具体需求：</p><p>商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。</p><hr><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我们需要三个jar包：</p><pre><code>1、hibernate-validator.jar2、jboss-logging.jar3、validation-api.jar</code></pre><p>这里我们添加maven依赖：</p><pre><code>&lt;!-- hibernate 校验 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>查看maven依赖树：</p><pre><code>[INFO] \- org.hibernate:hibernate-validator:jar:5.2.4.Final:compile[INFO]    +- javax.validation:validation-api:jar:1.1.0.Final:compile[INFO]    +- org.jboss.logging:jboss-logging:jar:3.2.1.Final:compile[INFO]    \- com.fasterxml:classmate:jar:1.1.0:compile</code></pre><p>可以看到，另外两个jar包被hibernate-validator依赖，所以不用再额外添加了。</p><hr><h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p>（1）在springmvc.xml中添加</p><pre><code>&lt;!-- 校验器 --&gt;&lt;bean id=&quot;validator&quot;      class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;    &lt;!-- hibernate校验器--&gt;    &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt;    &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt;    &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id=&quot;messageSource&quot;      class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;    &lt;!-- 资源文件名--&gt;    &lt;property name=&quot;basenames&quot;&gt;        &lt;list&gt;            &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- 资源文件编码格式 --&gt;    &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot; /&gt;    &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;    &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot; /&gt;&lt;/bean&gt;</code></pre><p>（2)校验器注入到处理器适配器中</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;                       validator=&quot;validator&quot;&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>(3)在CustomValidationMessages.properties配置校验错误信息：</p><pre><code>#添加校验的错误提示信息items.name.length.error=请输入1到30个字符的商品名称items.createtime.isNUll=请输入商品的生产日期</code></pre><hr><h3 id="在pojo中添加校验规则"><a href="#在pojo中添加校验规则" class="headerlink" title="在pojo中添加校验规则"></a>在pojo中添加校验规则</h3><p>(1)在ItemsCustom.java中添加校验规则：</p><pre><code>public class Items {    private Integer id;    //校验名称在1到30字符中间    //message是提示校验出错显示的信息    //groups：此校验属于哪个分组，groups可以定义多个分组    @Size(min=1,max=30,message=&quot;{items.name.length.error}&quot;)    private String name;    private Float price;    private String pic;    //非空校验    @NotNull(message=&quot;{items.createtime.isNUll}&quot;)    private Date createtime;)</code></pre><hr><h3 id="捕获和显示校验错误信息"><a href="#捕获和显示校验错误信息" class="headerlink" title="捕获和显示校验错误信息"></a>捕获和显示校验错误信息</h3><pre><code>@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @Validated ItemsCustom itemsCustom,        BindingResult bindingResult)throws Exception {}</code></pre><p>(1)在controller中将错误信息传到页面即可</p><pre><code>//获取校验错误信息if(bindingResult.hasErrors()){    // 输出错误信息    List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();    for (ObjectError objectError :allErrors){        // 输出错误信息        System.out.println(objectError.getDefaultMessage());    }    // 将错误信息传到页面    model.addAttribute(&quot;allErrors&quot;, allErrors);    //可以直接使用model将提交pojo回显到页面    model.addAttribute(&quot;items&quot;, itemsCustom);    // 出错重新到商品修改页面    return &quot;items/editItems&quot;;}</code></pre><p>(2)页面显示错误信息：</p><pre><code>&lt;!-- 显示错误信息 --&gt;&lt;c:if test=&quot;${allErrors!=null }&quot;&gt;    &lt;c:forEach items=&quot;${allErrors }&quot; var=&quot;error&quot;&gt;        ${ error.defaultMessage}&lt;br/&gt;    &lt;/c:forEach&gt;&lt;/c:if&gt;</code></pre><hr><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>需求： </p><p>在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验。</p><p>解决方法： </p><p>定义多个校验分组（其实是一个java接口），分组中定义有哪些规则，每个controller方法使用不同的校验分组。</p><p>1.校验分组</p><pre><code>public interface ValidGroup1 {    //接口中不需要定义任何方法，仅是对不同的校验规则进行分组    //此分组只校验商品名称长度}</code></pre><p>2.在校验规则中添加分组</p><pre><code>//校验名称在1到30字符中间//message是提示校验出错显示的信息//groups：此校验属于哪个分组，groups可以定义多个分组@Size(min=1,max=30,message=&quot;{items.name.length.error}&quot;,groups = {ValidGroup1.class})private String name;</code></pre><p>3.在controller方法使用指定分组的校验</p><pre><code>// value={ValidGroup1.class}指定使用ValidGroup1分组的校验@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,        BindingResult bindingResult)throws Exception {}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;病起萧萧两鬓华，卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。&lt;/center&gt;&lt;br&gt;&lt;center&gt;枕上诗书闲处好，门前风景雨来佳。终日向人多酝藉，木犀花。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·李清照《摊破浣溪沙·病起萧萧两鬓华》&lt;/center&gt;

&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/26/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/26/springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定/</id>
    <published>2019-07-26T14:24:12.000Z</published>
    <updated>2019-07-27T06:58:51.088Z</updated>
    
    <content type="html"><![CDATA[<center>大鹏一日同风起，扶摇直上九万里。</center><br><center>假令风歇时下来，犹能簸却沧溟水。</center><br><center>世人见我恒殊调，闻余大言皆冷笑。</center><br><center>宣父犹能畏后生，丈夫未可轻年少。</center><br><center>—-唐·李白《上李邕》</center><hr><h3 id="数组绑定"><a href="#数组绑定" class="headerlink" title="数组绑定"></a>数组绑定</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>商品批量删除，用户在页面选择多个商品，批量删除。</p><h4 id="表现层实现"><a href="#表现层实现" class="headerlink" title="表现层实现"></a>表现层实现</h4><p>关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。</p><p>（1）controller方法定义：</p><pre><code>// 批量删除 商品信息@RequestMapping(&quot;/deleteItems&quot;)public String deleteItems(Integer[] items_id) throws Exception{}</code></pre><p>(2)页面定义：</p><pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;items_id&quot; value=&quot;${item.id}&quot;/&gt;&lt;/td&gt;    &lt;td&gt;${item.name }&lt;/td&gt;    &lt;td&gt;${item.price }&lt;/td&gt;    &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;    &lt;td&gt;${item.detail }&lt;/td&gt;    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/items/editItems.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><hr><h3 id="list绑定"><a href="#list绑定" class="headerlink" title="list绑定"></a>list绑定</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>通常在需要批量提交数据时，将提交的数据绑定到list<pojo>中，比如：成绩录入（录入多门课成绩，批量提交），</pojo></p><p>本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。</p><h4 id="表现层实现-1"><a href="#表现层实现-1" class="headerlink" title="表现层实现"></a>表现层实现</h4><p>(1)controller方法定义： </p><pre><code>进入批量商品修改页面(页面样式参考商品列表实现)。批量修改商品提交。</code></pre><p>使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list<pojo>属性</pojo></p><pre><code>public class ItemsQueryVo {    //商品信息    private Items items;    //为了系统 可扩展性，对原始生成的po进行扩展    private ItemsCustom itemsCustom;    //批量商品信息    private List&lt;ItemsCustom&gt; itemsList;}// 批量修改商品提交// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。@RequestMapping(&quot;/editItemsAllSubmit&quot;)public String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception {    return &quot;success&quot;;}</code></pre><p>（2）页面定义：</p><pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].name&quot; value=&quot;${item.name }&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].price&quot; value=&quot;${item.price }&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].createtime&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].detail&quot; value=&quot;${item.detail }&quot;/&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>（3）name的格式：</p><p>对应包装pojo中的list类型属性名[下标(从0开始)].包装pojo中List类型的属性中pojo的属性名</p><p>例子：</p><p>“name=”itemsList[${status.index }].price”</p><p>可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。</p><hr><h3 id="map绑定"><a href="#map绑定" class="headerlink" title="map绑定"></a>map绑定</h3><p>也通过在包装pojo中定义map类型属性。在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。 </p><p>（1）包装类中定义Map对象如下：</p><pre><code>Public class QueryVo {    private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();      //get/set方法...}</code></pre><p>(2)页面定义如下：</p><pre><code>&lt;tr&gt;    &lt;td&gt;学生信息：&lt;/td&gt;    &lt;td&gt;        姓名：&lt;inputtype=&quot;text&quot; name=&quot;itemInfo[&apos;name&apos;]&quot;/&gt;        年龄：&lt;inputtype=&quot;text&quot; name=&quot;itemInfo[&apos;price&apos;]&quot;/&gt;        .. .. ..    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>(3)Contrller方法定义如下：</p><pre><code>public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{    System.out.println(queryVo.getStudentinfo());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;大鹏一日同风起，扶摇直上九万里。&lt;/center&gt;&lt;br&gt;&lt;center&gt;假令风歇时下来，犹能簸却沧溟水。&lt;/center&gt;&lt;br&gt;&lt;center&gt;世人见我恒殊调，闻余大言皆冷笑。&lt;/center&gt;&lt;br&gt;&lt;center&gt;宣父犹能畏后生，丈夫未可轻年少。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/26/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/26/springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定/</id>
    <published>2019-07-26T14:13:43.000Z</published>
    <updated>2019-07-26T14:20:07.138Z</updated>
    
    <content type="html"><![CDATA[<center>自君之出矣，不复理残机。</center><br><center>思君如满月，夜夜减清辉。</center><br><center>—-唐·张九龄《赋得自君之出矣》</center><hr><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>商品查询controller方法中实现商品查询条件传入。</p><hr><pre><code>第一种方法：在形参中添加HttpServletRequest request参数，通过request接收查询条件参数。第二种方法：在形参中让包装类型的pojo接收查询条件参数。</code></pre><p>分析：</p><p>页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。</p><p>如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。</p><hr><h3 id="页面参数和controller方法形参定义"><a href="#页面参数和controller方法形参定义" class="headerlink" title="页面参数和controller方法形参定义"></a>页面参数和controller方法形参定义</h3><p>（1）页面参数：</p><p>商品名称：<input name="itemsCustom.name"></p><p>注意：itemsCustom和包装pojo中的属性名一致即可。</p><p>（2）controller方法形参：</p><pre><code>public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception</code></pre><p>（3）包装类ItemsQueryVo中部分属性：</p><pre><code>public class ItemsQueryVo {    //商品信息    private Items items;    //为了系统 可扩展性，对原始生成的po进行扩展    private ItemsCustom itemsCustom;}</code></pre><p>可见，ItemsQueryVo中属性itemsCustom和页面参数中一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;自君之出矣，不复理残机。&lt;/center&gt;&lt;br&gt;&lt;center&gt;思君如满月，夜夜减清辉。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-唐·张九龄《赋得自君之出矣》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(11)-springmvc注解开发之简单参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/23/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/23/springmvc学习笔记(11)-springmvc注解开发之简单参数绑定/</id>
    <published>2019-07-23T14:58:37.000Z</published>
    <updated>2019-07-24T15:49:31.618Z</updated>
    
    <content type="html"><![CDATA[<center>秋风起兮白云飞，草木黄落兮雁南归。</center><br><center>兰有秀兮菊有芳，怀佳人兮不能忘。</center><br><center>泛楼船兮济汾河，横中流兮扬素波。</center><br><center>箫鼓鸣兮发棹歌，欢乐极兮哀情多。</center><br><center>少壮几时兮奈老何！</center><br><center>—-两汉·刘彻《秋风辞》</center><hr><p>本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换</p><hr><h3 id="spring参数绑定过程"><a href="#spring参数绑定过程" class="headerlink" title="spring参数绑定过程"></a>spring参数绑定过程</h3><p>从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变量接收！！！！</p><p>处理器适配器调用springmvc提供参数绑定组件将key/value数据转成controller方法的形参。在springmvc早期版本使用PropertyEditor(只能将字符串转化成java对象)，后期使用converter(进行任意类型的转换)，在特殊情况下需要自定义converter。</p><hr><h3 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h3><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p><pre><code>1、HttpServletRequest：通过request对象获取请求信息。2、HttpServletResponse：通过response处理响应信息。3、HttpSession：通过session对象得到session中存放的对象。4、Model/ModelMap：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。</code></pre><hr><h3 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h3><p>通过@RequestParam对简单类型的参数进行绑定。如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</p><p>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</p><p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。</p><pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})//@RequestParam里边指定request传入参数名称(即下边的value=&quot;id&quot;)和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。public String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {}</code></pre><hr><h3 id="pojo绑定"><a href="#pojo绑定" class="headerlink" title="pojo绑定"></a>pojo绑定</h3><p>页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。</p><p>注意:这里只是要求name和形参的属性名一致，而不是要求和形参的名称一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的)</p><p>(1)页面定义：</p><pre><code>&lt;table width=&quot;100%&quot; border=1&gt;&lt;tr&gt;    &lt;td&gt;商品名称&lt;/td&gt;    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${itemsCustom.name }&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;商品价格&lt;/td&gt;    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${itemsCustom.price }&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><p>(2)controller的pojo形参的定义：</p><pre><code>public class Items {    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    ......}</code></pre><p>（3）为了防止前端传入的中文数据出现乱码问题，使用Spring提供的编码过滤器来统一编码，在web.xml中添加如下代码：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>（4）以上可以解决post请求乱码问题，对于get请求中文参数出现乱码解决方法有两个：</p><p>a、修改tomcat配置文件添加编码与工程编码一致：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>b、对接收的参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p><strong>其中IOS8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8重新编码。</strong></p><hr><h3 id="自定义参数绑定实现日期类型绑定"><a href="#自定义参数绑定实现日期类型绑定" class="headerlink" title="自定义参数绑定实现日期类型绑定"></a>自定义参数绑定实现日期类型绑定</h3><p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。</p><p>将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成java.util.Date类型。需要向处理器适配器中注入自定义的参数绑定组件。</p><p>(1)自定义日期类型绑定:</p><pre><code>public class CustomDateConverter implements Converter&lt;String,Date&gt;{    public Date convert(String s) {        //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        try {            //转成直接返回            return simpleDateFormat.parse(s);        } catch (ParseException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        //如果参数绑定失败返回null        return null;    }}</code></pre><p>(2)配置方式</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 自定义参数绑定 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;!-- 转换器 --&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;!-- 日期类型转换 --&gt;            &lt;bean class=&quot;com.echodemo.springmvcmybatis.controller.converter.CustomDateConverter&quot;/&gt;       &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="springmvc和struts2的区别"><a href="#springmvc和struts2的区别" class="headerlink" title="springmvc和struts2的区别"></a>springmvc和struts2的区别</h3><p>（1）springmvc基于方法开发的，struts2基于类开发的。springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。</p><p>（2）springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。</p><p>（3）经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;秋风起兮白云飞，草木黄落兮雁南归。&lt;/center&gt;&lt;br&gt;&lt;center&gt;兰有秀兮菊有芳，怀佳人兮不能忘。&lt;/center&gt;&lt;br&gt;&lt;center&gt;泛楼船兮济汾河，横中流兮扬素波。&lt;/center&gt;&lt;br&gt;&lt;center&gt;箫鼓鸣兮发棹歌，欢乐极兮哀情多。&lt;/ce
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(10)-springmvc注解开发之商品修改功能</title>
    <link href="http://www.echodemo.cc/2019/07/23/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E5%95%86%E5%93%81%E4%BF%AE%E6%94%B9%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.echodemo.cc/2019/07/23/springmvc学习笔记(10)-springmvc注解开发之商品修改功能/</id>
    <published>2019-07-23T14:27:09.000Z</published>
    <updated>2019-07-23T14:57:05.667Z</updated>
    
    <content type="html"><![CDATA[<center>劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。 </center><br><center>须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。</center><br><center>—-唐·韦庄《《菩萨蛮·劝君今夜须沉醉》》</center><hr><p>本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,@RequestMapping,controller方法的返回值等。</p><hr><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><pre><code>1、进入商品查询列表页面。2、点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息。3、在商品修改页面，修改商品信息，修改后，点击提交。</code></pre><h3 id="开发mapper"><a href="#开发mapper" class="headerlink" title="开发mapper"></a>开发mapper</h3><p>1、根据id查询商品信息</p><p>2、根据id更新Items表的数据</p><hr><h3 id="开发service"><a href="#开发service" class="headerlink" title="开发service"></a>开发service</h3><p>（1）在com.echodemo.springmvcmybatis.service.ItemsService中添加两个接口。</p><pre><code>//根据id查询商品信息ItemsCustom findItemsById(Integer id) throws Exception;//修改商品信息void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;</code></pre><p>（2）在com.echodemo.springmvcmybatis.service..impl.ItemsServiceImpl中实现接口，增加itemsMapper属性。</p><pre><code>@Autowiredprivate ItemsMapper itemsMapper;public ItemsCustom findItemsById(Integer id) throws Exception {    Items items = itemsMapper.selectByPrimaryKey(id);    //中间对商品信息进行业务处理    //....    //返回ItemsCustom    ItemsCustom itemsCustom = new ItemsCustom();    //将items的属性值拷贝到itemsCustom    BeanUtils.copyProperties(items, itemsCustom);    return itemsCustom;}public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {    //添加业务校验，通常在service接口对关键参数进行校验    //校验 id是否为空，如果为空抛出异常    //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段    //updateByPrimaryKeyWithBLOBs要求必须转入id    itemsCustom.setId(id);    itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);}</code></pre><hr><h3 id="开发controller"><a href="#开发controller" class="headerlink" title="开发controller"></a>开发controller</h3><pre><code>//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action//@RequestMapping(&quot;/items&quot;)public class ItemsController {    @Autowired    private ItemsService itemsService;    //商品查询列表    @RequestMapping(&quot;/queryItems&quot;)    //实现 对queryItems方法和url进行映射，一个方法对应一个url    //一般建议将url和方法写成一样    public ModelAndView queryItems() throws Exception{        //调用service查找数据库，查询商品列表        List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null);        //返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;,itemsList);        //指定视图        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList        //modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀        modelAndView.setViewName(&quot;items/itemsList&quot;);        return modelAndView;    }    //商品信息修改页面显示    @RequestMapping(&quot;/editItems&quot;)    //限制http请求方法，可以post和get    //@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})    public ModelAndView editItems()throws Exception {        //调用service根据商品id查询商品信息        ItemsCustom itemsCustom = itemsService.findItemsById(1);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //将商品信息放到model        modelAndView.addObject(&quot;itemsCustom&quot;, itemsCustom);        //商品修改页面        modelAndView.setViewName(&quot;items/editItems&quot;);        return modelAndView;    }    //商品信息修改提交    @RequestMapping(&quot;/editItemsSubmit&quot;)    public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception {        //调用service更新商品信息，页面需要将商品信息传到此方法        itemsService.updateItems(id, itemsCustom);        //返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //返回一个成功页面        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    }}</code></pre><hr><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>（1）URL映射</p><p>定义controller方法对应的url，进行处理器映射使用。</p><p>（2）窄化请求映射</p><pre><code>//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action@RequestMapping(&quot;/items&quot;)public class ItemsController {}</code></pre><p>（3）限制http请求方法</p><pre><code>//商品信息修改页面显示//@RequestMapping(&quot;/editItems&quot;)//限制http请求方法，可以post和get@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})public ModelAndView editItems()throws Exception {}</code></pre><hr><h3 id="controller方法的返回值"><a href="#controller方法的返回值" class="headerlink" title="controller方法的返回值"></a>controller方法的返回值</h3><p>（1）返回ModelAndView</p><p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</p><p>（2）返回string</p><p>如果controller方法返回string：</p><p>a、表示返回逻辑视图名：</p><p><strong>真正视图(jsp路径)=前缀+逻辑视图名+后缀</strong></p><pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})//@RequestParam里边指定request传入参数名称和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。//public String editItems(Model model, @RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {public String editItems(Model model)throws Exception {    //调用service根据商品id查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(1);    //通过形参中的model将model数据传到页面    //相当于modelAndView.addObject方法    model.addAttribute(&quot;itemsCustom&quot;, itemsCustom);    return &quot;items/editItems&quot;;}</code></pre><p>b、redirect重定向</p><p>商品修改提交后，重定向到商品查询列表。</p><p>redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）</p><pre><code>//重定向到商品查询列表//return &quot;redirect:queryItems.action&quot;;</code></pre><p>c、forward页面转发</p><p>通过forward进行页面转发，浏览器地址栏url不变，request可以共享。</p><pre><code>//页面转发return &quot;forward:queryItems.action&quot;;</code></pre><p>(3)返回void</p><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><pre><code>// 使用request转向页面，如下：request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);// 也可以通过response页面重定向：response.sendRedirect(&quot;url&quot;)// 也可以通过response指定响应结果，例如响应json数据如下：response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-唐·韦庄《《菩萨蛮·劝君今夜须沉醉》》&lt;/center&gt;

&lt;hr&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(9)-springmvc整合mybatis之controller</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)-springmvc%E6%95%B4%E5%90%88mybatis%E4%B9%8Bcontroller/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(9)-springmvc整合mybatis之controller/</id>
    <published>2019-07-14T13:59:39.000Z</published>
    <updated>2019-07-14T14:07:29.686Z</updated>
    
    <content type="html"><![CDATA[<center>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。 </center><br><center>长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</center><br><center>—-宋·苏轼《临江仙·夜饮东坡醒复醉》</center><hr><h3 id="配置springmvc-xml"><a href="#配置springmvc-xml" class="headerlink" title="配置springmvc.xml"></a>配置springmvc.xml</h3><p>在resources/spring文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;    &lt;!-- 对于注解的Handler 可以单个配置    实际开发中建议使用组件扫描    --&gt;    &lt;!-- 可以扫描controller、service、...    这里让扫描controller，指定controller的包     --&gt;    &lt;context:component-scan base-package=&quot;com.echodemo.springmvcmybatis.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注解的映射器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;--&gt;    &lt;!-- 注解的适配器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;--&gt;    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置     mvc:annotation-driven默认加载很多的参数绑定方法，     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter     实际开发时使用mvc:annotation-driven     --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!-- 视图解析器    解析jsp,默认使用jstl,classpath下要有jstl的包    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app  version=&quot;2.3&quot;          xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_3.xsd&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!-- 加载spring的容器 --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:/spring/applicationContext-*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)    --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，            使用此种方式和实现RESTful风格的url    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，            不能根据jsp页面找到handler，会报错    --&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>这个文件有两个作用：</p><p>（1）配置前端控制器(DispatcherServlet)</p><p>（2）加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载spring/下的配置文件：</p><pre><code>applicationContext-dao.xmlapplicationContext-service.xmlapplicationContext-transaction.xml</code></pre><hr><h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><pre><code>package com.echodemo.springmvcmybatis.controller;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;@Controllerpublic class ItemsController {    @Autowired    private ItemsService itemsService;    // 商品查询    @RequestMapping(&quot;/queryItems&quot;)    public ModelAndView queryItems() throws Exception{        // 调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;ItemsCustom&gt; itemsList = new ArrayList&lt;&gt;();        itemsList = itemsService.findItemsList(null);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        // 相当于request的setAttribute，在JSP页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;, itemsList);        // 指定视图        modelAndView.setViewName(&quot;items/itemsList&quot;);        System.out.println(modelAndView);        return modelAndView;    }}</code></pre><hr><h3 id="编写jsp"><a href="#编写jsp" class="headerlink" title="编写jsp"></a>编写jsp</h3><p>服务器路径为WEB-INF/jsp/items/itemsList.jsp。</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot;         pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;; charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;${pageContext.request.contextPath }/item/queryItem.action&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品id&lt;/td&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:if test=&quot;${not empty itemsList}&quot;&gt;            &lt;c:forEach items=&quot;${itemsList}&quot; var=&quot;item&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;${item.id}&lt;/td&gt;                    &lt;td&gt;${item.name}&lt;/td&gt;                    &lt;td&gt;${item.price}&lt;/td&gt;                    &lt;td&gt;${item.detail}&lt;/td&gt;                    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath}/item/editItem.action?id=${item.id}&quot; &gt;修改&lt;/a&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/c:forEach&gt;        &lt;/c:if&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="部署调试"><a href="#部署调试" class="headerlink" title="部署调试"></a>部署调试</h3><p>1、idea上部署tomcat可以参考这里：<a href="http://www.echodemo.cc/2019/07/13/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1">springmvc学习笔记(1)-框架原理和入门配置</a>-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/)</p><p>2、启动之后访问：<a href="http://localhost:8080/springmvcmybatis/queryItems.action。大功告成。" target="_blank" rel="noopener">http://localhost:8080/springmvcmybatis/queryItems.action。大功告成。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《临江仙·夜饮东坡醒复醉》
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(8)-springmvc整合mybatis之service</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)-springmvc%E6%95%B4%E5%90%88mybatis%E4%B9%8Bservice/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(8)-springmvc整合mybatis之service/</id>
    <published>2019-07-14T13:53:41.000Z</published>
    <updated>2019-07-14T13:58:20.314Z</updated>
    
    <content type="html"><![CDATA[<center>两两归鸿欲破群，依依还似北归人。</center><br><center>遥知朔漠多风雪，更待江南半月春。</center><br><center>—-宋·苏轼《惠崇春江晚景二首·其二》</center><hr><h3 id="定义service"><a href="#定义service" class="headerlink" title="定义service"></a>定义service</h3><p>1、定义service接口</p><pre><code>package com.echodemo.springmvcmybatis.service;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.bean.ItemsQueryVo;import java.util.List;public interface ItemsService {    // 查询商品列表    List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;}</code></pre><p>2、定义service实现类</p><pre><code>package com.echodemo.springmvcmybatis.service.Impl;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.bean.ItemsQueryVo;import com.echodemo.springmvcmybatis.mapper.ItemsMapperCustom;import com.echodemo.springmvcmybatis.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ItemsServiceImpl implements ItemsService {    @Autowired    private ItemsMapperCustom itemsMapperCustom;    @Override    public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {        return itemsMapperCustom.findItemsList(itemsQueryVo);    }}</code></pre><hr><h3 id="在spring容器配置service"><a href="#在spring容器配置service" class="headerlink" title="在spring容器配置service"></a>在spring容器配置service</h3><p>在resources/spring下创建applicationContext-service.xml，文件中配置service。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 商品管理的service --&gt;    &lt;bean id=&quot;itemsService&quot; class=&quot;com.echodemo.springmvcmybatis.service.Impl.ItemsServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><hr><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><p>在resources/spring下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 事务管理器        对mybatis操作数据库的事务控制，spring使用jdbc的事务控制    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 数据源            dataSource在applicationContext-dao.xml中配置了         --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 传播行为 --&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- aop --&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.echodemo.springmvcmybatis.service.Impl.*.*(..))&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;两两归鸿欲破群，依依还似北归人。&lt;/center&gt;&lt;br&gt;&lt;center&gt;遥知朔漠多风雪，更待江南半月春。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《惠崇春江晚景二首·其二》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;定义service&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(7)-springmvc整合mybatis之mapper</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)-springmvc%E6%95%B4%E5%90%88mybatis%E4%B9%8Bmapper/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(7)-springmvc整合mybatis之mapper/</id>
    <published>2019-07-14T13:38:53.000Z</published>
    <updated>2019-07-14T13:52:11.999Z</updated>
    
    <content type="html"><![CDATA[<center>元丰六年十月十二日夜，解衣欲睡，月色入户，欣然起行。念无与为乐者，遂至承天寺寻张怀民。怀民亦未寝，相与步于中庭。</center><br><center>庭下如积水空明，水中藻、荇交横，盖竹柏影也。何夜无月？何处无竹柏？但少闲人如吾两人者耳。</center><br><center>—-宋·苏轼《记承天寺夜游》</center><hr><h3 id="数据库配置文件和日志配置文件"><a href="#数据库配置文件和日志配置文件" class="headerlink" title="数据库配置文件和日志配置文件"></a>数据库配置文件和日志配置文件</h3><p>在resource文件夹下添加两个文件：数据库配置文件和日志配置文件。</p><p>1、数据库配置文件db.properties</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=utf-8&amp;serverTimezone=UTCjdbc.username=rootjdbc.password=</code></pre><p>2、日志配置文件log4j.properties</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><hr><h3 id="sqlMapConfig-xml（mybatis自己的配置文件）"><a href="#sqlMapConfig-xml（mybatis自己的配置文件）" class="headerlink" title="sqlMapConfig.xml（mybatis自己的配置文件）"></a>sqlMapConfig.xml（mybatis自己的配置文件）</h3><p>在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 全局setting配置，根据需要添加 --&gt;    &lt;!-- 别名定义 --&gt;    &lt;typeAliases&gt;        &lt;!-- 批量别名定义        指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名        （首字母大写或小写都可以）        --&gt;        &lt;package name=&quot;com.echodemo.springmvcmybatis.bean&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!-- 配置mapper     由于使用spring和mybatis的整合包进行mapper扫描，这里不需要进行配置     必须遵循：mapper.xml和mapper.java文件同名，且在同一个目录下--&gt;    &lt;!--&lt;mappers&gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash;通过resource方法一次加载一个映射文件 &amp;ndash;&amp;gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash;&lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;&amp;ndash;&amp;gt;--&gt;        &lt;!--&amp;lt;!&amp;ndash; 批量加载mapper--&gt;        &lt;!--指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载--&gt;        &lt;!--遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，--&gt;        &lt;!--且在一个目录中上边规范的前提是：使用的是mapper代理方法--&gt;         &lt;!--&amp;ndash;&amp;gt;--&gt;        &lt;!--&lt;package name=&quot;com.echodemo.springmybatis.mapper&quot;/&gt;--&gt;    &lt;!--&lt;/mappers&gt;--&gt;&lt;/configuration&gt;</code></pre><hr><h3 id="applicationContext-dao-xml"><a href="#applicationContext-dao-xml" class="headerlink" title="applicationContext-dao.xml"></a>applicationContext-dao.xml</h3><p>在resources目录下新建spring文件夹，并新建applicationContext-dao.xml文件。分别配置：数据源、SqlSessionFactory、mapper扫描器。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;    destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt;        &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt;    &lt;/bean&gt;    &lt;!-- sqlSessionFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot;/&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册        遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录中        自动扫描出来的mapper的bean的id为mapper类名（首字母小写）        --&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 指定扫描的包名，如果需要扫描多个包，中间使用半角的逗号隔开 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.echodemo.springmvcmybatis.mapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h3 id="逆向工程生成po类及mapper-单表增删改查"><a href="#逆向工程生成po类及mapper-单表增删改查" class="headerlink" title="逆向工程生成po类及mapper(单表增删改查)"></a>逆向工程生成po类及mapper(单表增删改查)</h3><p>具体参见：<a href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(18">mybatis学习笔记(18)-mybatis逆向工程</a>-mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/)</p><h3 id="手动定义商品查询mapper"><a href="#手动定义商品查询mapper" class="headerlink" title="手动定义商品查询mapper"></a>手动定义商品查询mapper</h3><p>针对综合查询mapper，一般情况会有关联查询，建议自定义mapper。</p><p>1、ItemsMapperCustom.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.echodemo.springmvcmybatis.mapper.ItemsMapperCustom&quot;&gt;    &lt;!-- 定义商品查询的SQL片段 --&gt;    &lt;sql id=&quot;query_items_where&quot;&gt;        &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt;        &lt;!-- 商品中的查询条件通过ItemsQueryVo包装对象中itemsCustom属性值传递 --&gt;        &lt;if test=&quot;itemsCustom!=null&quot;&gt;            &lt;if test=&quot;itemsCustom.name!=null and itemsCustom.name!=&apos;&apos;&quot;&gt;                items.name LIEK &apos;${itemsCustom.name}&apos;            &lt;/if&gt;        &lt;/if&gt;    &lt;/sql&gt;    &lt;!-- 商品的列表查询 --&gt;    &lt;!-- 建议paramterType传入包装对象         resultType建议使用扩展对象    --&gt;    &lt;select id=&quot;findItemsList&quot; parameterType=&quot;com.echodemo.springmvcmybatis.bean.ItemsQueryVo&quot; resultType=&quot;com.echodemo.springmvcmybatis.bean.ItemsCustom&quot;&gt;      SELECT * FROM items      &lt;where&gt;          &lt;include refid=&quot;query_items_where&quot;&gt;&lt;/include&gt;      &lt;/where&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>2、ItemsMapperCustom.java</p><pre><code>package com.echodemo.springmvcmybatis.mapper;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.bean.ItemsQueryVo;import java.util.List;public interface ItemsMapperCustom {    // 查询商品列表    List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;}</code></pre><p>3、po类ItemsCustom</p><pre><code>package com.echodemo.springmvcmybatis.bean;/** * 商品信息的扩展类 */public class ItemsCustom extends Items{    // 添加商品信息的扩展属性}</code></pre><p>4、输入pojo的包装类</p><pre><code>package com.echodemo.springmvcmybatis.bean;/** * 商品的包装对象 */public class ItemsQueryVo {    // 商品信息    private Items items;    // 为了系统的可扩展性，对原始生成的po类进行扩展    private ItemsCustom itemsCustom;    public Items getItems() {        return items;    }    public void setItems(Items items) {        this.items = items;    }    public ItemsCustom getItemsCustom() {        return itemsCustom;    }    public void setItemsCustom(ItemsCustom itemsCustom) {        this.itemsCustom = itemsCustom;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;元丰六年十月十二日夜，解衣欲睡，月色入户，欣然起行。念无与为乐者，遂至承天寺寻张怀民。怀民亦未寝，相与步于中庭。&lt;/center&gt;&lt;br&gt;&lt;center&gt;庭下如积水空明，水中藻、荇交横，盖竹柏影也。何夜无月？何处无竹柏？但少闲人如吾两人者耳。&lt;/center&gt;&lt;b
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(6)-springmvc整合mybatis</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)-springmvc%E6%95%B4%E5%90%88mybatis/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(6)-springmvc整合mybatis/</id>
    <published>2019-07-14T13:22:47.000Z</published>
    <updated>2019-07-14T13:37:37.945Z</updated>
    
    <content type="html"><![CDATA[<center>肃肃凉风生，加我林壑清。</center><br><center>驱烟寻涧户，卷雾出山楹。</center><br><center>去来固无迹，动息如有情。</center><br><center>日落山水静，为君起松声。</center><br><center>—-唐·王勃《咏风》</center><hr><h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><p>通过spring管理持久层的mapper(相当于dao接口)；通过spring管理业务层的service，service中可以调用mapper接口；通过spring管理表现层的Handler（也就是controller），Handler里面可以调用service接口。像mapper、service、Handler都是javaBean，所以用到的是spring的IOC的容器。</p><p>1、第一步：整合dao层</p><pre><code>（1）mybatis和spring整合，通过spring管理mapper接口。（2）使用mapper的扫描器自动扫描mapper接口在spring中进行注册。</code></pre><p>第二步：整合service层</p><pre><code>（1）通过spring管理service接口。（2）使用配置方式将service接口配置在spring配置文件中。（3）实现事务控制。</code></pre><p>第三步：整合springmvc</p><pre><code>（1）由于springmvc是spring的模块，不需要整合。</code></pre><hr><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>如何创建使用maven构建的web应用可以参考前面的一篇：<a href="http://www.echodemo.cc/2019/07/13/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1">springmvc学习笔记(1)-框架原理和入门配置</a>-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/)</p><p>1、添加依赖</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.echodemo&lt;/groupId&gt;  &lt;artifactId&gt;springmvc-mybatis&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;springmvc-mybatis Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&apos;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;spring-base-version&gt;4.2.4.RELEASE&lt;/spring-base-version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;${spring-base-version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;1.2.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;4.0.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;jstl&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;taglibs&lt;/groupId&gt;      &lt;artifactId&gt;standard&lt;/artifactId&gt;      &lt;version&gt;1.1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;      &lt;version&gt;1.7.25&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;      &lt;version&gt;1.2.3&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-core --&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;      &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;      &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;      &lt;version&gt;1.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.3.0&lt;/version&gt;    &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;          &lt;version&gt;1.3.5&lt;/version&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;springmvc-mybatis&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.8.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.22.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;    &lt;resources&gt;      &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;    &lt;/resources&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;肃肃凉风生，加我林壑清。&lt;/center&gt;&lt;br&gt;&lt;center&gt;驱烟寻涧户，卷雾出山楹。&lt;/center&gt;&lt;br&gt;&lt;center&gt;去来固无迹，动息如有情。&lt;/center&gt;&lt;br&gt;&lt;center&gt;日落山水静，为君起松声。&lt;/center&gt;&lt;br&gt;&lt;center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(5)-入门程序小结</title>
    <link href="http://www.echodemo.cc/2019/07/14/2019-07-14springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.echodemo.cc/2019/07/14/2019-07-14springmvc学习笔记-5-入门程序小结/</id>
    <published>2019-07-14T08:26:35.000Z</published>
    <updated>2019-07-14T08:42:58.755Z</updated>
    
    <content type="html"><![CDATA[<center>凉风起天末，君子意如何。</center><br><center>鸿雁几时到，江湖秋水多。</center><br><center>文章憎命达，魑魅喜人过。</center><br><center>应共冤魂语，投诗赠汨罗。</center><br><center>—-唐·杜甫《天末怀李白》</center><hr><h3 id="入门程序配置小结"><a href="#入门程序配置小结" class="headerlink" title="入门程序配置小结"></a>入门程序配置小结</h3><p>1、前端控制器配置：</p><p>（1）第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析。</p><p>（2）第二种：/，所有访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析,使用此种方式可以实现RESTful风格的url。</p><p>2、处理器映射器：</p><pre><code>（1）非注解处理器映射器（了解）。（2）注解的处理器映射器（掌握）。</code></pre><p>对标记@Controller类中标识有@RequestMapping的方法进行映射。在@RequestMapping里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。</p><p>3、处理器适配器：</p><p>（1）非注解处理器适配器（了解） 。</p><p>（2）注解的处理器适配器（掌握） 。</p><p>注解处理器适配器和注解的处理器映射器是配对使用。理解为不能使用非注解映射器进行映射。</p><pre><code>&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; </code></pre><p>可以代替下面的配置：</p><pre><code>&lt;!--注解映射器 --&gt;  &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;  &lt;!--注解适配器 --&gt;  &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><hr><h3 id="非注解的完整的配置文件"><a href="#非注解的完整的配置文件" class="headerlink" title="非注解的完整的配置文件"></a>非注解的完整的配置文件</h3><p>src/main/resources/springmvc.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;    &lt;!-- 配置Handler --&gt;    &lt;bean id=&quot;itemsController&quot; name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;    &lt;!-- 处理器映射器    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)    所有的映射器都实现HandlerMapping接口    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;    &lt;!-- 配置处理器适配器，所有处理器适配器都实现了HandlerAdapter接口，编写的Handler实现Controller接口 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;    &lt;!-- 视图解析器    解析jsp,默认使用jstl,classpath下要有jstl的包    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>或者：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;    &lt;!-- 配置Handler --&gt;    &lt;bean id=&quot;itemsController&quot; name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;    &lt;bean id=&quot;itemsController1&quot; class=&quot;com.echodemo.ssm.controller.ItemsController1&quot;/&gt;    &lt;!-- 简单的url映射 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;        &lt;property name=&quot;mappings&quot;&gt;            &lt;props&gt;                &lt;!-- 对itemsController进行url映射，key表示访问的路径，itemsController表示Handler的id --&gt;                &lt;prop key=&quot;/queryItems0.action&quot;&gt;itemsController&lt;/prop&gt;                &lt;prop key=&quot;/queryItems1.action&quot;&gt;itemsController1&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 另一个处理器适配器，编写的Handler实现HttpRequestHandler接口 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;    &lt;!-- 视图解析器    解析jsp,默认使用jstl,classpath下要有jstl的包    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>注：以上这两种不同的处理器和适配器的配置方式是可以并存的。</strong></p><hr><h3 id="注解的完整配置文件"><a href="#注解的完整配置文件" class="headerlink" title="注解的完整配置文件"></a>注解的完整配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;    &lt;!-- 对于注解的Handler 可以单个配置    实际开发中建议使用组件扫描    --&gt;    &lt;!--&lt;bean class=&quot;com.echodemo.ssm.controller.ItemsController2&quot;/&gt;--&gt;    &lt;!-- 可以扫描controller、service、...    这里让扫描controller，指定controller的包     --&gt;    &lt;context:component-scan base-package=&quot;com.echodemo.ssm.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注解的映射器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;--&gt;    &lt;!-- 注解的适配器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;--&gt;    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置     mvc:annotation-driven默认加载很多的参数绑定方法，     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter     实际开发时使用mvc:annotation-driven     --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!-- 视图解析器    解析jsp,默认使用jstl,classpath下要有jstl的包    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;凉风起天末，君子意如何。&lt;/center&gt;&lt;br&gt;&lt;center&gt;鸿雁几时到，江湖秋水多。&lt;/center&gt;&lt;br&gt;&lt;center&gt;文章憎命达，魑魅喜人过。&lt;/center&gt;&lt;br&gt;&lt;center&gt;应共冤魂语，投诗赠汨罗。&lt;/center&gt;&lt;br&gt;&lt;center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(4)-前端控制器</title>
    <link href="http://www.echodemo.cc/2019/07/14/2019-07-14springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/14/2019-07-14springmvc学习笔记-4-前端控制器/</id>
    <published>2019-07-14T06:10:05.000Z</published>
    <updated>2019-07-14T06:29:40.584Z</updated>
    
    <content type="html"><![CDATA[<center>四面垂杨十里荷，问云何处最花多。画楼南畔夕阳和。</center><br><center>天气乍凉人寂寞，光阴须得酒消磨。且来花里听笙歌。</center><br><center>—-宋·苏轼《浣溪沙·荷花》</center><hr><h3 id="前端控制器接收请求"><a href="#前端控制器接收请求" class="headerlink" title="前端控制器接收请求"></a>前端控制器接收请求</h3><p>调用doDispatch方法：</p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;         。。。。。}</code></pre><hr><h3 id="前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler"><a href="#前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler" class="headerlink" title="前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler"></a>前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler</h3><p>在doDispatch方法中：</p><pre><code>mappedHandler = this.getHandler(processedRequest);</code></pre><p>Handler的实现：</p><pre><code>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {    Iterator var2 = this.handlerMappings.iterator();    HandlerExecutionChain handler;    do {        if (!var2.hasNext()) {            return null;        }        HandlerMapping hm = (HandlerMapping)var2.next();        if (this.logger.isTraceEnabled()) {            this.logger.trace(&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + this.getServletName() + &quot;&apos;&quot;);        }        handler = hm.getHandler(request);    } while(handler == null);    return handler;}</code></pre><hr><h3 id="调用处理器适配器执行Handler-得到执行的结果ModelAndView-mv"><a href="#调用处理器适配器执行Handler-得到执行的结果ModelAndView-mv" class="headerlink" title="调用处理器适配器执行Handler,得到执行的结果ModelAndView mv"></a>调用处理器适配器执行Handler,得到执行的结果ModelAndView mv</h3><p>在doDispatch方法中：</p><pre><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre><hr><h3 id="视图渲染，将model数据填充到request域"><a href="#视图渲染，将model数据填充到request域" class="headerlink" title="视图渲染，将model数据填充到request域"></a>视图渲染，将model数据填充到request域</h3><pre><code>doDispatch-&gt;processDispatchResult-&gt;render</code></pre><p>在render方法中,视图解析得到view:</p><pre><code>view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</code></pre><p>调用view的渲染方法，将model数据填充到request域。在render方法中,调用View接口的render方法。</p><pre><code>view.render(mv.getModelInternal(), request, response);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;四面垂杨十里荷，问云何处最花多。画楼南畔夕阳和。&lt;/center&gt;&lt;br&gt;&lt;center&gt;天气乍凉人寂寞，光阴须得酒消磨。且来花里听笙歌。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《浣溪沙·荷花》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;前端控制
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(3)-注解的处理器映射器和适配器</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(3)-注解的处理器映射器和适配器/</id>
    <published>2019-07-14T04:07:39.000Z</published>
    <updated>2019-07-14T05:55:03.664Z</updated>
    
    <content type="html"><![CDATA[<center>荷叶罗裙一色裁，芙蓉向脸两边开。</center><br><center>乱入池中看不见，闻歌始觉有人来。</center><br><center>—-唐·王昌龄《采莲曲二首》</center><hr><h3 id="默认加载"><a href="#默认加载" class="headerlink" title="默认加载"></a>默认加载</h3><p>前端控制器从\org\springframework\web\servlet\DispatcherServlet.properties件中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的</p><p>注解的处理器映射器和适配器：</p><pre><code>（1）在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。（2）在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。（3）在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。（4）在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器</code></pre><hr><h3 id="注解的处理器映射器和适配器"><a href="#注解的处理器映射器和适配器" class="headerlink" title="注解的处理器映射器和适配器"></a>注解的处理器映射器和适配器</h3><p>使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用)。</p><!-- 注解的映射器 --><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></pre><!-- 注解的适配器 --><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;</code></pre><p>或者：</p><pre><code>&lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</code></pre><hr><h3 id="开发注解Handler"><a href="#开发注解Handler" class="headerlink" title="开发注解Handler"></a>开发注解Handler</h3><pre><code>package com.echodemo.ssm.controller;import com.echodemo.ssm.bean.Items;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;@Controllerpublic class ItemsController2 {    @RequestMapping(&quot;/queryItems2&quot;)    public ModelAndView queryItems2() throws Exception{        //调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();        //向list中填充静态数据        Items items_1 = new Items();        items_1.setName(&quot;联想笔记本&quot;);        items_1.setPrice(6000f);        items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);        Items items_2 = new Items();        items_2.setName(&quot;苹果手机&quot;);        items_2.setPrice(5000f);        items_2.setDetail(&quot;iphone6苹果手机！&quot;);        itemsList.add(items_1);        itemsList.add(items_2);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        // 相当于request的setAttribute，在JSP页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;, itemsList);        // 指定视图        modelAndView.setViewName(&quot;items/itemsList&quot;);        System.out.println(modelAndView);        return modelAndView;    }}</code></pre><h3 id="在spring容器中加载Handler"><a href="#在spring容器中加载Handler" class="headerlink" title="在spring容器中加载Handler"></a>在spring容器中加载Handler</h3><pre><code>&lt;!-- 对于注解的Handler 可以单个配置实际开发中建议使用组件扫描--&gt;&lt;!--&lt;bean class=&quot;com.echodemo.ssm.controller.ItemsController2&quot;/&gt;--&gt;&lt;!-- 可以扫描controller、service、...这里让扫描controller，指定controller的包 --&gt;&lt;context:component-scan base-package=&quot;com.echodemo.ssm.controller&quot;&gt;&lt;/context:component-scan&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;荷叶罗裙一色裁，芙蓉向脸两边开。&lt;/center&gt;&lt;br&gt;&lt;center&gt;乱入池中看不见，闻歌始觉有人来。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-唐·王昌龄《采莲曲二首》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;默认加载&quot;&gt;&lt;a href=&quot;#默认加载
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(2)-非注解的处理器映射器和适配器</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-%E9%9D%9E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(2)-非注解的处理器映射器和适配器/</id>
    <published>2019-07-13T16:02:19.000Z</published>
    <updated>2019-07-13T16:20:29.037Z</updated>
    
    <content type="html"><![CDATA[<center>菡萏香销翠叶残，西风愁起绿波间。还与韶光共憔悴，不堪看。</center><br><center>细雨梦回鸡塞远，小楼吹彻玉笙寒。多少泪珠何限恨，倚栏干。</center><br><center>—-五代·李璟《摊破浣溪沙·菡萏香销翠叶残》</center><hr><h3 id="非注解的处理器映射器"><a href="#非注解的处理器映射器" class="headerlink" title="非注解的处理器映射器"></a>非注解的处理器映射器</h3><pre><code>&lt;!-- 配置Handler --&gt;&lt;bean id=&quot;itemsController&quot; name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)所有的映射器都实现HandlerMapping接口--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!-- 简单的url映射 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;    &lt;property name=&quot;mappings&quot;&gt;        &lt;props&gt;            &lt;!-- 对itemsController进行url映射，key表示访问的路径，itemsController表示Handler的id --&gt;            &lt;prop key=&quot;/queryItems1.action&quot;&gt;itemsController&lt;/prop&gt;            &lt;prop key=&quot;/queryItems2.action&quot;&gt;itemsController&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理。</p><h3 id="非注解的处理器适配器"><a href="#非注解的处理器适配器" class="headerlink" title="非注解的处理器适配器"></a>非注解的处理器适配器</h3><pre><code>&lt;!-- 配置处理器适配器，所有处理器适配器都实现了HandlerAdapter接口，编写的Handler实现Controller接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!-- 另一个处理器适配器，编写的Handler实现HttpRequestHandler接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;</code></pre><p>实现HttpRequestHandler接口的ItemsController1：</p><pre><code>package com.echodemo.ssm.controller;import com.echodemo.ssm.bean.Items;import org.springframework.web.HttpRequestHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class ItemsController1 implements HttpRequestHandler {    @Override    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {        //调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();        //向list中填充静态数据        Items items_1 = new Items();        items_1.setName(&quot;联想笔记本&quot;);        items_1.setPrice(6000f);        items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);        Items items_2 = new Items();        items_2.setName(&quot;苹果手机&quot;);        items_2.setPrice(5000f);        items_2.setDetail(&quot;iphone6苹果手机！&quot;);        itemsList.add(items_1);        itemsList.add(items_2);        // 设置模型数据        httpServletRequest.setAttribute(&quot;/WEB-INF/jsp/itemsList.jsp&quot;, itemsList);        // 设置转发的视图        httpServletRequest.getRequestDispatcher(&quot;items/itemsList&quot;)                .forward(httpServletRequest, httpServletResponse);        /*         *HttpRequestHandler适配器的handleRequest方法返回为void,         *没有返回ModelAndView，可通过response修改响应内容,比如返回json数据：         *///        httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;);//        httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;);//        httpServletResponse.getWriter().write(&quot;json串&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;菡萏香销翠叶残，西风愁起绿波间。还与韶光共憔悴，不堪看。&lt;/center&gt;&lt;br&gt;&lt;center&gt;细雨梦回鸡塞远，小楼吹彻玉笙寒。多少泪珠何限恨，倚栏干。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-五代·李璟《摊破浣溪沙·菡萏香销翠叶残》&lt;/center&gt;

&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(1)-框架原理和入门配置</title>
    <link href="http://www.echodemo.cc/2019/07/13/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2019/07/13/springmvc学习笔记(1)-框架原理和入门配置/</id>
    <published>2019-07-13T15:12:58.000Z</published>
    <updated>2019-07-13T16:13:44.057Z</updated>
    
    <content type="html"><![CDATA[<center>绿槐高柳咽新蝉。薰风初入弦。碧纱窗下水沉烟。棋声惊昼眠。</center><br><center>微雨过，小荷翻。榴花开欲然。玉盆纤手弄清泉。琼珠碎却圆。</center><br><center>—-宋·苏轼《阮郎归·初夏》</center><hr><p>本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p><hr><h3 id="springmvc框架原理"><a href="#springmvc框架原理" class="headerlink" title="springmvc框架原理"></a>springmvc框架原理</h3><p>官网示意图如下：</p><center><br><br><img src="/images/2019/7/springmvc.png" alt="&quot;Springmvc&quot;"><br><br></center><p>SpringMVC的核心架构：</p><center><br><br><img src="/images/2019/7/springmvc原理.png" alt="&quot;Springmvc原理&quot;"><br><br></center><p>组件及其作用：</p><pre><code>（1）前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度。（2）处理器映射器(HandlerMapping)：根据请求的url查找Handler。（3）Handler处理器：按照HandlerAdapter的要求编写。（4）处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。（5）视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View)。（6)视图(View)：View是一个接口实现类试吃不同的View类型（jsp,pdf等等）。</code></pre><p>具体流程：</p><pre><code>1.发起请求到前端控制器(DispatcherServlet)。2.前端控制器请求处理器映射器(HandlerMapping)查找Handler(可根据xml配置、注解进行查找)。3.处理器映射器(HandlerMapping)向前端控制器返回Handler。4.前端控制器调用处理器适配器(HandlerAdapter)执行Handler。5.处理器适配器(HandlerAdapter)去执行Handler。6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)。7.处理器适配器(HandlerAdapter)向前端控制器返回ModelAndView。8.前端控制器(DispatcherServlet)请求视图解析器(ViewResolver)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)。9.视图解析器(ViewResolver)向前端控制器(DispatcherServlet)返回View。10.前端控制器进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域。11.前端控制器向用户响应结果。</code></pre><hr><h3 id="springmvc入门程序"><a href="#springmvc入门程序" class="headerlink" title="springmvc入门程序"></a>springmvc入门程序</h3><p>一个展示商品列表的小页面</p><p>1、环境搭建</p><p>（1）new-&gt;project-&gt;maven-&gt;勾选create from archetype-&gt;选中webapp。</p><p>（2）在src/main下新建java文件夹，标记为Sources Root。在在src/main下新建resources文件夹，标记为Resources Root。</p><p>2、添加依赖</p><pre><code>&lt;properties&gt;  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;  &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;spring-base-version&gt;4.2.4.RELEASE&lt;/spring-base-version&gt;&lt;/properties&gt;&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.11&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;${spring-base-version}&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>build标签的finalName要和Artifacts的output directory一致：</p><pre><code>&lt;finalName&gt;springmvcfirst&lt;/finalName&gt;</code></pre><p>3、配置文件</p><p>（1）配置前端控制器</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app  version=&quot;2.3&quot;          xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_3.xsd&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)    --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，            使用此种方式和实现RESTful风格的url    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，            不能根据jsp页面找到handler，会报错    --&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>（2）创建springmvc.xml（springmvc.xml放在resources目录下）</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;&lt;/beans&gt;</code></pre><p>（3）在springmvc.xml中配置Handler</p><pre><code>&lt;bean name=&quot;/queryItems.action&quot; class=&quot;com.echodemo.ssm.controller.ItemsController&quot;/&gt;</code></pre><p>(4)在springmvc.xml中配置处理器映射器</p><pre><code>&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)所有的映射器都实现HandlerMapping接口--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre><p>（5）在springmvc.xml中配置处理器适配器</p><pre><code>&lt;!-- 配置处理器适配器，所有处理器适配器都实现了HandlerAdapter接口 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;</code></pre><p>源码：</p><pre><code>public boolean supports(Object handler) {        return handler instanceof Controller;}</code></pre><p>此适配器能执行实现Controller接口的Handler</p><p>（6）在springmvc.xml中配置视图解析器</p><pre><code>&lt;!-- 视图解析器解析jsp,默认使用jstl,classpath下要有jstl的包--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;</code></pre><p>在springmvc.xml中视图解析器配置前缀和后缀：</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;</code></pre><p>程序中不用指定前缀和后缀：</p><pre><code>// 指定视图// 下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList// modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);// 下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀modelAndView.setViewName(&quot;items/itemsList&quot;);</code></pre><h3 id="部署调试"><a href="#部署调试" class="headerlink" title="部署调试"></a>部署调试</h3><p>Items类：</p><pre><code>package com.echodemo.ssm.bean;import java.util.Date;public class Items {    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name == null ? null : name.trim();    }    public Float getPrice() {        return price;    }    public void setPrice(Float price) {        this.price = price;    }    public String getPic() {        return pic;    }    public void setPic(String pic) {        this.pic = pic == null ? null : pic.trim();    }    public Date getCreatetime() {        return createtime;    }    public void setCreatetime(Date createtime) {        this.createtime = createtime;    }    public String getDetail() {        return detail;    }    public void setDetail(String detail) {        this.detail = detail == null ? null : detail.trim();    }}</code></pre><p>实现Controller接口的ItemsController:</p><pre><code>package com.echodemo.ssm.controller;import com.echodemo.ssm.bean.Items;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import java.util.ArrayList;import java.util.List;public class ItemsController implements Controller {    @Override    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception {        // 调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;Items&gt; itemsList = new ArrayList&lt;&gt;();        // 向list中填充静态数据        Items items_1 = new Items();        items_1.setName(&quot;联想笔记本&quot;);        items_1.setPrice(5000f);        items_1.setDetail(&quot;Think Pad T430联想笔记本&quot;);        Items items_2 = new Items();        items_2.setName(&quot;苹果手机&quot;);        items_2.setPrice(5000f);        items_2.setDetail(&quot;Iphone6苹果手机&quot;);        itemsList.add(items_1);        itemsList.add(items_2);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        // 相当于request的setAttribute，在JSP页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;, itemsList);        // 指定视图        modelAndView.setViewName(&quot;items/itemsList&quot;);        return modelAndView;    }}</code></pre><p>1、在idea中EditConfigurations，添加一个local的tomcat server。</p><p>2、设置tomcat启动路径，并且配置为修改自动更新（这样就不需要总是重启了）</p><center><br><img src="/images/2019/7/tomcat1.png" alt="&quot;Tomcat1&quot;"><br></center><p>3、需要相应设置application context为上一步默认url后加的/springmvcfirst</p><center><br><img src="/images/2019/7/tomcat2.png" alt="&quot;Tomcat2&quot;"><br></center><p>4、最后在tomcat的webapps目录下新建一个同名的文件夹，将output directory置为它。</p><center><br><img src="/images/2019/7/tomcat3.png" alt="&quot;Tomcat3&quot;"><br></center><p>5、相关问题</p><pre><code>HTTP Status 404 - 处理器映射器根据url找不到Handler,说明url错误HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp 处理器映射器根据url找到了Handler，转发的jsp页面找不到</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;绿槐高柳咽新蝉。薰风初入弦。碧纱窗下水沉烟。棋声惊昼眠。&lt;/center&gt;&lt;br&gt;&lt;center&gt;微雨过，小荷翻。榴花开欲然。玉盆纤手弄清泉。琼珠碎却圆。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《阮郎归·初夏》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习中碰到的的一些问题</title>
    <link href="http://www.echodemo.cc/2019/07/06/mybatis%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2019/07/06/mybatis学习中碰到的一些问题/</id>
    <published>2019-07-06T03:40:59.000Z</published>
    <updated>2019-07-06T04:12:23.927Z</updated>
    
    <content type="html"><![CDATA[<center>君不见走马川行雪海边，平沙莽莽黄入天。 </center><br><center>轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。</center><br><center>匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。</center><br><center>将军金甲夜不脱，半夜军行戈相拨，风头如刀面如割。</center><br><center>马毛带雪汗气蒸，五花连钱旋作冰，幕中草檄砚水凝。 </center><br><center>虏骑闻之应胆慑，料知短兵不敢接，车师西门伫献捷。</center><br><center>—-唐·岑参《走马川行奉送封大夫出师西征》</center><hr><pre><code>1、元素类型为 &quot;configuration&quot; 的内容必须匹配 &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;。org.apache.ibatis.exceptions.PersistenceException: ### Error building SqlSession.### Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 46; columnNumber: 17; 元素类型为 &quot;configuration&quot; 的内容必须匹配 &quot;(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;。</code></pre><p>mybatis-config.xml配置文件配置时，要注意节点顺序。</p><hr><pre><code>2、&lt;property name=&quot;username&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=utf-8&quot; /&gt;org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: java.sql.SQLNonTransientConnectionException: Cannot load connection class because of underlying exception: com.mysql.cj.exceptions.WrongArgumentException: Malformed database URL, failed to parse the connection string near &apos;;serverTimezone=UTC&apos;.</code></pre><p>这是时区问题，只需配置成下面这样就OK了（其中的&amp;表示的是XML的&amp;字符的转义符，所以当你在把这个配置放到db.properties中时就要将&amp;改回&amp;字符了，不然也会报错）：</p><pre><code>&lt;property name=&quot;username&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&quot; /&gt;</code></pre><hr><pre><code>3、org.apache.ibatis.binding.BindingException: Type interface com.echodemo.mybatislearning.mapper.UserMapper is not known to the MapperRegistry</code></pre><p>这个是因为xml文件没有被添加到mybatis的配置文件中扫描。在这里我的mapper当时是这样配置的，看到网上很多都是在前面加个mapper就OK了，but我的目录结构估计和他们不一样。那么如何优雅让工程找到我们的映射文件呢？</p><pre><code>&lt;!--我的--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;&lt;!--网上众多博客--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;</code></pre><p>我在pom文件的bulid里面添加了下面这个路径的指引，再也不怕找不到我的映射文件了，哈哈。</p><pre><code>&lt;resources&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>当然如果说你是想要配置成批量加载的话，可以像下面这样：</p><pre><code>&lt;mappers&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;&lt;!--还是要在pom文件当中定义路径哈！--&gt;&lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;        &lt;include&gt;**/*.xml&lt;/include&gt;    &lt;/includes&gt;&lt;/resource&gt;</code></pre><hr><p>4、IDEA中使用Mybatis的逆向工程提示说找不到配置文件generatorConfig.xml的问题</p><p>网上很多的文章和博客在指定逆向工程配置文件的时候都是直接用的”generatorConfig.xml”的文件名，而没有前面的路径，虽然按住ctrl可以跳转到该文件，但是在运行main方法的时候却总是报”未找到该文件”的错。我是这样配置的就可以了：</p><pre><code>//指定逆向工程配置文件File configFile = new File(&quot;src\\main\\resources\\generatorConfig.xml&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;君不见走马川行雪海边，平沙莽莽黄入天。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;轮台九月风夜吼，一川碎石大如斗，随风满地石乱走。&lt;/center&gt;&lt;br&gt;&lt;center&gt;匈奴草黄马正肥，金山西见烟尘飞，汉家大将西出师。&lt;/center&gt;&lt;br&gt;&lt;center&gt;将
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(18)-mybatis逆向工程</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(18)-mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(18)-mybatis逆向工程/</id>
    <published>2019-06-30T15:49:47.000Z</published>
    <updated>2019-07-06T03:59:50.850Z</updated>
    
    <content type="html"><![CDATA[<center>西风吹老洞庭波，一夜湘君白发多。</center><br><center>醉后不知天在水，满船清梦压星河。</center><br><center>—-元·唐珙《题龙阳县青草湖》</center><hr><p>mybaits需要程序员自己编写sql语句,mybatis官方提供逆向工程,可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..）企业实际开发中，常用的逆向工程方式：由数据库的表生成java代码。</p><blockquote></blockquote><p><a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">MyBatis Generator</a></p><blockquote></blockquote><p><a href="https://github.com/mybatis/generator" target="_blank" rel="noopener">A code generator for MyBatis and iBATIS. - GitHub</a></p><hr><h3 id="配置maven依赖"><a href="#配置maven依赖" class="headerlink" title="配置maven依赖"></a>配置maven依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;    &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;</code></pre><hr><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>（1）运行逆向工程</p><p>根据官网说的<a href="http://www.mybatis.org/generator/running/running.html" target="_blank" rel="noopener">Running MyBatis Generator</a>：</p><p><strong>Running MyBatis Generator</strong></p><p>MyBatis Generator (MBG) can be run in the following ways:</p><pre><code>From the command prompt with an XML configurationAs an Ant task with an XML configurationAs a Maven PluginFrom another Java program with an XML configurationFrom another Java program with a Java based configuration</code></pre><p>还可以通过eclipse的插件生成代码,建议使用java程序方式，不依赖开发工具。</p><p>(2)生成代码配置文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8&quot;             userId=&quot;root&quot;            password=&quot;123&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.iot.ssm.po&quot;            targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.iot.ssm.mapper&quot;             targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.iot.ssm.mapper&quot;             targetProject=&quot;.\src\main\java&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;items&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;orders&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>需要注意的位置：</p><pre><code>javaModelGenerator,生成PO类的位置sqlMapGenerator,mapper映射文件生成的位置javaClientGenerator,mapper接口生成的位置table,指定数据库表</code></pre><p>(3)执行生成程序</p><pre><code>public class GeneratorSqlmap {    public void generator() throws Exception{        List&lt;String&gt; warnings = new ArrayList&lt;&gt;();        boolean overwrite = true;        // 指定逆向工程配置文件        File configFile = new File(&quot;src\\main\\resources\\generatorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,                callback, warnings);        myBatisGenerator.generate(null);    }    public static void main(String[] args) {        try {            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();            generatorSqlmap.generator();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p><strong>注：网上很多的文章和博客在指定逆向工程配置文件的时候都是直接用的”generatorConfig.xml”的文件名，而没有前面的路径，虽然按住ctrl可以跳转到该文件，但是在运行main方法的时候却总是报”未找到该文件”的错。</strong></p><hr><h3 id="使用生成的代码"><a href="#使用生成的代码" class="headerlink" title="使用生成的代码"></a>使用生成的代码</h3><pre><code>package com.iot.ssm.mapper;import static org.junit.Assert.*;import java.util.Date;import java.util.List;import com.iot.ssm.po.Items;import com.iot.ssm.po.ItemsExample;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ItemsMapperTest {    private ApplicationContext applicationContext;    private ItemsMapper itemsMapper;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);        itemsMapper = (ItemsMapper) applicationContext.getBean(&quot;itemsMapper&quot;);    }    //根据主键删除     @Test    public void testDeleteByPrimaryKey() {    }    //插入    @Test    public void testInsert() {        //构造 items对象        Items items = new Items();        items.setName(&quot;手机&quot;);        items.setPrice(999f);        items.setCreatetime(new Date());        itemsMapper.insert(items);    }    //自定义条件查询    @Test    public void testSelectByExample() {        ItemsExample itemsExample = new ItemsExample();        //通过criteria构造查询条件        ItemsExample.Criteria criteria = itemsExample.createCriteria();        criteria.andNameEqualTo(&quot;笔记本&quot;);        //可能返回多条记录        List&lt;Items&gt; list = itemsMapper.selectByExample(itemsExample);        System.out.println(list);    }    //根据主键查询    @Test    public void testSelectByPrimaryKey() {        Items items = itemsMapper.selectByPrimaryKey(1);        System.out.println(items);    }    //更新数据    @Test    public void testUpdateByPrimaryKey() {        //对所有字段进行更新，需要先查询出来再更新        Items items = itemsMapper.selectByPrimaryKey(1);        items.setName(&quot;手机&quot;);        itemsMapper.updateByPrimaryKey(items);        //如果传入字段不空为才更新，在批量更新中使用此方法，不需要先查询再更新        //itemsMapper.updateByPrimaryKeySelective(record);    }}</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778937" target="_blank" rel="noopener">mybatis学习笔记(18)-mybatis逆向工程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;西风吹老洞庭波，一夜湘君白发多。&lt;/center&gt;&lt;br&gt;&lt;center&gt;醉后不知天在水，满船清梦压星河。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-元·唐珙《题龙阳县青草湖》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;mybaits需要程序员自己编写sql语句,my
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(17)-spring和mybatis整合</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)-spring%E5%92%8Cmybatis%E6%95%B4%E5%90%88/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(17)-spring和mybatis整合/</id>
    <published>2019-06-30T08:38:43.000Z</published>
    <updated>2019-06-30T11:07:54.954Z</updated>
    
    <content type="html"><![CDATA[<center>西风吹老洞庭波，一夜湘君白发多。</center><br><center>醉后不知天在水，满船清梦压星河。</center><br><center>—-元·唐珙《题龙阳县青草湖》</center><hr><p>本文主要将如何将spring和mybatis整合，只是作简单的示例，没有使用Maven构建。并展示mybatis与spring整合后如何进行原始dao开发和mapper代理开发。</p><h3 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h3><p>需要spring通过单例方式管理SqlSessionFactory。spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成）持久层的mapper都需要由spring进行管理。</p><hr><h3 id="整合环境"><a href="#整合环境" class="headerlink" title="整合环境"></a>整合环境</h3><p>创建一个新的java工程（接近实际开发的工程结构）</p><p>（1）jar包</p><pre><code>1、mybatis3.2.7的jar包。2、spring3.2.0的jar包。3、mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供。</code></pre><p>（2）sqlSessionFactory</p><p>在applicationContext.xml配置sqlSessionFactory和数据源。sqlSessionFactory在mybatis和spring的整合包下。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis的配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h3 id="原始dao开发-和spring整合后"><a href="#原始dao开发-和spring整合后" class="headerlink" title="原始dao开发(和spring整合后)"></a>原始dao开发(和spring整合后)</h3><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.ssm.po.User&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;</code></pre><p></p><p>(2)在SqlMapconfig.xml中加载UserMapper.xml</p><pre><code>&lt;!-- 加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt; </code></pre><p>(3)dao(实现类继承SqlSessionDaoSupport)</p><pre><code>public interface UserDao {    //根据id查询用户信息    public User findUserById(int id) throws Exception;}</code></pre><p>(4)dao接口实现类注入SqlSessoinFactory</p><p>通过spring进行注入。这里spring声明配置方式，配置dao的bean。<strong>让UserDaoImpl实现类继承SqlSessionDaoSupport</strong></p><pre><code>public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao{    @Override    public User findUserById(int id) throws Exception {        //继承SqlSessionDaoSupport，通过this.getSqlSession()得到sqlSessoin        SqlSession sqlSession = this.getSqlSession();        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id);        return user;    }}</code></pre><p>(5)配置dao</p><p>在applicationContext.xml中配置dao:</p><pre><code>&lt;!-- 原始dao接口 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.iot.ssm.dao.UserDaoImpl&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>(6)测试程序</p><pre><code>public class UserDaoImplTest {    private ApplicationContext applicationContext;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testFindUserById() throws Exception {        // 创建UserDao的对象        UserDao userDao = (UserDao)applicationContext.getBean(&quot;userDao&quot;);        // 调用UserDao的方法        User user = userDao.findUserById(1);        System.out.println(user);    }}</code></pre><hr><h3 id="mapper代理开发"><a href="#mapper代理开发" class="headerlink" title="mapper代理开发"></a>mapper代理开发</h3><p>（1）UserMapper.java</p><pre><code>public interface UserMapper {    //根据id查询用户信息    User findUserById(int id) throws Exception;}</code></pre><p>（2）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;com.iot.ssm.mapper.UserMapper&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>（3）通过MapperFactoryBean创建代理对象</p><pre><code>&lt;!-- mapper配置    MapperFactoryBean：根据mapper接口生成代理对象    --&gt;&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        //mapperInterface指定mapper接口        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>此方法问题：需要针对每个mapper进行配置，麻烦。建议使用通过MapperScannerConfigurer进行mapper扫描。</p><pre><code>&lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册    遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中    自动扫描出来的mapper的bean的id为mapper类名（首字母小写）    --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 指定扫描的包名    如果扫描多个包，每个包中间使用半角逗号分隔    --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>（4）测试代码</p><pre><code>package com.iot.mybatis.mapper;import com.iot.ssm.mapper.UserMapper;import com.iot.ssm.po.User;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserMapperTest {    private ApplicationContext applicationContext;    //在setUp这个方法得到spring容器    @Before    public void setUp() throws Exception {        applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);    }    @Test    public void testFindUserById() throws Exception {        UserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);        //调用userMapper的方法        User user = userMapper.findUserById(1);        System.out.println(user);    }}</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778934" target="_blank" rel="noopener">mybatis学习笔记(17)-spring和mybatis整合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;西风吹老洞庭波，一夜湘君白发多。&lt;/center&gt;&lt;br&gt;&lt;center&gt;醉后不知天在水，满船清梦压星河。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-元·唐珙《题龙阳县青草湖》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文主要将如何将spring和mybatis整合
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(16)-mybatis整合ehcache</title>
    <link href="http://www.echodemo.cc/2019/06/30/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)-mybatis%E6%95%B4%E5%90%88ehcache/"/>
    <id>http://www.echodemo.cc/2019/06/30/mybatis学习笔记(16)-mybatis整合ehcache/</id>
    <published>2019-06-30T08:25:30.000Z</published>
    <updated>2019-06-30T08:38:08.459Z</updated>
    
    <content type="html"><![CDATA[<center>夜来携手梦同游，晨起盈巾泪莫收。</center><br><center>漳浦老身三度病，咸阳宿草八回秋。</center><br><center>君埋泉下泥销骨，我寄人间雪满头。</center><br><center>阿卫韩郎相次去，夜台茫昧得知不？</center><br><center>—-唐·白居易《梦微之》</center><hr><p>ehcache是一个分布式缓存框架。</p><h3 id="分布缓存"><a href="#分布缓存" class="headerlink" title="分布缓存"></a>分布缓存</h3><p>通常系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。不使用分布缓存，缓存的数据在各个服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><hr><h3 id="整合方法-掌握"><a href="#整合方法-掌握" class="headerlink" title="整合方法(掌握)"></a>整合方法(掌握)</h3><p>mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。</p><pre><code>package org.apache.ibatis.cache;import java.util.concurrent.locks.ReadWriteLock;/** * SPI for cache providers. *  * One instance of cache will be created for each namespace. *  * The cache implementation must have a constructor that receives the cache id as an String parameter. *  * MyBatis will pass the namespace as id to the constructor. *  * &lt;pre&gt; * public MyCache(final String id) { *  if (id == null) { *    throw new IllegalArgumentException(&quot;Cache instances require an ID&quot;); *  } *  this.id = id; *  initialize(); * } * &lt;/pre&gt; * * @author Clinton Begin */public interface Cache {  /**   * @return The identifier of this cache   */  String getId();  /**   * @param key Can be any object but usually it is a {@link CacheKey}   * @param value The result of a select.   */  void putObject(Object key, Object value);  /**   * @param key The key   * @return The object stored in the cache.   */  Object getObject(Object key);  /**   * Optional. It is not called by the core.   *    * @param key The key   * @return The object that was removed   */  Object removeObject(Object key);  /**   * Clears this cache instance   */    void clear();  /**   * Optional. This method is not called by the core.   *    * @return The number of elements stored in the cache (not its capacity).   */  int getSize();  /**    * Optional. As of 3.2.6 this method is no longer called by the core.   *     * Any locking needed by the cache must be provided internally by the cache provider.   *    * @return A ReadWriteLock    */  ReadWriteLock getReadWriteLock();}</code></pre><p>mybatis默认实现cache类是：</p><pre><code>package org.apache.ibatis.cache.impl;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.cache.CacheException;/** * @author Clinton Begin */public class PerpetualCache implements Cache {  private String id;  private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;();  public PerpetualCache(String id) {    this.id = id;  }  public String getId() {    return id;  }  public int getSize() {    return cache.size();  }  public void putObject(Object key, Object value) {    cache.put(key, value);  }  public Object getObject(Object key) {    return cache.get(key);  }  public Object removeObject(Object key) {    return cache.remove(key);  }  public void clear() {    cache.clear();  }  public ReadWriteLock getReadWriteLock() {    return null;  }  public boolean equals(Object o) {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    if (this == o) return true;    if (!(o instanceof Cache)) return false;    Cache otherCache = (Cache) o;    return getId().equals(otherCache.getId());  }  public int hashCode() {    if (getId() == null) throw new CacheException(&quot;Cache instances require an ID.&quot;);    return getId().hashCode();  }}</code></pre><hr><h3 id="整合ehcache"><a href="#整合ehcache" class="headerlink" title="整合ehcache"></a>整合ehcache</h3><p>加入ehcache包：</p><pre><code>1、ehcache-core-2.6.5.jar2、mybatis-ehcache-1.0.2.jar</code></pre><p>配置mapper中cache中的type为ehcache对cache接口的实现类型</p><pre><code>&lt;!-- 开启本mapper的namespace下的二级缓存type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache要和ehcache整合，需要配置type为ehcache实现cache接口的类型&lt;cache /&gt;--&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><hr><h3 id="加入ehcache的配置文件"><a href="#加入ehcache的配置文件" class="headerlink" title="加入ehcache的配置文件"></a>加入ehcache的配置文件</h3><p>在classpath下配置ehcache.xml：</p><pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt;    &lt;defaultCache         maxElementsInMemory=&quot;1000&quot;         maxElementsOnDisk=&quot;10000000&quot;        eternal=&quot;false&quot;         overflowToDisk=&quot;false&quot;         timeToIdleSeconds=&quot;120&quot;        timeToLiveSeconds=&quot;120&quot;         diskExpiryThreadIntervalSeconds=&quot;120&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50778933" target="_blank" rel="noopener">mybatis学习笔记(16)-mybatis整合ehcache</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;夜来携手梦同游，晨起盈巾泪莫收。&lt;/center&gt;&lt;br&gt;&lt;center&gt;漳浦老身三度病，咸阳宿草八回秋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;君埋泉下泥销骨，我寄人间雪满头。&lt;/center&gt;&lt;br&gt;&lt;center&gt;阿卫韩郎相次去，夜台茫昧得知不？&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
</feed>
