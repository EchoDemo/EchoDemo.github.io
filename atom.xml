<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2020-02-04T02:04:57.135Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git高级用法</title>
    <link href="http://www.echodemo.cc/2020/02/04/Git%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2020/02/04/Git高级用法/</id>
    <published>2020-02-04T00:21:29.000Z</published>
    <updated>2020-02-04T02:04:57.135Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/2/git工作流程图.png" alt="&quot;git工作流程图&quot;"></p><h3 id="1、跳到之前的分支"><a href="#1、跳到之前的分支" class="headerlink" title="1、跳到之前的分支"></a>1、跳到之前的分支</h3><pre><code>git checkout -</code></pre><h3 id="2、查看历史"><a href="#2、查看历史" class="headerlink" title="2、查看历史"></a>2、查看历史</h3><pre><code># 每个提交在一行内显示git log --oneline# 在所有提交日志中搜索包含「homepage」的提交git log --all --grep=&apos;homepage&apos;# 获取某人的提交日志git log --author=&quot;Maxence&quot;</code></pre><h3 id="3、之前重置了一个不想保留的提交，但是现在又想要回滚"><a href="#3、之前重置了一个不想保留的提交，但是现在又想要回滚" class="headerlink" title="3、之前重置了一个不想保留的提交，但是现在又想要回滚"></a>3、之前重置了一个不想保留的提交，但是现在又想要回滚</h3><pre><code># 获取所有操作历史git reflog# 重置到相应提交git reset HEAD@{4}# ……或者……git reset --hard &lt;提交的哈希值&gt;</code></pre><h3 id="4、我把本地仓库搞得一团糟，应该怎么清理？"><a href="#4、我把本地仓库搞得一团糟，应该怎么清理？" class="headerlink" title="4、我把本地仓库搞得一团糟，应该怎么清理？"></a>4、我把本地仓库搞得一团糟，应该怎么清理？</h3><pre><code>git fetch origingit checkout mastergit reset --hard origin/master</code></pre><h3 id="5、查看我的分支和-master-的不同"><a href="#5、查看我的分支和-master-的不同" class="headerlink" title="5、查看我的分支和 master 的不同"></a>5、查看我的分支和 master 的不同</h3><pre><code>git diff master..my-branch</code></pre><h3 id="6、定制提交"><a href="#6、定制提交" class="headerlink" title="6、定制提交"></a>6、定制提交</h3><pre><code># 编辑上次提交git commit --amend -m &quot;更好的提交日志&quot;# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit# 空提交 —— 可以用来重新触发 CI 构建git commit --allow-empty -m &quot;chore: re-trigger build&quot;</code></pre><h3 id="7、squash-提交"><a href="#7、squash-提交" class="headerlink" title="7、squash 提交"></a>7、squash 提交</h3><p>比方说我想要 rebase 最近 3 个提交：</p><pre><code>- git rebase -i HEAD~3- 保留第一行的 pick，剩余提交替换为 squash 或 s- 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）pick 64d26a1 feat: add index.jss 45f0259 fix: update index.jss 8b15b0a fix: typo in index.js</code></pre><h3 id="8、修正"><a href="#8、修正" class="headerlink" title="8、修正"></a>8、修正</h3><p>比方说想在提交 fed14a4c 加上一些内容。</p><p><img src="/images/2020/2/git提交分支.png" alt="&quot;git工作流程图&quot;"></p><pre><code>git add .git commit --fixup HEAD~1# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1git rebase -i HEAD~3 --autosquash# 保存并退出文件（VI 中输入 `:wq`）</code></pre><h3 id="9、rebase-的时候在每个提交上执行命令"><a href="#9、rebase-的时候在每个提交上执行命令" class="headerlink" title="9、rebase 的时候在每个提交上执行命令"></a>9、rebase 的时候在每个提交上执行命令</h3><p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase –exec 命令在每个提交上执行命令。</p><pre><code># 在最近 3 个提交上运行 `npm test` 命令git rebase HEAD~3 --exec &quot;npm test&quot;</code></pre><p><img src="/images/2020/2/在每个提交上执行命令.png" alt="&quot;git工作流程图&quot;"></p><h3 id="10、暂存"><a href="#10、暂存" class="headerlink" title="10、暂存"></a>10、暂存</h3><p>暂存不止是 git stash 和 git stash pop ;)</p><pre><code># 保存所有正在追踪的文件git stash save &quot;日志信息&quot;# 列出所有的暂存项git stash list# 获取并删除暂存项git stash apply stash@{1}git stash drop stash@{1}# ……或使用一条命令……git stash pop stash@{1}</code></pre><h3 id="11、清理"><a href="#11、清理" class="headerlink" title="11、清理"></a>11、清理</h3><pre><code># 移除远程仓库上不存在的分支git fetch -p# 移除所有包含 `greenkeeper` 的分支git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &apos;s/^.\{9\}//&apos; | xargs git push origin --delete</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2020/2/git工作流程图.png&quot; alt=&quot;&amp;quot;git工作流程图&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、跳到之前的分支&quot;&gt;&lt;a href=&quot;#1、跳到之前的分支&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 最长公共前缀</title>
    <link href="http://www.echodemo.cc/2020/01/18/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://www.echodemo.cc/2020/01/18/LeetCode-最长公共前缀/</id>
    <published>2020-01-18T02:20:19.000Z</published>
    <updated>2020-01-18T11:41:00.979Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><pre><code>示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h3 id="题解：一个字符一个字符比较"><a href="#题解：一个字符一个字符比较" class="headerlink" title="题解：一个字符一个字符比较"></a>题解：一个字符一个字符比较</h3><pre><code>class Solution {    public String longestCommonPrefix(String[] strs) {        int strsLen = strs.length;        if (strsLen == 0) {            return &quot;&quot;;        }        int str1Len = strs[0].length();        int i = 0;        String str1 = strs[0];        for (i = 0; i &lt; str1Len; i++) {            char c = str1.charAt(i);            int k = 1;            for (int j = 1; j &lt; strsLen; j++) {                if (strs[j].length() &lt;= i)                    break;                if (c == strs[j].charAt(i))                    k++;            }            if (k == strsLen) {                continue;            } else {                break;            }        }        if (i == 0) {            return &quot;&quot;;        } else {            return str1.substring(0, i);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]
输出
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 罗马数字转整型</title>
    <link href="http://www.echodemo.cc/2020/01/12/LeetCode-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2020/01/12/LeetCode-罗马数字转整型/</id>
    <published>2020-01-12T09:04:35.000Z</published>
    <updated>2020-01-13T13:17:50.336Z</updated>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><pre><code>示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h3 id="题解一：纯遍历（map）"><a href="#题解一：纯遍历（map）" class="headerlink" title="题解一：纯遍历（map）:"></a>题解一：纯遍历（map）:</h3><pre><code>class Solution {    public int romanToInt(String s) {        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(7);        map.put(&apos;I&apos;, 1);        map.put(&apos;V&apos;, 5);        map.put(&apos;X&apos;, 10);        map.put(&apos;L&apos;, 50);        map.put(&apos;C&apos;, 100);        map.put(&apos;D&apos;, 500);        map.put(&apos;M&apos;, 1000);        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = map.get(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = map.get(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }}</code></pre><h3 id="题解二-switch-："><a href="#题解二-switch-：" class="headerlink" title="题解二(switch)："></a>题解二(switch)：</h3><pre><code>class Solution {    public int romanToInt(String s) {        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = getValue(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = getValue(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }    private int getValue(char c) {        switch (c) {            case &apos;I&apos;: return 1;            case &apos;V&apos;: return 5;            case &apos;X&apos;: return 10;            case &apos;L&apos;: return 50;            case &apos;C&apos;: return 100;            case &apos;D&apos;: return 500;            case &apos;M&apos;: return 1000;            default : return 0;        }    }}(1)执行用时 :4 ms, 在所有 Java 提交中击败了99.96%的用户(2)内存消耗 :35.9 MB, 在所有 Java 提交中击败了99.59%的用户</code></pre><p>switch语句被编译后，对应得是jvm的tableswitch指令，执行起来也就几条指令就完成了;而HashMap的get操作源码如下:</p><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    int hash = hash(key.hashCode());    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];         e != null;         e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    return null;}</code></pre><p>所以map.get执行的jvm指令肯定是要比tableswitch要多的。但是如果JVM在执行的过程中进行JIT优化会发现，map的执行速度会大大加快，而使用switch实现的方法并不会被优化。</p><h4 id="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"><a href="#所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。" class="headerlink" title="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"></a>所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C      
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://www.echodemo.cc/2020/01/11/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2020/01/11/docker常用命令/</id>
    <published>2020-01-11T13:00:23.000Z</published>
    <updated>2020-01-11T13:01:19.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker镜像常用命令"><a href="#docker镜像常用命令" class="headerlink" title="docker镜像常用命令"></a>docker镜像常用命令</h3><h4 id="1、搜索镜像"><a href="#1、搜索镜像" class="headerlink" title="1、搜索镜像"></a>1、搜索镜像</h4><pre><code>docker search java</code></pre><h4 id="2、下载镜像"><a href="#2、下载镜像" class="headerlink" title="2、下载镜像"></a>2、下载镜像</h4><pre><code>// 由于docker search命令只能查找出是否有该镜像，不能找到该镜像支持的版本，所以我们需要通过docker hub来搜索支持的版本。进入docker hub的官网，地址：https://hub.docker.com。然后搜索需要的镜像，查看镜像支持的版本。docker pull java:8</code></pre><h4 id="3、列出镜像"><a href="#3、列出镜像" class="headerlink" title="3、列出镜像"></a>3、列出镜像</h4><pre><code>docker images</code></pre><h4 id="4、删除镜像"><a href="#4、删除镜像" class="headerlink" title="4、删除镜像"></a>4、删除镜像</h4><pre><code>// 指定名称删除镜像docker rmi java:8// 指定名称删除镜像（强制）docker rmi -f java:8// 强制删除所有镜像docker rmi -f $(docker images)</code></pre><h3 id="docker容器常用命令"><a href="#docker容器常用命令" class="headerlink" title="docker容器常用命令"></a>docker容器常用命令</h3><h4 id="1、新建并启动容器"><a href="#1、新建并启动容器" class="headerlink" title="1、新建并启动容器"></a>1、新建并启动容器</h4><pre><code>docker run -p 80:80 --name nginx -d nginx:1.17.0-d选项：表示后台运行--name选项：指定运行后容器的名字为nginx,之后可以通过名字来操作容器-p选项：指定端口映射，格式为：hostPort:containerPort</code></pre><h4 id="2、列出容器"><a href="#2、列出容器" class="headerlink" title="2、列出容器"></a>2、列出容器</h4><pre><code>// 列出运行中的容器docker ps// 列出所有容器docker ps -a</code></pre><h4 id="3、停止容器"><a href="#3、停止容器" class="headerlink" title="3、停止容器"></a>3、停止容器</h4><pre><code>// $ContainerName及$ContainerId可以用docker ps命令查询出来docker stop $ContainerName(或者$ContainerId)// 强制停止容器docker kill $ContainerName(或者$ContainerId)// 启动已停止的容器docker start $ContainerName(或者$ContainerId)</code></pre><h4 id="4、进入容器"><a href="#4、进入容器" class="headerlink" title="4、进入容器"></a>4、进入容器</h4><pre><code>// 先查询出容器的piddocker inspect --format &quot;{{.State.Pid}}&quot; $ContainerName(或者$ContainerId)// 根据容器的pid进入容器nsenter --target &quot;$pid&quot; --mount --uts --ipc --net --pid</code></pre><h4 id="5、删除容器"><a href="#5、删除容器" class="headerlink" title="5、删除容器"></a>5、删除容器</h4><pre><code>// 删除指定容器docker rm $ContainerName(或者$ContainerID)// 强制删除所有容器docker rm -f $(docker ps -a -q)</code></pre><h4 id="6、查看容器的日志"><a href="#6、查看容器的日志" class="headerlink" title="6、查看容器的日志"></a>6、查看容器的日志</h4><pre><code>docker logs $ContainerName(或者$ContainerId)</code></pre><h4 id="7、查看容器的IP地址"><a href="#7、查看容器的IP地址" class="headerlink" title="7、查看容器的IP地址"></a>7、查看容器的IP地址</h4><pre><code>docker inspect --format &apos;{{ .NetworkSettings.IPAddress }}&apos; $ContainerName(或者$ContainerId)</code></pre><h4 id="8、同步宿主机时间到容器"><a href="#8、同步宿主机时间到容器" class="headerlink" title="8、同步宿主机时间到容器"></a>8、同步宿主机时间到容器</h4><pre><code>docker cp /etc/localtime $ContainerName(或者$ContainerId):/etc/</code></pre><h4 id="9、在宿主机查看docker使用cpu、内存、网络、io情况"><a href="#9、在宿主机查看docker使用cpu、内存、网络、io情况" class="headerlink" title="9、在宿主机查看docker使用cpu、内存、网络、io情况"></a>9、在宿主机查看docker使用cpu、内存、网络、io情况</h4><pre><code>// 查看指定容器情况docker stats $ContainerName(或者$ContainerId)// 查看所有容器情况docker stats -a</code></pre><h4 id="10、进入Docker容器内部的bash"><a href="#10、进入Docker容器内部的bash" class="headerlink" title="10、进入Docker容器内部的bash"></a>10、进入Docker容器内部的bash</h4><pre><code>docker exec -it $ContainerName /bin/bash</code></pre><h3 id="修改Docker镜像的存放位置"><a href="#修改Docker镜像的存放位置" class="headerlink" title="修改Docker镜像的存放位置"></a>修改Docker镜像的存放位置</h3><h4 id="1、查看docker镜像的存放位置"><a href="#1、查看docker镜像的存放位置" class="headerlink" title="1、查看docker镜像的存放位置"></a>1、查看docker镜像的存放位置</h4><pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><h4 id="2、关闭Docker服务"><a href="#2、关闭Docker服务" class="headerlink" title="2、关闭Docker服务"></a>2、关闭Docker服务</h4><pre><code>systemctl stop docker</code></pre><h4 id="3、移动目录到目标路径"><a href="#3、移动目录到目标路径" class="headerlink" title="3、移动目录到目标路径"></a>3、移动目录到目标路径</h4><pre><code>mv /var/lib/docker /mydata/docker</code></pre><h4 id="4、建立软连接"><a href="#4、建立软连接" class="headerlink" title="4、建立软连接"></a>4、建立软连接</h4><pre><code>ln -s /mydata/docker /var/lib/docker</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker镜像常用命令&quot;&gt;&lt;a href=&quot;#docker镜像常用命令&quot; class=&quot;headerlink&quot; title=&quot;docker镜像常用命令&quot;&gt;&lt;/a&gt;docker镜像常用命令&lt;/h3&gt;&lt;h4 id=&quot;1、搜索镜像&quot;&gt;&lt;a href=&quot;#1、搜索镜像&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装MongoDB</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装MongoDB/</id>
    <published>2020-01-11T12:50:17.000Z</published>
    <updated>2020-01-11T12:51:41.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、搜索MongoDB镜像"><a href="#1、搜索MongoDB镜像" class="headerlink" title="1、搜索MongoDB镜像"></a>1、搜索MongoDB镜像</h3><pre><code>docker search mongodb</code></pre><h3 id="2、拉取MongoDB镜像"><a href="#2、拉取MongoDB镜像" class="headerlink" title="2、拉取MongoDB镜像"></a>2、拉取MongoDB镜像</h3><pre><code>docker pull mongo:4.0.14</code></pre><h3 id="3-查看本地的镜像"><a href="#3-查看本地的镜像" class="headerlink" title="3.查看本地的镜像"></a>3.查看本地的镜像</h3><pre><code>docker images mongo</code></pre><h3 id="4、启动mongo-27017为端口号"><a href="#4、启动mongo-27017为端口号" class="headerlink" title="4、启动mongo (27017为端口号)"></a>4、启动mongo (27017为端口号)</h3><pre><code>docker run -p 27017:27017 -td mongo</code></pre><h3 id="5、查看启动情况"><a href="#5、查看启动情况" class="headerlink" title="5、查看启动情况"></a>5、查看启动情况</h3><pre><code>docker ps</code></pre><h3 id="6、win10下载进行navicat连接"><a href="#6、win10下载进行navicat连接" class="headerlink" title="6、win10下载进行navicat连接"></a>6、win10下载进行navicat连接</h3><h3 id="7、进入到mongodb容器"><a href="#7、进入到mongodb容器" class="headerlink" title="7、进入到mongodb容器"></a>7、进入到mongodb容器</h3><pre><code>docker exec -it  371601d910b8  mongo admin (以管理员身份进入 371601d910b8 镜像运行id通过docker ps查看)容器停止退出，命令： exit</code></pre><h3 id="8、docker-exec进入Docker容器"><a href="#8、docker-exec进入Docker容器" class="headerlink" title="8、docker exec进入Docker容器"></a>8、docker exec进入Docker容器</h3><pre><code>sudo docker exec -it 775c7c9ee1e1 /bin/bash (-it 标准输入和关联伪终端，-it后跟容器ID，/bin/bash是命令，表示在该容器中运行该命令)</code></pre><h3 id="9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID"><a href="#9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID" class="headerlink" title="9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)"></a>9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;a href=&quot;#1、搜索MongoDB镜像&quot; class=&quot;headerlink&quot; title=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;/a&gt;1、搜索MongoDB镜像&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;docker search mong
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="MongoDB" scheme="http://www.echodemo.cc/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装RabbitMQ</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装RabbitMQ/</id>
    <published>2020-01-11T12:48:06.000Z</published>
    <updated>2020-01-11T12:50:15.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、访问：https-hub-docker-com"><a href="#1、访问：https-hub-docker-com" class="headerlink" title="1、访问：https://hub.docker.com/"></a>1、访问：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></h3><h3 id="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。"><a href="#2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。" class="headerlink" title="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。"></a>2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。</h3><h3 id="3、拉取镜像："><a href="#3、拉取镜像：" class="headerlink" title="3、拉取镜像："></a>3、拉取镜像：</h3><pre><code>docker pull rabbitmq:3.7.17-management</code></pre><h3 id="4、查看是否拉取成功"><a href="#4、查看是否拉取成功" class="headerlink" title="4、查看是否拉取成功"></a>4、查看是否拉取成功</h3><pre><code>docker images</code></pre><h3 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h3><pre><code>docker run -d -p 5672:5672 -p 15672:15672  --name rabbitmq  7601e834fa14-d：后台运行-p：映射端口-p 5672:5672 ：把主机的5672端口映射成rabbitMQ的5672端口-p 15672:15672 ： web管理界面的–name :起个名字7601e834fa14：镜像的id</code></pre><h3 id="测试是否访问成功"><a href="#测试是否访问成功" class="headerlink" title="测试是否访问成功:"></a>测试是否访问成功:</h3><pre><code>在浏览器中输入：http://安装RabbitMQ的主机IP:15672 (默认的账号密码皆为guest)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、访问：https-hub-docker-com&quot;&gt;&lt;a href=&quot;#1、访问：https-hub-docker-com&quot; class=&quot;headerlink&quot; title=&quot;1、访问：https://hub.docker.com/&quot;&gt;&lt;/a&gt;1、访问：&lt;a 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="RabbitMQ" scheme="http://www.echodemo.cc/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 整数反转</title>
    <link href="http://www.echodemo.cc/2020/01/11/LeetCode-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://www.echodemo.cc/2020/01/11/LeetCode-整数反转/</id>
    <published>2020-01-11T12:23:49.000Z</published>
    <updated>2020-01-11T12:42:15.257Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><pre><code>示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21</code></pre><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h3 id="题解-一-：转化为字符串，再转回整型"><a href="#题解-一-：转化为字符串，再转回整型" class="headerlink" title="题解(一)：转化为字符串，再转回整型"></a>题解(一)：转化为字符串，再转回整型</h3><pre><code>class Solution{    public static int reverse(int x) {        String str = String.valueOf(x);        String result = &quot;&quot;;        if (&apos;-&apos; == str.charAt(0)) {            result = result + &quot;-&quot;;            str = str.substring(1);        }        int strLen = str.length();        for (int i = strLen - 1; i &gt; -1; i--) {            result = result + str.charAt(i);        }        try {            int iResult = Integer.parseInt(result);            return iResult;        } catch (NumberFormatException e) {            return 0;        }    }}</code></pre><h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><pre><code>// pop operation:pop = x % 10;x /= 10;// push operation:temp = rev * 10 + pop;rev = temp;</code></pre><p>这种方法很危险，因为当 temp = rev * 10 + pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。为了便于解释，我们假设 rev 是正数。</p><pre><code>(1）如果 temp = rev * 10 + pop 导致溢出，那么一定有 rev ≥ INTMAX / 10。(2)如果 rev &gt; INTMAX / 10 ，那么 temp = rev * 10 + pop 一定会溢出。(3)如果 rev == INTMAX / 10，那么只要 pop &gt; 7，temp = rev * 10 + pop 就会溢出。当 rev 为负时可以应用类似的逻辑。class Solution {    public int reverse(int x) {        int rev = 0;        while (x != 0) {            int pop = x % 10;            x /= 10;            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0;            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0;            rev = rev * 10 + pop;        }        return rev;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 123
输出: 321

示例 2:

输入: -123
输出: -321

示例 3:

输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 可被5整除的二进制前缀</title>
    <link href="http://www.echodemo.cc/2020/01/11/LeetCode-%E5%8F%AF%E8%A2%AB5%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80/"/>
    <id>http://www.echodemo.cc/2020/01/11/LeetCode-可被5整除的二进制前缀/</id>
    <published>2020-01-11T12:21:29.000Z</published>
    <updated>2020-01-11T12:46:12.955Z</updated>
    
    <content type="html"><![CDATA[<p>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。</p><pre><code>示例 1：输入：[0,1,1]输出：[true,false,false]解释：输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。示例 2：输入：[1,1,1]输出：[false,false,false]示例 3：输入：[0,1,1,1,1,1]输出：[true,false,false,false,true,false]示例 4：输入：[1,1,1,0,1]输出：[false,false,false,false,false]</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><pre><code>class Solution {    public List&lt;Boolean&gt; prefixesDivBy5(int[] A) {        int len = A.length;        int sum = 0;        List&lt;Boolean&gt; result = new ArrayList&lt;&gt;(len);        for (int i = 0; i &lt; len; i++) {            sum = ((sum &lt;&lt; 1) + A[i]) % 5;            if (sum == 0) {                result.add(i, true);            } else {                result.add(i, false);            }        }        return result;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。&lt;/p&gt;
&lt;p&gt;返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 戳气球</title>
    <link href="http://www.echodemo.cc/2020/01/05/LeetCode-%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>http://www.echodemo.cc/2020/01/05/LeetCode-戳气球/</id>
    <published>2020-01-05T12:07:36.000Z</published>
    <updated>2020-01-11T12:25:32.844Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p><pre><code>示例:输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i][j]表示第i至第j个元素这个区间能获得的最大硬币数，k表示在i,j这个区间内最后戳破的气球，状态转移方程dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]<em>nums[k]</em>nums[j])</p><pre><code>    public int maxCoins(int[] nums) {        int N = nums.length;        int len = N + 2;        int[] newNums = new int[len];        newNums[0] = 1;        newNums[len -1] = 1;        for(int i = 0; i &lt; nums.length; i++){            newNums[i+1] = nums[i];        }        int[][] dp = new int[len][len];        for (int i = 0; i &lt; len; i++) {            for (int j = 0; j &lt; len; j++) {                dp[i][j] = 0;            }        }        for (int c = 2; c &lt;= len; c++) {            for (int i = 0; i &lt; len - c; i++) {                int j = i + c;                for (int k = i + 1; k &lt; j; k++) {                    dp[i][j] = Math.max(dp[i][j], newNums[i] * newNums[k] * newNums[j]                            + dp[i][k] + dp[k][j]);                }            }        }        return dp[0][len - 1];}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] &lt;em&gt; nums[i] &lt;/em&gt; nums[right] 个硬币。 这
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 查找常用字符</title>
    <link href="http://www.echodemo.cc/2019/12/21/LeetCode-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.echodemo.cc/2019/12/21/LeetCode-查找常用字符/</id>
    <published>2019-12-21T11:02:36.000Z</published>
    <updated>2019-12-21T13:06:23.748Z</updated>
    
    <content type="html"><![CDATA[<p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><pre><code>示例 1：输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]示例 2：输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;]</code></pre><h3 id="题解一（利用set和map）："><a href="#题解一（利用set和map）：" class="headerlink" title="题解一（利用set和map）："></a>题解一（利用set和map）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    // 存放第一个字符串的字符    Set&lt;Character&gt; characterSet = new HashSet&lt;&gt;(A[0].length());    // 存放第一个字符串字符出现的次数，初始值为1    Map&lt;Character, Integer&gt; a0CharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());    // 将第一个字符串中字符装载进set和map    for (int i = 0; i&lt; A[0].length(); i++) {        // 如果set里面已经有该字符，则第一个字符串map对应的字符出现次数加一        if (characterSet.contains(A[0].charAt(i))) {            a0CharacterIntegerMap.put(A[0].charAt(i), a0CharacterIntegerMap.get(A[0].charAt(i)) + 1);        } else {            // 如果没有，则将该字符都初始化进map和set            characterSet.add(A[0].charAt(i));            a0CharacterIntegerMap.put(A[0].charAt(i), 1);        }    }    // 对剩下的字符串进行处理    for (int i = 1; i &lt; A.length; i++) {        // 每个字符串字符的临时map，初始值为0        Map&lt;Character, Integer&gt; tempCharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());        for (int j = 0; j&lt; A[i].length(); j++) {            if (!tempCharacterIntegerMap.containsKey(A[i].charAt(j))) {                tempCharacterIntegerMap.put(A[i].charAt(j), 0);            }            if (characterSet.contains((A[i].charAt(j)))) {                tempCharacterIntegerMap.put(A[i].charAt(j), tempCharacterIntegerMap.get(A[i].charAt(j)) + 1);            }        }        // 将临时map和第一个字符串的map作比较并处理        for (int j = 0; j &lt; A[0].length(); j++) {            // 如果临时map没有第一个字符串map里面的字符，则第一个字符串map的该字符出现次数置为0            if (!tempCharacterIntegerMap.containsKey(A[0].charAt(j))) {                a0CharacterIntegerMap.put(A[0].charAt(j), 0);            } else {                // 如果临时map有第一个字符串map里面的字符，且临时map出现的次数更少，则取更少次数的值                if (a0CharacterIntegerMap                        .get(A[0].charAt(j)) &gt; tempCharacterIntegerMap.get(A[0].charAt(j))) {                    a0CharacterIntegerMap.put(A[0].charAt(j), tempCharacterIntegerMap.get(A[0].charAt(j)));                }            }        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    // 遍历set，取第一个字符串字符对应的出现次数    for (Character character : characterSet) {        if (a0CharacterIntegerMap.get(character) &gt; 0) {            for (int i = 0; i &lt; a0CharacterIntegerMap.get(character); i++) {                list.add(String.valueOf(character));            }        }    }    return list;}</code></pre><h3 id="题解二（抓住提示字符都是小写字母）："><a href="#题解二（抓住提示字符都是小写字母）：" class="headerlink" title="题解二（抓住提示字符都是小写字母）："></a>题解二（抓住提示字符都是小写字母）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    int[] a0 = new int[26];    for (int i = 0; i &lt; 26; i++) {        a0[i] = Integer.MAX_VALUE;    }    for (String str : A) {        // 初始化        int[] temp = new int[26];        for (int i = 0; i &lt; 26; i++) {            temp[i] = 0;        }        // 统计字符出现次数        for (char c : str.toCharArray()) {            temp[c - &apos;a&apos;]++;        }        for (int i = 0; i &lt; 26; i++) {            a0[i] = Math.min(a0[i], temp[i]);        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 26; i++) {        while (a0[i] &gt; 0) {            list.add(String.valueOf((char)(&apos;a&apos; + i)));            a0[i]--;        }    }    return list;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 两数之和</title>
    <link href="http://www.echodemo.cc/2019/12/13/LeetCode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.echodemo.cc/2019/12/13/LeetCode-两数之和/</id>
    <published>2019-12-13T14:29:40.000Z</published>
    <updated>2019-12-13T14:30:04.557Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><pre><code>示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="题解一（自写暴力破解法）："><a href="#题解一（自写暴力破解法）：" class="headerlink" title="题解一（自写暴力破解法）："></a>题解一（自写暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        int i;        int j = 0;        for (i = 0; i &lt; numsLen; i++) {            boolean k = false;            for (j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    k = true;                    break;                }            }            if (k) {                break;            }        }        int[] resultIntArray = new int[2];        resultIntArray[0] = i;        resultIntArray[1] = j;        return resultIntArray;    }}</code></pre><h3 id="题解二（官方暴力破解法）："><a href="#题解二（官方暴力破解法）：" class="headerlink" title="题解二（官方暴力破解法）："></a>题解二（官方暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        for (int i = 0; i &lt; numsLen; i++) {            for (int j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    return new int[] { i, j };                }            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><p>以上两种解法的复杂度分析：</p><p>时间复杂度：O(n^2)O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n2)。</p><p>空间复杂度：O(1)O(1)。</p><h3 id="题解三（两遍哈希表）："><a href="#题解三（两遍哈希表）：" class="headerlink" title="题解三（两遍哈希表）："></a>题解三（两遍哈希表）：</h3><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            map.put(nums[i], i);        }        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {                return new int[] { i, map.get(complement) };            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><h3 id="题解四（一遍哈希表）："><a href="#题解四（一遍哈希表）：" class="headerlink" title="题解四（一遍哈希表）："></a>题解四（一遍哈希表）：</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement)) {                return new int[] { map.get(complement), i };            }            map.put(nums[i], i);        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

给定 nums
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>临飞鸟</title>
    <link href="http://www.echodemo.cc/2019/11/30/%E4%B8%B4%E9%A3%9E%E9%B8%9F/"/>
    <id>http://www.echodemo.cc/2019/11/30/临飞鸟/</id>
    <published>2019-11-30T14:32:52.000Z</published>
    <updated>2019-12-26T14:23:49.748Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>我看着窗边的单向历一页页地薄下去<br><br>就像天边的光亮一点点地变暗<br><br>他们都在悄悄地告诉我<br><br>距离见到你又更近了一步<br><br><br><br><br>此刻，我的心在扑通扑通地跳动<br><br>右手的指头轮询地敲打着木桃色的桌面<br><br>神经递质游走的能量来自于对你的想念<br><br>是你予我的记忆陪伴我度过一个个夜晚<br><br><br><br><br>也许你不太知道的是<br><br>我想和你一起去发现杭州冬天的讯息<br><br>去看曲院风荷里一陇又一陇的残荷<br><br>傍晚在苏堤春晓的尽头看雷峰夕照的倩影<br><br>以及站在断桥残雪上看整条北山街泛红的梧桐树叶<br><br><br><br><br>所有这些，甚至是在梦里<br><br>我想这我不必告诉你<br><br>在飞鸟来临的清晨<br><br>当你看到松的沉默，雪的孤寂就能明了<br><br><br><br><br>如果定要我说点什么的话<br><br>那么我所想过的最浪漫的事情<br><br>便是与你一起看遍西湖的春夏与秋冬<br><br></center><h6 id="注：致一段还未开始就已夭折的经历"><a href="#注：致一段还未开始就已夭折的经历" class="headerlink" title="注：致一段还未开始就已夭折的经历"></a>注：致一段还未开始就已夭折的经历</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;我看着窗边的单向历一页页地薄下去&lt;br&gt;&lt;br&gt;就像天边的光亮一点点地变暗&lt;br&gt;&lt;br&gt;他们都在悄悄地告诉我&lt;br&gt;&lt;br&gt;距离见到你又更近了一步&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;此刻，我的心在扑通扑通地跳动&lt;br&gt;&lt;br&gt;右手的指头轮询地
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>秋夜</title>
    <link href="http://www.echodemo.cc/2019/09/05/%E7%A7%8B%E5%A4%9C/"/>
    <id>http://www.echodemo.cc/2019/09/05/秋夜/</id>
    <published>2019-09-05T13:45:58.000Z</published>
    <updated>2019-09-15T03:19:53.438Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>秋天的夜晚能否告诉我<br><br>有谁？曾在这样的时刻走进你的心房<br><br>倾听你的低语<br><br>聆听你的呢喃<br><br>为你沉默寡言<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;秋天的夜晚能否告诉我&lt;br&gt;&lt;br&gt;有谁？曾在这样的时刻走进你的心房&lt;br&gt;&lt;br&gt;倾听你的低语&lt;br&gt;&lt;br&gt;聆听你的呢喃&lt;br&gt;&lt;br&gt;为你沉默寡言&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2019/08/31/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2019/08/31/梦境/</id>
    <published>2019-08-30T16:27:05.000Z</published>
    <updated>2019-09-15T03:18:17.604Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>深夜里的寂静<br><br>被窗檐的滴雨打碎<br><br>一束亮光侵袭眉眼<br><br>我不记得梦中的发生<br><br>清晨，傍晚或是午后<br><br>故乡，此地还是远处<br><br>我是我不是我是我不<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;深夜里的寂静&lt;br&gt;&lt;br&gt;被窗檐的滴雨打碎&lt;br&gt;&lt;br&gt;一束亮光侵袭眉眼&lt;br&gt;&lt;br&gt;我不记得梦中的发生&lt;br&gt;&lt;br&gt;清晨，傍晚或是午后&lt;br&gt;&lt;br&gt;故乡，此地还是远处&lt;br&gt;&lt;br&gt;我是我不是我是我不&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>遐想</title>
    <link href="http://www.echodemo.cc/2019/08/27/%E9%81%90%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2019/08/27/遐想/</id>
    <published>2019-08-27T15:30:41.000Z</published>
    <updated>2019-09-15T03:16:28.181Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>请你不要呼唤我的名字<br><br>傍晚天边的晚霞<br><br>秋日晴朗的天气<br><br><br><br><br>当太阳隐没之后<br><br>你就在我的眼眸里流转<br><br>还有路边小桥下的流水<br><br>都是久违的神情<br><br><br><br><br>请你不要呼唤我的名字<br><br>西北高楼里刚燃起的灯火<br><br>手中瞬息万变的一方土地<br><br><br><br><br>当尽在眼底的繁华褪去<br><br>没有人会记得你们的名字<br><br>还有那些默默相守的时光<br><br>一切都是烟云<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;请你不要呼唤我的名字&lt;br&gt;&lt;br&gt;傍晚天边的晚霞&lt;br&gt;&lt;br&gt;秋日晴朗的天气&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;当太阳隐没之后&lt;br&gt;&lt;br&gt;你就在我的眼眸里流转&lt;br&gt;&lt;br&gt;还有路边小桥下的流水&lt;br&gt;&lt;br&gt;都是久违的神情&lt;br&gt;&lt;b
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(20)-拦截器</title>
    <link href="http://www.echodemo.cc/2019/08/04/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B020)-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/08/04/springmvc学习笔记20)-拦截器/</id>
    <published>2019-08-04T12:23:29.000Z</published>
    <updated>2019-08-04T12:41:16.157Z</updated>
    
    <content type="html"><![CDATA[<center>青山隐隐水迢迢，秋尽江南草未凋。</center><br><center>二十四桥明月夜，玉人何处教吹箫？</center><br><center>—-宋·杜牧《寄扬州韩绰判官》</center><hr><h3 id="拦截定义"><a href="#拦截定义" class="headerlink" title="拦截定义"></a>拦截定义</h3><p>定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</p><pre><code>public class HandlerInterceptor1 implements HandlerInterceptor{    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><p>可以从名称和参数看出各个接口的顺序和作用:</p><pre><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{}</code></pre><p>参数最少，只有三个。进入 Handler方法之前执行。用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行。</p><pre><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception{}</code></pre><p>多了一个modelAndView参数。进入Handler方法之后，返回modelAndView之前执行应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图。</p><pre><code>public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {}</code></pre><p>多了一个Exception的类型的参数。执行Handler完成执行此方法。应用场景：统一异常处理，统一日志处理。</p><hr><h3 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h3><p>（1）针对HandlerMapping配置</p><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。</p><pre><code>&lt;bean    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;    &lt;property name=&quot;interceptors&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt;            &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt;&lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt;</code></pre><p>一般不推荐使用。</p><p>（2）类似全局的拦截器</p><p>springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;mvc:interceptor&gt;        &lt;!-- /**表示所有url包括子url路径 --&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><hr><h3 id="拦截测试"><a href="#拦截测试" class="headerlink" title="拦截测试"></a>拦截测试</h3><p>测试多个拦截器各个方法执行时机。访问/items/queryItems.action。</p><p>（1）两个拦截器都放行</p><pre><code>DEBUG [http-apr-8080-exec-1] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSourceDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC ConnectionDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSourceHandlerInterceptor2...postHandleHandlerInterceptor1...postHandleDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name &apos;items/itemsList&apos;; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name &apos;springmvc&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemtypes&apos; of type [java.util.HashMap] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsQueryVo&apos; of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;org.springframework.validation.BindingResult.itemsQueryVo&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsList&apos; of type [java.util.ArrayList] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView &apos;items/itemsList&apos;HandlerInterceptor2...afterCompletionHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-1] - Successfully completed request</code></pre><p>总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。</p><p>（2）拦截器1放行，拦截器2不放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1放行，拦截器2 preHandle才会执行。2、拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。3、只要有一个拦截器不放行，postHandle不会执行。</code></pre><p>（3）两个拦截器都不放</p><pre><code>DEBUG [http-apr-8080-exec-9] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-9] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。2、拦截器1 preHandle不放行，拦截器2不执行。</code></pre><p>（4）拦截器1不放行，拦截器2放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>根据测试结果，对拦截器应用。</p><p>比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</p><p>比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）</p><hr><h3 id="拦截器应用-实现登陆认证"><a href="#拦截器应用-实现登陆认证" class="headerlink" title="拦截器应用(实现登陆认证)"></a>拦截器应用(实现登陆认证)</h3><p>(1)需求</p><pre><code>1、用户请求url2、拦截器进行拦截校验     （1）如果请求的url是公开地址（无需登陆即可访问的url），让放行。    （2）如果用户session 不存在跳转到登陆页面。    （3）如果用户session存在放行，继续操作。</code></pre><p>（2）登陆controller方法</p><pre><code>@Controllerpublic class LoginController {    // 登陆    @RequestMapping(&quot;/login&quot;)    public String login(HttpSession session, String username, String password)            throws Exception {        // 调用service进行用户身份验证        // ...        // 在session中保存用户身份信息        session.setAttribute(&quot;username&quot;, username);        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }    // 退出    @RequestMapping(&quot;/logout&quot;)    public String logout(HttpSession session) throws Exception {        // 清除session        session.invalidate();        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }}</code></pre><p>（3）登陆认证拦截实现</p><p>代码实现：</p><pre><code>public class LoginInterceptor implements HandlerInterceptor {    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response, Object handler) throws Exception {        //获取请求的url        String url = request.getRequestURI();        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）        //这里公开地址是登陆提交的地址        if(url.indexOf(&quot;login.action&quot;)&gt;=0){            //如果进行登陆提交，放行            return true;        }        //判断session        HttpSession session  = request.getSession();        //从session中取出用户身份信息        String username = (String) session.getAttribute(&quot;username&quot;);        if(username != null){            //身份存在，放行            return true;        }        //执行这里表示用户身份需要认证，跳转登陆页面        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request,                           HttpServletResponse response, Object handler,                           ModelAndView modelAndView) throws Exception {        System.out.println(&quot;LoginInterceptor...postHandle&quot;);    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request,                                HttpServletResponse response, Object handler, Exception ex)            throws Exception {        System.out.println(&quot;LoginInterceptor...afterCompletion&quot;);    }}</code></pre><p>拦截器配置：</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;!-- 登陆认证拦截器 --&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    ......&lt;/mvc:interceptors&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;青山隐隐水迢迢，秋尽江南草未凋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;二十四桥明月夜，玉人何处教吹箫？&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·杜牧《寄扬州韩绰判官》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;拦截定义&quot;&gt;&lt;a href=&quot;#拦截定
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(19)-RESTful支持</title>
    <link href="http://www.echodemo.cc/2019/08/04/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(19)-RESTful%E6%94%AF%E6%8C%81/"/>
    <id>http://www.echodemo.cc/2019/08/04/springmvc学习笔记(19)-RESTful支持/</id>
    <published>2019-08-04T11:40:38.000Z</published>
    <updated>2019-08-04T12:25:39.479Z</updated>
    
    <content type="html"><![CDATA[<center>人生到处知何似，应似飞鸿踏雪泥。</center><br><center>泥上偶然留指爪，鸿飞那复计东西。</center><br><center>老僧已死成新塔，坏壁无由见旧题。</center><br><center>往日崎岖还记否，路长人困蹇驴嘶。</center><br><center>—-宋·苏轼《和子由渑池怀旧》</center><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p><p>（1）对url进行规范，写RESTful格式的url</p><pre><code>1、非REST的url：http://...../queryItems.action?id=001&amp;type=T012、REST的url风格：http://..../items/001</code></pre><p>特点：url简洁，将参数通过url传到服务端。</p><p>（2）http的方法规范</p><p>不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</p><p>（3）对http的contentType规范</p><p>请求时指定contentType，要json数据，设置成json格式的type。</p><hr><h3 id="REST的例子"><a href="#REST的例子" class="headerlink" title="REST的例子"></a>REST的例子</h3><p>查询商品信息，返回json数据。</p><p>（1）controller</p><p>定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller。输出json使用@ResponseBody将java对象输出json。</p><pre><code>//查询商品信息，输出json//itemsView/{id}里边的{id}表示表示将这个位置的参数传到@PathVariable指定名称中。//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称@RequestMapping(&quot;/itemsView/{id}&quot;)public @ResponseBody ItemsCustom itemsView(@PathVariable(&quot;id&quot;) Integer items_id)throws Exception{    //调用service查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);    return itemsCustom;}</code></pre><p>@RequestMapping(value=”/itemsView/{id}”)：{×××}占位符，请求的URL可以是/viewItems/1或/viewItems/2，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。</p><p>如果@RequestMapping中表示为/itemsView/{id}，id和形参名称一致，@PathVariable不用指定名称。</p><p>（2）REST方法的前端控制器配置</p><pre><code>&lt;!-- springmvc前端控制器，rest配置 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>（3)对静态资源的解析</p><p>配置前端控制器的url-pattern中指定/，对静态资源的解析会出现问题，报404错误。在springmvc.xml中添加静态资源解析方法。</p><pre><code>&lt;!-- 静态资源解析    包括 ：js、css、img、..     --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;</code></pre><p>这时访问<a href="http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。" target="_blank" rel="noopener">http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;人生到处知何似，应似飞鸿踏雪泥。&lt;/center&gt;&lt;br&gt;&lt;center&gt;泥上偶然留指爪，鸿飞那复计东西。&lt;/center&gt;&lt;br&gt;&lt;center&gt;老僧已死成新塔，坏壁无由见旧题。&lt;/center&gt;&lt;br&gt;&lt;center&gt;往日崎岖还记否，路长人困蹇驴嘶。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(18)-json数据交互</title>
    <link href="http://www.echodemo.cc/2019/08/01/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(18)-json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.echodemo.cc/2019/08/01/springmvc学习笔记(18)-json数据交互/</id>
    <published>2019-08-01T15:39:09.000Z</published>
    <updated>2019-08-01T15:53:19.608Z</updated>
    
    <content type="html"><![CDATA[<center>我居北海君南海，寄雁传书谢不能。</center><br><center>桃李春风一杯酒，江湖夜雨十年灯。</center><br><center>持家但有四立壁，治病不蕲三折肱。</center><br><center>想见读书头已白，隔溪猿哭瘴溪藤。</center><br><center>—-宋·黄庭坚《寄黄几复》</center><hr><p>本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互。</p><hr><h3 id="springmvc进行json交互"><a href="#springmvc进行json交互" class="headerlink" title="springmvc进行json交互"></a>springmvc进行json交互</h3><p>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。</p><p>（1）请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。</p><p>（2）请求key/value、输出json。此方法比较常用。</p><hr><h3 id="添加json转换的依赖"><a href="#添加json转换的依赖" class="headerlink" title="添加json转换的依赖"></a>添加json转换的依赖</h3><pre><code>&lt;!-- json 转换--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;    &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>查看依赖树：</p><pre><code>[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile[INFO] |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile[INFO] |  \- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile[INFO] \- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile[INFO]    \- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile</code></pre><hr><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p><strong>注意：如果使用&lt;mvc:annotation-driven /&gt;则不用定义上边的内容。</strong></p><hr><h3 id="json交互测试"><a href="#json交互测试" class="headerlink" title="json交互测试"></a>json交互测试</h3><p>显示两个按钮分别测试:</p><p>(1)jsp页面</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: brian  Date: 2016/3/7  Time: 20:49  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;json交互测试&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //请求json，输出是json        function requestJson(){     省略    }        //请求key/value，输出是json        function responseJson(){    省略    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;&lt;input type=&quot;button&quot; onclick=&quot;responseJson()&quot; value=&quot;请求key/value，输出是json&quot;/&gt;&lt;/body&gt;</code></pre><p>(2)controller</p><pre><code>@Controllerpublic class JsonTest {    ...}</code></pre><hr><h3 id="输入json串，输出是json串"><a href="#输入json串，输出是json串" class="headerlink" title="输入json串，输出是json串"></a>输入json串，输出是json串</h3><p>使用jquery的ajax提交json串，对输出的json结果进行解析。</p><p>(1)jsp页面</p><pre><code>// 请求json，输出是jsonfunction requestJson(){    $.ajax({        type:&apos;post&apos;,        url:&apos;${pageContext.request.contextPath }/requestJson.action&apos;,        contentType:&apos;application/json;charset=utf-8&apos;,        //数据格式是json串，商品信息        data:&apos;{&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999}&apos;,        success:function(data){//返回json结果            alert(data);        }    });}</code></pre><p>(2)controller</p><pre><code>//请求json串(商品信息)，输出json(商品信息)//@RequestBody将请求的商品信息的json串转成itemsCustom对象//@ResponseBody将itemsCustom转成json输出@RequestMapping(&quot;/requestJson&quot;)public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){    //@ResponseBody将itemsCustom转成json输出    return itemsCustom;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我居北海君南海，寄雁传书谢不能。&lt;/center&gt;&lt;br&gt;&lt;center&gt;桃李春风一杯酒，江湖夜雨十年灯。&lt;/center&gt;&lt;br&gt;&lt;center&gt;持家但有四立壁，治病不蕲三折肱。&lt;/center&gt;&lt;br&gt;&lt;center&gt;想见读书头已白，隔溪猿哭瘴溪藤。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(17)-上传图片</title>
    <link href="http://www.echodemo.cc/2019/07/31/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>http://www.echodemo.cc/2019/07/31/springmvc学习笔记(17)-上传图片/</id>
    <published>2019-07-31T15:03:42.000Z</published>
    <updated>2019-07-31T15:25:44.253Z</updated>
    
    <content type="html"><![CDATA[<center>黄水塘里游着白鸭</center><br><center>高粱梗油青的刚高过头</center><br><center>这跳动的心怎样安插</center><br><center>田里一窄条路，八月里这忧愁？</center><center>天是昨夜雨洗过的，山岗</center><br><center>照着太阳又留一片影</center><br><center>羊跟着放羊的转进村庄</center><br><center>一大棵树荫下罩着井，又像是心！</center><center>从没有人说过八月什么话</center><br><center>夏天过去了，也不到秋天</center><br><center>但我望着田垄，土墙上的瓜</center><br><center>仍不明白生活同梦怎样的连牵</center><br><center>—-现代·林徽因《八月的忧愁》节选</center><hr><h3 id="springmvc中对多部件类型解析"><a href="#springmvc中对多部件类型解析" class="headerlink" title="springmvc中对多部件类型解析"></a>springmvc中对多部件类型解析</h3><p>在修改商品页面，添加上传商品图片功能。在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。通过在springmvc.xml中配置multipart类型解析器来完成。</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;      class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="加入上传图片的jar"><a href="#加入上传图片的jar" class="headerlink" title="加入上传图片的jar"></a>加入上传图片的jar</h3><p>（1）添加依赖</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>（2）依赖树</p><pre><code>[INFO] \- commons-fileupload:commons-fileupload:jar:1.3.1:compile[INFO]    \- commons-io:commons-io:jar:2.2:compile</code></pre><p><strong>可以看到，其实还间接依赖了commons-io:commons-io:jar。</strong></p><h3 id="创建图片虚拟目录存储图片"><a href="#创建图片虚拟目录存储图片" class="headerlink" title="创建图片虚拟目录存储图片"></a>创建图片虚拟目录存储图片</h3><p>直接修改tomcat的配置,在conf/server.xml文件，添加虚拟目录。</p><pre><code>&lt;Context docBase=&quot;图片存放的磁盘路径&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。</p><hr><h3 id="上传图片代码"><a href="#上传图片代码" class="headerlink" title="上传图片代码"></a>上传图片代码</h3><p>(1)页面</p><pre><code>&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;        &lt;c:if test=&quot;${items.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${items.pic}&quot; width=100 height=100/&gt;            &lt;br/&gt;        &lt;/c:if&gt;        &lt;input type=&quot;file&quot;  name=&quot;items_pic&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>(2)controller方法</p><p>修改：商品修改controller方法：</p><pre><code>@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @ModelAttribute(&quot;items&quot;)        @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,        BindingResult bindingResult,        MultipartFile items_pic)throws Exception {...}</code></pre><p>(3)实现</p><pre><code>// 原始名称String originalFilename = items_pic.getOriginalFilename();// 上传图片if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0){    // 存储图片的物理路径    String pic_path = &quot;D:\\tmp\\&quot;;    // 新的图片名称    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));    // 新图片    File newFile = new File(pic_path+newFileName);    // 将内存中的数据写入磁盘    items_pic.transferTo(newFile);    //将新图片名称写到itemsCustom中    itemsCustom.setPic(newFileName);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;黄水塘里游着白鸭&lt;/center&gt;&lt;br&gt;&lt;center&gt;高粱梗油青的刚高过头&lt;/center&gt;&lt;br&gt;&lt;center&gt;这跳动的心怎样安插&lt;/center&gt;&lt;br&gt;&lt;center&gt;田里一窄条路，八月里这忧愁？&lt;/center&gt;

&lt;center&gt;天是昨夜雨洗过的，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(16)-异常处理器</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(16)-异常处理器/</id>
    <published>2019-07-28T13:47:57.000Z</published>
    <updated>2019-07-28T13:58:29.224Z</updated>
    
    <content type="html"><![CDATA[<center>窗间梅熟落蒂，墙下笋成出林。</center><br><center>连雨不知春去，一晴方觉夏深。</center><br><center>—-宋·范成大《喜晴》</center><hr><p>本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置。</p><hr><h3 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h3><p>系统中异常包括两类：</p><pre><code>1、预期异常。2、运行时异常RuntimeException。</code></pre><p>前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。</p><p><strong>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</strong></p><hr><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>对不同的异常类型定义异常类，继承Exception。</p><pre><code>public class CustomException  extends  Exception{    //异常信息    public String message;    public CustomException(String message){        super(message);        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }}</code></pre><hr><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>思路：</p><p>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</p><p>全局异常处理器处理思路：</p><p>解析出异常类型</p><pre><code>1、如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示。2、如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）。</code></pre><p>springmvc提供一个HandlerExceptionResolver接口：</p><pre><code>public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        //handler就是处理器适配器要执行Handler对象（只有method）        //解析出异常类型        //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示        //String message = null;        //if(ex instanceof CustomException){            //message = ((CustomException)ex).getMessage();        //}else{            ////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）            //message=&quot;未知错误&quot;;        //}        //上边代码变为        CustomException customException;        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            customException = new CustomException(&quot;未知错误&quot;);        }        //错误信息        String message = customException.getMessage();        ModelAndView modelAndView = new ModelAndView();        //将错误信息传到页面        modelAndView.addObject(&quot;message&quot;, message);        //指向错误页面        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><hr><h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Brian  Date: 2016/3/4  Time: 10:51  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${message}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="在springmvc-xml配置全局异常处理器"><a href="#在springmvc-xml配置全局异常处理器" class="headerlink" title="在springmvc.xml配置全局异常处理器"></a>在springmvc.xml配置全局异常处理器</h3><pre><code>&lt;!-- 全局异常处理器只要实现HandlerExceptionResolver接口就是全局异常处理器--&gt;&lt;bean class=&quot;com.iot.learnssm.firstssm.exception.CustomExceptionResolver&quot;&gt;&lt;/bean&gt;</code></pre><p><strong>全局异常处理器只有一个，配置多个也没用。</strong></p><hr><h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。</p><p>(1)在商品修改的controller方法中抛出异常</p><pre><code>public String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {    //调用service根据商品id查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);    //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在    if(itemsCustom == null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //通过形参中的model将model数据传到页面    //相当于modelAndView.addObject方法    model.addAttribute(&quot;items&quot;, itemsCustom);    return &quot;items/editItems&quot;;}</code></pre><p>(2)在service接口中抛出异常</p><pre><code>public ItemsCustom findItemsById(Integer id) throws Exception {    Items items = itemsMapper.selectByPrimaryKey(id);    if(items==null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //中间对商品信息进行业务处理    //....    //返回ItemsCustom    ItemsCustom itemsCustom = null;    //将items的属性值拷贝到itemsCustom    if(items!=null){        itemsCustom = new ItemsCustom();        BeanUtils.copyProperties(items, itemsCustom);    }    return itemsCustom;}</code></pre><p>1、如果与业务功能相关的异常，建议在service中抛出异常。</p><p>2、与业务功能没有关系的异常，建议在controller中抛出。</p><p>上边的功能，建议在service中抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;窗间梅熟落蒂，墙下笋成出林。&lt;/center&gt;&lt;br&gt;&lt;center&gt;连雨不知春去，一晴方觉夏深。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·范成大《喜晴》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文主要介绍springmvc中异常处理的思路，并展示如何自定义
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
