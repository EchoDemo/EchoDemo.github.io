<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-04-17T16:26:27.090Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鲜为人知的Unsafe类</title>
    <link href="http://www.echodemo.cc/2019/04/17/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84Unsafe%E7%B1%BB/"/>
    <id>http://www.echodemo.cc/2019/04/17/鲜为人知的Unsafe类/</id>
    <published>2019-04-17T15:31:52.000Z</published>
    <updated>2019-04-17T16:26:27.090Z</updated>
    
    <content type="html"><![CDATA[<center>孤山寺北贾亭西，水面初平云脚低。</center><br><center>几处早莺争暖树，谁家新燕啄春泥。</center><br><center>乱花渐欲迷人眼，浅草才能没马蹄。</center><br><center>最爱湖东行不足，绿杨阴里白沙堤。</center><br><center>—-白居易《钱塘湖春行》</center><hr><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：</p><pre><code>1、内存管理，Unsafe类中存在直接操作内存的方法。2、获取对象的实例。3、挂起与恢复。4、CAS操作</code></pre><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>通过Unsafe类可以分配内存，可以释放内存；类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应。</p><pre><code>//分配内存指定大小的内存public native long allocateMemory(long bytes);//根据给定的内存地址address设置重新分配指定大小的内存public native long reallocateMemory(long address, long bytes);//用于释放allocateMemory和reallocateMemory申请的内存public native void freeMemory(long address);</code></pre><p>除此之外，它还有下列一些操作内存的方法：</p><pre><code>//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值public native void setMemory(Object o, long offset, long bytes, byte value);//设置给定内存地址的值public native void putAddress(long address, long x);//获取指定内存地址的值public native long getAddress(long address);//设置给定内存地址的long值public native void putLong(long address, long x);//获取指定内存地址的long值public native long getLong(long address);//设置指定内存的byte值//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同public native byte getByte(long address);//获取指定内存的byte值public native void putByte(long address, byte x);//操作系统的内存页大小public native int pageSize();//对象字段的定位,该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的public native long staticFieldOffset(Field field);//获取对象中offset偏移地址对应的整型field的值,支持volatile load语义public native int getIntVolatile(Object obj, long l);//获取数组第一个元素的偏移地址public native int arrayBaseOffset(Class class1);//获取数组的转换因子，也就是数组中元素的增量地址public native int arrayIndexScale(Class class1);</code></pre><p>Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。</p><hr><h4 id="获取对象的实例"><a href="#获取对象的实例" class="headerlink" title="获取对象的实例"></a>获取对象的实例</h4><pre><code>//传入一个对象的class并创建该实例对象，但不会调用构造方法public native Object allocateInstance(Class cls) throws InstantiationException;</code></pre><hr><h4 id="挂起与恢复"><a href="#挂起与恢复" class="headerlink" title="挂起与恢复"></a>挂起与恢复</h4><p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中（java.util.concurrent包中挂起操作都是在LockSupport类实现的），LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法来实现的。</p><pre><code>public class LockSupport {    public static void unpark(Thread thread) {        if (thread != null)            unsafe.unpark(thread);    }    public static void park(Object blocker) {        Thread t = Thread.currentThread();        setBlocker(t, blocker);        unsafe.park(false, 0L);        setBlocker(t, null);    }    public static void parkNanos(Object blocker, long nanos) {        if (nanos &gt; 0) {            Thread t = Thread.currentThread();            setBlocker(t, blocker);            unsafe.park(false, nanos);            setBlocker(t, null);        }    }    public static void parkUntil(Object blocker, long deadline) {        Thread t = Thread.currentThread();        setBlocker(t, blocker);        unsafe.park(true, deadline);        setBlocker(t, null);    }    public static void park() {        unsafe.park(false, 0L);    }    public static void parkNanos(long nanos) {        if (nanos &gt; 0)            unsafe.park(false, nanos);    }    public static void parkUntil(long deadline) {        unsafe.park(true, deadline);    }}</code></pre><hr><h4 id="Unsafe里的CAS操作"><a href="#Unsafe里的CAS操作" class="headerlink" title="Unsafe里的CAS操作"></a>Unsafe里的CAS操作</h4><p>CAS是一些CPU直接支持的指令，在Java中无锁操作CAS基于以下3个方法实现：</p><pre><code>public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x); </code></pre><p>第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值。expected表示期望值，x表示要设置的值。</p><hr><h3 id="利用Unsafe类"><a href="#利用Unsafe类" class="headerlink" title="利用Unsafe类"></a>利用Unsafe类</h3><h4 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h4><pre><code>public static Unsafe getUnsafeInstance() throws Exception{    Field unsafeStaticField =     Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);    unsafeStaticField.setAccessible(true);    return (Unsafe) unsafeStaticField.get(Unsafe.class);}</code></pre><p>通过java反射机制，我们跳过了安全检测，拿到了一个unsafe类的实例。</p><hr><h4 id="修改和读取数组中的值"><a href="#修改和读取数组中的值" class="headerlink" title="修改和读取数组中的值"></a>修改和读取数组中的值</h4><pre><code>Unsafe u = getUnsafeInstance();int[] arr = {1,2,3,4,5,6,7,8,9,10};//返回当前数组第一个元素地址相对于数组起始地址的偏移值，在本例中返回6int b = u.arrayBaseOffset(int[].class);//返回当前数组一个元素占用的字节数,在本例中返回4int s = u.arrayIndexScale(int[].class);//获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，将intval写入内存u.putInt(arr, (long)b+s*9, 1);for(int i=0;i&lt;10;i++){     //获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，从而获得元素的值    int v = u.getInt(arr, (long)b+s*i);    System.out.print(v+“ ”);}</code></pre><p>打印结果:1 2 3 4 5 6 7 8 9 1 ,可以看到，成功读出了数组中的值，而且最后一个值由10改为了1。</p><blockquote><p>偏移值: 数组元素偏移值 = arrayBaseOffset + arrayIndexScalse * i。</p></blockquote><hr><h4 id="修改静态变量和实例变量的值"><a href="#修改静态变量和实例变量的值" class="headerlink" title="修改静态变量和实例变量的值"></a>修改静态变量和实例变量的值</h4><p>先定义一个Test类:</p><pre><code>public class Test {    public int intfield ;    public static int staticIntField;    public static int[] arr;    private Test(){        System.out.println(&quot;constructor called&quot;);    }}</code></pre><p>修改Test类的实例变量:</p><pre><code>Unsafe u = getUnsafeInstance();Test t = (Test) u.allocateInstance(Test.class);//获取对象某个属性的地址偏移值long b1 = u.objectFieldOffset(Test.class.getDeclaredField(&quot;intfield&quot;));u.putInt(t, b1, 2);System.out.println(&quot;intfield:&quot;+t.intfield);</code></pre><p>这里使用allocateInstance方法获取了一个Test类的实例，并且没有打印“constructor called”，说明构造方法没有调用。修改实例变量与修改数组的值类似，同样要获取地址偏移值，然后调用putInt方法。</p><p>修改Test类的静态变量:</p><pre><code>Field staticIntField = Test.class.getDeclaredField(&quot;staticIntField&quot;);//获取静态变量所属的类在方法区的首地址。可以看到，返回的对象就是Test.classObject o = u.staticFieldBase(staticIntField);System.out.prinln(o==Test.class);//获取静态变量地址偏移值Long b4 = u.staticFieldOffset(staticIntField);//因为是静态变量，传入的Object参数应为class对象u.putInt(o, b4, 10);System.out.println(&quot;staticIntField:&quot;+u.getInt(Test.class, b4));</code></pre><p>打印结果：</p><pre><code>truestaticIntField:10</code></pre><p>静态变量与实例变量不同之处在于，静态变量位于于方法区中，它的地址偏移值与Test类在方法区的地址相关，与Test类的实例无关。</p><hr><h4 id="调戏String-intern"><a href="#调戏String-intern" class="headerlink" title="调戏String.intern"></a>调戏String.intern</h4><p>在jdk7中，String.intern不再拷贝string对象实例，而是保存第一次出现的对象的引用。在下面的代码中，通过Unsafe修改被引用对象s的私有属性value达到间接修改s1的效果！</p><pre><code>String s = &quot;abc&quot;;//保存s的引用s.intern();//此时s1==s，地址相同String s1 = &quot;abc&quot;;Unsafe u = getUnsafeInstance();//获取s的实例变量valueField valueInString = String.class.getDeclaredField(&quot;value&quot;);//获取value的变量偏移值long offset = u.objectFieldOffset(valueInString);//value本身是一个char[],要修改它元素的值，仍要获取baseOffset和indexScalelong base = u.arrayBaseOffset(char[].class);long scale = u.arrayIndexScale(char[].class);//获取valuechar[] values = (char[]) u.getObject(s, offset);//为value赋值u.putChar(values, base + scale, &apos;c&apos;);System.out.println(&quot;s:&quot;+s+&quot; s1:&quot;+s1);//将s的值改为 abcs = &quot;abc&quot;;String s2 = &quot;abc&quot;;String s3 = &quot;abc&quot;;System.out.println(&quot;s:&quot;+s+&quot; s1:&quot;+s1);</code></pre><p>打印结果：</p><pre><code>s:acc s1:accs:acc s1:acc s2:acc s3:acc</code></pre><p>我们发现了什么？所有值为“abc”的字符串都变成了“acc”。Unsafe类果然不安全！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;孤山寺北贾亭西，水面初平云脚低。&lt;/center&gt;&lt;br&gt;&lt;center&gt;几处早莺争暖树，谁家新燕啄春泥。&lt;/center&gt;&lt;br&gt;&lt;center&gt;乱花渐欲迷人眼，浅草才能没马蹄。&lt;/center&gt;&lt;br&gt;&lt;center&gt;最爱湖东行不足，绿杨阴里白沙堤。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁的一种实现方式CAS</title>
    <link href="http://www.echodemo.cc/2019/04/17/%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8FCAS/"/>
    <id>http://www.echodemo.cc/2019/04/17/乐观锁的一种实现方式CAS/</id>
    <published>2019-04-17T13:26:47.000Z</published>
    <updated>2019-04-17T16:32:17.298Z</updated>
    
    <content type="html"><![CDATA[<center>怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！</center><br><center>靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。</center><br><center>—-岳飞《满江红·写怀》</center><hr><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>众所周知，Java是多线程的。但是，Java对多线程的支持其实是一把双刃剑。一旦涉及到多个线程操作共享资源的情况时，处理不好就可能产生线程安全问题。线程安全性可能是非常复杂的，在没有充足的同步的情况下，多个线程中的操作执行顺序是不可预测的。</p><p>Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性。加上复合操作的原子性，我们可以认为Java的线程安全性问题主要关注点有3个：可见性、有序性和原子性。</p><p><a href="http://www.echodemo.cc/2019/04/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a>（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题。这里不再详细介绍JMM及锁的其他相关知识。但是我们要讨论一个问题，那就是锁到底是不是有利无弊的？</p><hr><h3 id="锁存在的问题"><a href="#锁存在的问题" class="headerlink" title="锁存在的问题"></a>锁存在的问题</h3><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。但是悲观锁机制存在以下问题：</p><blockquote><p>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p></blockquote><p>而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><p>与锁相比，volatile变量是一个更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile不能解决原子性问题，因此当一个变量依赖旧值时就不能使用volatile变量。因此对于同步最终还是要回到锁机制上来。</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><hr><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p><blockquote><p>这里再强调一下，乐观锁是一种思想。CAS是这种思想的一种实现方式。</p></blockquote><hr><h4 id="Java对CAS的支持"><a href="#Java对CAS的支持" class="headerlink" title="Java对CAS的支持"></a>Java对CAS的支持</h4><p>在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。</p><p>我们以java.util.concurrent中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解getAndIncrement方法，该方法的作用相当于 ++i 操作。</p><pre><code>public class AtomicInteger extends Number implements java.io.Serializable {      private volatile int value;      public final int get() {          return value;      }      public final int getAndIncrement() {          for (;;) {              int current = get();              int next = current + 1;              if (compareAndSet(current, next))                  return current;          }      }      public final boolean compareAndSet(int expect, int update) {          return unsafe.compareAndSwapInt(this, valueOffset, expect, update);      }  }</code></pre><p>在没有锁的机制下需要字段value要借助volatile原语，保证线程间的数据是可见的。这样在获取变量的值的时候才能直接读取。getAndIncrement采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet利用JNI来完成CPU指令的操作。从代码中我们可以发现，JAVA中的CAS操作都是通过sun.misc包下Unsafe类实现的，关于Unsafe类更详细的说明，可以查阅我的这篇文章:<a href="http://www.echodemo.cc/2019/04/17/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84Unsafe%E7%B1%BB/">鲜为人知的Unsafe类</a></p><hr><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p>部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><hr><h3 id="CAS与对象创建"><a href="#CAS与对象创建" class="headerlink" title="CAS与对象创建"></a>CAS与对象创建</h3><p>另外，CAS还有一个应用，那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的。即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制。锁机制包含两种：乐观锁与悲观锁。悲观锁是独占锁，阻塞锁。乐观锁是非独占锁，非阻塞锁。有一种乐观锁的实现方式就是CAS ，这种算法在JDK 1.5中引入的java.util.concurrent中有广泛应用。但是值得注意的是这种算法会存在ABA问题。</p><p>改文章转载自：<a href="https://www.hollischuang.com/archives/1537" target="_blank" rel="noopener">乐观锁的一种实现方式——CAS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！&lt;/center&gt;&lt;br&gt;&lt;center&gt;靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Moniter的实现原理</title>
    <link href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BMoniter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.echodemo.cc/2019/04/15/深入理解多线程之Moniter的实现原理/</id>
    <published>2019-04-15T15:06:23.000Z</published>
    <updated>2019-04-16T14:48:21.829Z</updated>
    
    <content type="html"><![CDATA[<center>阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。</center><br><center>待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。</center><br><center>—-王国维《蝶恋花·阅尽天涯离别苦》</center><hr><h3 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h3><p>如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。</p><blockquote><p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p></blockquote><hr><h3 id="Java线程同步相关的Moniter"><a href="#Java线程同步相关的Moniter" class="headerlink" title="Java线程同步相关的Moniter"></a>Java线程同步相关的Moniter</h3><p>在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><p>先来举个例子，然后我们再上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。</p><p><img src="/images/2019/4/Java-Monitor.jpg" alt="&quot;Java-Monitor&quot;"></p><p>如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间可以稍后再次进入那间特殊的房间。如上面所说，这个建筑屋中一共有三个场所。</p><p><img src="/images/2019/4/java-monitor-associate-with-object.jpg" alt="&quot;java-monitor-associate-with-object&quot;"></p><p>总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p><blockquote><p>对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。</p><p>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p></blockquote><hr><h3 id="监视器的实现"><a href="#监视器的实现" class="headerlink" title="监视器的实现"></a>监视器的实现</h3><p>在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">ObjectMonitor</a>实现的，其主要数据结构如下：</p><pre><code>ObjectMonitor() {    _header       = NULL;    _count        = 0;    _waiters      = 0,    _recursions   = 0;    _object       = NULL;    _owner        = NULL;    _WaitSet      = NULL;    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;    FreeNext      = NULL ;    _EntryList    = NULL ;    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;}</code></pre><p>源码地址：<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.hpp#L193" target="_blank" rel="noopener">objectMonitor.hpp</a>ObjectMonitor中有几个关键属性：</p><pre><code>_owner：指向持有ObjectMonitor对象的线程_WaitSet：存放处于wait状态的线程队列_EntryList：存放处于等待锁block状态的线程队列_recursions：锁的重入次数_count：用来记录该线程获取锁的次数</code></pre><p>当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。</p><p>若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示:</p><p><img src="/images/2019/4/monitor.png" alt="&quot;monitor&quot;"></p><hr><p>ObjectMonitor类中提供了几个方法：</p><h4 id="获得锁"><a href="#获得锁" class="headerlink" title="获得锁"></a>获得锁</h4><pre><code>void ATTR ObjectMonitor::enter(TRAPS) {      Thread * const Self = THREAD ;      void * cur ;      //通过CAS尝试把monitor的`_owner`字段设置为当前线程      cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;      //获取锁失败      if (cur == NULL) {         assert (_recursions == 0   , &quot;invariant&quot;) ;         assert (_owner      == Self, &quot;invariant&quot;) ;         // CONSIDER: set or assert OwnerIsThread == 1         return ;      }      // 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。      if (cur == Self) {          // TODO-FIXME: check for integer overflow!  BUGID 6557169.         _recursions ++ ;         return ;      }      // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程      if (Self-&gt;is_lock_owned ((address)cur)) {         assert (_recursions == 0, &quot;internal state error&quot;);        _recursions = 1 ;        // Commute owner from a thread-specific on-stack BasicLockObject address to        // a full-fledged &quot;Thread *&quot;.        _owner = Self ;        OwnerIsThread = 1 ;        return ;      }      // 省略部分代码。      // 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放      for (;;) {      jt-&gt;set_suspend_equivalent();      // cleared by handle_special_suspend_equivalent_condition()      // or java_suspend_self()      EnterI (THREAD) ;      if (!ExitSuspendEquivalent(jt)) break ;      //      // We have acquired the contended monitor, but while we were      // waiting another thread suspended us. We don&apos;t want to enter      // the monitor while suspended because that would surprise the      // thread that suspended us.      //          _recursions = 0 ;      _succ = NULL ;      exit (Self) ;      jt-&gt;java_suspend_self();}</code></pre><p><img src="/images/2019/4/lockenter.png" alt="&quot;lockenter&quot;"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><pre><code>void ATTR ObjectMonitor::exit(TRAPS) {   Thread * Self = THREAD ;   //如果当前线程不是Monitor的所有者   if (THREAD != _owner) {      if (THREAD-&gt;is_lock_owned((address) _owner)) { //        // Transmute _owner from a BasicLock pointer to a Thread address.       // We don&apos;t need to hold _mutex for this transition.       // Non-null to Non-null is safe as long as all readers can       // tolerate either flavor.       assert (_recursions == 0, &quot;invariant&quot;) ;       _owner = THREAD ;       _recursions = 0 ;       OwnerIsThread = 1 ;     } else {       // NOTE: we need to handle unbalanced monitor enter/exit       // in native code by throwing an exception.       // TODO: Throw an IllegalMonitorStateException ?       TEVENT (Exit - Throw IMSX) ;       assert(false, &quot;Non-balanced monitor enter/exit!&quot;);       if (false) {          THROW(vmSymbols::java_lang_IllegalMonitorStateException());       }       return;     }  }  // 如果_recursions次数不为0.自减  if (_recursions != 0) {     _recursions--;        // this is simple recursive enter     TEVENT (Inflated exit - recursive) ;     return ;  }}</code></pre><blockquote><p>//省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。</p></blockquote><p><img src="/images/2019/4/lockexit.png" alt="&quot;lockexit&quot;"></p><p>除了enter和exit方法以外，<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">objectMonitor.cpp</a>中还有:</p><pre><code>void      wait(jlong millis, bool interruptable, TRAPS);void      notify(TRAPS);void      notifyAll(TRAPS);</code></pre><p>等方法。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的就是HotSpot虚拟机中Moniter的的加锁以及解锁的原理。</p><p>通过这篇文章我们知道了sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？</p><p>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费处理器很多的时间，对于代码简单的同步块（如被synchronized修饰的get或set方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说synchronized是java语言中一个重量级的操纵。</p><p>所以，在JDK1.6中对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-王国维《蝶恋花·阅尽天涯离别苦》&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Java的对象头</title>
    <link href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <id>http://www.echodemo.cc/2019/04/15/深入理解多线程之Java的对象头/</id>
    <published>2019-04-15T14:46:23.000Z</published>
    <updated>2019-04-15T15:16:13.505Z</updated>
    
    <content type="html"><![CDATA[<center>今古河山无定据。画角声中，牧马频来去。满目荒凉谁可语？西风吹老丹枫树。</center><br><center>从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。</center><br><center>—-纳兰容若《蝶恋花·出塞》</center><hr><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。那么这里提到的对象头到底是什么呢？</p><pre><code>class oopDesc {  friend class VMStructs; private:  volatile markOop  _mark;  union _metadata {    wideKlassOop    _klass;    narrowOop       _compressed_klass;  } _metadata;}</code></pre><p>上面代码中的_mark和_metadata其实就是对象头的定义。关于_metadata之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下_mark ，即mark word。</p><p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。</p><p><img src="/images/2019/4/markword.png" alt="&quot;markword&quot;"></p><hr><p>同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类。</p><pre><code>enum { age_bits                 = 4,      lock_bits                = 2,      biased_lock_bits         = 1,      max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,      hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits,      cms_bits                 = LP64_ONLY(1) NOT_LP64(0),      epoch_bits               = 2};</code></pre><p>从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记位的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。</p><blockquote><p>在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。</p></blockquote><hr><p>markOop.hpp类中有关于对象状态的定义：</p><pre><code>enum {      locked_value             = 0,         unlocked_value           = 1,         monitor_value            = 2,         marked_value             = 3,         biased_lock_pattern      = 5};简单翻译一下：locked_value(00) = 0unlocked_value(01) = 1monitor_value(10) = 2marked_value(11) = 3biased_lock_pattern(101) = 5</code></pre><p>关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。</p><p>该文转载自：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;今古河山无定据。画角声中，牧马频来去。满目荒凉谁可语？西风吹老丹枫树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-纳兰容若《蝶恋花·出塞》&lt;/cent
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Java的对象模型</title>
    <link href="http://www.echodemo.cc/2019/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/14/深入理解多线程之Java的对象模型/</id>
    <published>2019-04-14T06:43:24.000Z</published>
    <updated>2019-04-16T15:49:26.937Z</updated>
    
    <content type="html"><![CDATA[<center>似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。</center><br><center>不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。</center><br><center>—-苏轼《水龙吟·次韵章质夫杨花词》</center><hr><p>我们都知道，几乎所有的Java对象都是保存在堆内存当中（有例外，自行了解），在内存中Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有的锁等标志。这篇文章就主要从Java对象模型入手，找一找我们关心的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。</p><h3 id="Java的对象模型"><a href="#Java的对象模型" class="headerlink" title="Java的对象模型"></a>Java的对象模型</h3><p>任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生：</p><pre><code>1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 2、一切皆对象。</code></pre><p>我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于HotSpot虚拟机。</p><hr><h3 id="oop-klass-model"><a href="#oop-klass-model" class="headerlink" title="oop-klass model"></a>oop-klass model</h3><p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>为什么HotSpot要设计一套oop-klass model呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表）。这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p><blockquote><p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p><blockquote><p>在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。</p></blockquote><blockquote><p>在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p></blockquote></blockquote><p>上面这段是从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。关于opp-klass模型的整体定义，在HotSpot的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">源码</a>中可以找到。oops模块可以分成两个相对独立的部分：<strong>OOP框架和Klass框架。</strong>在oopsHierarchy.hpp里定义了oop和klass各自的体系。</p><hr><h3 id="oop-klass结构"><a href="#oop-klass结构" class="headerlink" title="oop-klass结构"></a>oop-klass结构</h3><p><img src="/images/2019/4/oops.png" alt="&quot;oop-klass结构&quot;"></p><p>oop体系：</p><pre><code>//定义了oops共同基类typedef class   oopDesc*                            oop;//表示一个Java类型实例typedef class   instanceOopDesc*            instanceOop;//表示一个Java方法typedef class   methodOopDesc*                    methodOop;//表示一个Java方法中的不变信息typedef class   constMethodOopDesc*            constMethodOop;//记录性能信息的数据结构typedef class   methodDataOopDesc*            methodDataOop;//定义了数组OOPS的抽象基类typedef class   arrayOopDesc*                    arrayOop;//表示持有一个OOPS数组typedef class   objArrayOopDesc*            objArrayOop;//表示容纳基本类型的数组typedef class   typeArrayOopDesc*            typeArrayOop;//表示在Class文件中描述的常量池typedef class   constantPoolOopDesc*            constantPoolOop;//常量池告诉缓存typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;//描述一个与Java类对等的C++类typedef class   klassOopDesc*                    klassOop;//表示对象头typedef class   markOopDesc*                    markOop;</code></pre><p>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。从上面的代码中可以看到，有一个变量opp的类型是oppDesc ，OOPS类的共同基类型为oopDesc。</p><p>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。在HotSpot中，根据JVM内部使用的对象业务类型，具有多种oopDesc的子类。除了oppDesc类型外，opp体系中还有很多instanceOopDesc、arrayOopDesc 等类型的实例，他们都是oopDesc的子类。</p><p><img src="/images/2019/4/OOP结构.png" alt="&quot;oop结构&quot;"></p><p>这些OOPS在JVM内部有着不同的用途，例如，instanceOopDesc表示类实例，arrayOopDesc表示数组。也就是说，当我们使用new创建一个Java对象实例的时候，JVM会创建一个instanceOopDesc对象来表示这个Java对象。同理，当我们使用new创建一个Java数组实例的时候，JVM会创建一个arrayOopDesc对象来表示这个数组对象。</p><p>在HotSpot中，oopDesc类定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp" target="_blank" rel="noopener">oop.hpp</a>中，instanceOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp" target="_blank" rel="noopener">instanceOop.hpp</a>中，arrayOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp" target="_blank" rel="noopener">arrayOop.hpp</a>中。简单看一下相关定义：</p><pre><code>class oopDesc {  friend class VMStructs;  private:      volatile markOop  _mark;      union _metadata {        wideKlassOop    _klass;        narrowOop       _compressed_klass;      } _metadata;  private:      // field addresses in oop      void*     field_base(int offset)        const;      jbyte*    byte_field_addr(int offset)   const;      jchar*    char_field_addr(int offset)   const;      jboolean* bool_field_addr(int offset)   const;      jint*     int_field_addr(int offset)    const;      jshort*   short_field_addr(int offset)  const;      jlong*    long_field_addr(int offset)   const;      jfloat*   float_field_addr(int offset)  const;      jdouble*  double_field_addr(int offset) const;      address*  address_field_addr(int offset) const;}class instanceOopDesc : public oopDesc {}class arrayOopDesc : public oopDesc {}</code></pre><p>通过上面的源码可以看到，instanceOopDesc实际上就是继承了oopDesc，并没有增加其他的数据结构，也就是说instanceOopDesc中主要包含以下几部分数据：markOop _mark和union _metadata 以及一些不同类型的 field。</p><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个instanceOopDesc的对象。其中对象头包含了两部分内容：_mark和_metadata，而实例数据则保存在oopDesc中定义的各种field中。</p><hr><h4 id="mark"><a href="#mark" class="headerlink" title="_mark"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是synchronized以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在_mark中。因为本文主要介绍的oop-klass模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p><h4 id="metadata"><a href="#metadata" class="headerlink" title="_metadata"></a>_metadata</h4><p>前面介绍到的_metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。在深入介绍之前，就要来到oop-Klass中的另外一个主角klass了。</p><h4 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h4><p>klass体系</p><pre><code>//klassOop的一部分，用来描述语言层的类型class  Klass;//在虚拟机层面描述一个Java类class   instanceKlass;//专有instantKlass，表示java.lang.Class的Klassclass     instanceMirrorKlass;//专有instantKlass，表示java.lang.ref.Reference的子类的Klassclass     instanceRefKlass;//表示methodOop的Klassclass   methodKlass;//表示constMethodOop的Klassclass   constMethodKlass;//表示methodDataOop的Klassclass   methodDataKlass;//最为klass链的端点，klassKlass的Klass就是它自身class   klassKlass;//表示instanceKlass的Klassclass     instanceKlassKlass;//表示arrayKlass的Klassclass     arrayKlassKlass;//表示objArrayKlass的Klassclass       objArrayKlassKlass;//表示typeArrayKlass的Klassclass       typeArrayKlassKlass;//表示array类型的抽象基类class   arrayKlass;//表示objArrayOop的Klassclass     objArrayKlass;//表示typeArrayOop的Klassclass     typeArrayKlass;//表示constantPoolOop的Klassclass   constantPoolKlass;//表示constantPoolCacheOop的Klassclass   constantPoolCacheKlass;</code></pre><p>和oopDesc是其他oop类型的父类一样，Klass类是其他klass类型的父类。</p><p><img src="/images/2019/4/klass.png" alt="&quot;klass&quot;"></p><p>Klass向JVM提供两个功能：</p><pre><code>1、实现语言层面的Java类（在Klass基类中已经实现）2、实现Java对象的分发功能（由Klass的子类提供虚函数实现）</code></pre><p>文章开头的时候说过：之所以设计oop-klass模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。</p><p>HotSopt JVM的设计者把对象一拆为二，分为klass和oop，其中oop的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。</p><hr><p>_metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。这两个指针都指向instanceKlass对象，它用来描述对象的具体类型。</p><h4 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h4><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个instanceKlass对象，用来在JVM层表示Java类。来看下<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceKlass.hpp" target="_blank" rel="noopener">instanceKlass</a>的内部结构：</p><pre><code>//类拥有的方法列表objArrayOop     _methods;//描述方法顺序typeArrayOop    _method_ordering;//实现的接口objArrayOop     _local_interfaces;//继承的接口objArrayOop     _transitive_interfaces;//域typeArrayOop    _fields;//常量constantPoolOop _constants;//类加载器oop             _class_loader;//protected域oop             _protection_domain;    ....</code></pre><p>可以看到，一个类该具有的东西，这里面基本都包含了。</p><p>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：</p><p><img src="/images/2019/4/klass链.png" alt="&quot;klass链&quot;"></p><p>在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图：</p><p><img src="/images/2019/4/oop-klass-klassKlass.png" alt="&quot;oop-klass-klassKlass&quot;"></p><hr><h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p><blockquote><p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p></blockquote><p>其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。</p><pre><code>class Model{    public static int a = 1;    public int b;    public Model(int b) {        this.b = b;    }}public static void main(String[] args) {    int c = 10;    Model modelA = new Model(2);    Model modelB = new Model(3);}</code></pre><p>存储结构如下：</p><p><img src="/images/2019/4/OOPKlass.png" alt="&quot;OOPKlass&quot;"></p><p>从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。&lt;/center&gt;&lt;br&gt;&lt;center&gt;不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java代码的编译与反编译那些事儿</title>
    <link href="http://www.echodemo.cc/2019/04/14/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://www.echodemo.cc/2019/04/14/Java代码的编译与反编译那些事儿/</id>
    <published>2019-04-14T03:51:38.000Z</published>
    <updated>2019-04-14T06:37:32.888Z</updated>
    
    <content type="html"><![CDATA[<center>槛菊愁烟兰泣露，罗幕轻寒，燕子双飞去。明月不谙离恨苦，斜光到晓穿朱户。</center><br><center>昨夜西风凋碧树，独上高楼，望尽天涯路。欲寄彩笺兼尺素，山长水阔知何处？</center><br><center>—-晏殊《蝶恋花·槛菊愁烟兰泣露》</center><hr><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>在介绍编译和反编译之前，我们先来简单介绍下编程语言（Programming Language）。编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。</p><p>机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。</p><p>计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。但是，汇编语言用起来同样比较复杂，后面，就衍生出了Java、C、C++等高级语言。</p><hr><h3 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h3><p>上面提到语言有两种，一种低级语言，一种高级语言。可以这样简单的理解：低级语言是计算机认识的语言、高级语言是程序员认识的语言。那么如何从高级语言转换成低级语言呢？这个过程其实就是编译。</p><p>C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条a=b+1;语句要翻译成三条汇编或机器指令，这个过程称为编译（Compile），由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用C语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用C语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。</p><p><strong>将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。</strong></p><p>现在我们知道了什么是编译，也知道了什么是编译器。不同的语言都有自己的编译器，Java语言中负责编译的编译器是一个命令：javac</p><blockquote><p>javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p></blockquote><p>当我们写完一个HelloWorld.java文件后，我们可以使用javac HelloWorld.java命令来生成HelloWorld.class文件，这个class类型的文件是JVM可以识别的文件。通常我们认为这个过程叫做Java语言的编译。其实，class文件仍然不是机器能够识别的语言，因为机器只能识别机器语言，还需要JVM再将这种class文件类型字节码转换成机器可以识别的机器语言。</p><hr><h3 id="什么是反编译"><a href="#什么是反编译" class="headerlink" title="什么是反编译"></a>什么是反编译</h3><p>反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。</p><p>有了反编译工具，我们可以做很多事情，最主要的功能就是有了反编译工具，我们就能读得懂Java编译器生成的字节码。如果你想问读懂字节码有啥用，那么我可以很负责任的告诉你，好处大大的。比如一些原理性文章的分析，都是通过反编译工具得到反编译后的代码得到的。</p><hr><h3 id="Java反编译工具"><a href="#Java反编译工具" class="headerlink" title="Java反编译工具"></a>Java反编译工具</h3><p>本文主要介绍3个Java的反编译工具：javap、jad和cfr</p><h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><p>javap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。javap和其他两个反编译工具最大的区别是他生成的文件并不是java文件，也不像其他两个工具生成代码那样更容易理解。拿一段简单的代码举例，如我们想分析Java 7中的switch是如何支持String的，我们先有以下可以编译通过的源代码：</p><pre><code>public class switchDemoString {    public static void main(String[] args) {        String str = &quot;world&quot;;        switch (str) {            case &quot;hello&quot;:                System.out.println(&quot;hello&quot;);                break;            case &quot;world&quot;:                System.out.println(&quot;world&quot;);                break;            default:                break;        }    }}</code></pre><p>执行以下两个命令：</p><pre><code>javac switchDemoString.javajavap -c switchDemoString.class</code></pre><p>生成代码如下：</p><pre><code>public class com.hollis.suguar.switchDemoString {  public com.hollis.suguar.switchDemoString();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  // String world       2: astore_1       3: aload_1       4: astore_2       5: iconst_m1       6: istore_3       7: aload_2       8: invokevirtual #3                  // Method java/lang/String.hashCode:()I      11: lookupswitch  { // 2              99162322: 36             113318802: 50               default: 61          }      36: aload_2      37: ldc           #4                  // String hello      39: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z      42: ifeq          61      45: iconst_0      46: istore_3      47: goto          61      50: aload_2      51: ldc           #2                  // String world      53: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z      56: ifeq          61      59: iconst_1      60: istore_3      61: iload_3      62: lookupswitch  { // 2                     0: 88                     1: 99               default: 110          }      88: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;      91: ldc           #4                  // String hello      93: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      96: goto          110      99: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;     102: ldc           #2                  // String world     104: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V     107: goto          110     110: return}</code></pre><p>我个人的理解，javap并没有将字节码反编译成java文件，而是生成了一种我们可以看得懂的字节码。其实javap生成的文件仍然是字节码，只是程序员可以稍微看得懂一些。如果你对字节码有所掌握，还是可以看得懂以上的代码的。其实就是把String转成hashcode，然后进行比较。</p><p>个人认为，一般情况下我们会用到javap命令的时候不多，一般只有在真的需要看字节码的时候才会用到。但是字节码中间暴露的东西是最全的，你肯定有机会用到，比如在分析synchronized的原理的时候就有用到javap。通过javap生成的字节码，我们发现synchronized底层依赖了ACC_SYNCHRONIZED标记和monitorenter、monitorexit两个指令来实现同步。</p><hr><h4 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h4><p>jad是一个比较不错的反编译工具，只要下载一个执行工具，就可以实现对class文件的反编译了。还是上面的源代码，使用jad反编译后内容如下：</p><blockquote><p>命令：jad switchDemoString.class</p></blockquote><pre><code>public class switchDemoString{    public switchDemoString()    {    }    public static void main(String args[])    {        String str = &quot;world&quot;;        String s;        switch((s = str).hashCode())        {        default:            break;        case 99162322:            if(s.equals(&quot;hello&quot;))                System.out.println(&quot;hello&quot;);            break;        case 113318802:            if(s.equals(&quot;world&quot;))                System.out.println(&quot;world&quot;);            break;        }    }}</code></pre><p>看，这个代码你肯定看的懂，因为这不就是标准的java的源代码么。这个就很清楚的可以看到原来字符串的switch是通过equals()和hashCode()方法来实现的。但是，jad已经很久不更新了，在对Java7生成的字节码进行反编译时，偶尔会出现不支持的问题，在对Java 8的lambda表达式反编译时就彻底失败。</p><hr><h4 id="CFR"><a href="#CFR" class="headerlink" title="CFR"></a>CFR</h4><p>jad很好用，但是无奈的是很久没更新了，所以只能用一款新的工具替代他，CFR是一个不错的选择，像我现在所使用的2018版本的intelliJ IDEA默认的反编译器是Fernflower，如果我用它打开class文件，会得到它自动帮我反编译的结果，该结果和CFR反编译器得到的结果基本上是一致的。相比jad来说，它们的语法可能会稍微复杂一些，但是好在他可以work。如，我们使用cfr对刚刚的代码进行反编译。执行一下命令：</p><pre><code>java -jar cfr_0_125.jar switchDemoString.class --decodestringswitch false</code></pre><p>得到以下代码：</p><pre><code>public class switchDemoString {    public static void main(String[] arrstring) {        String string;        String string2 = string = &quot;world&quot;;        int n = -1;        switch (string2.hashCode()) {            case 99162322: {                if (!string2.equals(&quot;hello&quot;)) break;                n = 0;                break;            }            case 113318802: {                if (!string2.equals(&quot;world&quot;)) break;                n = 1;            }        }        switch (n) {            case 0: {                System.out.println(&quot;hello&quot;);                break;            }            case 1: {                System.out.println(&quot;world&quot;);                break;            }        }    }}</code></pre><p>通过这段代码也能得到字符串的switch是通过equals()和hashCode()方法来实现的结论。相比Jad来说，CFR有很多参数，还是刚刚的代码，如果我们使用以下命令，输出结果就会不同：</p><pre><code>java -jar cfr_0_125.jar switchDemoString.classpublic class switchDemoString {    public static void main(String[] arrstring) {        String string;        switch (string = &quot;world&quot;) {            case &quot;hello&quot;: {                System.out.println(&quot;hello&quot;);                break;            }            case &quot;world&quot;: {                System.out.println(&quot;world&quot;);                break;            }        }    }}</code></pre><p>所以–decodestringswitch表示对于switch支持string的细节进行解码。类似的还有–decodeenumswitch、–decodefinally、–decodelambdas等。在我的关于语法糖的文章中，我使用–decodelambdas对lambda表达式进行了反编译。 源码：</p><pre><code>public static void main(String... args) {    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);    strList.forEach( s -&gt; { System.out.println(s); } );}</code></pre><p>java -jar cfr_0_125.jar lambdaDemo.class –decodelambdas false反编译后代码：</p><pre><code>public static /* varargs */ void main(String ... args) {    ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;);    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());}private static /* synthetic */ void lambda$main$0(String s) {    System.out.println(s);}</code></pre><p>CFR还有很多其他参数，均用于不同场景，读者可以使用java -jar cfr_0_125.jar –help进行了解。这里不逐一介绍了。</p><hr><h3 id="如何防止反编译"><a href="#如何防止反编译" class="headerlink" title="如何防止反编译"></a>如何防止反编译</h3><p>由于我们有工具可以对Class文件进行反编译，所以，对开发人员来说，如何保护Java程序就变成了一个非常重要的挑战。但是，魔高一尺、道高一丈。当然有对应的技术可以应对反编译咯。但是，这里还是要说明一点，和网络安全的防护一样，无论做出多少努力，其实都只是提高攻击者的成本而已。无法彻底防治。</p><p>典型的应对策略有以下几种：</p><pre><code>*隔离Java程序    *让用户接触不到你的Class文件*对Class文件进行加密    *提到破解难度*代码混淆    *将代码转换成功能上等价，但是难于阅读和理解的形式</code></pre><p>该文转载自：<a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">Java代码的编译与反编译那些事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;槛菊愁烟兰泣露，罗幕轻寒，燕子双飞去。明月不谙离恨苦，斜光到晓穿朱户。&lt;/center&gt;&lt;br&gt;&lt;center&gt;昨夜西风凋碧树，独上高楼，望尽天涯路。欲寄彩笺兼尺素，山长水阔知何处？&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-晏殊《蝶恋花·槛菊愁烟兰泣露》&lt;/c
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机是如何执行线程同步的</title>
    <link href="http://www.echodemo.cc/2019/04/14/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84/"/>
    <id>http://www.echodemo.cc/2019/04/14/Java虚拟机是如何执行线程同步的/</id>
    <published>2019-04-14T02:27:29.000Z</published>
    <updated>2019-04-14T03:01:35.083Z</updated>
    
    <content type="html"><![CDATA[<center>花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！</center><br><center>墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。</center><br><center>—-苏轼《蝶恋花·春景》</center><hr><p>了解Java语言的人都知道，Java代码要想被JVM执行，需要被转换成由字节码组成的class文件。本文主要来分析下Java虚拟机是如何在字节码层面上执行线程同步的。这里是原文的地址：<a href="https://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">Java虚拟机是如何执行线程同步的</a></p><h3 id="线程和共享数据"><a href="#线程和共享数据" class="headerlink" title="线程和共享数据"></a>线程和共享数据</h3><p>Java编程语言的优点之一是它在语言层面上对多线程的支持。这种支持大部分集中在协调多个线程对共享数据的访问上。JVM的内存结构主要包含以下几个重要的区域：栈、堆、方法区等。</p><p>在Java虚拟中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其他线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。所以，在JVM中，栈上是无法保存真实的对象的，只能保存对象的引用。真正的对象要保存在堆中。</p><p>在JVM中，堆内存是所有线程共享的。堆中只包含对象，没有其他东西。所以，堆上也无法保存基本类型和对象引用。堆和栈分工明确。但是，对象的引用其实也是对象的一部分。这里值得一提的是，数组是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。因为在Java中，数组是对象。</p><p>除了栈和堆，还有一部分数据可能保存在JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象应用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。</p><hr><h3 id="对象和类的锁"><a href="#对象和类的锁" class="headerlink" title="对象和类的锁"></a>对象和类的锁</h3><p>如前文提到，JVM中有两块内存区域可以被所有线程共享：</p><pre><code>1、堆，上面存放着所有对象2、方法区，上面存放着静态变量</code></pre><p>那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果。</p><p>为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者也许很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。当线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其他申请锁的线程。</p><p>类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个java.lang.Class 对象，当你锁住一个类的时候，其实锁住的是其对应的Class 对象。</p><hr><h3 id="监视器（Monitors）"><a href="#监视器（Monitors）" class="headerlink" title="监视器（Monitors）"></a>监视器（Monitors）</h3><p>监视器和锁同时被JVM使用（我理解作者的意思应该是想说锁其实是通过监视器实现的。），监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。</p><p>每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，他是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。当线程离开代码块的时候，无论如何离开，都会释放所关联对象的锁。</p><hr><h3 id="多次加锁"><a href="#多次加锁" class="headerlink" title="多次加锁"></a>多次加锁</h3><p>同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p><hr><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！&lt;/center&gt;&lt;br&gt;&lt;center&gt;墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-苏轼《蝶恋花·春景》&lt;/center
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Synchronized的实现原理</title>
    <link href="http://www.echodemo.cc/2019/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.echodemo.cc/2019/04/14/深入理解多线程之Synchronized的实现原理/</id>
    <published>2019-04-14T01:42:35.000Z</published>
    <updated>2019-04-15T15:08:37.438Z</updated>
    
    <content type="html"><![CDATA[<center>伫倚危楼风细细，望极春愁，黯黯生天际。草色烟光残照里，无言谁会凭阑意。</center><br><center>拟把疏狂图一醉，对酒当歌，强乐还无味。衣带渐宽终不悔，为伊消得人憔悴。</center><br><center>—-柳永《蝶恋花·伫倚危楼风细细》</center><hr><p>在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）。在了解synchronized的实现原理之前，我们先来看看synchronized关键字的三种应用方式。</p><h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><pre><code>1、修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。2、修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。3、修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</code></pre><h4 id="没有加synchronized关键字的情况"><a href="#没有加synchronized关键字的情况" class="headerlink" title="没有加synchronized关键字的情况"></a>没有加synchronized关键字的情况</h4><pre><code>public class SynchronizedTest {      public void method1(){          System.out.println(&quot;Method 1 start&quot;);          try {              System.out.println(&quot;Method 1 execute&quot;);              Thread.sleep(3000);          } catch (InterruptedException e) {             e.printStackTrace();         }         System.out.println(&quot;Method 1 end&quot;);     }     public void method2(){         System.out.println(&quot;Method 2 start&quot;);         try {             System.out.println(&quot;Method 2 execute&quot;);             Thread.sleep(1000);         } catch (InterruptedException e) {             e.printStackTrace();         }         System.out.println(&quot;Method 2 end&quot;);     }     public static void main(String[] args) {         final SynchronizedTest test = new SynchronizedTest();         new Thread(new Runnable() {             @Override             public void run() {                 test.method1();             }         }).start();         new Thread(new Runnable() {             @Override             public void run() {                 test.method2();             }         }).start();     } }</code></pre><p>执行结果如下，线程1先执行，但由于线程1在中途sleep了3秒钟时间，所以导致了线程2先执行完成。</p><pre><code>Method 1 startMethod 1 executeMethod 2 startMethod 2 executeMethod 2 endMethod 1 end</code></pre><hr><h4 id="synchronized作用于实例方法"><a href="#synchronized作用于实例方法" class="headerlink" title="synchronized作用于实例方法"></a>synchronized作用于实例方法</h4><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法。</p><pre><code>public class SynchronizedTest {  public synchronized void method1(){      System.out.println(&quot;Method 1 start&quot;);      try {          System.out.println(&quot;Method 1 execute&quot;);          Thread.sleep(3000);      } catch (InterruptedException e) {         e.printStackTrace();     }     System.out.println(&quot;Method 1 end&quot;); } public synchronized void method2(){     System.out.println(&quot;Method 2 start&quot;);     try {         System.out.println(&quot;Method 2 execute&quot;);         Thread.sleep(1000);     } catch (InterruptedException e) {         e.printStackTrace();     }     System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) {     final SynchronizedTest test = new SynchronizedTest();     new Thread(new Runnable() {         @Override         public void run() {             test.method1();         }     }).start();     new Thread(new Runnable() {         @Override         public void run() {             test.method2();         }     }).start(); }}</code></pre><p>执行结果如下，跟代码段一比较，可以很明显的看出，线程2需要等待线程1的method1执行完成才能开始执行method2方法。</p><pre><code>Method 1 startMethod 1 executeMethod 1 endMethod 2 startMethod 2 executeMethod 2 end</code></pre><hr><h4 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h4><p>当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p><pre><code>public class SynchronizedTest { public static synchronized void method1(){     System.out.println(&quot;Method 1 start&quot;);     try {         System.out.println(&quot;Method 1 execute&quot;);         Thread.sleep(3000);     } catch (InterruptedException e) {         e.printStackTrace();     }     System.out.println(&quot;Method 1 end&quot;); } public static synchronized void method2(){     System.out.println(&quot;Method 2 start&quot;);     try {         System.out.println(&quot;Method 2 execute&quot;);         Thread.sleep(1000);     } catch (InterruptedException e) {         e.printStackTrace();     }     System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) {     final SynchronizedTest test = new SynchronizedTest();     final SynchronizedTest test2 = new SynchronizedTest();     new Thread(new Runnable() {         @Override         public void run() {             test.method1();         }     }).start();     new Thread(new Runnable() {         @Override         public void run() {             test2.method2();         }     }).start(); }}</code></pre><p>执行结果如下，对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使test和test2属于不同的对象，但是它们都属于SynchronizedTest类的实例，所以也只能顺序的执行method1和method2，不能并发执行。</p><pre><code>Method 1 startMethod 1 executeMethod 1 endMethod 2 startMethod 2 executeMethod 2 end</code></pre><hr><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了。</p><pre><code>public class SynchronizedTest {    public void method1(){        System.out.println(&quot;Method 1 start&quot;);        try {            synchronized (this) {                System.out.println(&quot;Method 1 execute&quot;);                Thread.sleep(3000);            }        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;Method 1 end&quot;);    }    public void method2(){        System.out.println(&quot;Method 2 start&quot;);        try {            synchronized (this) {                System.out.println(&quot;Method 2 execute&quot;);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;Method 2 end&quot;);    }    public static void main(String[] args) {        final SynchronizedTest test = new SynchronizedTest();        new Thread(new Runnable() {            @Override            public void run() {                test.method1();            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                test.method2();            }        }).start();    }}</code></pre><p>执行结果如下，虽然线程1和线程2都进入了对应的方法开始执行，但是线程2在进入同步块之前，需要等待线程1中同步块执行完成。</p><pre><code>Method 1 startMethod 1 executeMethod 2 startMethod 1 endMethod 2 executeMethod 2 end</code></pre><hr><h3 id="Synchronized的实现原理"><a href="#Synchronized的实现原理" class="headerlink" title="Synchronized的实现原理"></a>Synchronized的实现原理</h3><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法并不是由monitorenter和monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED 标志来隐式实现的。</p><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>我们先来看一下下面这段synchronized同步方法和同步代码块两种使用形式的代码：</p><pre><code>public class SynchronizedTest {    public synchronized void doSth(){        System.out.println(&quot;Hello World&quot;);    }    public void doSth1(){        synchronized (SynchronizedTest.class){            System.out.println(&quot;Hello World&quot;);        }    }}</code></pre><p>使用<a href="https://www.hollischuang.com/archives/1876" target="_blank" rel="noopener">javap</a>来反编译以上代码，结果如下（部分无用信息过滤掉了）：</p><pre><code>public synchronized void doSth();descriptor: ()Vflags: ACC_PUBLIC, ACC_SYNCHRONIZEDCode:  stack=2, locals=1, args_size=1     0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;     3: ldc           #3                  // String Hello World     5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V     8: returnpublic void doSth1();descriptor: ()Vflags: ACC_PUBLICCode:  stack=2, locals=3, args_size=1     0: ldc           #5                  // class com/hollis/SynchronizedTest     2: dup     3: astore_1     4: monitorenter     5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;     8: ldc           #3                  // String Hello World    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V    13: aload_1    14: monitorexit    15: goto          23    18: astore_2    19: aload_1    20: monitorexit    21: aload_2    22: athrow    23: return</code></pre><p><a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>后，我们可以看到Java编译器为我们生成的字节码。在对于doSth和doSth1的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。</p><p>对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步。 对于同步代码块，JVM采用monitorenter、monitorexit两个指令来实现同步。关于这部分内容，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener">JVM规范</a>中也可以找到相关的描述。</p><hr><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a>中有关于方法级同步的介绍：</p><blockquote><p>Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method.</p></blockquote><p>主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p><hr><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>同步代码块使用monitorenter和monitorexit两个指令实现。 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a> 中有关于这两个指令的介绍：</p><h5 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h5><blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p><blockquote><p>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p></blockquote></blockquote><h5 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h5><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>大致内容如下： 可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。</p><p>同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得所锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。</p><p>每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;伫倚危楼风细细，望极春愁，黯黯生天际。草色烟光残照里，无言谁会凭阑意。&lt;/center&gt;&lt;br&gt;&lt;center&gt;拟把疏狂图一醉，对酒当歌，强乐还无味。衣带渐宽终不悔，为伊消得人憔悴。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-柳永《蝶恋花·伫倚危楼风细细》&lt;/c
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://www.echodemo.cc/2019/04/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/13/Java内存模型/</id>
    <published>2019-04-13T10:02:45.000Z</published>
    <updated>2019-04-14T01:00:21.954Z</updated>
    
    <content type="html"><![CDATA[<center>君不见，黄河之水天上来，奔流到海不复回。</center><br><center>君不见，高堂明镜悲白发，朝如青丝暮成雪。</center><br><center>人生得意须尽欢，莫使金樽空对月。</center><br><center>天生我材必有用，千金散尽还复来。</center><br><center>—-李白《将进酒》</center><hr><h3 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h3><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型（Memory Model），然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><h4 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h4><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><hr><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。下图为一个CPU双核的缓存结构。</p><p><img src="/images/2019/4/scache.png" alt="&quot;CPU双核缓存结构&quot;"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><h4 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h4><p>上面提到在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><hr><h3 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h3><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><pre><code>1、原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。2、可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。3、有序性即程序执行的顺序按照代码的先后顺序执行。</code></pre><p>有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><hr><h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><hr><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="/images/2019/4/jmm1.png" alt="&quot;java内存模型&quot;"></p><p>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p>所以，再来总结下，<strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p><hr><h3 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h3><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码，在Java中对应的关键字就是synchronized。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;君不见，黄河之水天上来，奔流到海不复回。&lt;/center&gt;&lt;br&gt;&lt;center&gt;君不见，高堂明镜悲白发，朝如青丝暮成雪。&lt;/center&gt;&lt;br&gt;&lt;center&gt;人生得意须尽欢，莫使金樽空对月。&lt;/center&gt;&lt;br&gt;&lt;center&gt;天生我材必有用，千金散尽还
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构、Java内存模型和Java对象模型</title>
    <link href="http://www.echodemo.cc/2019/04/13/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/13/JVM内存结构、Java内存模型和Java对象模型/</id>
    <published>2019-04-13T07:40:51.000Z</published>
    <updated>2019-04-13T10:01:14.168Z</updated>
    
    <content type="html"><![CDATA[<center>休对故人思故国，且将新火试新茶，诗酒趁年华。—-苏轼《望江南》</center><hr><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下：</p><p><img src="/images/2019/4/jvmstructure.png" alt="&quot;java内存结构&quot;"></p><p>以上是JVM规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。根据JVM规范，JVM把内存划分成了这几个区域<strong>（其中，方法区和堆是所有线程共享的）：</strong></p><pre><code>1.方法区（Method Area）2.堆区（Heap）3.虚拟机栈（JVM Stack）4.本地方法栈（Native Method Stack）5.PC寄存器（The PC Register）</code></pre><hr><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC（Garbage Collection）。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。</p><p>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation），一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在方法区上进行GC，条件相当苛刻而且困难。</p><p>如图中所示，运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</p><h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><p>堆区是GC最频繁的，也是理解GC机制最重要的区域。<strong>堆区由所有线程共享，在虚拟机启动时创建。</strong>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</p><h4 id="Java虚拟机栈（JVM-Stack）"><a href="#Java虚拟机栈（JVM-Stack）" class="headerlink" title="Java虚拟机栈（JVM Stack）"></a>Java虚拟机栈（JVM Stack）</h4><p>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。</p><p>局部变量表中存储着和方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：<strong>内存空间可以在编译期间就确定，运行时不再改变。</strong></p><p>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</p><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，<strong>虚拟机栈执行Java方法，本地方法栈执行native方法。</strong>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</p><h4 id="PC寄存器（The-PC-Register）"><a href="#PC寄存器（The-PC-Register）" class="headerlink" title="PC寄存器（The PC Register）"></a>PC寄存器（The PC Register）</h4><p>PC寄存器（The PC Register）是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变PC寄存器（程序计数器）的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。</p><p>每个PC寄存器只能记录一个线程的行号，因此它是线程私有的。如果程序当前正在执行的是一个java方法，则PC寄存器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则寄存器的值为空，此内存区是唯一不会抛出OutOfMemoryError的区域。</p><hr><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿。在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p><p>Java内存模型（Java Memory Model）简称JMM。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，它描述了一组规则或规范，这个规范定义了一个线程在对共享变量进行写入时对另一个线程是可见的。</p><p>简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。下面是JMM抽象示意图：</p><p><img src="/images/2019/4/jmm.png" alt="&quot;java内存模型&quot;"></p><hr><h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>我们都知道Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。这个关于Java对象自身的存储模型称之为Java对象模型。</p><p>在HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。下面是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p><p><img src="/images/2019/4/OOPKlass.jpg" alt="&quot;java对象模型&quot;"></p><p>从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，我们再来区分下JVM内存结构、 Java内存模型 以及Java对象模型这三个概念：JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。Java对象模型和Java对象在虚拟机中的表现形式有关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;休对故人思故国，且将新火试新茶，诗酒趁年华。—-苏轼《望江南》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中碰到的问题</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中碰到的问题/</id>
    <published>2019-04-13T07:05:47.000Z</published>
    <updated>2019-04-13T06:29:55.472Z</updated>
    
    <content type="html"><![CDATA[<center>我把天空和大地打扫地干干净净，归还一个陌不相识的人。—-海子《黎明》</center><hr><h3 id="在使用group-by时碰到的问题"><a href="#在使用group-by时碰到的问题" class="headerlink" title="在使用group by时碰到的问题"></a>在使用group by时碰到的问题</h3><p>(1)选择列表中的列无效，因为该列没有包含在聚合函数或者group by子句中。</p><pre><code>select id,name,count(0) as cx from student group by id order by cx desc</code></pre><p>其中name会无效，因为该列没有包含在聚合函数或者group by子句当中。也就是说：在select需要查询语句中选中的字段，必须出现在group by子句中。我们还需注意的是：group by和order by一起使用时，order by要在group by的后面。</p><p>(2)每个 group by 表达式必须至少包含一个不是外部引用的列。</p><pre><code>select  count(0)，nothing  from student group by nothing having name=&apos;echodemo&apos;</code></pre><p>出错的原因是因为group by语句所跟的内容一般是数据表中的字段或者数据表的表达式，因为上边的句子中在group by后边使用的是数据表中不存在的字段且也不是数据表的表达式，为外部实例，所以才会报上变得错误。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我把天空和大地打扫地干干净净，归还一个陌不相识的人。—-海子《黎明》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;在使用group-by时碰到的问题&quot;&gt;&lt;a href=&quot;#在使用group-by时碰到的问题&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/乐观锁与悲观锁/</id>
    <published>2019-04-13T06:30:39.000Z</published>
    <updated>2019-04-13T06:26:00.617Z</updated>
    
    <content type="html"><![CDATA[<center>死亡不是真的逝去，遗忘才是永恒的消亡。—-李·昂克里奇《寻梦环游记》</center><hr><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。而乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>其实无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。乐观锁和悲观锁的概念不仅仅是关系型数据库系统所具有的，像memcache、hibernate、tair等都有类似的概念。</p><p>针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><hr><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p><p>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p><h4 id="在数据库中，悲观锁的流程如下："><a href="#在数据库中，悲观锁的流程如下：" class="headerlink" title="在数据库中，悲观锁的流程如下："></a>在数据库中，悲观锁的流程如下：</h4><p>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p><h4 id="MySQL-InnoDB中使用悲观锁"><a href="#MySQL-InnoDB中使用悲观锁" class="headerlink" title="MySQL InnoDB中使用悲观锁"></a>MySQL InnoDB中使用悲观锁</h4><p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0。</p><pre><code>//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work;</code></pre><p>上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p><h4 id="优点与不足"><a href="#优点与不足" class="headerlink" title="优点与不足"></a>优点与不足</h4><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p><h4 id="使用版本号实现乐观锁"><a href="#使用版本号实现乐观锁" class="headerlink" title="使用版本号实现乐观锁"></a>使用版本号实现乐观锁</h4><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><pre><code>//1.查询出商品信息select (status,status,version) from t_goods where id=#{id}//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};</code></pre><h4 id="优点与不足-1"><a href="#优点与不足-1" class="headerlink" title="优点与不足"></a>优点与不足</h4><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;死亡不是真的逝去，遗忘才是永恒的消亡。—-李·昂克里奇《寻梦环游记》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。而乐观并发控制(乐观锁)和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的读锁和写锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%9A%84%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中的读锁和写锁/</id>
    <published>2019-04-13T05:50:17.000Z</published>
    <updated>2019-04-13T05:52:41.530Z</updated>
    
    <content type="html"><![CDATA[<center>即使明天早上，枪口和血淋淋的太阳，让我交出自由、青春和笔，我也绝不会交出这个夜晚。—-北岛《履历》</center><hr><p>本文提到的读锁和写锁都是MySQL数据库的MyISAM引擎支持的表级锁。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享锁与排他锁。其实共享锁指的就是读锁！互斥锁、排他锁、独占锁值得都是写锁。</p><hr><h3 id="重点知识回顾"><a href="#重点知识回顾" class="headerlink" title="重点知识回顾"></a>重点知识回顾</h3><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB存储引擎采用的是页面锁(page-level locking)，但也支持表级锁;InnoDB存储引擎既支持行级锁(row-level locking)，也支持表级锁，但默认情况下是采用行级锁。</p><pre><code>表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。页面锁:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><hr><h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>MyISAM 存储引擎只支持表锁，MySQL 的表级锁有两种模式:表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。</p><p>对于读操作，可以增加读锁，一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。（当一个请求在读数据时，其他请求也可以读，但是不能写，因为一旦另外一个线程写了数据，就会导致当前线程读取到的数据不是最新的了。这就是不可重复读现象）</p><p>对于写操作，可以增加写锁，一旦数据表被加上写锁，其他请求无法在对该表增加读锁和写锁。（当一个请求在写数据时，其他请求不能执行任何操作，因为在当前事务提交之前，其他的请求无法看到本次修改的内容。这有可能产生脏读、不可重复读和幻读）</p><h4 id="读锁和写锁都是阻塞锁。"><a href="#读锁和写锁都是阻塞锁。" class="headerlink" title="读锁和写锁都是阻塞锁。"></a>读锁和写锁都是阻塞锁。</h4><p>如果t1对数据表增加了写锁，这时t2请求对数据表增加写锁，t2并不会直接返回，而是会一直处于阻塞状态，直到t1释放了对表的锁，这时t2便有可能加锁成功，获取到结果。</p><h4 id="表锁的加锁-解锁方式"><a href="#表锁的加锁-解锁方式" class="headerlink" title="表锁的加锁/解锁方式"></a>表锁的加锁/解锁方式</h4><p>MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。如果用户想要显示的加锁可以使用以下命令：</p><pre><code>锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…]解锁表：UNLOCK TABLES </code></pre><p>在用 LOCK TABLES 给表显式加表锁时,必须同时取得所有涉及到表的锁。在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表;如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。</p><pre><code>//对表test_table增加读锁：LOCK TABLES test_table READUNLOCK test_table//对表test_table增加写锁：LOCK TABLES test_table WRITEUNLOCK test_table</code></pre><p>当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错!</p><p>比如如下SQL语句：</p><pre><code>select a.first_name,b.first_name, from actor a,actor b where a.first_name = b.first_name;</code></pre><p>该Sql语句中，actor表以别名的方式出现了两次，分别是a,b，这时如果要在该Sql执行之前加锁就要使用以下Sql:</p><pre><code>lock table actor as a read,actor as b read;</code></pre><hr><h4 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h4><p>上文提到过 MyISAM 表的读和写是串行的,但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p><p>1、当concurrent_insert设置为0时,不允许并发插入。</p><p>2、当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL的默认设置。</p><p>3、当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录。可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。</p><hr><h4 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h4><p>前面讲过,MyISAM 存储引擎的读锁和写锁是互斥的,读写操作是串行的。那么,一个进程请求某个MyISAM 表的读锁,同时另一个进程也请求同一表的写锁,MySQL 如何处理呢? 答案是写进程先获得锁。</p><p>不仅如此,即使读请求先到锁等待队列,写请求后到,写锁也会插到读锁请求之前!这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因,因为,大量的更新操作会造成查询操作很难获得读锁,从而可能永远阻塞。这种情况有时可能会变得非常糟糕!不过幸好我们可以通过 一些设置来调节 MyISAM 的调度行为。</p><pre><code>1、通过指定启动参数low-priority-updates,使MyISAM引擎默认给予读请求以优先的权利。 2、通过执行命令SET LOWPRIORITYUPDATES=1,使该连接发出的更新请求优先级降低。 3、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性,降低该语句的优先级。</code></pre><p>另外,MySQL也提供了一种折中的办法来调节读写冲突,即给系统参数max_write_lock_count 设置一个合适的值,当一个表的读锁达到这个值后,MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;即使明天早上，枪口和血淋淋的太阳，让我交出自由、青春和笔，我也绝不会交出这个夜晚。—-北岛《履历》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文提到的读锁和写锁都是MySQL数据库的MyISAM引擎支持的表级锁。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的共享锁与排他锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E4%BB%96%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中的共享锁与排他锁/</id>
    <published>2019-04-13T05:17:06.000Z</published>
    <updated>2019-04-13T05:26:38.066Z</updated>
    
    <content type="html"><![CDATA[<center>从别后，忆相逢，几回魂梦与君同。—-晏几道《鹧鸪天》</center><hr><p>在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。</p><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。</p><pre><code>SELECT ... LOCK IN SHARE MODE;</code></pre><p>在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><p>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。</p><pre><code>SELECT ... FOR UPDATE;</code></pre><p>在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB还有两个表锁：</p><p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。</p><p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p><pre><code>注：意向锁是InnoDB自动加的，不需要用户干预。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;从别后，忆相逢，几回魂梦与君同。—-晏几道《鹧鸪天》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的行级锁、表级锁、页级锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/Mysql%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/Mysql中的行级锁、表级锁、页级锁/</id>
    <published>2019-04-13T03:07:56.000Z</published>
    <updated>2019-04-13T05:27:41.090Z</updated>
    
    <content type="html"><![CDATA[<center>我的建议是：出发吧。给你的宇宙套上马鞍，看它会变成什么样？—-《瑞克和莫蒂》</center><hr><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><hr><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><pre><code>特点:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</code></pre><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><pre><code>特点:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</code></pre><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>表级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。</p><pre><code>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><hr><h3 id="MySQL常用存储引擎的锁机制"><a href="#MySQL常用存储引擎的锁机制" class="headerlink" title="MySQL常用存储引擎的锁机制"></a>MySQL常用存储引擎的锁机制</h3><pre><code>MyISAM和MEMORY采用表级锁(table-level locking)。BDB采用页面锁(page-level locking)或表级锁，默认为页面锁。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</p><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p><h4 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h4><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p><p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p><p>当两个事务同时执行，一个锁住了主键索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><p>有多种方法可以避免死锁，这里只介绍常见的三种:</p><pre><code>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我的建议是：出发吧。给你的宇宙套上马鞍，看它会变成什么样？—-《瑞克和莫蒂》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。在DBMS中，可以按照锁的粒度把数据库锁分为
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的读现象浅析</title>
    <link href="http://www.echodemo.cc/2019/04/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E7%8E%B0%E8%B1%A1%E6%B5%85%E6%9E%90/"/>
    <id>http://www.echodemo.cc/2019/04/13/数据库的读现象浅析/</id>
    <published>2019-04-13T02:18:27.000Z</published>
    <updated>2019-04-13T02:31:43.220Z</updated>
    
    <content type="html"><![CDATA[<center>别怕美好的一切会消失，咱们先来让它存在。—-王小波《爱你就像爱生命》</center><hr><p>“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据,那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p><p>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。<br>　　<br>幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;别怕美好的一切会消失，咱们先来让它存在。—-王小波《爱你就像爱生命》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Limit的用法</title>
    <link href="http://www.echodemo.cc/2019/04/13/Limit%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2019/04/13/Limit的用法/</id>
    <published>2019-04-13T02:08:26.000Z</published>
    <updated>2019-04-13T02:14:22.412Z</updated>
    
    <content type="html"><![CDATA[<center>春天来得很慢，春天才有浪漫。 —-deca joins《夜间独白》</center><hr><pre><code>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</code></pre><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><pre><code>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.//如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;春天来得很慢，春天才有浪漫。 —-deca joins《夜间独白》&lt;/center&gt;

&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的事件处理</title>
    <link href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://www.echodemo.cc/2019/04/05/Redis中事件处理/</id>
    <published>2019-04-05T02:20:00.000Z</published>
    <updated>2019-04-13T02:34:36.602Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><p>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字（Socket）操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</p><p>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p><pre><code>注：TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。</code></pre><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器；当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。下图是Redis线程模型：</p><p><img src="/images/2019/4/IO.png" alt="&quot;redis线程模型&quot;"></p><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p>（1）文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>（2）I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。如果你不太清楚IO多路复用程序可以阅读我的这篇博客：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">Redis中的IO多路复用</a></p><p><img src="/images/2019/4/socket.png" alt="&quot;socket&quot;"></p><p>（3）文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p><p>（4）事件处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件分为以下两类：</p><pre><code>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次;周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</code></pre><p>时间事件主要由以下三个属性组成：</p><pre><code>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大;when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间;timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</code></pre><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><p>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达;</p><p>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。(现在的Redis主要使用这个)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：&lt;/p&gt;
&lt;p&gt;文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字（Socket）操作的抽象。服务器与客户端（或者其他服务器）
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初识Redis</title>
    <link href="http://www.echodemo.cc/2019/04/05/%E5%88%9D%E8%AF%86Redis/"/>
    <id>http://www.echodemo.cc/2019/04/05/初识Redis/</id>
    <published>2019-04-05T01:49:17.000Z</published>
    <updated>2019-04-13T02:29:37.637Z</updated>
    
    <content type="html"><![CDATA[<center>你身体里的每一粒原子都来自一颗爆炸了的恒星。形成你左手的原子和形成你右手的原子也许来自不同的恒星。这是我所知的物理学中最富有诗意的事情：你们都是星辰。—-劳伦斯·克劳斯《一颗原子的时空之旅》</center><hr><h3 id="1，盛赞Redis"><a href="#1，盛赞Redis" class="headerlink" title="1，盛赞Redis"></a>1，盛赞Redis</h3><p>Redis（REmote Dictionary Server）的前身是一个叫做LLOOGG的网站，在2008年，Redis的作者在开发该网站时，需要实现一个高性能的队列功能，最开始是使用MySQL来实现的， 但后来发现无论如何优化SQL语句都无法使网站的性能提高上去，他决定做一个专属于LLOOGG的数据库 。</p><p>Redis是一种基于键值对（key-value）的NoSQL数据库。NoSQL(NoSQL = Not Only SQL )。是对不同于传统的关系型数据库的数据库管理系统的统称。高可扩展性，分布式计算，低成本，架构的灵活性等特性。</p><p><img src="/images/2019/4/nosql.png" alt="&quot;NoSQL数据库分类&quot;"></p><p>国外的Twitter、 Instagram、Stack Overflow、GitHub，国内像新浪微博、阿里巴巴、腾讯、百度、搜狐、优酷土豆、美团、小米、唯品会等公司都是 Redis的使用者。</p><h3 id="2-Redis特性"><a href="#2-Redis特性" class="headerlink" title="2,Redis特性"></a>2,Redis特性</h3><pre><code>1、速度快2、基于键值对的数据结构服务器3、丰富的功能4、简单稳定5、客户端语言多6、持久化7、主从复制8、高可用和分布式</code></pre><p>（1）速度快</p><p>Redis的所有数据都是存放在内存当中。它是完全基于内存，其绝大部分请求是纯粹的内存操作。</p><p>Redis使用了单线程架构。避免了不必要的上下文切换和竞争条件，从而不存在多进程或者多线程切换导致的CPU消耗问题，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p>采用了非阻塞I/O多路复用机制。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，此时程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流。阻塞式I/O如果要接收更多的连接，就必须创建更多的线程。在I/O复用模式下大量的连接统统都可以过来直接注册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。这就是I/O复用与传统的阻塞式I/O最大的不同。也正是I/O复用的精髓所在。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。具体的关于I/O多路复用可以查看我的这篇文章：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a></p><p>Redis是用C语言实现的。一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p><p>（2）基于键值对的数据结构服务器</p><p>与很多键值对数据库不同的是，Redis中的值不仅可以是字符串，而且还可以是具体的数据结构，Redis它主要提供了5种数据结构：字符串（String）、哈希（Hash)、列表（List）、集合（Set）、有序集合（Sorted Set），同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种神奇的“数据结构”，并且随着 LBS（Location Based Service，基于位置服务）的不断发展，Redis3.2版本中加入有关GEO（地理信息定位）的功能，在这些数据结构的帮助下，不仅提高了开发的效率，而且适用于更多的应用场景。</p><p>（3）丰富的功能</p><pre><code>1、提供了键过期功能，可以用来实现缓存。2、提供了发布订阅功能，可以用来实现消息系统。3、支持Lua脚本功能，可以利用Lua创造出新的Redis命令。4、提供了简单的事务功能，能在一定程度上保证事务特性。5、提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到 Redis，减少了网络的开销。</code></pre><p>（4）简单稳定</p><p>Redis的源码很少，早期版本的代码只有2万行左右，3.0版本以后由于添加了集群特性，代码增至5万行左右，也就意味着普通的开发和运维人员完全可以“吃透”它。</p><p>Redis使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。</p><p>Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖 libevent这样的系统类库），Redis自己实现了事件处理的相关功能。</p><p>（5）客户端语言多</p><p>Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入到 Redis，几乎涵盖了主流的编程语言，例如Java、PHP、 Python、C、C++、Nodejs等。</p><p>（6）持久化</p><p>我们都知道的是：将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失。Redis提供了两种持久化方式用来将内存的数据保存到硬盘：RDB和 AOF。</p><p>RDB(Redis DataBase)是在某个时间点将数据（Database中的key-value的二进制形式数据）写入一个临时的rdb文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。它是通过配置Redis在n秒内如果超过m个key被修改就执行一次RDB操作，这中持久化的方式也叫做snapshots。RDB是间隔一段时间进行持久化，如果在持久化之间发生故障，会发生数据的丢失，所以这种方式更适合数据要求不严谨的时候。</p><p>AOF(Append Only File)把数据的每一条修改命令都追加到aof文件。该“日志文件”保存了历史所有的操作过程，虽然可以保证数据的不易丢失，但是这样也造成了其文件势必会比rdb文件大很多，且aof文件中存储的是命令，导致其恢复的速度变慢。</p><p>（7）主从复制</p><p>Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。</p><p>（8）高可用和分布式</p><p>Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis 节点的故障发现和故障自动转移。Redis从3.0版本正式提供了分布式实现 Redis Cluster，它是Redis真正的分布式实现，提供了高可用、读写和容量的扩展性。</p><p>3，Redis使用场景</p><p>（1）缓存</p><p>Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p><p>（2）排行榜系统</p><p>Redis提供了列表和有序集合数据结构。</p><p>（3）计数器应用</p><p>传统关系型数据库如果并发量很大，为了保证数据的实时性，对其性能是一种很大的挑战。Redis天然支持计数功能而且计数的性能也非常好。</p><p>（4）社交网络</p><p>由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存点赞，推送，下拉刷新等类型的数据，而Redis提供的数据结构可以相对比较容易地实现这些功能。</p><p>（5）消息队列系统</p><p>Redis提供了发布订阅功能和阻塞队列的功能。</p><p>（6）Redis不适合的场景</p><p>不适合存储大规模的数据和冷数据。</p><p>4，安装Redis</p><p>（1）在Linux上安装Redis</p><pre><code>$ wget http://download.redis.io/releases/redis-3.0.7.tar.gz $ tar xzf redis-3.0.7.tar.gz $ ln -s redis-3.0.7 redis $ cd redis $ make $ make install1、下载Redis指定版本的源码压缩包到当前目录。2、解压缩Redis源码压缩包。3、建立一个redis目录的软连接，指向redis-3.0.7。这是为了不把redis目录固定在指定版本上，有利于Redis未来版本升级， 是安装软件的一种好习惯。4、进入redis目录。5、编译（编译之前确保操作系统已经安装gcc）。6、安装。将Redis的相关运行文 件放到/usr/local/bin/下，这样就可以在任意目录下执行Redis的命令。</code></pre><p>（2）在Windows上安装Redis</p><p>5，启动、操作、关闭Redis</p><p>启动Redis服务</p><p>（1）默认配置</p><pre><code>$ redis-server</code></pre><p>（2）运行启动</p><pre><code>$ redis-server --configKey1 configValue1 --configKey2 configValue2</code></pre><p>（3）配置文件启动</p><pre><code>$ redis-server /opt/redis/redis.conf</code></pre><p>Redis命令行客户端</p><p>（1）交互式方式</p><pre><code>$ redis-cli -h 127.0.0.1 -p 6379 $ 127.0.0.1:6379&gt; set hello world$ OK$ 127.0.0.1:6379&gt; get hello$ &quot;world&quot;</code></pre><p>（2）命令方式</p><pre><code>$ redis-cli -h 127.0.0.1 -p 6379 get hello$ &quot;world&quot;</code></pre><p>注：如果没有-h参数，那么默认连接127.0.0.1；如 果没有-p，那么默认6379端口，也就是说如果-h和-p都没写就是连接 127.0.0.1：6379这个Redis实例。</p><p>停止Redis服务</p><p>Redis提供了shutdown命令来停止Redis服务，如果要停掉127.0.0.1上 6379端口上的Redis服务：</p><pre><code>$ redis-cli shutdown</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;你身体里的每一粒原子都来自一颗爆炸了的恒星。形成你左手的原子和形成你右手的原子也许来自不同的恒星。这是我所知的物理学中最富有诗意的事情：你们都是星辰。—-劳伦斯·克劳斯《一颗原子的时空之旅》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;1，盛赞Redis&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的I/O多路复用</title>
    <link href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2019/04/05/Redis中的IO多路复用/</id>
    <published>2019-04-05T01:10:56.000Z</published>
    <updated>2019-04-13T02:38:14.070Z</updated>
    
    <content type="html"><![CDATA[<center>人真正活过的那段生命仅仅是一小部分。其余的部分不能算是生命，仅仅是时间而已。—-伊坂幸太郎《死神的精确度》</center><hr><p>在谈I/O多路复用机制之前，我们先来讲讲阻塞I/O和非阻塞I/O。</p><h3 id="1、阻塞I-O"><a href="#1、阻塞I-O" class="headerlink" title="1、阻塞I/O"></a>1、阻塞I/O</h3><p>我们常用的IO操作（比如read和write）都是阻塞I/O，也就是说当你调用read时，如果没有收到数据的返回，那么线程或者进程就会被挂起，直到收到数据。阻塞的意思，就是一直等着。阻塞I/O就是等着数据返回，进行读写操作。通过应用的函数进行调用，但是内核一直没有返回，就一直等着。应用的函数长时间处于等待数据返回的状态，我们就称之为阻塞I/O。</p><h3 id="2、非阻塞I-O"><a href="#2、非阻塞I-O" class="headerlink" title="2、非阻塞I/O"></a>2、非阻塞I/O</h3><p>非阻塞IO是通过fcntl（POSIX）或ioctl（Unix）设为非阻塞模式。此时，当你调用read时，如果有数据收到，就返回数据；如果没有数据收到，就立刻返回一个错误。这样的话就不存在线程的阻塞了，但是你还是要不断的轮询来读取或写入。相当于你去查看有没有数据，告诉你没有，过一会再来吧！应用过一会再来问，有没有数据？没有数据，会有一个返回。但是依旧很不好。应用必须得过一会来一下，问问内核有木有数据啊。</p><h3 id="3、I-O多路复用"><a href="#3、I-O多路复用" class="headerlink" title="3、I/O多路复用"></a>3、I/O多路复用</h3><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路复用是指使用一个线程来检查多个Socket的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。什么意思呢？就是派一个代表，同时监听多个文件描述符是否有数据到来。等着等着，如果有数据，就告诉某某你的数据来啦！赶紧来处理吧。</p><p>我们先来看一张JDK的基于I/O多路复用技术的NIO实现的图片，如下：</p><p><img src="/images/2019/4/selector.png" alt="&quot;JDK的基于I/O多路复用技术的NIO实现&quot;"></p><p>从图片中我们可以看到，很多的网络连接都向Selector进行注册，Selector会对已经向它注册了的网络连接进行轮询监控，一旦发现某个网络连接有了数据的返回，便通过SelectKey通知相应的Channel。从而达到多路复用的目的。</p><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换。下面是redis线程模型，如图所示：</p><p><img src="/images/2019/4/IO.png" alt="&quot;redis线程模型&quot;"></p><p>我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。更详细的关于redis中的事件处理请参见我的这篇文章：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">Redis中的事件处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;人真正活过的那段生命仅仅是一小部分。其余的部分不能算是生命，仅仅是时间而已。—-伊坂幸太郎《死神的精确度》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在谈I/O多路复用机制之前，我们先来讲讲阻塞I/O和非阻塞I/O。&lt;/p&gt;
&lt;h3 id=&quot;1、阻塞I-O&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
</feed>
