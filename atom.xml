<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-06-23T11:42:34.734Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis学习笔记(11)-一对多查询</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)-%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(11)-一对多查询/</id>
    <published>2019-06-23T11:31:38.000Z</published>
    <updated>2019-06-23T11:42:34.734Z</updated>
    
    <content type="html"><![CDATA[<center>楼上谁将玉笛吹？山前水阔暝云低。劳劳燕子人千里，落落梨花雨一枝。</center><br><center>修禊近，卖饧时。故乡惟有梦相随。夜来折得江头柳，不是苏堤也皱眉。</center><br><center>—-宋·张炎《鹧鸪天·楼上谁将玉笛吹》</center><p>张炎（1248年－1320年），字叔夏，号玉田，晚年号乐笑翁。祖籍陕西凤翔。六世祖张俊，宋朝著名将领。父张枢，“西湖吟社”重要成员，妙解音律，与著名词人周密相交。张炎是勋贵之后，前半生居于临安，生活优裕，而宋亡以后则家道中落，晚年漂泊落拓。著有《山中白云词》，存词302首。张炎另一重要的贡献在于创作了中国最早的词论专著《词源》，总结整理了宋末雅词一派的主要艺术思想与成就，其中以“清空”，“骚雅”为主要主张。</p><hr><p>本文实现一对多查询，查询订单及订单明细的信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;楼上谁将玉笛吹？山前水阔暝云低。劳劳燕子人千里，落落梨花雨一枝。&lt;/center&gt;&lt;br&gt;&lt;center&gt;修禊近，卖饧时。故乡惟有梦相随。夜来折得江头柳，不是苏堤也皱眉。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·张炎《鹧鸪天·楼上谁将玉笛吹》&lt;/cente
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(10)-一对一查询</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(10)-一对一查询/</id>
    <published>2019-06-23T09:11:45.000Z</published>
    <updated>2019-06-23T11:09:14.494Z</updated>
    
    <content type="html"><![CDATA[<center>梅子留酸软齿牙，芭蕉分绿与窗纱。</center><br><center>日长睡起无情思，闲看儿童捉柳花。</center><br><center>—-宋·杨万里《闲居初夏午睡起·其一》</center><hr><p>本文使用两种方式(resultType和resultMap)实现一对一查询，查询订单信息，关联查询创建订单的用户信息。</p><h3 id="resultType实现"><a href="#resultType实现" class="headerlink" title="resultType实现"></a>resultType实现</h3><p>（1）sql语句</p><pre><code>1、确定查询的主表：订单表。2、确定查询的关联表：用户表。3、关联查询使用内连接？还是外连接？4、由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。</code></pre><p>sql语句如下：</p><pre><code>SELECT   orders.*,  user.username,  user.sex,  user.address FROM  orders,  user WHERE orders.user_id = user.id</code></pre><p>（2）创建pojo</p><pre><code>1、将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。2、原始的Orders.java不能映射全部字段，需要新创建的pojo。3、创建一个pojo继承包括查询字段较多的po类。4、对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类OrdersCustom的代码。</code></pre><p>pojo类如下：</p><pre><code>/** *  * &lt;p&gt;Title: OrdersCustom&lt;/p&gt; * &lt;p&gt;Description: 订单的扩展类&lt;/p&gt; *///通过此类映射订单和用户查询的结果，让此类继承包括字段较多的pojo类public class OrdersCustom extends Orders{    //添加用户属性    /*user.username,      user.sex,      user.address */    private String username;    private String sex;    private String address;    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }}</code></pre><p>（3）OrdersCustomMapper.xml</p><pre><code>&lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=&quot;findOrdersUser&quot;  resultType=&quot;com.echodemo.mybatislearning.bean.OrdersCustom&quot;&gt;  SELECT      orders.*,      user.username,      user.sex,      user.address    FROM      orders,      user    WHERE orders.user_id = user.id&lt;/select&gt;</code></pre><p>（4）OrdersCustomMapper.java</p><pre><code>// 查询订单关联查询用户信息public List&lt;OrdersCustom&gt; findOrdersUser()throws Exception;}</code></pre><hr><h3 id="resultMap实现"><a href="#resultMap实现" class="headerlink" title="resultMap实现"></a>resultMap实现</h3><p>使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。</p><p>（1）定义resultMap</p><pre><code>&lt;!-- 订单查询关联用户的resultMap将整个查询的结果映射到com.echodemo.mybatislearning.bean.Orders中 --&gt;&lt;resultMap type=&quot;com.echodemo.mybatislearning.bean.Orders&quot; id=&quot;OrdersUserResultMap&quot;&gt;    &lt;!-- 配置映射的订单信息 --&gt;    &lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id        column：订单信息的唯一标识列        property：订单信息的唯一标识列所映射到Orders中哪个属性      --&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;    &lt;!-- 配置映射的关联的用户信息 --&gt;    &lt;!-- association：用于映射关联查询单个对象的信息    property：要将关联查询的用户信息映射到Orders中哪个属性     --&gt;    &lt;association property=&quot;user&quot;  javaType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        &lt;!-- id：关联查询用户的唯 一标识        column：指定唯 一标识用户信息的列        javaType：映射到user的哪个属性         --&gt;        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;</code></pre><p>（2）statement定义</p><pre><code>&lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=&quot;findOrdersUserResultMap&quot; resultMap=&quot;OrdersUserResultMap&quot;&gt;    SELECT    orders.*,    user.username,    user.sex,    user.address    FROM    orders,    user    WHERE orders.user_id = user.id&lt;/select&gt;</code></pre><p>（3）OrdersMapper.java</p><pre><code>// 查询订单关联查询用户使用resultMappublic List&lt;Orders&gt; findOrdersUserResultMap()throws Exception;</code></pre><p>（4）测试代码</p><pre><code>@Testpublic void testFindOrdersUserResultMap() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    // 创建代理对象    OrdersMapperCustom ordersMapperCustom = sqlSession            .getMapper(OrdersMapperCustom.class);    // 调用maper的方法    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap();    System.out.println(list);    sqlSession.close();}</code></pre><hr><h3 id="resultType和resultMap实现一对一查询小结"><a href="#resultType和resultMap实现一对一查询小结" class="headerlink" title="resultType和resultMap实现一对一查询小结"></a>resultType和resultMap实现一对一查询小结</h3><p>（1）resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。</p><p>（2）resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。</p><p>（3）resultMap可以实现延迟加载，resultType无法实现延迟加载。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770023" target="_blank" rel="noopener">mybatis学习笔记(10)-一对一查询</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;梅子留酸软齿牙，芭蕉分绿与窗纱。&lt;/center&gt;&lt;br&gt;&lt;center&gt;日长睡起无情思，闲看儿童捉柳花。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·杨万里《闲居初夏午睡起·其一》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文使用两种方式(resultType和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(9)-订单商品数据模型分析</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)-%E8%AE%A2%E5%8D%95%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(9)-订单商品数据模型分析/</id>
    <published>2019-06-23T08:36:12.000Z</published>
    <updated>2019-06-23T09:10:14.994Z</updated>
    
    <content type="html"><![CDATA[<center>九月江南花事休, 芙蓉宛转在中洲。</center><br><center>美人笑隔盈盈水, 落日还生渺渺愁。</center><br><center>露洗玉盘金殿冷, 风吹罗带锦城秋。</center><br><center>相看未用伤迟暮, 别有池塘一种幽。</center><br><center>—-明·文徵明《钱氏池上芙蓉》</center><hr><p>本文对接下来几篇博客中用到的数据模型进行分析，并附上建表sql文件和测试数据文件。</p><h3 id="数据模型分析思路"><a href="#数据模型分析思路" class="headerlink" title="数据模型分析思路"></a>数据模型分析思路</h3><p>（1）每张表记录的数据内容</p><pre><code>分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。</code></pre><p>（2）每张表重要的字段设置</p><pre><code>非空字段、外键字段。</code></pre><p>（3）数据库级别表与表之间的关系</p><pre><code>外键关系。</code></pre><p>（4）表与表之间的业务关系</p><pre><code>在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析。</code></pre><hr><h3 id="数据模型分析"><a href="#数据模型分析" class="headerlink" title="数据模型分析"></a>数据模型分析</h3><pre><code>1、用户表user：记录了购买商品的用户信息。2、订单表orders：记录了用户所创建的订单（购买商品的订单）。3、订单明细表orderdetail：记录了订单的详细信息以及购买商品的信息。4、商品表items：记录了商品信息。</code></pre><p>表与表之间的业务关系<strong>（在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。先分析数据级别之间有关系的表之间的业务关系）</strong>：</p><p>（1）user和orders：</p><pre><code>user—&gt;orders：一个用户可以创建多个订单，一对多。orders—&gt;user：一个订单只由一个用户创建，一对一。</code></pre><p>（2）orders和orderdetail：</p><pre><code>orders—&gt;orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系。orderdetail—&gt; orders：一个订单明细只能包括在一个订单中，一对一。</code></pre><p>（3）orderdetail和items：</p><pre><code>orderdetail—&gt;itesms：一个订单明细只对应一个商品信息，一对一。items—&gt; orderdetail:一个商品可以存在于多个订单明细中，一对多。</code></pre><p>再分析数据库级别没有关系的表之间是否有业务关系：</p><p>（4）orders和items：</p><pre><code>orders和items之间可以通过orderdetail表建立关系。</code></pre><hr><h3 id="订单商品数据模型建表sql"><a href="#订单商品数据模型建表sql" class="headerlink" title="订单商品数据模型建表sql"></a>订单商品数据模型建表sql</h3><p>（1）商品信息表</p><pre><code>CREATE TABLE `items` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(32) NOT NULL COMMENT &apos;商品名称&apos;,  `price` float(10,1) NOT NULL COMMENT &apos;商品定价&apos;,  `detail` text COMMENT &apos;商品描述&apos;,  `pic` varchar(64) DEFAULT NULL COMMENT &apos;商品图片&apos;,  `createtime` datetime NOT NULL COMMENT &apos;生产日期&apos;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</code></pre><p>（2）用户信息表</p><pre><code>CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;,  `birthday` date DEFAULT NULL COMMENT &apos;生日&apos;,  `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;,  `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;</code></pre><p>（3）订单表</p><pre><code>CREATE TABLE `orders` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `user_id` int(11) NOT NULL COMMENT &apos;下单用户id&apos;,  `number` varchar(32) NOT NULL COMMENT &apos;订单号&apos;,  `createtime` datetime NOT NULL COMMENT &apos;创建订单时间&apos;,  `note` varchar(100) DEFAULT NULL COMMENT &apos;备注&apos;,  PRIMARY KEY (`id`),  KEY `FK_orders_1` (`user_id`),  CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</code></pre><p>（4）订单详情表</p><pre><code>CREATE TABLE `orderdetail` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `orders_id` int(11) NOT NULL COMMENT &apos;订单id&apos;,  `items_id` int(11) NOT NULL COMMENT &apos;商品id&apos;,  `items_num` int(11) DEFAULT NULL COMMENT &apos;商品购买数量&apos;,  PRIMARY KEY (`id`),  KEY `FK_orderdetail_1` (`orders_id`),  KEY `FK_orderdetail_2` (`items_id`),  CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,  CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</code></pre><hr><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>（1）商品信息表数据</p><pre><code>insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,&apos;台式机&apos;,3000.0,&apos;该电脑质量非常好！！！！&apos;,NULL,&apos;2015-02-03 13:22:53&apos;),(2,&apos;笔记本&apos;,6000.0,&apos;笔记本性能好，质量好！！！！！&apos;,NULL,&apos;2015-02-09 13:22:57&apos;),(3,&apos;背包&apos;,200.0,&apos;名牌背包，容量大质量好！！！！&apos;,NULL,&apos;2015-02-06 13:23:02&apos;);</code></pre><p>（2）用户信息表数据</p><pre><code>insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&apos;王五&apos;,NULL,&apos;2&apos;,NULL),(10,&apos;张三&apos;,&apos;2014-07-10&apos;,&apos;1&apos;,&apos;北京市&apos;),(16,&apos;张小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(22,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(24,&apos;张三丰&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(25,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(26,&apos;王五&apos;,NULL,NULL,NULL);</code></pre><p>（3）订单表数据</p><pre><code>insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,&apos;1000010&apos;,&apos;2015-02-04 13:22:35&apos;,NULL),(4,1,&apos;1000011&apos;,&apos;2015-02-03 13:22:41&apos;,NULL),(5,10,&apos;1000012&apos;,&apos;2015-02-12 16:13:23&apos;,NULL);</code></pre><p>（4）订单详情表数据</p><pre><code>insert  into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3);</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50770013" target="_blank" rel="noopener">mybatis学习笔记(9)-订单商品数据模型分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;九月江南花事休, 芙蓉宛转在中洲。&lt;/center&gt;&lt;br&gt;&lt;center&gt;美人笑隔盈盈水, 落日还生渺渺愁。&lt;/center&gt;&lt;br&gt;&lt;center&gt;露洗玉盘金殿冷, 风吹罗带锦城秋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;相看未用伤迟暮, 别有池塘一种幽。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(8)-动态sql</title>
    <link href="http://www.echodemo.cc/2019/06/23/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)-%E5%8A%A8%E6%80%81sql/"/>
    <id>http://www.echodemo.cc/2019/06/23/mybatis学习笔记(8)-动态sql/</id>
    <published>2019-06-23T01:10:09.000Z</published>
    <updated>2019-06-23T01:35:00.634Z</updated>
    
    <content type="html"><![CDATA[<center>碧圆自洁。向浅洲远渚，亭亭清绝。犹有遗簪，不展秋心，能卷几多炎热。鸳鸯密语同倾盖，且莫与、浣纱人说。恐怨歌、忽断花风，碎却翠云千叠。 </center><br><center>回首当年汉舞，怕飞去、谩皱留仙裙折。恋恋青衫，犹染枯香，还叹鬓丝飘雪。盘心清露如铅水，又一夜、西风吹折。喜静看、匹练秋光，倒泻半湖明月。</center><br><center>—-宋·张炎《疏影·咏荷叶》</center><hr><p>mybatis核心,对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。</p><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>（1）UserMapper.xml</p><pre><code>&lt;!-- 用户信息综合查询    #{userCustom.sex}:取出pojo包装对象中性别值    ${userCustom.username}：取出pojo包装对象中用户名称 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot;        resultType=&quot;com.echodemo.mybatislearning.bean.UserCustom&quot;&gt;    SELECT * FROM user    &lt;where&gt;        &lt;if test=&quot;userCustom!=null&quot;&gt;            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt;               AND user.sex=#{userCustom.sex}            &lt;/if&gt;            &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt;               AND user.username LIKE &apos;%${userCustom.username}%&apos;            &lt;/if&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;!-- 用户信息综合查询总数    parameterType：指定输入类型和findUserList一样    resultType：输出结果类型--&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) FROM user    &lt;where&gt;        &lt;if test=&quot;userCustom!=null&quot;&gt;            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt;                AND user.sex=#{userCustom.sex}            &lt;/if&gt;            &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt;                AND user.username LIKE &apos;%${userCustom.username}%&apos;            &lt;/if&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><hr><p>（2）测试结果</p><blockquote><p>a、注释掉testFindUserList()方法中的userCustom.setUsername(“张三”);</p></blockquote><pre><code>//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中userCustom.setSex(&quot;1&quot;);//userCustom.setUsername(&quot;张三&quot;);userQueryVo.setUserCustom(userCustom);</code></pre><p>输出</p><pre><code>DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapper matches criteria [is assignable to Object]DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapperTest matches criteria [is assignable to Object]DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 352359770.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1500955a]DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user WHERE user.sex=? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;==      Total: 6[User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]</code></pre><p>可以看到sql语句为reparing: SELECT * FROM user WHERE user.sex=?，没有username的部分。</p><hr><blockquote><p>b、userQueryVo设为null,则userCustom为null</p></blockquote><pre><code>//List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);List&lt;UserCustom&gt; list = userMapper.findUserList(null);</code></pre><p>输出</p><pre><code>DEBUG [main] - ==&gt;  Preparing: SELECT * FROM user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;==      Total: 9[User [id=1, username=王五, sex=2, birthday=null, address=null], User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=26, username=王五, sex=null, birthday=null, address=null], User [id=27, username=王大军, sex=2, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]]</code></pre><p>可以看到sql语句变为了SELECT * FROM user。</p><hr><h3 id="sql片段-重点"><a href="#sql片段-重点" class="headerlink" title="sql片段(重点)"></a>sql片段(重点)</h3><p>将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。</p><p>（1）定义sql片段</p><pre><code>&lt;!-- 定义sql片段id：sql片段的唯一标识经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高在sql片段中不要包括 where --&gt;&lt;sql id=&quot;query_user_where&quot;&gt;    &lt;if test=&quot;userCustom!=null&quot;&gt;        &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;            AND user.sex = #{userCustom.sex}        &lt;/if&gt;        &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;            AND user.username LIKE &apos;%${userCustom.username}%&apos;        &lt;/if&gt;    &lt;/if&gt;&lt;/sql&gt;</code></pre><p>（2）引用sql片段</p><pre><code>&lt;!-- 用户信息综合查询    #{userCustom.sex}:取出pojo包装对象中性别值    ${userCustom.username}：取出pojo包装对象中用户名称 --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.iot.mybatis.po.UserQueryVo&quot;        resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt;    SELECT * FROM user    &lt;!--  where 可以自动去掉条件中的第一个and --&gt;    &lt;where&gt;        &lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;        &lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt;        &lt;!-- 在这里还要引用其它的sql片段  --&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><hr><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>向sql传递数组或List，mybatis使用foreach解析<br>在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，一个使用OR,一个使用IN。sql语句如下：</p><pre><code>SELECT * FROM USER WHERE id=1 OR id=10 OR id=16SELECT * FROM USER WHERE id IN(1,10,16)</code></pre><p>（1）在输入参数类型中添加List<integer> ids传入多个id</integer></p><pre><code>public class UserQueryVo {    //传入多个id    private List&lt;Integer&gt; ids;    getter、setter方法    。。。}</code></pre><p>（2）修改UserMapper.xml</p><pre><code>&lt;if test=&quot;ids!=null&quot;&gt;    &lt;!-- 使用 foreach遍历传入ids    collection：指定输入对象中集合属性    item：每个遍历生成的对象    open：开始遍历时拼接的串    close：结束遍历时拼接的串    separator：遍历的两个对象中需要拼接的串     --&gt;    &lt;!-- 使用实现下边的sql拼接：     AND (id=1 OR id=10 OR id=16)     --&gt;    &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;        &lt;!-- 每个遍历需要拼接的串 --&gt;        id=#{user_id}    &lt;/foreach&gt;    &lt;!-- 实现  “ and id IN(1,10,16)”拼接 --&gt;    &lt;!-- &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;and id IN(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;        每个遍历需要拼接的串        #{user_id}    &lt;/foreach&gt; --&gt;&lt;/if&gt;</code></pre><p>（3）测试代码</p><p>在testFindUserList中加入：</p><pre><code>//传入多个idList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();ids.add(1);ids.add(10);ids.add(16);//将ids通过userQueryVo传入statement中userQueryVo.setIds(ids);</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50766105" target="_blank" rel="noopener">mybatis学习笔记(8)-动态sql</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;碧圆自洁。向浅洲远渚，亭亭清绝。犹有遗簪，不展秋心，能卷几多炎热。鸳鸯密语同倾盖，且莫与、浣纱人说。恐怨歌、忽断花风，碎却翠云千叠。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;回首当年汉舞，怕飞去、谩皱留仙裙折。恋恋青衫，犹染枯香，还叹鬓丝飘雪。盘心清露如铅水，又
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(6)-输入映射</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)-%E8%BE%93%E5%85%A5%E6%98%A0%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(6)-输入映射/</id>
    <published>2019-06-22T03:14:53.000Z</published>
    <updated>2019-06-22T03:27:28.429Z</updated>
    
    <content type="html"><![CDATA[<center>杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。</center><br><center>返照迎潮，行云带雨。依依似与骚人语。当年不肯嫁春风，无端却被秋风误。</center><br><center>—-宋·贺铸《芳心苦·杨柳回塘》</center><hr><p>通过parameterType指定输入参数的类型，类型可以是：</p><blockquote><p>简单类型</p><p>hashmap</p><p>pojo的包装类型（在实际的应用中，很多时候我们需要的查询条件都是一个综合的查询条件。比如进行连表查询时需要传入多个对象的数据）</p></blockquote><hr><h3 id="传递pojo的包装对象"><a href="#传递pojo的包装对象" class="headerlink" title="传递pojo的包装对象"></a>传递pojo的包装对象</h3><p>（1）定义包装类型pojo</p><pre><code>package com.echodemo.mybatislearning.bean;/** * Created by Brian on 2016/2/24. */public class UserQueryVo {    //在这里包装所需要的查询条件    //用户查询条件    private UserCustom userCustom;    public UserCustom getUserCustom() {        return userCustom;    }    public void setUserCustom(UserCustom userCustom) {        this.userCustom = userCustom;    }    //可以包装其它的查询条件，订单、商品    //....}</code></pre><p>其中，UserCustom类继承User：</p><pre><code>public class UserCustom extends User{}</code></pre><hr><p>（2）UserMapper.xml</p><p>在UserMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行复杂关联查询）。</p><pre><code>&lt;!-- 用户信息综合查询        #{userCustom.sex}:取出pojo包装对象中性别值        ${userCustom.username}：取出pojo包装对象中用户名称     --&gt;&lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot;        resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt;    SELECT * FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos;&lt;/select&gt;</code></pre><p>注意:不要将#{userCustom.sex}中的userCustom写成UserCustom,前者指属性名(由于使用IDE提示自动补全，所以只是把类型名首字母小写了)，后者指类型名，这里是UserQueryVo类中的userCustom属性，是属性名。写错会报如下异常：</p><pre><code>org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos;</code></pre><hr><p>（3）UserMapper.java</p><pre><code>//用户信息综合查询public List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception;</code></pre><hr><p>（4）测试代码</p><pre><code>//用户信息的综合查询@Testpublic void testFindUserList() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建包装对象，设置查询条件    UserQueryVo userQueryVo = new UserQueryVo();    UserCustom userCustom = new UserCustom();    //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中    userCustom.setSex(&quot;1&quot;);    userCustom.setUsername(&quot;张三&quot;);    userQueryVo.setUserCustom(userCustom);    //调用userMapper的方法    List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);    System.out.println(list);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。&lt;/center&gt;&lt;br&gt;&lt;center&gt;返照迎潮，行云带雨。依依似与骚人语。当年不肯嫁春风，无端却被秋风误。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·贺铸《芳心苦·杨柳回塘》&lt;/cent
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(7)-输出映射</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)-%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(7)-输出映射/</id>
    <published>2019-06-22T03:14:53.000Z</published>
    <updated>2019-06-22T03:35:19.408Z</updated>
    
    <content type="html"><![CDATA[<center>涉江玩秋水，爱此红蕖鲜。</center><br><center>攀荷弄其珠，荡漾不成圆。</center><br><center>佳人彩云里，欲赠隔远天。</center><br><center>相思无因见，怅望凉风前。</center><br><center>—-唐·李白《折荷有赠》</center><hr><h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，<br>该列才可以映射成功。</p><p>2、如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。</p><p>3、只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。</p><hr><h3 id="输出简单类型"><a href="#输出简单类型" class="headerlink" title="输出简单类型"></a>输出简单类型</h3><p>（1）UserMapper.xml</p><pre><code>&lt;!-- 用户信息综合查询总数        parameterType：指定输入类型和findUserList一样        resultType：输出结果类型    --&gt;&lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos;&lt;/select&gt;</code></pre><p>（2）UserMapper.java</p><pre><code>//用户信息综合查询总数@Testpublic void testFindUserCount() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //创建包装对象，设置查询条件    UserQueryVo userQueryVo = new UserQueryVo();    UserCustom userCustom = new UserCustom();    //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中    userCustom.setSex(&quot;1&quot;);    userCustom.setUsername(&quot;小&quot;);    userQueryVo.setUserCustom(userCustom);    //调用userMapper的方法    int count = userMapper.findUserCount(userQueryVo);    System.out.println(count);}</code></pre><p>注：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。</p><hr><h3 id="输出pojo对象和pojo列表"><a href="#输出pojo对象和pojo列表" class="headerlink" title="输出pojo对象和pojo列表"></a>输出pojo对象和pojo列表</h3><p>不管输出的pojo是单个对象还是一个列表（list中包括pojo），在UserMapper.xml中resultType指定的类型是一样的。</p><p>（1）输出单个pojo对象，方法返回值是单个对象类型</p><pre><code>//根据id查询用户信息public User findUserById(int id) throws Exception;</code></pre><p>（2）输出pojo对象list，方法返回值是List</p><pre><code>//根据用户名列查询用户列表public List&lt;User&gt; findUserByName(String name) throws Exception;</code></pre><p>生成的动态代理对象中是根据mapper方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList（返回集合对象调用 ）。</p><hr><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>mybatis中使用resultMap完成高级输出结果映射。(一对多，多对多)</p><h4 id="resultMap使用方法"><a href="#resultMap使用方法" class="headerlink" title="resultMap使用方法"></a>resultMap使用方法</h4><p>（1）如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。首先定义resultMap，然后使用resultMap作为statement的输出映射类型。</p><pre><code>&lt;!-- 定义resultMap    将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系    type：resultMap最终映射的java对象类型,可以使用别名    id：对resultMap的唯一标识     --&gt;     &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;        &lt;!-- id表示查询结果集中唯一标识         column：查询出来的列名        property：type指定的pojo类型中的属性名        最终resultMap对column和property作一个映射关系 （对应关系）        --&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;        &lt;!--         result：对普通名映射定义        column：查询出来的列名        property：type指定的pojo类型中的属性名        最终resultMap对column和property作一个映射关系 （对应关系）         --&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt;</code></pre><p>（2）使用resultMap作为statement的输出映射类型</p><pre><code>&lt;!-- 使用resultMap进行输出映射    resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace    --&gt;&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    SELECT id id_,username username_ FROM USER WHERE id=#{value}&lt;/select&gt;</code></pre><p>（3）UserMapper.java</p><pre><code>//根据id查询用户信息，使用resultMap输出public User findUserByIdResultMap(int id) throws Exception;</code></pre><p>（4）测试代码</p><pre><code>@Testpublic void testFindUserByIdResultMap() throws Exception {    SqlSession sqlSession = sqlSessionFactory.openSession();    //创建UserMapper对象，mybatis自动生成mapper代理对象    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);    //调用userMapper的方法    User user = userMapper.findUserByIdResultMap(1);    System.out.println(user);}</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。</p><p>2、如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。</p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50765422" target="_blank" rel="noopener">mybatis学习笔记(7)-输出映射</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;涉江玩秋水，爱此红蕖鲜。&lt;/center&gt;&lt;br&gt;&lt;center&gt;攀荷弄其珠，荡漾不成圆。&lt;/center&gt;&lt;br&gt;&lt;center&gt;佳人彩云里，欲赠隔远天。&lt;/center&gt;&lt;br&gt;&lt;center&gt;相思无因见，怅望凉风前。&lt;/center&gt;&lt;br&gt;&lt;center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(5)-配置文件</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(5)-配置文件/</id>
    <published>2019-06-22T02:50:48.000Z</published>
    <updated>2019-06-22T03:13:51.012Z</updated>
    
    <content type="html"><![CDATA[<center>野有蔓草，零露漙兮。有美一人，清扬婉兮。邂逅相遇，适我愿兮。</center><br><center>野有蔓草，零露瀼瀼。有美一人，婉如清扬。邂逅相遇，与子偕臧。</center><br><center>—-先秦·佚名《国风·郑风·野有蔓草》</center><hr><h3 id="SqlMapConfig-xml中配置的内容和顺序"><a href="#SqlMapConfig-xml中配置的内容和顺序" class="headerlink" title="SqlMapConfig.xml中配置的内容和顺序"></a>SqlMapConfig.xml中配置的内容和顺序</h3><pre><code>1、properties（属性）2、settings（全局配置参数）3、typeAliases（类型别名）4、typeHandlers（类型处理器）5、objectFactory（对象工厂）6、plugins（插件）7、environments（环境集合属性对象）     &gt;environment（环境子属性对象）         &gt;transactionManager（事务管理）        &gt;dataSource（数据源）8、mappers（映射器）</code></pre><p>其中typeAliases（类型别名）和mappers（映射器）是重点。</p><hr><h3 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties(属性)"></a>properties(属性)</h3><p>将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。原因：方便对参数进行统一管理，其它xml也可以引用该db.properties。</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis?characterEncoding=utf-8&amp;amp;serverTimezonejdbc.username=rootjdbc.password=</code></pre><hr><p>在sqlMapConfig.xml加载属性文件：</p><pre><code>&lt;properties resource=&quot;db.properties&quot;&gt;        &lt;!--properties中还可以配置一些属性名和属性值  --&gt;        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;&lt;/properties&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;        &lt;transactionManager type=&quot;JDBC&quot; /&gt;        &lt;!-- 数据库连接池,由mybatis管理--&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><hr><p>注意： MyBatis 将按照下面的顺序(优先级)来加载属性：</p><p>1、在properties元素体内定义的属性首先被读取。</p><p>2、然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。</p><p>3、最后读取parameterType传递的属性，它会覆盖已读取的同名属性。</p><p>建议：</p><p>1、不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。</p><p>2、在properties文件中定义属性名要有一定的特殊性，如：XXXXX.XXXXX.XXXX</p><hr><h3 id="settings-全局参数配置"><a href="#settings-全局参数配置" class="headerlink" title="settings(全局参数配置)"></a>settings(全局参数配置)</h3><p>mybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载…<br>全局参数将会影响mybatis的运行行为。具体参考官网：</p><p><a href="http://www.mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">MyBatis-settings</a></p><hr><h3 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h3><p>在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。</p><p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p><p>（1）mybatis默认支持别名</p><p><a href="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">MyBatis-typeAliases</a></p><p>（2）自定义别名</p><pre><code>1、单个别名定义2、批量定义别名（常用）&lt;!-- 别名定义 --&gt;&lt;typeAliases&gt;    &lt;!-- 针对单个别名定义    type：类型的路径    alias：别名     --&gt;    &lt;!-- &lt;typeAlias type=&quot;com.echodemo.mybatislearning.bean.User&quot; alias=&quot;user&quot;/&gt; --&gt;    &lt;!-- 批量别名定义    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名    （首字母大写或小写都可以）    --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.bean&quot;/&gt;&lt;/typeAliases&gt;</code></pre><hr><h3 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如：</p><pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        select * from user where id = #{id}&lt;/select&gt;</code></pre><p>mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。</p><pre><code>http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers</code></pre><hr><h3 id="mappers-映射配置"><a href="#mappers-映射配置" class="headerlink" title="mappers(映射配置)"></a>mappers(映射配置)</h3><p>（1）通过resource加载单个映射文件：</p><pre><code>&lt;mappers&gt;    &lt;!--通过resource方法一次加载一个映射文件 --&gt;    &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;&lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt;&lt;resources&gt;    &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>（2）通过mapper接口加载单个mapper：</p><pre><code>&lt;!-- 通过mapper接口加载单个映射文件        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，        且在一个目录中上边规范的前提是：使用的是mapper代理方法         --&gt;&lt;mapper class=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;/&gt;</code></pre><p>（3）目录示例：</p><pre><code>com.iot.mybatis.mapper------------------package包   |----UserMapper.java   |----UserMapper.xml</code></pre><p>（4）批量加载mapper(推荐使用)</p><pre><code>&lt;mappers&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;&lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt;&lt;resources&gt;    &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50759845" target="_blank" rel="noopener">mybatis学习笔记(5)-配置文件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;野有蔓草，零露漙兮。有美一人，清扬婉兮。邂逅相遇，适我愿兮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;野有蔓草，零露瀼瀼。有美一人，婉如清扬。邂逅相遇，与子偕臧。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-先秦·佚名《国风·郑风·野有蔓草》&lt;/center&gt;


      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(4)-开发dao方法</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)-%E5%BC%80%E5%8F%91dao%E6%96%B9%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(4)-开发dao方法/</id>
    <published>2019-06-22T02:18:37.000Z</published>
    <updated>2019-06-22T03:13:19.940Z</updated>
    
    <content type="html"><![CDATA[<center>疏雨洗天清，枕簟凉生。井桐一叶做秋声。谁念客身轻似叶，千里飘零？</center><br><center>梦断古台城，月淡潮平。便须携酒访新亭。不见当时王谢宅，烟草青青。</center><br><center>—-宋·邓剡《浪淘沙·疏雨洗天清》</center><hr><h3 id="SqlSession使用范围"><a href="#SqlSession使用范围" class="headerlink" title="SqlSession使用范围"></a>SqlSession使用范围</h3><p>（1）SqlSessionFactoryBuilder</p><p>通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建SqlSessionFactory时候，只需要new一次SqlSessionFactoryBuilder即可。</p><p>（2）SqlSessionFactory</p><p>通过SqlSessionFactory创建SqlSession，使用单例模式管理sqlSessionFactory（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory。</p><p>（3）SqlSession</p><p>SqlSession是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法。如：selectOne(返回单个对象)、selectList（返回单个或多个对象）。</p><p>SqlSession是线程不安全的，在SqlSesion实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性（比如org.apache.ibatis.session.Configuration和java.sql.Connection）。SqlSession最佳应用场合在方法体内，定义成局部变量使用。</p><center><br><br><img src="/images/2019/6/SqlSession.png" alt="&quot;SqlSession&quot;"><br><br></center><hr><h3 id="原始dao开发方法"><a href="#原始dao开发方法" class="headerlink" title="原始dao开发方法"></a>原始dao开发方法</h3><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><pre><code>package com.echodemo.mybatislearning.dao;import com.echodemo.mybatislearning.bean.User;import java.util.List;public interface UserDao {    //根据id查询用户信息    public User findUserById(int id) throws Exception;    //根据用户名列查询用户列表    public List&lt;User&gt; findUserByName(String name) throws Exception;    //添加用户信息    public void insertUser(User user) throws Exception;    //删除用户信息    public void deleteUser(int id) throws Exception;}</code></pre><h4 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h4><pre><code>package com.echodemo.mybatislearning.dao.Impl;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.dao.UserDao;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao {    // 需要向dao实现类中注入SqlSessionFactory，这里通过构造方法注入    private SqlSessionFactory sqlSessionFactory;    public UserDaoImpl(SqlSessionFactory sqlSessionFactory){        this.sqlSessionFactory = sqlSessionFactory;    }    @Override    public User findUserById(int id) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id);        //释放资源        sqlSession.close();        return user;    }    @Override    public List&lt;User&gt; findUserByName(String name) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, name);        // 释放资源        sqlSession.close();        return list;    }    @Override    public void insertUser(User user) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行插入操作        sqlSession.insert(&quot;test.insertUser&quot;, user);        // 提交事务        sqlSession.commit();        // 释放资源        sqlSession.close();    }    @Override    public void deleteUser(int id) throws Exception {        SqlSession sqlSession = sqlSessionFactory.openSession();        //执行插入操作        sqlSession.delete(&quot;test.deleteUser&quot;, id);        // 提交事务        sqlSession.commit();        // 释放资源        sqlSession.close();    }}</code></pre><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.dao.Impl.UserDaoImpl;import com.echodemo.mybatislearning.dao.UserDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;public class UserDaoImplTest {    private SqlSessionFactory sqlSessionFactory;    // 此方法是在执行testFindUserById之前执行    @Before    public void setUp() throws Exception {        // 创建sqlSessionFactory，mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);    }    @Test    public void testFindUserById() throws Exception {        // 创建UserDao的对象        UserDao userDao = new UserDaoImpl(sqlSessionFactory);        // 调用UserDao的方法        User user = userDao.findUserById(3);        System.out.println(user.toString());    }}</code></pre><h4 id="总结原始dao开发问题"><a href="#总结原始dao开发问题" class="headerlink" title="总结原始dao开发问题"></a>总结原始dao开发问题</h4><p>1、dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。</p><p>2、调用sqlsession方法时将statement的id硬编码了</p><p>3、调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。</p><h3 id="mapper代理方法"><a href="#mapper代理方法" class="headerlink" title="mapper代理方法"></a>mapper代理方法</h3><pre><code>1、程序员只需要mapper接口（相当于dao接口）2、程序员还需要编写mapper.xml映射文件3、程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。</code></pre><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><p>（1）在UserMapper.xml中namespace等于mapper接口地址</p><pre><code>&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址 --&gt;&lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt;</code></pre><p>1、UserMapper.java接口中的方法名和UserMapper.xml中statement的id一致</p><p>2、UserMapper.java接口中的方法输入参数类型和UserMapper.xml中statement的parameterType指定的类型一致。</p><p>3、UserMapper.java接口中的方法返回值类型和UserMapper.xml中statement的resultType指定的类型一致。</p><pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.mybatis.po.User&quot;&gt;    SELECT * FROM  user  WHERE id=#{value}&lt;/select&gt;//根据id查询用户信息public User findUserById(int id) throws Exception;//总结：以上开发规范主要是对类似下边代码进行统一生成：User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);sqlSession.insert(&quot;test.insertUser&quot;, user);</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;    &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条    resultType：指定就是单条记录所映射的java对象类型    ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。    使用${}拼接sql，引起 sql注入    ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value     --&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt;        SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos;    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;        &lt;!--         将插入数据的主键返回，返回到user对象中         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序         resultType：指定SELECT LAST_INSERT_ID()的结果类型          --&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;integer&quot;&gt;            SELECT LAST_INSERT_ID()        &lt;/selectKey&gt;        INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address})        &lt;!--            使用mysql的uuid（）生成主键            执行过程：            首先通过uuid()得到主键，将主键设置到user对象的id属性中            其次在insert执行时，从user对象中取出id属性值             --&gt;        &lt;!--  &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;            SELECT uuid()        &lt;/selectKey&gt;        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt;    &lt;/insert&gt;    &lt;!-- 删除 用户        根据id删除用户，需要输入 id值         --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;integer&quot;&gt;        delete from user where id=#{id}    &lt;/delete&gt;    &lt;!-- 根据id更新用户    分析：    需要传入用户的id    需要传入用户的更新信息    parameterType指定user对象，包括 id和更新信息，注意：id必须存在    #{id}：从输入 user对象中获取id属性值     --&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;user&quot;&gt;        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}        where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>（2）在SqlMapConfig.xml中加载映射文件</p><pre><code>&lt;mappers&gt;    &lt;!--通过resource方法一次加载一个映射文件 --&gt;    &lt;!--&lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;--&gt;    &lt;!-- 批量加载mapper    指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载    遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，    且在一个目录中上边规范的前提是：使用的是mapper代理方法     --&gt;    &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre><p>有两种方式，每种方式都要在pom文件中的build标签里面加入相应的路径指引：</p><pre><code>&lt;resources&gt;    &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt;    &lt;!--&lt;resource&gt;--&gt;        &lt;!--&lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;--&gt;        &lt;!--&lt;includes&gt;--&gt;            &lt;!--&lt;include&gt;**/*.xml&lt;/include&gt;--&gt;        &lt;!--&lt;/includes&gt;--&gt;    &lt;!--&lt;/resource&gt;--&gt;    &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt;    &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;    &lt;/resource&gt;&lt;/resources&gt;</code></pre><p>（3）UserMapper.java</p><pre><code>package com.echodemo.mybatislearning.mapper;import com.echodemo.mybatislearning.bean.User;import java.util.List;public interface UserMapper {    //根据id查询用户信息    public User findUserById(int id) throws Exception;    //根据用户名列查询用户列表    public List&lt;User&gt; findUserByName(String name) throws Exception;    //添加用户信息    public void insertUser(User user) throws Exception;    //删除用户信息    public void deleteUser(int id) throws Exception;    //更新用户    public void updateUser(User user)throws Exception;}</code></pre><p>（4）UserMapperTest.java</p><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.mapper.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;public class UserMapperTest {    private SqlSessionFactory sqlSessionFactory;    //注解Before是在执行本类所有测试方法之前先调用这个方法    @Before    public void setup() throws Exception{        //创建SqlSessionFactory        String resource=&quot;SqlMapConfig.xml&quot;;        //将配置文件加载成流        InputStream inputStream = Resources.getResourceAsStream(resource);        //创建会话工厂，传入mybatis配置文件的信息        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testFindUserById() throws Exception{        SqlSession sqlSession = sqlSessionFactory.openSession();        //创建UserMapper代理对象        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //调用userMapper的方法        User user = userMapper.findUserById(3);        System.out.println(user.getUsername());    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）代理对象内部调用selectOne或selectList</p><pre><code>1、如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。2、如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。</code></pre><p>（2）mapper接口方法参数只能有一个是否影响系统开发</p><p>mapper接口方法参数只能有一个，系统是否不利于扩展维护?系统框架中，dao层的代码是被业务层公用的。即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。</p><p><strong>注意：持久层方法的参数可以包装类型、map…等，service方法中建议不要使用包装类型（不利于业务层的可扩展）。</strong></p><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50756808" target="_blank" rel="noopener">mybatis学习笔记(4)-开发dao方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;疏雨洗天清，枕簟凉生。井桐一叶做秋声。谁念客身轻似叶，千里飘零？&lt;/center&gt;&lt;br&gt;&lt;center&gt;梦断古台城，月淡潮平。便须携酒访新亭。不见当时王谢宅，烟草青青。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·邓剡《浪淘沙·疏雨洗天清》&lt;/center&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(3)-入门程序</title>
    <link href="http://www.echodemo.cc/2019/06/22/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E4%B8%80/"/>
    <id>http://www.echodemo.cc/2019/06/22/mybatis学习笔记(3)-入门程序一/</id>
    <published>2019-06-22T01:52:40.000Z</published>
    <updated>2019-06-22T02:17:35.683Z</updated>
    
    <content type="html"><![CDATA[<center>燎沉香，消溽暑。鸟雀呼晴，侵晓窥檐语。叶上初阳干宿雨、水面清圆，一一风荷举。</center><br><center>故乡遥，何日去。家住吴门，久作长安旅。五月渔郎相忆否。小楫轻舟，梦入芙蓉浦。</center><br><center>—-宋·周邦彦《苏幕遮·燎沉香》</center><hr><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>（1）log4j.properties</p><pre><code># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><p>（2）SqlMapConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 和spring整合后 environments配置将废除--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据库连接池,由mybatis管理--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p>（1）UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=&quot;test&quot;&gt;    &lt;!-- 在映射文件中配置很多sql语句 --&gt;    &lt;!--需求:通过id查询用户表的记录 --&gt;    &lt;!-- 通过select执行数据库查询     id:标识映射文件中的sql，称为statement的id     将sql语句封装到mappedStatement对象中，所以将id称为statement的id     parameterType:指定输入参数的类型     #{}标示一个占位符,     #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。     resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象     --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        SELECT * FROM  user  WHERE id=#{value}    &lt;/select&gt;    &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条    resultType：指定就是单条记录所映射的java对象类型    ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。    使用${}拼接sql，引起 sql注入    ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value     --&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos;    &lt;/select&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        &lt;!--         将插入数据的主键返回，返回到user对象中         SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键         keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性         order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序         resultType：指定SELECT LAST_INSERT_ID()的结果类型          --&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;            SELECT LAST_INSERT_ID()        &lt;/selectKey&gt;        INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address})        &lt;!--            使用mysql的uuid（）生成主键            执行过程：            首先通过uuid()得到主键，将主键设置到user对象的id属性中            其次在insert执行时，从user对象中取出id属性值             --&gt;        &lt;!--  &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;            SELECT uuid()        &lt;/selectKey&gt;        insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt;    &lt;/insert&gt;    &lt;!-- 删除 用户        根据id删除用户，需要输入 id值         --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;        delete from user where id=#{id}    &lt;/delete&gt;    &lt;!-- 根据id更新用户    分析：    需要传入用户的id    需要传入用户的更新信息    parameterType指定user对象，包括 id和更新信息，注意：id必须存在    #{id}：从输入 user对象中获取id属性值     --&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt;        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}        where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>（2）在sqlMapConfig.xml中加载User.xml</p><pre><code>&lt;!-- 加载映射文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><h3 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h3><p>（1）po类User.java</p><p>package com.echodemo.mybatislearning.bean;</p><p>import lombok.ToString;</p><pre><code>@ToStringpublic class User {    //属性名要和数据库表的字段对应    private int id;    private String username;// 用户姓名    private String sex;// 性别    private String birthday;// 生日    private String address;// 地址    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getSex() {        return sex;    }    public void setSex(String sex) {        this.sex = sex;    }    public String getBirthday() {        return birthday;    }    public void setBirthday(String birthday) {        this.birthday = birthday;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }}</code></pre><p>（2）测试代码</p><pre><code>package com.echodemo.mybatislearning;import com.echodemo.mybatislearning.bean.User;import com.echodemo.mybatislearning.util.DateUtil;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class UserTest {    @Test    public void findUserByIdTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream =  Resources.getResourceAsStream(resource);        //创建会话工厂，传入mybatis配置文件的信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 通过SqlSession操作数据库        // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id        // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数        // sqlSession.selectOne结果是与映射文件中所匹配的resultType类型的对象        // selectOne查询出一条记录        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);        System.out.println(user);        // 释放资源        sqlSession.close();    }    // 根据用户名称模糊查询用户列表    @Test    public void findUserByNameTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // list中的user和映射文件中resultType所指定的类型一致        List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, &quot;小明&quot;);        System.out.println(list);        sqlSession.close();    }    // 添加用户信息    @Test    public void insertUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 插入用户对象        User user = new User();        user.setId(5);        user.setUsername(&quot;王小军&quot;);        user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;));        user.setSex(&quot;男&quot;);        user.setAddress(&quot;河南郑州&quot;);        sqlSession.insert(&quot;test.insertUser&quot;, user);        // 提交事务        sqlSession.commit();        // 获取用户信息主键        System.out.println(user.getId());        // 关闭会话        sqlSession.close();    }    // 根据id删除 用户信息    @Test    public void deleteUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 传入id删除 用户        sqlSession.delete(&quot;test.deleteUser&quot;, 1);        // 提交事务        sqlSession.commit();        // 关闭会话        sqlSession.close();    }    // 更新用户信息    @Test    public void updateUserTest() throws IOException {        // mybatis配置文件        String resource = &quot;SqlMapConfig.xml&quot;;        // 得到配置文件流        InputStream inputStream = Resources.getResourceAsStream(resource);        // 创建会话工厂，传入mybatis的配置文件信息        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder()                .build(inputStream);        // 通过工厂得到SqlSession        SqlSession sqlSession = sqlSessionFactory.openSession();        // 更新用户信息        User user = new User();        //必须设置id        user.setId(5);        user.setUsername(&quot;王大军&quot;);        user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;));        user.setSex(&quot;2&quot;);        user.setAddress(&quot;河南郑州&quot;);        sqlSession.update(&quot;test.updateUser&quot;, user);        // 提交事务        sqlSession.commit();        // 关闭会话        sqlSession.close();    }}</code></pre><p>改文章转载自：</p><p><a href="https://blog.csdn.net/h3243212/article/details/50756631" target="_blank" rel="noopener">mybatis学习笔记(3)-入门程序一</a></p><p><a href="https://blog.csdn.net/h3243212/article/details/50756635" target="_blank" rel="noopener">mybatis学习笔记(3)-入门程序二</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;燎沉香，消溽暑。鸟雀呼晴，侵晓窥檐语。叶上初阳干宿雨、水面清圆，一一风荷举。&lt;/center&gt;&lt;br&gt;&lt;center&gt;故乡遥，何日去。家住吴门，久作长安旅。五月渔郎相忆否。小楫轻舟，梦入芙蓉浦。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·周邦彦《苏幕遮·燎沉
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(2)-mybatis概述</title>
    <link href="http://www.echodemo.cc/2019/06/19/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-mybatis%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.echodemo.cc/2019/06/19/mybatis学习笔记(2)-mybatis概述/</id>
    <published>2019-06-19T13:47:20.000Z</published>
    <updated>2019-06-21T16:51:09.601Z</updated>
    
    <content type="html"><![CDATA[<center>一尺深红胜曲尘，天生旧物不如新。</center><br><center>合欢桃核终堪恨，里许元来别有人。</center><br><center>井底点灯深烛伊，共郎长行莫围棋。</center><br><center>玲珑骰子安红豆，入骨相思知不知。</center><br><center>—-唐·温庭筠《新添声杨柳枝词》</center><hr><h3 id="mybatis-介绍"><a href="#mybatis-介绍" class="headerlink" title="mybatis 介绍"></a>mybatis 介绍</h3><p>（1）mybatis是一个持久层的框架，是apache下的顶级项目。</p><p>（2）mybatis托管到goolecode下，再后来托管到github(<a href="https://github.com/mybatis/mybatis-3/releases)。" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases)。</a></p><p>（3）mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p><p>（4）mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）。</p><hr><h3 id="mybatis框架执行过程"><a href="#mybatis框架执行过程" class="headerlink" title="mybatis框架执行过程"></a>mybatis框架执行过程</h3><p>（1）配置mybatis的配置文件，SqlMapConfig.xml（名称不固定）。</p><p>（2）通过配置文件，加载mybatis运行环境（environment标签），创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式) 。</p><p>（3）通过SqlSessionFactory创建SqlSession。<strong>SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。 </strong></p><p>（4）调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。 </p><p>（5）释放资源，关闭SqlSession。</p><center><br><br><img src="/images/2019/6/SqlSession.png" alt="&quot;SqlSession&quot;"><br><br></center><hr><h3 id="mybatis开发dao的方法"><a href="#mybatis开发dao的方法" class="headerlink" title="mybatis开发dao的方法"></a>mybatis开发dao的方法</h3><p>（1）原始dao 的方法</p><pre><code>a、需要程序员编写dao接口和实现类b、需要在dao实现类中注入一个SqlSessionFactory工厂</code></pre><p>（2）mapper代理开发方法（建议使用）</p><p>只需要程序员编写mapper接口（就是dao接口）。 程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范：</p><pre><code>a、mapper.xml中namespace就是mapper.java的类全路径。b、mapper.xml中statement的id和mapper.java中方法名一致。c、mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致。d、mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。</code></pre><p>SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。</p><hr><h3 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h3><p>（1）输入映射：</p><pre><code>a、parameterType：指定输入参数类型可以简单类型、pojo、hashmap。b、对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。</code></pre><p>（2）输出映射：</p><pre><code>a、resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。b、reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。 </code></pre><p>（3）高级映射： </p><pre><code>a、将关联查询的列映射到一个pojo属性中。（一对一）b、将关联查询的列映射到一个List中。（一对多）</code></pre><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><blockquote><p>动态sql：（重点） </p><blockquote><p>if判断（掌握）</p></blockquote><blockquote><p>where</p></blockquote><blockquote><p>foreach</p></blockquote><blockquote><p>sql片段（掌握）</p></blockquote></blockquote><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50756622" target="_blank" rel="noopener">mybatis学习笔记(2)-mybatis概述</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;一尺深红胜曲尘，天生旧物不如新。&lt;/center&gt;&lt;br&gt;&lt;center&gt;合欢桃核终堪恨，里许元来别有人。&lt;/center&gt;&lt;br&gt;&lt;center&gt;井底点灯深烛伊，共郎长行莫围棋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;玲珑骰子安红豆，入骨相思知不知。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习笔记(1)-对原生jdbc程序中的问题总结</title>
    <link href="http://www.echodemo.cc/2019/06/19/mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)-%E5%AF%B9%E5%8E%9F%E7%94%9Fjdbc%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.echodemo.cc/2019/06/19/mybatis学习笔记(1)-对原生jdbc程序中的问题总结/</id>
    <published>2019-06-19T13:36:54.000Z</published>
    <updated>2019-06-21T16:51:24.904Z</updated>
    
    <content type="html"><![CDATA[<center>飒飒东风细雨来，芙蓉塘外有轻雷。</center><br><center>金蟾啮锁烧香入，玉虎牵丝汲井回。</center><br><center>贾氏窥帘韩掾少，宓妃留枕魏王才。</center><br><center>春心莫共花争发，一寸相思一寸灰。</center><br><center>—-唐·李商隐《无题》</center><hr><h3 id="jdbc编程步骤"><a href="#jdbc编程步骤" class="headerlink" title="jdbc编程步骤"></a>jdbc编程步骤</h3><pre><code>（1）加载数据库驱动（2）创建并获取数据库连接（3）设置sql语句（4）获取预处理的jdbc statement对象（5）设置sql语句中的参数(使用preparedStatement)（6）通过statement执行sql并获取结果（7）对sql执行结果进行解析处理（8）释放资源(resultSet、preparedstatement、connection)</code></pre><hr><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>（1）数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p><pre><code>设想：使用数据库连接池管理数据库连接。</code></pre><p>（2）将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。</p><pre><code>设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。</code></pre><p>（3）向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。</p><pre><code>设想：将sql语句及占位符号和参数全部配置在xml中。</code></pre><p>（4）从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。</p><pre><code>设想：将查询的结果集，自动映射成java对象。</code></pre><hr><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>package com.iot.mybatis.jdbc;//import java.sql.*;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * Created by Administrator on 2016/2/21. */public class JdbcTest {    public static void main(String[] args) {        //数据库连接        Connection connection = null;        //预编译的Statement，使用预编译的Statement提高数据库性能        PreparedStatement preparedStatement = null;        //结果集        ResultSet resultSet = null;        try {            //加载数据库驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //通过驱动管理类获取数据库链接            connection =  DriverManager.getConnection(&quot;jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123&quot;);            //定义sql语句 ?表示占位符            String sql = &quot;select * from user where username = ?&quot;;            //获取预处理statement            preparedStatement = connection.prepareStatement(sql);            //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值            preparedStatement.setString(1, &quot;王五&quot;);            //向数据库发出sql执行查询，查询出结果集            resultSet =  preparedStatement.executeQuery();            //遍历查询结果集            while(resultSet.next()){                System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));            }        } catch (Exception e) {            e.printStackTrace();        }finally{            //释放资源            if(resultSet!=null){                try {                    resultSet.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }            if(preparedStatement!=null){                try {                    preparedStatement.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }            if(connection!=null){                try {                    connection.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }        }    }}</code></pre><p>改文章转载自：<a href="https://blog.csdn.net/h3243212/article/details/50756617" target="_blank" rel="noopener">mybatis学习笔记(1)-对原生jdbc程序中的问题总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;飒飒东风细雨来，芙蓉塘外有轻雷。&lt;/center&gt;&lt;br&gt;&lt;center&gt;金蟾啮锁烧香入，玉虎牵丝汲井回。&lt;/center&gt;&lt;br&gt;&lt;center&gt;贾氏窥帘韩掾少，宓妃留枕魏王才。&lt;/center&gt;&lt;br&gt;&lt;center&gt;春心莫共花争发，一寸相思一寸灰。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>为什么阿里巴巴禁止把SimpleDateFormat定义为static类型</title>
    <link href="http://www.echodemo.cc/2019/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E4%B8%BAstatic%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/24/为什么阿里巴巴禁止把SimpleDateFormat定义为static类型/</id>
    <published>2019-04-24T14:45:53.000Z</published>
    <updated>2019-04-24T15:34:53.200Z</updated>
    
    <content type="html"><![CDATA[<center>明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。 </center><br><center>七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。</center><br><center>—-辛弃疾《西江月·夜行黄沙道中》</center><hr><p>在日常开发中，我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。在阿里巴巴Java开发手册中，有如下明确规定：</p><blockquote><p>5.[强制]SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。</p></blockquote><hr><h3 id="SimpleDateFormat用法"><a href="#SimpleDateFormat用法" class="headerlink" title="SimpleDateFormat用法"></a>SimpleDateFormat用法</h3><p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。在Java中，可以使用SimpleDateFormat的format方法，将一个Date类型转化成String类型，并且可以指定输出格式。</p><pre><code>// Date转StringDate data = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String dataStr = sdf.format(data);System.out.println(dataStr);</code></pre><p>以上代码，转换的结果是：2018-11-25 13:00:00，日期和时间格式由”日期和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就行了。</p><p>在Java中，可以使用SimpleDateFormat的parse方法，将一个String类型转化成Date类型。</p><pre><code>// String转DataSystem.out.println(sdf.parse(dataStr));</code></pre><hr><h4 id="日期和时间模式表达方法"><a href="#日期和时间模式表达方法" class="headerlink" title="日期和时间模式表达方法"></a>日期和时间模式表达方法</h4><p>在使用SimpleDateFormat的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表如下：</p><p><img src="/images/2019/4/simpledateformat.png" alt="&quot;simpledateformat&quot;"></p><p>模式字母通常是重复的，其数量确定其精确表示。</p><hr><h4 id="输出不同时区的时间"><a href="#输出不同时区的时间" class="headerlink" title="输出不同时区的时间"></a>输出不同时区的时间</h4><p>时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p><p>世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p><p>现今全球共分为24个时区。由于实用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。</p><p>由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一样，所以，在Java中想要获取时间的时候，要重点关注一下时区问题。</p><p>默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获取中国的当前时间的原因。那么，如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。</p><pre><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;));System.out.println(sdf.format(Calendar.getInstance().getTime()));</code></pre><p>以上代码，转换的结果是： 2018-11-24 21:00:00 。既中国的时间是11月25日的13点，而美国洛杉矶时间比中国北京时间慢了16个小时（这还和冬夏令时有关系，就不详细展开了）。</p><p>如果你感兴趣，你还可以尝试打印一下美国纽约时间（America/New_York）。纽约时间是2018-11-25 00:00:00。纽约时间比中国北京时间慢了13个小时。当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍SimpleDateFormat，其他方法暂不介绍了。</p><hr><h3 id="SimpleDateFormat线程安全性"><a href="#SimpleDateFormat线程安全性" class="headerlink" title="SimpleDateFormat线程安全性"></a>SimpleDateFormat线程安全性</h3><p>由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：</p><pre><code>public class Main {   private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);   public static void main(String[] args) {       simpleDateFormat.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;));       System.out.println(simpleDateFormat.format(Calendar.getInstance().getTime()));   }}</code></pre><p>这种定义方式，存在很大的安全隐患。我们来看一段代码，以下代码使用线程池来执行时间输出。</p><pre><code>/** * @author Hollis */ public class Main {   /**    * 定义一个全局的SimpleDateFormat    */   private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);   /**    * 使用ThreadFactoryBuilder定义一个线程池    */   private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()       .setNameFormat(&quot;demo-pool-%d&quot;).build();   private static ExecutorService pool = new ThreadPoolExecutor(5, 200,       0L, TimeUnit.MILLISECONDS,       new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());   /**    * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行    */   private static CountDownLatch countDownLatch = new CountDownLatch(100);   public static void main(String[] args) {       //定义一个线程安全的HashSet       Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;());       for (int i = 0; i &lt; 100; i++) {           //获取当前时间           Calendar calendar = Calendar.getInstance();           int finalI = i;           pool.execute(() -&gt; {                   //时间增加                   calendar.add(Calendar.DATE, finalI);                   //通过simpleDateFormat把时间转换成字符串                   String dateString = simpleDateFormat.format(calendar.getTime());                   //把字符串放入Set中                   dates.add(dateString);                   //countDown                   countDownLatch.countDown();           });       }       //阻塞，直到countDown数量为0       countDownLatch.await();       //输出去重后的时间个数       System.out.println(dates.size());   }}</code></pre><p>以上代码，其实比较容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。</p><blockquote><p>上面的例子我特意写的稍微复杂了一些，不过我几乎都加了注释。这里面涉及到了线程池的创建、CountDownLatch、lambda表达式、线程安全的HashSet等知识。感兴趣的朋友可以逐一了解一下。</p></blockquote><p>正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。</p><p>原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。那么，接下来我们就来看下到底是为什么，以及该如何解决。</p><hr><h4 id="线程不安全原因"><a href="#线程不安全原因" class="headerlink" title="线程不安全原因"></a>线程不安全原因</h4><p>通过以上代码，我们发现了在并发场景中使用SimpleDateFormat会有线程安全问题。其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中：</p><blockquote><p>Date formats are not synchronized.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><p>那么接下来分析下为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？我们跟一下SimpleDateFormat类中format方法的实现其实就能发现端倪。</p><pre><code>// Called from Format after creating a FieldDelegateprivate StringBuffer format(Date date, StringBuffer toAppendTo,                            FieldDelegate delegate) {    // Convert input date to time field list    calendar.setTime(date);    boolean useDateFormatSymbols = useDateFormatSymbols();    for (int i = 0; i &lt; compiledPattern.length; ) {        int tag = compiledPattern[i] &gt;&gt;&gt; 8;        int count = compiledPattern[i++] &amp; 0xff;        if (count == 255) {            count = compiledPattern[i++] &lt;&lt; 16;            count |= compiledPattern[i++];        }        switch (tag) {        case TAG_QUOTE_ASCII_CHAR:            toAppendTo.append((char)count);            break;        case TAG_QUOTE_CHARS:            toAppendTo.append(compiledPattern, i, count);            i += count;            break;        default:            subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);            break;        }    }    return toAppendTo;}</code></pre><p>SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p><p>假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的。</p><p>除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。所以，不要把SimpleDateFormat作为一个共享变量使用。</p><hr><h3 id="破解之法"><a href="#破解之法" class="headerlink" title="破解之法"></a>破解之法</h3><h4 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h4><pre><code>for (int i = 0; i &lt; 100; i++) {   //获取当前时间   Calendar calendar = Calendar.getInstance();   int finalI = i;   pool.execute(() -&gt; {       // SimpleDateFormat声明成局部变量   SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);       //时间增加       calendar.add(Calendar.DATE, finalI);       //通过simpleDateFormat把时间转换成字符串       String dateString = simpleDateFormat.format(calendar.getTime());       //把字符串放入Set中       dates.add(dateString);       //countDown       countDownLatch.countDown();   });} </code></pre><p>SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。</p><hr><h4 id="加同步锁"><a href="#加同步锁" class="headerlink" title="加同步锁"></a>加同步锁</h4><pre><code>for (int i = 0; i &lt; 100; i++) {   //获取当前时间   Calendar calendar = Calendar.getInstance();   int finalI = i;   pool.execute(() -&gt; {       //加锁       synchronized (simpleDateFormat) {           //时间增加           calendar.add(Calendar.DATE, finalI);           //通过simpleDateFormat把时间转换成字符串           String dateString = simpleDateFormat.format(calendar.getTime());           //把字符串放入Set中           dates.add(dateString);           //countDown           countDownLatch.countDown();       }   });}</code></pre><p>通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以只对simpleDateFormat.format这一行加锁，这样效率更高一些。</p><hr><h4 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h4><p>第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。</p><pre><code>/*** 使用ThreadLocal定义一个全局的SimpleDateFormat*/private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() {   @Override   protected SimpleDateFormat initialValue() {       return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);   }};//用法String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime());</code></pre><p>当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。</p><hr><h4 id="使用DateTimeFormatter"><a href="#使用DateTimeFormatter" class="headerlink" title="使用DateTimeFormatter"></a>使用DateTimeFormatter</h4><p>如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。</p><pre><code>//解析日期String dateStr= &quot;2016年10月25日&quot;;DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);LocalDate date= LocalDate.parse(dateStr, formatter);//日期转换为字符串LocalDateTime now = LocalDateTime.now();DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;);String nowStr = now .format(format);System.out.println(nowStr);</code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个和使用Java8中的DateTimeFormatter类代替等。</p><p>改文章转载自：<a href="https://www.hollischuang.com/archives/3017" target="_blank" rel="noopener">你真的会使用SimpleDateFormat吗？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-辛弃疾《西江月·夜行黄沙道中》&lt;/center&gt;

&lt;hr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Volatile关键字</title>
    <link href="http://www.echodemo.cc/2019/04/24/Java%E4%B8%AD%E7%9A%84Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.echodemo.cc/2019/04/24/Java中的Volatile关键字/</id>
    <published>2019-04-24T14:08:47.000Z</published>
    <updated>2019-04-24T14:24:59.221Z</updated>
    
    <content type="html"><![CDATA[<center>东城渐觉风光好。縠皱波纹迎客棹。绿杨烟外晓寒轻，红杏枝头春意闹。</center><br><center>浮生长恨欢娱少。肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。</center><br><center>—-宋祁《玉楼春·春景》</center><hr><h3 id="Java内存模型中的可见性、原子性和有序性"><a href="#Java内存模型中的可见性、原子性和有序性" class="headerlink" title="Java内存模型中的可见性、原子性和有序性"></a>Java内存模型中的可见性、原子性和有序性</h3><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>在Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。比如：</p><pre><code>i = 2;j = i;i++;i = i + 1；</code></pre><p>上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为三步，一是读取i的值，然后再赋值给j,最后将j的值存到写回主存，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，也3步操作。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。</p><p>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32位的操作来处理，但是最新JDK实现还是实现了原子操作的。</p><p>JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。</p><hr><h4 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h4><p>说到可见性，Java就是利用volatile来提供可见性的。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</p><p>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p><hr><h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p><pre><code>double pi = 3.14; //Adouble r = 1; //Bdouble s= pi * r * r;//C</code></pre><p>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。比如这样的代码:</p><pre><code>int a = 0;bool flag = false;public void write() {    a = 2; //1    flag = true; //2}public void multiply() {    if (flag) { //3        int ret = a * a;//4    }}</code></pre><p>假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定：</p><p><img src="/images/2019/4/clipboard.png" alt="&quot;clipboard&quot;"></p><p>如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</p><p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><p>另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了其中包含这样一条规则：volatile变量规则： <strong>对一个volatile域的写，happens-before于后续对这个volatile域的读。即如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</strong>其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。<strong>也就是说volatile关键字可以保证可见性以及有序性。</strong></p><hr><h3 id="volatile底层的实现机制"><a href="#volatile底层的实现机制" class="headerlink" title="volatile底层的实现机制"></a>volatile底层的实现机制</h3><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><pre><code>1、重排序时不能把后面的指令重排序到内存屏障之前的位置。2、使得本CPU的Cache写入内存。3、写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</code></pre><hr><h3 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h3><blockquote><p>状态量标记，就如上面对flag的标记：这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p><p>单例模式的实现，典型的双重检查锁定（DCL）：<br>    class Singleton{<br>        private volatile static Singleton instance = null;</p></blockquote><pre><code>    private Singleton() {    }    public static Singleton getInstance() {        if(instance==null) {            synchronized (Singleton.class) {                if(instance==null)                instance = new Singleton();            }        }        return instance;    }}</code></pre><blockquote><p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;东城渐觉风光好。縠皱波纹迎客棹。绿杨烟外晓寒轻，红杏枝头春意闹。&lt;/center&gt;&lt;br&gt;&lt;center&gt;浮生长恨欢娱少。肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋祁《玉楼春·春景》&lt;/center&gt;

&lt;hr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Java虚拟机的锁优化技术</title>
    <link href="http://www.echodemo.cc/2019/04/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.echodemo.cc/2019/04/20/深入理解多线程之Java虚拟机的锁优化技术/</id>
    <published>2019-04-19T16:23:29.000Z</published>
    <updated>2019-04-24T13:58:43.918Z</updated>
    
    <content type="html"><![CDATA[<center>漠漠轻寒上小楼，晓阴无赖似穷秋。淡烟流水画屏幽。</center><br><center>自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。</center><br><center>—-秦观《浣溪沙·漠漠轻寒上小楼》</center><hr><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><blockquote><p>1、同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。<a href="http://www.echodemo.cc/2019/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">深入理解多线程之Synchronized的实现原理</a></p><p>2、同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得所锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。<a href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BMoniter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">深入理解多线程之Moniter的实现原理</a></p><p>3、在HotSpot虚拟机中，使用oop-klass模型来表示对象。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。<a href="http://www.echodemo.cc/2019/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">深入理解多线程之Java的对象模型</a></p><p>4、对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。<a href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/">深入理解多线程之Java的对象头</a></p></blockquote><hr><p>在<a href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BMoniter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">深入理解多线程之Moniter的实现原理</a>的最后，我们说过，事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。</p><p>高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。本文主要先来介绍一下自旋、锁消除以及锁粗化等技术。</p><p>这里简单说明一下，本文要介绍的这几个概念，以及后面要介绍的轻量级锁和偏向锁，其实对于使用他的开发者来说是屏蔽掉了的，也就是说，作为一个Java开发，你只需要知道你想在加锁的时候使用synchronized就可以了，具体的锁的优化是虚拟机根据竞争情况自行决定的。也就是说，在JDK 1.5 以后，我们即将介绍的这些概念，都被封装在synchronized中了。</p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>要想把锁说清楚，一个重要的概念不得不提，那就是线程和线程的状态。锁和线程的关系是怎样的呢，举个简单的例子你就明白了。</p><p>比如，你今天要去银行办业务，你到了银行之后，要先取一个号，然后你坐在休息区等待叫号，过段时间，广播叫到你的号码之后，会告诉你去哪个柜台办理业务，这时，你拿着你手里的号码，去到对应的柜台，找相应的柜员开始办理业务。当你办理业务的时候，这个柜台和柜台后面的柜员只能为你自己服务。当你办完业务离开之后，广播再喊其他的顾客前来办理业务。</p><blockquote><p>这个例子中，每个顾客是一个线程。 柜台前面的那把椅子，就是锁。 柜台后面的柜员，就是共享资源。 你发现无法直接办理业务，要取号等待的过程叫做阻塞。 当你听到叫你的号码的时候，你起身去办业务，这就是唤醒。 当你坐在椅子上开始办理业务的时候，你就获得锁。 当你办完业务离开的时候，你就释放锁。</p></blockquote><p>对于线程来说，一共有五种状态，分别为：初始状态(New) 、就绪状态(Runnable) 、运行状态(Running) 、阻塞状态(Blocked) 和死亡状态(Dead) 。</p><p><img src="/images/2019/4/thread.png" alt="&quot;thread&quot;"></p><hr><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在前面的文章中，我们介绍的synchronized的实现方式中使用Monitor进行加锁，这是一种互斥锁，为了表示他对性能的影响我们称之为重量级锁。这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间。</p><blockquote><p>就像去银行办业务的例子，当你来到银行，发现柜台前面都有人的时候，你需要取一个号，然后再去等待区等待，一直等待被叫号。这个过程是比较浪费时间的，那么有没有什么办法改进呢？有一种比较好的设计，那就是银行提供自动取款机，当你去银行取款的时候，你不需要取号，不需要去休息区等待叫号，你只需要找到一台取款机，排在其他人后面等待取款就行了。</p><p>之所以能这样做，是因为取款的这个过程相比较之下是比较节省时间的。如果所有人去银行都只取款，或者办理业务的时间都很短的话，那也就可以不需要取号，不需要去单独的休息区，不需要听叫号，也不需要再跑到对应的柜台了。</p></blockquote><p>在程序中，Java虚拟机的开发工程师们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。</p><p>很多人在对于自旋锁的概念不清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。</p><blockquote><p>对于去银行取钱的你来说，站在取款机面前等待和去休息区等待叫号有一个很大的区别：那就是如果你在休息区等待，这段时间你什么都不需要管，随意做自己的事情，等着被唤醒就行了。如果你在取款机面前等待，那么你需要时刻关注自己前面还有没有人，因为没人会唤醒你。很明显，这种直接去取款机前面排队取款的效率是比较高。</p></blockquote><p>所以，<strong>自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。</strong></p><p>由于<strong>自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，也就无需调用操作系统原生的线程，所以响应速度更快。</strong>但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p><hr><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>除了自旋锁之后，JDK中还有一种锁的优化被称之为锁消除。还拿去银行取钱的例子说。</p><blockquote><p>你去银行取钱，所有情况下都需要取号，并且等待吗？其实是不用的，当银行办理业务的人不多的时候，可能根本不需要取号，直接走到柜台前面办理业务就好了。能这么做的前提是，没有人和你抢着办业务。上面的这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。</p></blockquote><p>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。如以下代码：</p><pre><code>public void f() {    Object hollis = new Object();    synchronized(hollis) {        System.out.println(hollis);    }}</code></pre><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：</p><pre><code>public void f() {    Object hollis = new Object();    System.out.println(hollis);}</code></pre><p>这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，比如我们经常在代码中使用StringBuffer作为局部变量，而StringBuffer中的append是线程安全的，有synchronized修饰的，这种情况开发者可能会忽略。这时候，JIT就可以帮忙优化，进行锁消除。</p><p>总之，读者只需要知道，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。</p><hr><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。这也是很多人用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。</p><blockquote><p>还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。</p></blockquote><p><strong>加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。</strong></p><p>那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。</p><blockquote><p>就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。</p></blockquote><p>如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。</p><p>如以下代码：</p><pre><code>for(int i=0;i&lt;100000;i++){      synchronized(this){          do();  }</code></pre><p>会被粗化成：</p><pre><code>synchronized(this){      for(int i=0;i&lt;100000;i++){          do();  }</code></pre><blockquote><p>这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。</p><p>本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;漠漠轻寒上小楼，晓阴无赖似穷秋。淡烟流水画屏幽。&lt;/center&gt;&lt;br&gt;&lt;center&gt;自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-秦观《浣溪沙·漠漠轻寒上小楼》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;前
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>String那些事儿</title>
    <link href="http://www.echodemo.cc/2019/04/18/String%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://www.echodemo.cc/2019/04/18/String那些事儿/</id>
    <published>2019-04-18T15:25:47.000Z</published>
    <updated>2019-04-19T16:22:29.985Z</updated>
    
    <content type="html"><![CDATA[<center>树绕村庄，水满陂塘。倚东风、豪兴徜徉。小园几许，收尽春光。有桃花红，李花白，菜花黄。</center><br><center>远远围墙，隐隐茅堂。飏青旗、流水桥旁。偶然乘兴、步过东冈。正莺儿啼，燕儿舞，蝶儿忙。</center><br><center>—-秦观《行香子·树绕村庄》</center><hr><p>String，是Java中除了基本数据类型以外，最为重要的一个类型了。很多人会认为他比较简单。但是和String有关的面试题有很多，下面我随便找两道面试题，看看你能不能都答对：</p><pre><code>Q1：String s = new String(&quot;hollis&quot;);定义了几个对象。Q2：如何理解String的intern方法？</code></pre><p>上面这两个是面试题和String相关的比较常考的，很多人一般都知道答案。</p><blockquote><p>A1：若常量池中已经存在”hollis”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存在”hollis”，则先创建后引用，也就是有两个。</p><p>A2：当一个String实例调用intern()方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。</p></blockquote><p>两个答案看上去没有任何问题，但是，仔细想想好像哪里不对呀。按照上面的两个面试题的回答，就是说new String会检查常量池，如果有的话就直接引用，如果不存在就要在常量池创建一个，那么还要intern干啥？难道以下代码是没有意义的吗？</p><pre><code>String s = new String(&quot;Hollis&quot;).intern();</code></pre><p>如果每当我们使用new创建字符串的时候，都会到字符串池检查，然后返回。那么以下代码也应该输出结果都是true?</p><pre><code>String s1 = &quot;Hollis&quot;;String s2 = new String(&quot;Hollis&quot;);String s3 = new String(&quot;Hollis&quot;).intern();System.out.println(s1 == s2);System.out.println(s1 == s3);</code></pre><p>但是，以上代码输出结果为（base jdk1.8.0_73）：</p><pre><code>falsetrue</code></pre><p>不知道，聪明的读者看完这段代码之后，是不是有点被搞蒙了，到底是怎么回事儿？别急，且听我慢慢道来。</p><hr><h3 id="字面量和运行时常量池"><a href="#字面量和运行时常量池" class="headerlink" title="字面量和运行时常量池"></a>字面量和运行时常量池</h3><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。</p><p>了解Class文件结构或者做过Java代码的反编译的朋友可能都知道，在java代码被javac编译之后，文件结构中是包含一部分Constant pool的。比如以下代码：</p><pre><code>public static void main(String[] args) {    String s = &quot;Hollis&quot;;}</code></pre><p>经过编译后，常量池内容如下：</p><pre><code>Constant pool:    #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V    #2 = String             #21            // Hollis    #3 = Class              #22            // StringDemo    #4 = Class              #23            // java/lang/Object    ...    #16 = Utf8               s    ..    #21 = Utf8               Hollis    #22 = Utf8               StringDemo    #23 = Utf8               java/lang/Object</code></pre><p>上面的Class文件中的常量池中，比较重要的几个内容：</p><pre><code>#16 = Utf8               s#21 = Utf8               Hollis#22 = Utf8               StringDemo</code></pre><p>上面几个常量中，s就是前面提到的符号引用，而Hollis就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p><hr><h3 id="new-String创建了几个对象"><a href="#new-String创建了几个对象" class="headerlink" title="new String创建了几个对象"></a>new String创建了几个对象</h3><p>下面，我们可以来分析下String s = new String(“Hollis”);创建对象情况了。</p><p>这段代码中，我们可以知道的是，在编译期，符号引用s和字面量Hollis会被加入到Class文件的常量池中，然后在类加载阶段，这两个常量会进入常量池。但是，这个“进入”过程，并不会直接把所有类中定义的常量全部都加载进来，而是会做个比较，如果需要加到字符串常量池中的字符串已经存在，那么就不需要再把字符串字面量加载进来了。</p><p>说完了编译期的事儿了，该到运行期了，在运行期，new String(“Hollis”);执行到的时候，是要在Java堆中创建一个字符串对象的，而这个对象所对应的字符串字面量是保存在运行时常量池中的。但是，String s = new String(“Hollis”);<strong>对象的符号引用s是保存在Java虚拟机栈上的，他保存的是堆中刚刚创建出来的的字符串对象的引用。</strong></p><p>所以，你也就知道以下代码输出结果为false的原因了。</p><pre><code>String s1 = new String(&quot;Hollis&quot;);String s2 = new String(&quot;Hollis&quot;);System.out.println(s1 == s2);</code></pre><p>因为，==比较的是s1和s2在堆中创建的对象的地址，当然不同了。但是如果使用equals，那么比较的就是字面量的内容了，那就会得到true。</p><p><img src="/images/2019/4/stringInstance.png" alt="&quot;string对象&quot;"></p><blockquote><p>在不同版本的JDK中，Java堆和字符串常量池之间的关系也是不同的，这里为了方便表述，就画成两个独立的物理区域了。具体情况请参考Java虚拟机规范。</p></blockquote><p><strong>常量池中的“对象”是在编译期就确定好了的，在类被加载的时候创建的，如果类加载时，该字符串常量在常量池中已经有了，那这一步就省略了。堆中的对象是在运行期才确定的，在代码执行到new的时候创建的。</strong></p><h3 id="运行时常量池的动态扩展"><a href="#运行时常量池的动态扩展" class="headerlink" title="运行时常量池的动态扩展"></a>运行时常量池的动态扩展</h3><p>编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是String的intern方法。</p><p>当一个String实例调用intern()方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><p>intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。我们再来看下开头的那个让人产生疑惑的例子：</p><pre><code>String s1 = &quot;Hollis&quot;;String s2 = new String(&quot;Hollis&quot;);String s3 = new String(&quot;Hollis&quot;).intern();System.out.println(s1 == s2);System.out.println(s1 == s3);</code></pre><p>你可以简单的理解为String s1 = “Hollis”;和String s3 = new String(“Hollis”).intern();做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。如下图：</p><p><img src="/images/2019/4/stringintern.png" alt="&quot;string对象1&quot;"></p><p>对于String s3 = new String(“Hollis”).intern();，在不调intern情况，s3指向的是JVM在堆中创建的那个对象的引用的（如图中的s2）。但是当执行了intern方法时，s3将指向字符串常量池中的那个字符串常量。</p><p>由于s1和s3都是字符串常量池中的字面量的引用，所以s1==s3。但是，s2的引用是堆中的对象，所以s2!=s1。</p><hr><h3 id="intern的正确用法"><a href="#intern的正确用法" class="headerlink" title="intern的正确用法"></a>intern的正确用法</h3><p>不知道，你有没有发现，在String s3 = new String(“Hollis”).intern();中，其实intern是多余的？</p><p>因为就算不用intern，Hollis作为一个字面量也会被加载到Class文件的常量池，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到intern呢?在解释这个之前，我们先来看下以下代码：</p><pre><code>String s1 = &quot;Hollis&quot;;String s2 = &quot;Chuang&quot;;String s3 = s1 + s2;String s4 = &quot;Hollis&quot; + &quot;Chuang&quot;;</code></pre><p>在经过反编译后，得到代码如下：</p><pre><code>String s1 = &quot;Hollis&quot;;String s2 = &quot;Chuang&quot;;String s3 = (new StringBuilder()).append(s1).append(s2).toString();String s4 = &quot;HollisChuang&quot;;</code></pre><p>可以发现，同样是字符串拼接，s3和s4在经过编译器编译后的实现方式并不一样。s3被转化成StringBuilder及append，而s4被直接拼接成新的字符串。如果你感兴趣，你还能发现，String s3 = s1 + s2; 经过编译之后，常量池中是有两个字符串常量的分别是 Hollis、Chuang（其实Hollis和Chuang是String s1 = “Hollis”;和String s2 = “Chuang”;定义出来的），拼接结果HollisChuang并不在常量池中。</p><p>如果代码只有String s4 = “Hollis” + “Chuang”;，那么常量池中将只有HollisChuang而没有Hollis和 Chuang。究其原因，是因为常量池要保存的是已确定的字面量值。也就是说，<strong>对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。</strong></p><p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。那么，有了这个特性了，intern就有用武之地了。那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中。</p><p>这时候，<strong>对于那种可能经常使用的字符串，使用intern进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</strong>如一美团点评团队的《深入解析String#intern》文中举的一个例子：</p><pre><code>static final int MAX = 1000 * 10000;static final String[] arr = new String[MAX];public static void main(String[] args) throws Exception {    Integer[] DB_DATA = new Integer[10];    Random random = new Random(10 * 10000);    for (int i = 0; i &lt; DB_DATA.length; i++) {        DB_DATA[i] = random.nextInt();    }    for (int i = 0; i &lt; MAX; i++) {         arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();    }}</code></pre><p>在以上代码中，我们明确的知道，会有很多重复的相同的字符串产生，但是这些字符串的值都是只有在运行期才能确定的。所以，只能我们通过intern显示的将其加入常量池，这样可以减少很多字符串的重复创建。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们再回到文章开头那个疑惑：按照上面的两个面试题的回答，就是说new String也会检查常量池，如果有的话就直接引用，如果不存在就要在常量池创建一个，那么还要intern干啥？难道以下代码是没有意义的吗？</p><pre><code>String s = new String(&quot;Hollis&quot;).intern();</code></pre><p>new String 所谓的“如果有的话就直接引用”，指的是Java堆中创建的String对象中包含的字符串字面量直接引用字符串池中的字面量对象。也就是说，还是要在堆里面创建对象的。而intern中说的“如果有的话就直接返回其引用”，指的是会把字面量对象的引用直接返回给定义的对象。这个过程是不会在Java堆中再创建一个String对象的。</p><p>的确，以上代码的写法其实是使用intern是没什么意义的。因为字面量Hollis会作为编译期常量被加载到运行时常量池。之所以能有以上的疑惑，其实是对字符串常量池、字面量等概念没有真正理解导致的。有些问题其实就是这样，单个问题，自己都知道答案，但是多个问题综合到一起就蒙了。归根结底是知识的理解还停留在点上，没有串成面。</p><p>改文章转载自：<a href="https://mp.weixin.qq.com/s/VBFDIHhPg0MJ-L9DpzbiWw" target="_blank" rel="noopener">我终于搞清楚了和String有关的那点事儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;树绕村庄，水满陂塘。倚东风、豪兴徜徉。小园几许，收尽春光。有桃花红，李花白，菜花黄。&lt;/center&gt;&lt;br&gt;&lt;center&gt;远远围墙，隐隐茅堂。飏青旗、流水桥旁。偶然乘兴、步过东冈。正莺儿啼，燕儿舞，蝶儿忙。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-秦观《行
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>鲜为人知的Unsafe类</title>
    <link href="http://www.echodemo.cc/2019/04/17/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84Unsafe%E7%B1%BB/"/>
    <id>http://www.echodemo.cc/2019/04/17/鲜为人知的Unsafe类/</id>
    <published>2019-04-17T15:31:52.000Z</published>
    <updated>2019-04-18T15:29:58.962Z</updated>
    
    <content type="html"><![CDATA[<center>孤山寺北贾亭西，水面初平云脚低。</center><br><center>几处早莺争暖树，谁家新燕啄春泥。</center><br><center>乱花渐欲迷人眼，浅草才能没马蹄。</center><br><center>最爱湖东行不足，绿杨阴里白沙堤。</center><br><center>—-白居易《钱塘湖春行》</center><hr><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：</p><pre><code>1、内存管理，Unsafe类中存在直接操作内存的方法。2、获取对象的实例。3、挂起与恢复。4、CAS操作</code></pre><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>通过Unsafe类可以分配内存，可以释放内存；类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应。</p><pre><code>//分配内存指定大小的内存public native long allocateMemory(long bytes);//根据给定的内存地址address设置重新分配指定大小的内存public native long reallocateMemory(long address, long bytes);//用于释放allocateMemory和reallocateMemory申请的内存public native void freeMemory(long address);</code></pre><p>除此之外，它还有下列一些操作内存的方法：</p><pre><code>//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值public native void setMemory(Object o, long offset, long bytes, byte value);//设置给定内存地址的值public native void putAddress(long address, long x);//获取指定内存地址的值public native long getAddress(long address);//设置指定内存的byte值//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同public native byte getByte(long address);//获取指定内存的byte值public native void putByte(long address, byte x);//操作系统的内存页大小public native int pageSize();//对象字段的定位,该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的public native long staticFieldOffset(Field field);//获取对象中offset偏移地址对应的整型field的值,支持volatile load语义public native int getIntVolatile(Object obj, long l);//获取数组第一个元素的偏移地址public native int arrayBaseOffset(Class class1);//获取数组的转换因子，也就是数组中元素的增量地址public native int arrayIndexScale(Class class1);</code></pre><p>Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。</p><hr><h4 id="获取对象的实例"><a href="#获取对象的实例" class="headerlink" title="获取对象的实例"></a>获取对象的实例</h4><pre><code>//传入一个对象的class并创建该实例对象，但不会调用构造方法public native Object allocateInstance(Class cls) throws InstantiationException;</code></pre><hr><h4 id="挂起与恢复"><a href="#挂起与恢复" class="headerlink" title="挂起与恢复"></a>挂起与恢复</h4><p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中（java.util.concurrent包中挂起操作都是在LockSupport类实现的），LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法来实现的。</p><pre><code>public class LockSupport {    public static void unpark(Thread thread) {        if (thread != null)            unsafe.unpark(thread);    }    public static void park(Object blocker) {        Thread t = Thread.currentThread();        setBlocker(t, blocker);        unsafe.park(false, 0L);        setBlocker(t, null);    }    public static void parkNanos(Object blocker, long nanos) {        if (nanos &gt; 0) {            Thread t = Thread.currentThread();            setBlocker(t, blocker);            unsafe.park(false, nanos);            setBlocker(t, null);        }    }    public static void parkUntil(Object blocker, long deadline) {        Thread t = Thread.currentThread();        setBlocker(t, blocker);        unsafe.park(true, deadline);        setBlocker(t, null);    }    public static void park() {        unsafe.park(false, 0L);    }    public static void parkNanos(long nanos) {        if (nanos &gt; 0)            unsafe.park(false, nanos);    }    public static void parkUntil(long deadline) {        unsafe.park(true, deadline);    }}</code></pre><hr><h4 id="Unsafe里的CAS操作"><a href="#Unsafe里的CAS操作" class="headerlink" title="Unsafe里的CAS操作"></a>Unsafe里的CAS操作</h4><p>CAS是一些CPU直接支持的指令，在Java中无锁操作CAS基于以下3个方法实现：</p><pre><code>public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x); </code></pre><p>第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值。expected表示期望值，x表示要设置的值。</p><hr><h3 id="利用Unsafe类"><a href="#利用Unsafe类" class="headerlink" title="利用Unsafe类"></a>利用Unsafe类</h3><h4 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h4><pre><code>public static Unsafe getUnsafeInstance() throws Exception{    Field unsafeStaticField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);    unsafeStaticField.setAccessible(true);    return (Unsafe) unsafeStaticField.get(Unsafe.class);}</code></pre><p>通过java反射机制，我们跳过了安全检测，拿到了一个Unsafe类的实例。</p><hr><h4 id="修改和读取数组中的值"><a href="#修改和读取数组中的值" class="headerlink" title="修改和读取数组中的值"></a>修改和读取数组中的值</h4><pre><code>@RequestMapping(&quot;/readandwritearray&quot;)public void readAndWriteArray() throws Exception {    Unsafe unsafe = getUnsafeInstance();    int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};    //返回当前数组的首地址    int b = unsafe.arrayBaseOffset(int[].class);    //返回当前数组一个元素占用的字节数    int s = unsafe.arrayIndexScale(int[].class);    //获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，将intval写入内存    unsafe.putInt(arr, (long) b + s * 9, 1);    for (int i = 0; i &lt; 10; i++) {        //获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，从而获得元素的值        int v = unsafe.getInt(arr, (long) b + s * i);        System.out.print(v + &quot; &quot;);    }}</code></pre><p>打印结果:1 2 3 4 5 6 7 8 9 1 ,可以看到，成功读出了数组中的值，而且最后一个值由10改为了1。</p><blockquote><p>偏移值: 数组元素偏移值 = arrayBaseOffset + arrayIndexScalse * i。</p></blockquote><hr><h4 id="修改静态变量和实例变量的值"><a href="#修改静态变量和实例变量的值" class="headerlink" title="修改静态变量和实例变量的值"></a>修改静态变量和实例变量的值</h4><p>先定义一个UnsafeTest类:</p><pre><code>public class UnsafeTest {    public int infield;    public static int staticIntField;    public static int[] arr;    private UnsafeTest() {        System.out.println(&quot;constructor called!&quot;);    }}</code></pre><p>修改UnsafeTest类的实例变量:</p><pre><code>@RequestMapping(&quot;/changeinstancefield&quot;)public void changeInstanceField() throws Exception {    Unsafe unsafe = getUnsafeInstance();    //传入一个对象的class并创建该实例对象，但不会调用构造方法    UnsafeTest unsafeTest = (UnsafeTest)unsafe.allocateInstance(UnsafeTest.class);    //获取对象某个属性的地址偏移值    long b1 = unsafe.objectFieldOffset(UnsafeTest.class.getDeclaredField(&quot;infield&quot;));    unsafe.putInt(unsafeTest, b1, 2);    System.out.println(&quot;infield:&quot; + unsafeTest.infield);}</code></pre><p>这里使用allocateInstance方法获取了一个UnsafeTest类的实例，并且没有打印“constructor called”，说明构造方法没有调用。修改实例变量与修改数组的值类似，同样要获取地址偏移值，然后调用putInt方法。</p><p>修改UnsafeTest类的静态变量:</p><pre><code>@RequestMapping(&quot;/changestaticfield&quot;)public void changeStaticField() throws Exception {    Unsafe unsafe = getUnsafeInstance();    Field staticIntField = UnsafeTest.class.getDeclaredField(&quot;staticIntField&quot;);    //获取静态变量所属的类在方法区的首地址。可以看到，返回的对象就是UnsafeTes.class    Object o = unsafe.staticFieldBase(staticIntField);    System.out.println(o == UnsafeTest.class);    //获取静态变量地址偏移值    Long b4 = unsafe.staticFieldOffset(staticIntField);    //因为是静态变量，传入的Object参数应为class对象    unsafe.putInt(o, b4, 10);    System.out.println(&quot;staticIntField:&quot; + unsafe.getInt(UnsafeTest.class, b4));}</code></pre><p>打印结果：</p><pre><code>truestaticIntField:10</code></pre><p>静态变量与实例变量不同之处在于，静态变量位于方法区中，它的地址偏移值与UnsafeTest类在方法区的地址相关，与UnsafeTest类的实例无关。</p><hr><h4 id="调戏String-intern"><a href="#调戏String-intern" class="headerlink" title="调戏String.intern"></a>调戏String.intern</h4><p>在jdk7中，String.intern不再拷贝string对象实例，而是保存第一次出现的对象的引用。在下面的代码中，通过Unsafe修改被引用对象s的私有属性value达到间接修改s1的效果！</p><pre><code>@RequestMapping(&quot;/stringintern&quot;)public void stringIntern() throws Exception {    String s = &quot;abc&quot;;    //保存s的引用    s.intern();    //此时s1==s，地址相同    String s1 = &quot;abc&quot;;    Unsafe unsafe = getUnsafeInstance();    //获取s的实例变量value    Field valueInString = String.class.getDeclaredField(&quot;value&quot;);    //获取value的变量偏移值    long offset = unsafe.objectFieldOffset(valueInString);    //value本身是一个char[],要修改它元素的值，仍要获取baseOffset和indexScale    long base = unsafe.arrayBaseOffset(char[].class);    long scale = unsafe.arrayIndexScale(char[].class);    //获取value    char[] values = (char[]) unsafe.getObject(s, offset);    //为value赋值    unsafe.putChar(values, base + scale, &apos;c&apos;);    System.out.println(&quot;s:&quot; + s + &quot; s1:&quot; + s1);    //将s的值改为 abc    s = &quot;abc&quot;;    String s2 = &quot;abc&quot;;    String s3 = &quot;abc&quot;;    System.out.println(&quot;s:&quot; + s + &quot; s1:&quot; + s1);    System.out.println(&quot;s2:&quot; + s2 +&quot; s3:&quot; + s3);}</code></pre><p>打印结果：</p><pre><code>s:acc s1:accs:acc s1:acc s2:acc s3:acc</code></pre><p>我们发现了什么？所有值为“abc”的字符串都变成了“acc”。Unsafe类果然不安全！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;孤山寺北贾亭西，水面初平云脚低。&lt;/center&gt;&lt;br&gt;&lt;center&gt;几处早莺争暖树，谁家新燕啄春泥。&lt;/center&gt;&lt;br&gt;&lt;center&gt;乱花渐欲迷人眼，浅草才能没马蹄。&lt;/center&gt;&lt;br&gt;&lt;center&gt;最爱湖东行不足，绿杨阴里白沙堤。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁的一种实现方式CAS</title>
    <link href="http://www.echodemo.cc/2019/04/17/%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8FCAS/"/>
    <id>http://www.echodemo.cc/2019/04/17/乐观锁的一种实现方式CAS/</id>
    <published>2019-04-17T13:26:47.000Z</published>
    <updated>2019-04-18T14:20:19.051Z</updated>
    
    <content type="html"><![CDATA[<center>怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！</center><br><center>靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。</center><br><center>—-岳飞《满江红·写怀》</center><hr><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>众所周知，Java是多线程的。但是，Java对多线程的支持其实是一把双刃剑。一旦涉及到多个线程操作共享资源的情况时，处理不好就可能产生线程安全问题。线程安全性可能是非常复杂的，在没有充足的同步的情况下，多个线程中的操作执行顺序是不可预测的。</p><p>Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性。加上复合操作的原子性，我们可以认为Java的线程安全性问题主要关注点有3个：可见性、有序性和原子性。</p><p><a href="http://www.echodemo.cc/2019/04/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a>（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题。这里不再详细介绍JMM及锁的其他相关知识。但是我们要讨论一个问题，那就是锁到底是不是有利无弊的？</p><hr><h3 id="锁存在的问题"><a href="#锁存在的问题" class="headerlink" title="锁存在的问题"></a>锁存在的问题</h3><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。但是悲观锁机制存在以下问题：</p><blockquote><p>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p></blockquote><p>而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><p>与锁相比，volatile变量是一个更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile不能解决原子性问题，因此当一个变量依赖旧值时就不能使用volatile变量。因此对于同步最终还是要回到锁机制上来。</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><hr><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。</p><blockquote><p>这里再强调一下，乐观锁是一种思想。CAS是这种思想的一种实现方式。</p></blockquote><hr><h4 id="Java对CAS的支持"><a href="#Java对CAS的支持" class="headerlink" title="Java对CAS的支持"></a>Java对CAS的支持</h4><p>在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。</p><p>我们以java.util.concurrent中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解getAndIncrement方法，该方法的作用相当于 ++i 操作。</p><pre><code>public class AtomicInteger extends Number implements java.io.Serializable {      private volatile int value;      public final int get() {          return value;      }      public final int getAndIncrement() {          for (;;) {              int current = get();              int next = current + 1;              if (compareAndSet(current, next))                  return current;          }      }      public final boolean compareAndSet(int expect, int update) {          return unsafe.compareAndSwapInt(this, valueOffset, expect, update);      }  }</code></pre><p>在没有锁的机制下需要字段value要借助volatile原语，保证线程间的数据是可见的。这样在获取变量的值的时候才能直接读取。getAndIncrement采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet利用JNI来完成CPU指令的操作。从代码中我们可以发现，JAVA中的CAS操作都是通过sun.misc包下Unsafe类实现的，关于Unsafe类更详细的说明，可以查阅我的这篇文章:<a href="http://www.echodemo.cc/2019/04/17/%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84Unsafe%E7%B1%BB/">鲜为人知的Unsafe类</a></p><hr><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p>部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><hr><h3 id="CAS与对象创建"><a href="#CAS与对象创建" class="headerlink" title="CAS与对象创建"></a>CAS与对象创建</h3><p>另外，CAS还有一个应用，那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的。即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制。锁机制包含两种：乐观锁与悲观锁。悲观锁是独占锁，阻塞锁。乐观锁是非独占锁，非阻塞锁。有一种乐观锁的实现方式就是CAS ，这种算法在JDK 1.5中引入的java.util.concurrent中有广泛应用。但是值得注意的是这种算法会存在ABA问题。</p><p>改文章转载自：<a href="https://www.hollischuang.com/archives/1537" target="_blank" rel="noopener">乐观锁的一种实现方式——CAS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！&lt;/center&gt;&lt;br&gt;&lt;center&gt;靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Moniter的实现原理</title>
    <link href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BMoniter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.echodemo.cc/2019/04/15/深入理解多线程之Moniter的实现原理/</id>
    <published>2019-04-15T15:06:23.000Z</published>
    <updated>2019-04-16T14:48:21.829Z</updated>
    
    <content type="html"><![CDATA[<center>阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。</center><br><center>待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。</center><br><center>—-王国维《蝶恋花·阅尽天涯离别苦》</center><hr><h3 id="操作系统中的管程"><a href="#操作系统中的管程" class="headerlink" title="操作系统中的管程"></a>操作系统中的管程</h3><p>如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。</p><blockquote><p>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</p></blockquote><hr><h3 id="Java线程同步相关的Moniter"><a href="#Java线程同步相关的Moniter" class="headerlink" title="Java线程同步相关的Moniter"></a>Java线程同步相关的Moniter</h3><p>在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><p>先来举个例子，然后我们再上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。</p><p><img src="/images/2019/4/Java-Monitor.jpg" alt="&quot;Java-Monitor&quot;"></p><p>如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间可以稍后再次进入那间特殊的房间。如上面所说，这个建筑屋中一共有三个场所。</p><p><img src="/images/2019/4/java-monitor-associate-with-object.jpg" alt="&quot;java-monitor-associate-with-object&quot;"></p><p>总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是：</p><blockquote><p>对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。</p><p>通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。</p></blockquote><hr><h3 id="监视器的实现"><a href="#监视器的实现" class="headerlink" title="监视器的实现"></a>监视器的实现</h3><p>在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">ObjectMonitor</a>实现的，其主要数据结构如下：</p><pre><code>ObjectMonitor() {    _header       = NULL;    _count        = 0;    _waiters      = 0,    _recursions   = 0;    _object       = NULL;    _owner        = NULL;    _WaitSet      = NULL;    _WaitSetLock  = 0 ;    _Responsible  = NULL ;    _succ         = NULL ;    _cxq          = NULL ;    FreeNext      = NULL ;    _EntryList    = NULL ;    _SpinFreq     = 0 ;    _SpinClock    = 0 ;    OwnerIsThread = 0 ;}</code></pre><p>源码地址：<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.hpp#L193" target="_blank" rel="noopener">objectMonitor.hpp</a>ObjectMonitor中有几个关键属性：</p><pre><code>_owner：指向持有ObjectMonitor对象的线程_WaitSet：存放处于wait状态的线程队列_EntryList：存放处于等待锁block状态的线程队列_recursions：锁的重入次数_count：用来记录该线程获取锁的次数</code></pre><p>当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。</p><p>若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示:</p><p><img src="/images/2019/4/monitor.png" alt="&quot;monitor&quot;"></p><hr><p>ObjectMonitor类中提供了几个方法：</p><h4 id="获得锁"><a href="#获得锁" class="headerlink" title="获得锁"></a>获得锁</h4><pre><code>void ATTR ObjectMonitor::enter(TRAPS) {      Thread * const Self = THREAD ;      void * cur ;      //通过CAS尝试把monitor的`_owner`字段设置为当前线程      cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;      //获取锁失败      if (cur == NULL) {         assert (_recursions == 0   , &quot;invariant&quot;) ;         assert (_owner      == Self, &quot;invariant&quot;) ;         // CONSIDER: set or assert OwnerIsThread == 1         return ;      }      // 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。      if (cur == Self) {          // TODO-FIXME: check for integer overflow!  BUGID 6557169.         _recursions ++ ;         return ;      }      // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程      if (Self-&gt;is_lock_owned ((address)cur)) {         assert (_recursions == 0, &quot;internal state error&quot;);        _recursions = 1 ;        // Commute owner from a thread-specific on-stack BasicLockObject address to        // a full-fledged &quot;Thread *&quot;.        _owner = Self ;        OwnerIsThread = 1 ;        return ;      }      // 省略部分代码。      // 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放      for (;;) {      jt-&gt;set_suspend_equivalent();      // cleared by handle_special_suspend_equivalent_condition()      // or java_suspend_self()      EnterI (THREAD) ;      if (!ExitSuspendEquivalent(jt)) break ;      //      // We have acquired the contended monitor, but while we were      // waiting another thread suspended us. We don&apos;t want to enter      // the monitor while suspended because that would surprise the      // thread that suspended us.      //          _recursions = 0 ;      _succ = NULL ;      exit (Self) ;      jt-&gt;java_suspend_self();}</code></pre><p><img src="/images/2019/4/lockenter.png" alt="&quot;lockenter&quot;"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><pre><code>void ATTR ObjectMonitor::exit(TRAPS) {   Thread * Self = THREAD ;   //如果当前线程不是Monitor的所有者   if (THREAD != _owner) {      if (THREAD-&gt;is_lock_owned((address) _owner)) { //        // Transmute _owner from a BasicLock pointer to a Thread address.       // We don&apos;t need to hold _mutex for this transition.       // Non-null to Non-null is safe as long as all readers can       // tolerate either flavor.       assert (_recursions == 0, &quot;invariant&quot;) ;       _owner = THREAD ;       _recursions = 0 ;       OwnerIsThread = 1 ;     } else {       // NOTE: we need to handle unbalanced monitor enter/exit       // in native code by throwing an exception.       // TODO: Throw an IllegalMonitorStateException ?       TEVENT (Exit - Throw IMSX) ;       assert(false, &quot;Non-balanced monitor enter/exit!&quot;);       if (false) {          THROW(vmSymbols::java_lang_IllegalMonitorStateException());       }       return;     }  }  // 如果_recursions次数不为0.自减  if (_recursions != 0) {     _recursions--;        // this is simple recursive enter     TEVENT (Inflated exit - recursive) ;     return ;  }}</code></pre><blockquote><p>//省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。</p></blockquote><p><img src="/images/2019/4/lockexit.png" alt="&quot;lockexit&quot;"></p><p>除了enter和exit方法以外，<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp" target="_blank" rel="noopener">objectMonitor.cpp</a>中还有:</p><pre><code>void      wait(jlong millis, bool interruptable, TRAPS);void      notify(TRAPS);void      notifyAll(TRAPS);</code></pre><p>等方法。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍的就是HotSpot虚拟机中Moniter的的加锁以及解锁的原理。</p><p>通过这篇文章我们知道了sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？</p><p>Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费处理器很多的时间，对于代码简单的同步块（如被synchronized修饰的get或set方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说synchronized是java语言中一个重量级的操纵。</p><p>所以，在JDK1.6中对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-王国维《蝶恋花·阅尽天涯离别苦》&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Java的对象头</title>
    <link href="http://www.echodemo.cc/2019/04/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    <id>http://www.echodemo.cc/2019/04/15/深入理解多线程之Java的对象头/</id>
    <published>2019-04-15T14:46:23.000Z</published>
    <updated>2019-04-15T15:16:13.505Z</updated>
    
    <content type="html"><![CDATA[<center>今古河山无定据。画角声中，牧马频来去。满目荒凉谁可语？西风吹老丹枫树。</center><br><center>从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。</center><br><center>—-纳兰容若《蝶恋花·出塞》</center><hr><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。那么这里提到的对象头到底是什么呢？</p><pre><code>class oopDesc {  friend class VMStructs; private:  volatile markOop  _mark;  union _metadata {    wideKlassOop    _klass;    narrowOop       _compressed_klass;  } _metadata;}</code></pre><p>上面代码中的_mark和_metadata其实就是对象头的定义。关于_metadata之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下_mark ，即mark word。</p><p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p>对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。</p><p><img src="/images/2019/4/markword.png" alt="&quot;markword&quot;"></p><hr><p>同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp" target="_blank" rel="noopener">markOop.hpp</a>类。</p><pre><code>enum { age_bits                 = 4,      lock_bits                = 2,      biased_lock_bits         = 1,      max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,      hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits,      cms_bits                 = LP64_ONLY(1) NOT_LP64(0),      epoch_bits               = 2};</code></pre><p>从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记位的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。</p><blockquote><p>在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。</p></blockquote><hr><p>markOop.hpp类中有关于对象状态的定义：</p><pre><code>enum {      locked_value             = 0,         unlocked_value           = 1,         monitor_value            = 2,         marked_value             = 3,         biased_lock_pattern      = 5};简单翻译一下：locked_value(00) = 0unlocked_value(01) = 1monitor_value(10) = 2marked_value(11) = 3biased_lock_pattern(101) = 5</code></pre><p>关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。</p><p>该文转载自：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;今古河山无定据。画角声中，牧马频来去。满目荒凉谁可语？西风吹老丹枫树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-纳兰容若《蝶恋花·出塞》&lt;/cent
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解多线程之Java的对象模型</title>
    <link href="http://www.echodemo.cc/2019/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/14/深入理解多线程之Java的对象模型/</id>
    <published>2019-04-14T06:43:24.000Z</published>
    <updated>2019-04-18T15:40:16.363Z</updated>
    
    <content type="html"><![CDATA[<center>似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。</center><br><center>不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。</center><br><center>—-苏轼《水龙吟·次韵章质夫杨花词》</center><hr><p>我们都知道，几乎所有的Java对象都是保存在堆内存当中（有例外，自行了解），在内存中Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有的锁等标志。这篇文章就主要从Java对象模型入手，找一找我们关心的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。</p><h3 id="Java的对象模型"><a href="#Java的对象模型" class="headerlink" title="Java的对象模型"></a>Java的对象模型</h3><p>任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生：</p><pre><code>1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 2、一切皆对象。</code></pre><p>我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于HotSpot虚拟机。</p><hr><h3 id="oop-klass-model"><a href="#oop-klass-model" class="headerlink" title="oop-klass model"></a>oop-klass model</h3><p>HotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>为什么HotSpot要设计一套oop-klass model呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表）。这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。</p><blockquote><p>多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。</p><blockquote><p>在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。</p></blockquote><blockquote><p>在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。</p></blockquote></blockquote><p>上面这段是从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。关于opp-klass模型的整体定义，在HotSpot的<a href="https://github.com/openjdk-mirror/jdk7u-hotspot" target="_blank" rel="noopener">源码</a>中可以找到。oops模块可以分成两个相对独立的部分：<strong>OOP框架和Klass框架。</strong>在oopsHierarchy.hpp里定义了oop和klass各自的体系。</p><hr><h3 id="oop-klass结构"><a href="#oop-klass结构" class="headerlink" title="oop-klass结构"></a>oop-klass结构</h3><p><img src="/images/2019/4/oops.png" alt="&quot;oop-klass结构&quot;"></p><p>oop体系：</p><pre><code>//定义了oops共同基类typedef class   oopDesc*                            oop;//表示一个Java类型实例typedef class   instanceOopDesc*            instanceOop;//表示一个Java方法typedef class   methodOopDesc*                    methodOop;//表示一个Java方法中的不变信息typedef class   constMethodOopDesc*            constMethodOop;//记录性能信息的数据结构typedef class   methodDataOopDesc*            methodDataOop;//定义了数组OOPS的抽象基类typedef class   arrayOopDesc*                    arrayOop;//表示持有一个OOPS数组typedef class   objArrayOopDesc*            objArrayOop;//表示容纳基本类型的数组typedef class   typeArrayOopDesc*            typeArrayOop;//表示在Class文件中描述的常量池typedef class   constantPoolOopDesc*            constantPoolOop;//常量池告诉缓存typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;//描述一个与Java类对等的C++类typedef class   klassOopDesc*                    klassOop;//表示对象头typedef class   markOopDesc*                    markOop;</code></pre><p>上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。从上面的代码中可以看到，有一个变量opp的类型是oppDesc ，OOPS类的共同基类型为oopDesc。</p><p>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。在HotSpot中，根据JVM内部使用的对象业务类型，具有多种oopDesc的子类。除了oppDesc类型外，opp体系中还有很多instanceOopDesc、arrayOopDesc 等类型的实例，他们都是oopDesc的子类。</p><p><img src="/images/2019/4/OOP结构.png" alt="&quot;oop结构&quot;"></p><p>这些OOPS在JVM内部有着不同的用途，例如，instanceOopDesc表示类实例，arrayOopDesc表示数组。也就是说，当我们使用new创建一个Java对象实例的时候，JVM会创建一个instanceOopDesc对象来表示这个Java对象。同理，当我们使用new创建一个Java数组实例的时候，JVM会创建一个arrayOopDesc对象来表示这个数组对象。</p><p>在HotSpot中，oopDesc类定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/oop.hpp" target="_blank" rel="noopener">oop.hpp</a>中，instanceOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceOop.hpp" target="_blank" rel="noopener">instanceOop.hpp</a>中，arrayOopDesc定义在<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/arrayOop.hpp" target="_blank" rel="noopener">arrayOop.hpp</a>中。简单看一下相关定义：</p><pre><code>class oopDesc {  friend class VMStructs;  private:      volatile markOop  _mark;      union _metadata {        wideKlassOop    _klass;        narrowOop       _compressed_klass;      } _metadata;  private:      // field addresses in oop      void*     field_base(int offset)        const;      jbyte*    byte_field_addr(int offset)   const;      jchar*    char_field_addr(int offset)   const;      jboolean* bool_field_addr(int offset)   const;      jint*     int_field_addr(int offset)    const;      jshort*   short_field_addr(int offset)  const;      jlong*    long_field_addr(int offset)   const;      jfloat*   float_field_addr(int offset)  const;      jdouble*  double_field_addr(int offset) const;      address*  address_field_addr(int offset) const;}class instanceOopDesc : public oopDesc {}class arrayOopDesc : public oopDesc {}</code></pre><p>通过上面的源码可以看到，instanceOopDesc实际上就是继承了oopDesc，并没有增加其他的数据结构，也就是说instanceOopDesc中主要包含以下几部分数据：markOop _mark和union _metadata 以及一些不同类型的 field。</p><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个instanceOopDesc的对象。其中对象头包含了两部分内容：_mark和_metadata，而实例数据则保存在oopDesc中定义的各种field中。</p><hr><h4 id="mark"><a href="#mark" class="headerlink" title="_mark"></a>_mark</h4><p>文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是synchronized以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在_mark中。因为本文主要介绍的oop-klass模型，在这里暂时不对对象头做展开，下一篇文章介绍。</p><h4 id="metadata"><a href="#metadata" class="headerlink" title="_metadata"></a>_metadata</h4><p>前面介绍到的_metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。在深入介绍之前，就要来到oop-Klass中的另外一个主角klass了。</p><h4 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h4><p>klass体系</p><pre><code>//klassOop的一部分，用来描述语言层的类型class  Klass;//在虚拟机层面描述一个Java类class   instanceKlass;//专有instantKlass，表示java.lang.Class的Klassclass     instanceMirrorKlass;//专有instantKlass，表示java.lang.ref.Reference的子类的Klassclass     instanceRefKlass;//表示methodOop的Klassclass   methodKlass;//表示constMethodOop的Klassclass   constMethodKlass;//表示methodDataOop的Klassclass   methodDataKlass;//最为klass链的端点，klassKlass的Klass就是它自身class   klassKlass;//表示instanceKlass的Klassclass     instanceKlassKlass;//表示arrayKlass的Klassclass     arrayKlassKlass;//表示objArrayKlass的Klassclass       objArrayKlassKlass;//表示typeArrayKlass的Klassclass       typeArrayKlassKlass;//表示array类型的抽象基类class   arrayKlass;//表示objArrayOop的Klassclass     objArrayKlass;//表示typeArrayOop的Klassclass     typeArrayKlass;//表示constantPoolOop的Klassclass   constantPoolKlass;//表示constantPoolCacheOop的Klassclass   constantPoolCacheKlass;</code></pre><p>和oopDesc是其他oop类型的父类一样，Klass类是其他klass类型的父类。</p><p><img src="/images/2019/4/klass.png" alt="&quot;klass&quot;"></p><p>Klass向JVM提供两个功能：</p><pre><code>1、实现语言层面的Java类（在Klass基类中已经实现）2、实现Java对象的分发功能（由Klass的子类提供虚函数实现）</code></pre><p>文章开头的时候说过：之所以设计oop-klass模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。</p><p>HotSopt JVM的设计者把对象一拆为二，分为klass和oop，其中oop的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。</p><hr><p>_metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。这两个指针都指向instanceKlass对象，它用来描述对象的具体类型。</p><h4 id="instanceKlass"><a href="#instanceKlass" class="headerlink" title="instanceKlass"></a>instanceKlass</h4><p>JVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个instanceKlass对象，用来在JVM层表示Java类。来看下<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/instanceKlass.hpp" target="_blank" rel="noopener">instanceKlass</a>的内部结构：</p><pre><code>//类拥有的方法列表objArrayOop     _methods;//描述方法顺序typeArrayOop    _method_ordering;//实现的接口objArrayOop     _local_interfaces;//继承的接口objArrayOop     _transitive_interfaces;//域typeArrayOop    _fields;//常量constantPoolOop _constants;//类加载器oop             _class_loader;//protected域oop             _protection_domain;    ....</code></pre><p>可以看到，一个类该具有的东西，这里面基本都包含了。</p><p>在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图：</p><p><img src="/images/2019/4/klass链.png" alt="&quot;klass链&quot;"></p><p>在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图：</p><p><img src="/images/2019/4/oop-klass-klassKlass.png" alt="&quot;oop-klass-klassKlass&quot;"></p><hr><h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答：</p><blockquote><p>对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。</p></blockquote><p>其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。</p><pre><code>class Model{    public static int a = 1;    public int b;    public Model(int b) {        this.b = b;    }}public static void main(String[] args) {    int c = 10;    Model modelA = new Model(2);    Model modelB = new Model(3);}</code></pre><p>存储结构如下：</p><p><img src="/images/2019/4/OOPKlass.jpg" alt="&quot;OOPKlass&quot;"></p><p>从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。&lt;/center&gt;&lt;br&gt;&lt;center&gt;不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.echodemo.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
