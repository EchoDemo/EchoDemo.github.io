<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-30T05:56:04.927Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/30/操作系统问题整理/</id>
    <published>2018-04-30T05:53:52.000Z</published>
    <updated>2018-04-30T05:56:04.927Z</updated>
    
    <content type="html"><![CDATA[<p>1、进程和线程</p><p>(1)线程是独立调度的基本单位，进程是拥有资源的基本单位。线程不拥有资源(减小了时空开销)。</p><p>(2)一个进程中可以包括多个线程，并且线程共享整个进程的资源(一般都要进行同步和互斥)，一个进程至少包括一个线程。进程内的线程对于其他进程不可见。</p><p>(3)引入进程的目的是为了更好地使用多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程度。引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>(4)进程间的通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以直接读/写进程数据段来进行通信。</p><p>2、线程同步的几种方式</p><p>(1)临界区(CCriticalSection):当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。</p><p>(2)互斥量(CMutex):互斥量与临界区的行为完全相同，但是也有一定的区别：互斥量是内核对象，临界区是用户模式下的同步对象，执行速度快于内核对象。</p><p>(3)事件(CEvent):通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</p><p>(4)信号量(CSemphore):它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目</p><p>3、进程间通信(IPC)</p><p>(1)共享存储：在通信的进程间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程间的通信。(常用到PV操作来进行同步和互斥)</p><p>(3)消息传递：进程通过系统提供的发送消息和接受消息两个原语进行数据交换。(有直接通信方式和间接通信方式)</p><p>(3)管道通信(通常指无名管道)是一种半双工的通信方式。它是指用于连接一个读进程和一个写进程以实现他们之间通信的共享文件。</p><p>4、缓冲区溢出</p><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。会产生以下危害：程序崩溃，导致拒绝额服务；跳转并且执行一段恶意代码。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>5、死锁</p><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的四个条件如下(有一个条件不成立，则不会产生死锁)</p><pre><code>(1)互斥条件：一个资源一次只能被一个进程使用。(2)请求与保持条件：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源被其他进程占用。(3)不剥夺条件：进程获得的资源，在未使用完之前，不能被强行剥夺，只能主动释放。(4)循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。</code></pre><p>解决死锁的基本方法:</p><p>(1)预防死锁：资源一次性分配(破坏请求和保持条件)；可剥夺资源，即当某进程新的资源未满足时，释放已占有的资源(破坏不可剥夺条件)；资源有序分配法，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反(破坏环路等待条件)</p><p>(2)避免死锁:系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p><p>(3)检测死锁:这种方法无须事先采取任何限性制措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。</p><p>(4)解除死锁:当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><p>6、进程的几种状态</p><pre><code>(1)就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源。(2)运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数。(3)阻塞状态： 进程等待某种条件，在条件满足之前无法执行。</code></pre><p>7、动态分区算法</p><p>(1)首次适应算法(FF):空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。该算法优先利用内存中低址空间，保留了高址空间，缺点是低址部分不断被划分，留下许多内存碎片。</p><p>(2)循环首次适应算法(NF):NF算法每次从上一次分配的地方继续分配，该算法需要一个起始查询的指针用于指示下一次查询的空间地址。缺点是：缺乏大的空间分区。</p><p>(3)最佳适应算法(BF):空闲分区以容量递增形成分区链，找到第一个能满足要求的空闲分区。缺点是：留下许多内存碎片。</p><p>(4)最坏适应算法(WF):空闲分区以容量递减形成分区链,找到第一个能满足要求的空闲分区。即总是挑选最大的空闲区域分配给作业使用。优点是不至于使空闲区间太小，产生碎片的可能性小，缺点是：缺乏大的空间分区</p><p>8、分页和分段的区别</p><pre><code>(1)都采用离散分配方式，且都是通过地址映射机构来实现地址的转换。(2)分页管理不会产生外部碎片，但产生内部碎片；分段管理不会产生内部碎片。(3)页的大小固定且由系统决定，在采用分页存储管理方式中直接由硬件实现。而段的大小不固定，决定于用户所编写的程序。(4)分页的地址空间是一维的，分段系统中是二维的。</code></pre><p>9、虚拟存储器页面置换算法</p><p>(1)最佳置换算法(Optimal):淘汰的页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p><p>(2)先进先出算法(FIFO):总是最先淘汰最先进去的页面。缺点：通常程序调入内存的先后顺序和程序执行的先后顺序不一致，导致缺页率高。</p><p>(3)最近最久未使用(LEU):选择最近最长时间未访问过的页面予以淘汰。</p><p>(4)时钟置换算法(LFU):在每个页面设置一个移位寄存器记录该页面的访问频率，最近时期最少使用的页面被淘汰。</p><p>10、调度算法</p><p>(1)先来先服务调度算法(FCFS):每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它。</p><p>(2)短作业优先调度算法(SJF):对短作业(运行时间最短)优先调度的算法。</p><p>(3)优先级调度算法:每次从后备作业中选择优先级最高的作业，将其调入内存，分配必要的资源。</p><p>(4)高响应比优先调度算法:在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p>(5)时间片轮转调度算法:将系统中所有就绪进程按照先来先服务的原则，但仅能运行一个时间片。</p><p>(6)多级反馈队列调度算法(集合了前几种算法的优点):是时间片轮转调度算法和优先级调度算法的综合和发展。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、进程和线程&lt;/p&gt;
&lt;p&gt;(1)线程是独立调度的基本单位，进程是拥有资源的基本单位。线程不拥有资源(减小了时空开销)。&lt;/p&gt;
&lt;p&gt;(2)一个进程中可以包括多个线程，并且线程共享整个进程的资源(一般都要进行同步和互斥)，一个进程至少包括一个线程。进程内的线程对于其他进
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://www.echodemo.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/30/计算机网络问题整理/</id>
    <published>2018-04-30T05:52:09.000Z</published>
    <updated>2018-04-30T05:53:19.877Z</updated>
    
    <content type="html"><![CDATA[<p>1、TCP连接时，为什么要进行三次握手</p><p>client发出的一个连接请求报文段在某个网络节点长时间滞留，以致于延误到连接释放以后才到达server。本来是一个早已失效的报文段，但server误认为是client发出的新的连接请求。于是就向client发送确认报文段，同意建立连接。如果不采取三次握手，那么只要server发出确认，新的连接就建立了。但由于client实际上并没有发出连接请求，因此不予理睬server的确认，也不会向server发送确认。但server却认为连接已经建立，并一直等待client发来数据。造成server资源的浪费。</p><pre><code>A：“喂，你听得到吗？”。B：“我听得到呀，你听得到我吗？”(应答和请求同时发出)。C：我能听得到你，balabala...”。</code></pre><p>2、为什么需要四次挥手</p><p>(1)当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口，就会发FIN给主机B。</p><p>(2)当主机B收到A发送的FIN，表示收到了，就会发送ACK回复A。</p><p>(3)但此时B可能还在发送数据，没有想要关闭数据口，所以B的FIN和回复A的ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。</p><p>(4)A收到B发来的FIN，知道B的数据也发送完了，回复ACK。A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭连接，B也关闭了连接。</p><pre><code>A：“喂，我不说了”。B：“我知道了。等一下，我还没说完。Balabala...”。B：“好了，我说完了，我也不说了”。A：“我知道了”。</code></pre><p>client发出最后的ACK回复可能会丢失。server如果没有收到ACK，将不断重复发送FIN片段。所以client不能立即关闭，他必须确认server收到了该ACK。client会在发出ACK之后进入到TIME_Wait状态。同时设置一个计时器，等待2MSL(MSL指一个片段在网络中最大的存活时间)的时间。如果在该段时间内收到FIN，那么需要重发ACK。如果没有再次收到ACK，client就认为server已经收到ACK，结束TCP连接。</p><p>3、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、TCP连接时，为什么要进行三次握手&lt;/p&gt;
&lt;p&gt;client发出的一个连接请求报文段在某个网络节点长时间滞留，以致于延误到连接释放以后才到达server。本来是一个早已失效的报文段，但server误认为是client发出的新的连接请求。于是就向client发送确认报文
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://www.echodemo.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1017 A除以B</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1017-A%E9%99%A4%E4%BB%A5B/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1017-A除以B/</id>
    <published>2018-04-29T08:38:02.000Z</published>
    <updated>2018-04-29T12:06:16.727Z</updated>
    
    <content type="html"><![CDATA[<p>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。</p><p>输入格式：输入在1行中依次给出A和B，中间以1空格分隔。</p><p>输出格式：在1行中依次输出Q和R，中间以1空格分隔。</p><pre><code>输入样例：123456789050987654321 7输出样例：17636684150141093474 3</code></pre><p>题目代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string s;    cin &gt;&gt; s;    int a;    cin &gt;&gt; a;    int len = s.length();    int t = (s[0] - &apos;0&apos;) / a;    if ((t != 0 &amp;&amp; len &gt; 1) || len == 1) {        cout &lt;&lt; t;    }    int temp = (s[0] - &apos;0&apos;) % a;    for (int i = 1; i &lt; len; i++) {        t = (temp * 10 + s[i] - &apos;0&apos;) / a;        cout &lt;&lt; t;        temp = (temp * 10 + s[i] - &apos;0&apos;) % a;    }    cout &lt;&lt; &quot; &quot; &lt;&lt; temp;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。&lt;/p&gt;
&lt;p&gt;输入格式：输入在1行中依次给出A和B，中间以1空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：在1行中依次输出Q和R，中间以1空格分隔。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1016 部分A+B</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1016-%E9%83%A8%E5%88%86A+B/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1016-部分A+B/</id>
    <published>2018-04-29T07:55:21.000Z</published>
    <updated>2018-04-29T08:38:07.580Z</updated>
    
    <content type="html"><![CDATA[<p>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。</p><p>现给定A、DA、B、DB，请编写程序计算PA + PB。</p><p>输入格式：输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 10^10。</p><p>输出格式：在一行中输出PA + PB的值。</p><pre><code>输入样例1：3862767 6 13530293 3输出样例1：399输入样例2：3862767 1 13530293 8输出样例2：0</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int PAB(string X, int Y) {  int n = 0, sum = 0;  for (int i = 0;i &lt; X.size();i++) {    if (X[i] - &apos;0&apos; == Y) n++;  }  for (int i = 0;i &lt; n;i++) {    sum = sum * 10 + Y;  }  return sum;}int main() {  int DA, DB;  string A, B;  cin &gt;&gt; A &gt;&gt; DA &gt;&gt; B &gt;&gt; DB;  cout &lt;&lt; PAB(A, DA)+ PAB(B, DB);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。&lt;/p&gt;
&lt;p&gt;现给定A、DA、B、DB，请编写程序计算PA + PB。&lt;/p&gt;
&lt;p&gt;输入格式：输入在一
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1015 德才论</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1015-德才论/</id>
    <published>2018-04-29T02:18:19.000Z</published>
    <updated>2018-04-29T07:54:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><p>输入格式：输入第1行给出3个正整数，分别为：N（&lt;=10^5），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p><p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p><p>输出格式：输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><pre><code>输入样例：14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60输出样例：1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”&lt;/p&gt;
&lt;p&gt;现给出一批考生的德才分数，请根据司马光的理论给出录取排名。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1014 福尔摩斯的约会</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1014-福尔摩斯的约会/</id>
    <published>2018-04-29T01:23:28.000Z</published>
    <updated>2018-04-29T07:13:49.221Z</updated>
    
    <content type="html"><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：</p><pre><code>“我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。</code></pre><p>大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p><p>输入格式：输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p><p>输出格式：在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，<br>即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，<br>SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p><pre><code>输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm输出样例：THU 14:04</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  string day[7] = { &quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot; };  string str1, str2, str3, str4;  cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3 &gt;&gt; str4;  int i = 0, j = 0, k = 0, n = 0;  while (i &lt; str1.size() &amp;&amp; i &lt; str2.size()) {    if ((str1[i] == str2[i]) &amp;&amp; (k == 1) &amp;&amp; ((str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;N&apos;) || (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;)))      break;    if (str1[i] == str2[i] &amp;&amp; str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;G&apos;) {      k++;      if (k == 1)        n = i;    }    i++;  }  cout &lt;&lt; day[str1[n] - &apos;A&apos;] &lt;&lt; &quot; &quot;;  if (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;) {//如果是数字    cout &lt;&lt; &quot;0&quot; &lt;&lt; str1[i] - &apos;0&apos;&lt;&lt;&quot;:&quot;;  }  else {//如果是字母    cout &lt;&lt; (9 + str1[i] - &apos;A&apos; + 1) &lt;&lt; &quot;:&quot;;  }  while (j &lt; str3.size() &amp;&amp; j &lt; str4.size()) {    if ((str3[j] == str4[j]) &amp;&amp; ((str3[j] &gt;= &apos;A&apos;&amp;&amp;str3[j] &lt;= &apos;Z&apos;) || (str3[j] &gt;= &apos;a&apos;&amp;&amp;str3[j] &lt;= &apos;z&apos;)))      break;    j++;  }  if (j &gt;= 0 &amp;&amp; j &lt;= 9)    cout &lt;&lt; &quot;0&quot; &lt;&lt; j;  else    cout &lt;&lt; j;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大侦探福尔摩斯接到一张奇怪的字条：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大侦探很快就明白了，字条上奇怪的乱
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1013 数素数</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1013-%E6%95%B0%E7%B4%A0%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1013-数素数/</id>
    <published>2018-04-29T00:51:26.000Z</published>
    <updated>2018-04-29T02:02:36.281Z</updated>
    
    <content type="html"><![CDATA[<p>令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。</p><p>输入格式：输入在一行中给出M和N，其间以空格分隔。</p><p>输出格式：输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。</p><pre><code>输入样例：5 27输出样例：11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;bool prime(int n) {//判定是否为素数  if (n &lt;= 1) return false;  for (int i = 2;i*i &lt;= n;i++) {    if (n%i == 0) return false;  }  return true;}int main() {  int M, N, i = 2, j = 0, k = 0;  cin &gt;&gt; M &gt;&gt; N;  while (k &lt; N) {    if (prime(i)) {      k++;//统计目前是第几个素数      if (k &gt;= M) {        cout &lt;&lt; i;        j++;        if (j % 10 == 0) cout &lt;&lt; endl;        else {          if (k &lt; N) cout &lt;&lt; &quot; &quot;;        }      }      }    i++;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;令Pi表示第i个素数。现任给两个正整数M &amp;lt;= N &amp;lt;= 104，请输出PM到PN的所有素数。&lt;/p&gt;
&lt;p&gt;输入格式：输入在一行中给出M和N，其间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1012 数字分类</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1012-数字分类/</id>
    <published>2018-04-28T07:59:10.000Z</published>
    <updated>2018-04-29T00:47:03.990Z</updated>
    
    <content type="html"><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p><pre><code>A1 = 能被5整除的数字中所有偶数的和；A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；A3 = 被5除后余2的数字的个数；A4 = 被5除后余3的数字的平均数，精确到小数点后1位；A5 = 被5除后余4的数字中最大数字。</code></pre><p>输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p><p>输出格式：对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出“N”。</p><pre><code>输入样例1：13 1 2 3 4 5 6 7 8 9 10 20 16 18输出样例1：30 11 2 9.7 9输入样例2：8 1 2 4 5 6 7 9 16输出样例2：N 11 2 N 9</code></pre><p>题目代码：需要注意的是最好不要让cout和printf在同一个程序当中出现。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt;using namespace std;int main() {  int n;  cin &gt;&gt; n;  vector&lt;int&gt; a(n);  for (int i = 0;i &lt; n;i++) {    cin &gt;&gt; a[i];  }  int A1 = 0, A2 = 0, A3 = 0, A5 = 0, flag2 = 0, j = 0 ;  double A4 = 0.0, flag4 = 0.0;  for (int i = 0;i &lt; n;i++) {    if (a[i] % 5 == 0 &amp;&amp; a[i] % 2 == 0) A1 += a[i];    if (a[i] % 5 == 1) { A2 += (int)(pow(-1, j++)*a[i]); flag2++; }    if (a[i] % 5 == 2) A3++;    if (a[i] % 5 == 3) { A4 += a[i]; flag4++; }    if (a[i] % 5 == 4) if (a[i] &gt; A5) A5 = a[i];  }  if (A1 &gt; 0) printf(&quot;%d &quot;, A1);  else printf(&quot;N &quot;);  if (flag2 &gt; 0) printf(&quot;%d &quot;, A2);  else printf(&quot;N &quot;);  if (A3 &gt; 0) printf(&quot;%d &quot;, A3);  else printf(&quot;N &quot;);  if (A4 &gt; 0) printf(&quot;%.1f &quot;, A4 / flag4);  else printf(&quot;N &quot;);  if (A5 &gt; 0) printf(&quot;%d&quot;, A5);  else printf(&quot;N&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A1 = 能被5整除的数字中所有偶数的和；
A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；
A3 = 被5除后余2的数字的个数；
A4 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1011 A+B和C</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1011-A+B%E5%92%8CC/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1011-A+B和C/</id>
    <published>2018-04-28T07:47:36.000Z</published>
    <updated>2018-04-28T07:58:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。</p><p>输入格式：输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p><p>输出格式：对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p><pre><code>输入样例：41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647输出样例：Case #1: falseCase #2: trueCase #3: trueCase #4: false</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {  int n;  long long A, B, C;  cin &gt;&gt; n;  for (int i = 0;i &lt; n;i++) {    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;    if ((A + B) &gt; C) cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: true&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: false&quot; &lt;&lt; endl;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。&lt;/p&gt;
&lt;p&gt;输入格式：输入第1行给出正整数T(&amp;lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：对每组测试用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1010 一元多项式求导</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1010-一元多项式求导/</id>
    <published>2018-04-28T07:20:29.000Z</published>
    <updated>2018-04-28T07:46:15.931Z</updated>
    
    <content type="html"><![CDATA[<p>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）</p><p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p><pre><code>输入样例：3 4 -5 2 6 1 -2 0输出样例：12 3 -10 1 6 0</code></pre><p>题目代码：这里设立一个flag标志位，如果指数为零并且标志位也同时为零，则说明是零多项式。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {  int m, n, flag = 0;  while (cin &gt;&gt; m &gt;&gt; n) {    if (!flag &amp;&amp; !n) {      cout &lt;&lt; &quot;0 0&quot;;//零多项式    }    if (n) {      if (flag) cout &lt;&lt; &quot; &quot;;//不是第一组输出时，要在当前这组数据输出前加上空格。      cout &lt;&lt; m*n &lt;&lt; &quot; &quot; &lt;&lt; n - 1;      flag = 1;    }  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）&lt;/p&gt;
&lt;p&gt;输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>致临安</title>
    <link href="http://www.echodemo.cc/2018/04/28/%E8%87%B4%E4%B8%B4%E5%AE%89/"/>
    <id>http://www.echodemo.cc/2018/04/28/致临安/</id>
    <published>2018-04-28T03:03:11.000Z</published>
    <updated>2018-04-28T05:27:08.430Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;――――题记</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起临安，我会想起什么呢？虽然彼此素未谋面。但我在许嵩的《断桥残雪》里；在柳永的《望海潮》中；从“暖风熏得游人醉，直把杭州作汴州”和“小楼一夜听春雨，深巷明朝卖杏花”那里面窥见的临安城是如此地楚楚动人，惹人喜爱。曾经这样想过：选择了一座城是否就选择了一种生活的方式？后来，自己给出的答案是肯定的。因为外界环境从始至终都会或多或少地影响一个人的心情和状态。再者我想：如果可以在自己喜欢的城市里柴米油盐地生活，便是一种极大的愉悦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;喜欢一座城，可以具备一定的缘由，或许也可以不问因果。我对杭州起初的向往就像三毛之于撒哈拉一样，怀着一种非此地不居的想法，犹如冥冥之中的神秘引力，让我们彼此惺惺相（吸）。还记得多年以前《新白娘子传奇》中那断桥上的油纸伞吗？还记得杨万里的那句“接天莲叶无穷碧，映日荷花别样红”吗？这其中哪个是我第一次接触到的有关于杭州的记忆，我又是从什么时候起拥有了对杭州的执念，这些都难以追溯。但我知道是什么促进了，加强了甚至是升华了我对杭州的喜爱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杭州自秦朝设县治以来已有2200多年的历史，曾是吴越国和南宋的都城，因风景秀丽，素有“人间天堂”的美誉。杭州之名从“秦时明月汉时关”里属会稽郡的钱唐，到东汉属吴郡的钱唐，到三国和两晋时期属吴郡但却归于古扬州的钱唐，再到后来隋朝时期“杭州”二字的首次登台，再到为避唐朝国号之讳将此“唐”改为彼“塘”。就这样等到五代十国时期一过，由于先前运河的修建，水利的兴修。杭州便迎来了在中国历史上的全盛时期，也就是宋王朝。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，正如你所看到的，上面这一大段大多都是百度百科里的东西。我所想抓住的便是其中的一个宋字。从北宋到南宋，用“钱塘自古繁华”一句来讲我想是恰当的。这些从张择端的《清明上河图》中便可见一斑。谈及北宋，作为苏子瞻这位诗词大文豪的铁杆粉丝，我想这里对他的记录是必不可少的。苏子瞻是四川眉州眉山人，凭借其清心洒脱、豪放不羁的文采征服了当时的文坛领袖欧阳修。在欧阳修的赏识之下，作为初唐宰相苏味道之后的苏子瞻，作为后来唐宋八大家苏氏一家独占三个名额的苏子瞻。顿时便名声大噪。无奈当时王安石变法如火如荼，但苏子瞻的很多师友，包括他自己在内也与王安石集团政见不和。于是遭受排挤在所难免。熙宁四年（1071年），苏子瞻上书皇帝谈论新法之弊病。遭王安石集团之不满，于是请求出京任职，被授为杭州通判。此后历经乌台诗案，被贬黄州。后因神宗驾崩，哲宗即位，高太后把持朝政（其对苏子瞻颇为赏识）。因此，从复为朝奉郎知登州（蓬莱），到以礼部郎中被召还朝，到升为起居舍人，到中书舍人，再到升翰林学士、知制诰，知礼部贡举。虽然苏子瞻一路高歌猛进，但当他发现司马光集团与原来的王安石集团不过是一丘之貉时，便再次向朝廷提出谏议，也因此再次遭受排挤。元祐四年也就是公元1089年，苏子瞻再度自求外调，任龙图阁学士、知杭州。苏子瞻这两次为官在杭州一共呆了5年，这五年我想应是他仕途当中最快乐的时光。远离了政治的中心，远离了朝局，没有了勾心斗角、尔虞我诈。有的是关心民瘼，赈济灾民，兴修水利，浚治西湖。因此也深受杭州百姓的爱戴。他也在闲暇之余，纵情山水之间，其足迹遍及西湖山水、园林、寺庙等等。留下了颇多的传说、题名、碑刻和诗词。作为诗人和词人，这无疑是一种莫大的享受。可以说苏子瞻为杭州的历史和文化底蕴增添了浓墨重彩的一笔。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起苏堤当然还有白堤，说起词人当然还有柳永，说起诗人当然还有陆游，除了北宋当然还有南宋。靖康之变后，徽钦二帝被俘，北宋沦亡，为金朝所灭。宋高宗赵构定都临安府。或许曾经的宋高宗也为临安的气质所折服才愿意在此偏安一隅吧。想起800多年前的岳鹏举怀着满腔的热血和报国之志踏上这片美丽而又繁华的土地，是否也会驻足回望，为临安的所有而惊艳。常年征战在外的他；身处军营和刀光剑影里的他；写下气势磅礴，英勇而悲壮的《满江红》的他；到头来却被奸佞所诬陷，高宗所猜忌的他。是否也曾在满月的夜里，想着能够和家人在类似于临安的城里共度余生。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对杭州的眷恋，想来与这些早已故去却一直存在的烟云有着莫大的关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1009 说反话</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1009-说反话/</id>
    <published>2018-04-26T13:09:20.000Z</published>
    <updated>2018-04-28T07:19:25.482Z</updated>
    
    <content type="html"><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p><p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p><pre><code>输入样例：Hello World Here I Come输出样例：Come I Here World Hello</code></pre><p>题目代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() {    stack&lt;string&gt; s;    string a;    while(cin &gt;&gt; a) s.push(a);    cout &lt;&lt; s.top();    s.pop();    while(!s.empty()) {        cout &lt;&lt; &quot; &quot; &lt;&lt; s.top();        s.pop();    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。&lt;/p&gt;
&lt;p&gt;输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1008 数组元素循环右移问题</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1008-数组元素循环右移问题/</id>
    <published>2018-04-26T12:55:19.000Z</published>
    <updated>2018-04-26T12:57:47.143Z</updated>
    
    <content type="html"><![CDATA[<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数,<br>之间用空格分隔。</p><p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><pre><code>输入样例：6 21 2 3 4 5 6输出样例：5 6 1 2 3 4</code></pre><p>题目代码：本题需要注意的是当移动的次数为0，为N或者大于N的特殊情况。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main() {  int N, M;  cin &gt;&gt; N &gt;&gt; M;  vector&lt;int&gt; a(N);  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; a[i];  }  if (M != 0 &amp;&amp; M != N) {    if (M &gt; N) M = M%N;    reverse(a.begin(), a.begin() + N - M);//将前面的N-M位进行反转    reverse(a.begin() + N - M, a.end());//将后面的M位进行反转    reverse(a.begin(), a.end());//将整个数组进行反转  }  for (int i = 0;i &lt; N;i++) {    cout &lt;&lt; a[i];    if (i &lt; N - 1) cout &lt;&lt; &quot; &quot;;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个数组A中存有N（N&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&amp;gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1007 素数对猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1007-素数对猜想/</id>
    <published>2018-04-26T12:18:15.000Z</published>
    <updated>2018-04-26T12:18:47.987Z</updated>
    
    <content type="html"><![CDATA[<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p><p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p><pre><code>输入样例：20输出样例：4</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;bool isPrime(int n) {//判定是否为素数  if (n &lt;= 1) return false;  for (int i = 2;i*i &lt;= n;i++) {    if (n % i == 0) return false;  }  return true;}int main() {  int n, num = 0;  cin &gt;&gt; n;  for (int i = 5;i &lt;= n;i++) {    if (isPrime(i - 2) &amp;&amp; isPrime(i))      num++;//如果相差2的两个数均为素数，则num自增1  }  cout &lt;&lt; num;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&amp;gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&amp;lt; 105)，请计算不超过N的满足猜想的素数对的个数。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1006 换个格式输出整数</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1006-换个格式输出整数/</id>
    <published>2018-04-26T03:39:02.000Z</published>
    <updated>2018-04-26T03:43:20.267Z</updated>
    
    <content type="html"><![CDATA[<p>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。</p><p>输出格式：每个测试用例的输出占一行，用规定的格式输出n。</p><pre><code>输入样例1：234输出样例1：BBSSS1234输入样例2：23输出样例2：SS123</code></pre><p>题目代码：此题也可以直接输出没有必要创建一个string类型的数据。个十百位也可以使用数组来进行保存。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  int n, g, s = 0, b = 0;  cin &gt;&gt; n;  g = n % 10;//个位  n /= 10;  if (n) s = n % 10;//十位  n /= 10;  if (n) b = n % 10;//百位  string str;  while (b) {    str += &apos;B&apos;;    b--;  }  while (s) {    str += &apos;S&apos;;    s--;  }  for (int i = 1;i &lt;= g;i++) {    str +=(i+&apos;0&apos;);  }  cout &lt;&lt; str;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&amp;lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1005 继续(3n+1)猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1005-继续(3n+1)猜想/</id>
    <published>2018-04-26T03:11:34.000Z</published>
    <updated>2018-04-26T03:13:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p><p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p><pre><code>输入样例：63 5 6 7 8 11输出样例：7 6</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool cmp(int a, int b) {  return a &gt; b;}int arr[10000];//全局数组默认值为0int main() {  int k, n;  cin &gt;&gt; k;  vector&lt;int&gt; v(k);  for (int i = 0;i &lt; k;i++) {    cin &gt;&gt; n;    v[i] = n;//初始化动态数组    while (n != 1) {      if (n % 2 == 0)        n /= 2;      else        n = (3 * n + 1) / 2;      arr[n] = 1;//将所有元素会覆盖的值加入arr当中,1表示覆盖过    }  }  sort(v.begin(), v.end(), cmp);//将动态数组元素从大到小排序  //用于判定是否输出空格(此处由于无法预知未曾遍历的数组元素当中是否存在没有被覆盖的情况，只好将空格的输出判定放在已经确定的未被覆盖元素之前)  int flag = 0;  for (int i = 0;i &lt; v.size();i++) {//遍历整个数组    if (!arr[v[i]]) {      if (flag == 1) cout &lt;&lt; &quot; &quot;;      cout &lt;&lt; v[i];      flag = 1;    }      }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。&lt;/p&gt;
&lt;p&gt;当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢夜是寂静的</title>
    <link href="http://www.echodemo.cc/2018/04/25/%E6%88%91%E5%96%9C%E6%AC%A2%E5%A4%9C%E6%98%AF%E5%AF%82%E9%9D%99%E7%9A%84/"/>
    <id>http://www.echodemo.cc/2018/04/25/我喜欢夜是寂静的/</id>
    <published>2018-04-25T14:11:09.000Z</published>
    <updated>2018-04-25T14:18:24.864Z</updated>
    
    <content type="html"><![CDATA[<p>我喜欢夜是寂静的</p><p>那遥远的地方跑过来的黑夜</p><p>喃喃地呼唤我</p><p>将我揽入她的怀抱</p><p><br><br>她也叫来昏黄的路灯</p><p>挂在我的头上</p><p>头顶再遥远的地方</p><p>淡淡的星子在闪</p><p>四周里安静无声，那是因为</p><p>夜，也喜欢我是寂静着的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我喜欢夜是寂静的&lt;/p&gt;
&lt;p&gt;那遥远的地方跑过来的黑夜&lt;/p&gt;
&lt;p&gt;喃喃地呼唤我&lt;/p&gt;
&lt;p&gt;将我揽入她的怀抱&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;她也叫来昏黄的路灯&lt;/p&gt;
&lt;p&gt;挂在我的头上&lt;/p&gt;
&lt;p&gt;头顶再遥远的地方&lt;/p&gt;
&lt;p&gt;淡淡的星子在闪&lt;/p&gt;
&lt;p&gt;四
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 二进制中有多少个1</title>
    <link href="http://www.echodemo.cc/2018/04/23/LintCode-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/"/>
    <id>http://www.echodemo.cc/2018/04/23/LintCode-二进制中有多少个1/</id>
    <published>2018-04-23T08:59:23.000Z</published>
    <updated>2018-04-23T09:13:06.117Z</updated>
    
    <content type="html"><![CDATA[<p>计算在一个 32 位的整数的二进制表示中有多少个 1.</p><p>样例</p><pre><code>给定 32 (100000)，返回 1给定 5 (101)，返回 2给定 1023 (1111111111)，返回 10</code></pre><p>代码一：此题如果采用的是移位的方法，那么这里唯一需要注意的是当给定的测试用例是负数的时候要先计算位于负号位的1，然后转化为正整数之后再进行移位的操作和计数。</p><pre><code>int countOnes(int num) {    int count = 0;    if (num &lt; 0) {        count++;        num = num ^ 0x80000000;    }    while (num &gt; 0) {        if (num &amp; 1) {            count++;          }        num = num &gt;&gt; 1;    }    return count;}</code></pre><p>代码二：这种方法还是比较巧妙，这里的数字本身和减一之后的数相与让我想起了计算数是否为2的幂次的程序。</p><pre><code>int countOnes(int num){    int count = 0;    while(num){        num = num &amp; (num-1);        count++;    }    return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算在一个 32 位的整数的二进制表示中有多少个 1.&lt;/p&gt;
&lt;p&gt;样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 32 (100000)，返回 1

给定 5 (101)，返回 2

给定 1023 (1111111111)，返回 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码一
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LintCode" scheme="http://www.echodemo.cc/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1004 成绩排名</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1004-成绩排名/</id>
    <published>2018-04-21T11:57:45.000Z</published>
    <updated>2018-04-25T14:58:45.338Z</updated>
    
    <content type="html"><![CDATA[<p>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><p>输入格式：每个测试输入包含1个测试用例，格式为</p><pre><code>第1行：正整数n第2行：第1个学生的姓名 学号 成绩第3行：第2个学生的姓名 学号 成绩... ... ...第n+1行：第n个学生的姓名 学号 成绩</code></pre><p>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><p>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p><pre><code>输入样例：3Joe Math990112 89Mike CS991301 100Mary EE990830 95输出样例：Mike CS991301Joe Math990112</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    int n, score, maxscore = -1, minscore = 101;    string name, number, maxname, minname, maxnumber, minnumber;    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; name &gt;&gt; number &gt;&gt; score;        if (score &gt; maxscore) {            maxscore = score;            maxname = name;            maxnumber = number;        }        if (score &lt; minscore) {            minscore = score;            minname = name;            minnumber = number;        }    }    cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnumber &lt;&lt; endl;    cout &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnumber;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，格式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第1行：正整数n
第2行：第1个学生的姓名 学号 成绩
第3行：第2个学生的姓名 学号 成绩
... .
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1003 我要通过！</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1003-我要通过！/</id>
    <published>2018-04-21T07:32:58.000Z</published>
    <updated>2018-04-25T14:58:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：</p><ol><li><p>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</p></li><li><p>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</p></li><li><p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</p></li></ol><p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p><p>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p><p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p><pre><code>输入样例：8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA输出样例：YESYESYESYESNONONONO</code></pre><p>分析：这种题目切不可仓促下笔，需要根据题目给出的条件分析清楚其中潜藏的规律。最好的方法就是使用输入输出样例当中的正确样例进行代入当然也可以自行多加一些样例来让结果更直观。此题的条件一可以说是一目了然，就没有代入的必要了。重点在于条件二和条件三。</p><p>条件二：任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举出以下皆正确的样例：</p><pre><code>PATAPATAAAPATAAAAAPATAAAAAAAPATAAAA...</code></pre><p>从中可以得出：在字符’PAT’的前面和后面添加任意相等个数的字符’A’即可满足条件二。</p><p>条件三：如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举以下样例：</p><pre><code>PATPAATPAAAAATAPATAAPAATAAAPAAATAAAAAPATAAAAPAATAAAAAAPAAATAAAAAA</code></pre><p>总结来说：只能有一个P一个T，中间末尾和开头可以随便插入A。但是必须满足开头的A的个数 * 中间的A的个数 = 结尾的A的个数。</p><pre><code>#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() {    int n, p = 0, t = 0;    string s;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) {        cin &gt;&gt; s;        map&lt;char, int&gt; m;        for(int j = 0; j &lt; s.size(); j++) {            m[s[j]]++;            if (s[j] == &apos;P&apos;) p = j;            if (s[j] == &apos;T&apos;) t = j;        }        if(m[&apos;P&apos;] == 1 &amp;&amp; m[&apos;A&apos;] != 0 &amp;&amp; m[&apos;T&apos;] == 1 &amp;&amp; m.size() == 3 &amp;&amp; p * (t-p-1) == s.length()-t-1)            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符串中必须仅有P, A, T这三种字符，不可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
</feed>
