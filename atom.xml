<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-26T03:13:24.838Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT B1005 继续(3n+1)猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1005-继续(3n+1)猜想/</id>
    <published>2018-04-26T03:11:34.000Z</published>
    <updated>2018-04-26T03:13:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p><p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p><pre><code>输入样例：63 5 6 7 8 11输出样例：7 6</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool cmp(int a, int b) {  return a &gt; b;}int arr[10000];//全局数组默认值为0int main() {  int k, n;  cin &gt;&gt; k;  vector&lt;int&gt; v(k);  for (int i = 0;i &lt; k;i++) {    cin &gt;&gt; n;    v[i] = n;//初始化动态数组    while (n != 1) {      if (n % 2 == 0)        n /= 2;      else        n = (3 * n + 1) / 2;      arr[n] = 1;//将所有元素会覆盖的值加入arr当中,1表示覆盖过    }  }  sort(v.begin(), v.end(), cmp);//将动态数组元素从大到小排序  //用于判定是否输出空格(此处由于无法预知未曾遍历的数组元素当中是否存在没有被覆盖的情况，只好将空格的输出判定放在已经确定的未被覆盖元素之前)  int flag = 0;  for (int i = 0;i &lt; v.size();i++) {//遍历整个数组    if (!arr[v[i]]) {      if (flag == 1) cout &lt;&lt; &quot; &quot;;      cout &lt;&lt; v[i];      flag = 1;    }      }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。&lt;/p&gt;
&lt;p&gt;当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢夜是寂静的</title>
    <link href="http://www.echodemo.cc/2018/04/25/%E6%88%91%E5%96%9C%E6%AC%A2%E5%A4%9C%E6%98%AF%E5%AF%82%E9%9D%99%E7%9A%84/"/>
    <id>http://www.echodemo.cc/2018/04/25/我喜欢夜是寂静的/</id>
    <published>2018-04-25T14:11:09.000Z</published>
    <updated>2018-04-25T14:18:24.864Z</updated>
    
    <content type="html"><![CDATA[<p>我喜欢夜是寂静的</p><p>那遥远的地方跑过来的黑夜</p><p>喃喃地呼唤我</p><p>将我揽入她的怀抱</p><p><br><br>她也叫来昏黄的路灯</p><p>挂在我的头上</p><p>头顶再遥远的地方</p><p>淡淡的星子在闪</p><p>四周里安静无声，那是因为</p><p>夜，也喜欢我是寂静着的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我喜欢夜是寂静的&lt;/p&gt;
&lt;p&gt;那遥远的地方跑过来的黑夜&lt;/p&gt;
&lt;p&gt;喃喃地呼唤我&lt;/p&gt;
&lt;p&gt;将我揽入她的怀抱&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;她也叫来昏黄的路灯&lt;/p&gt;
&lt;p&gt;挂在我的头上&lt;/p&gt;
&lt;p&gt;头顶再遥远的地方&lt;/p&gt;
&lt;p&gt;淡淡的星子在闪&lt;/p&gt;
&lt;p&gt;四
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 二进制中有多少个1</title>
    <link href="http://www.echodemo.cc/2018/04/23/LintCode-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/"/>
    <id>http://www.echodemo.cc/2018/04/23/LintCode-二进制中有多少个1/</id>
    <published>2018-04-23T08:59:23.000Z</published>
    <updated>2018-04-23T09:13:06.117Z</updated>
    
    <content type="html"><![CDATA[<p>计算在一个 32 位的整数的二进制表示中有多少个 1.</p><p>样例</p><pre><code>给定 32 (100000)，返回 1给定 5 (101)，返回 2给定 1023 (1111111111)，返回 10</code></pre><p>代码一：此题如果采用的是移位的方法，那么这里唯一需要注意的是当给定的测试用例是负数的时候要先计算位于负号位的1，然后转化为正整数之后再进行移位的操作和计数。</p><pre><code>int countOnes(int num) {    int count = 0;    if (num &lt; 0) {        count++;        num = num ^ 0x80000000;    }    while (num &gt; 0) {        if (num &amp; 1) {            count++;          }        num = num &gt;&gt; 1;    }    return count;}</code></pre><p>代码二：这种方法还是比较巧妙，这里的数字本身和减一之后的数相与让我想起了计算数是否为2的幂次的程序。</p><pre><code>int countOnes(int num){    int count = 0;    while(num){        num = num &amp; (num-1);        count++;    }    return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算在一个 32 位的整数的二进制表示中有多少个 1.&lt;/p&gt;
&lt;p&gt;样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 32 (100000)，返回 1

给定 5 (101)，返回 2

给定 1023 (1111111111)，返回 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码一
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LintCode" scheme="http://www.echodemo.cc/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1004 成绩排名</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1004-成绩排名/</id>
    <published>2018-04-21T11:57:45.000Z</published>
    <updated>2018-04-25T14:58:45.338Z</updated>
    
    <content type="html"><![CDATA[<p>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><p>输入格式：每个测试输入包含1个测试用例，格式为</p><pre><code>第1行：正整数n第2行：第1个学生的姓名 学号 成绩第3行：第2个学生的姓名 学号 成绩... ... ...第n+1行：第n个学生的姓名 学号 成绩</code></pre><p>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><p>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p><pre><code>输入样例：3Joe Math990112 89Mike CS991301 100Mary EE990830 95输出样例：Mike CS991301Joe Math990112</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    int n, score, maxscore = -1, minscore = 101;    string name, number, maxname, minname, maxnumber, minnumber;    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; name &gt;&gt; number &gt;&gt; score;        if (score &gt; maxscore) {            maxscore = score;            maxname = name;            maxnumber = number;        }        if (score &lt; minscore) {            minscore = score;            minname = name;            minnumber = number;        }    }    cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnumber &lt;&lt; endl;    cout &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnumber;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，格式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第1行：正整数n
第2行：第1个学生的姓名 学号 成绩
第3行：第2个学生的姓名 学号 成绩
... .
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1003 我要通过！</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1003-我要通过！/</id>
    <published>2018-04-21T07:32:58.000Z</published>
    <updated>2018-04-25T14:58:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：</p><ol><li><p>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</p></li><li><p>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</p></li><li><p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</p></li></ol><p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p><p>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p><p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p><pre><code>输入样例：8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA输出样例：YESYESYESYESNONONONO</code></pre><p>分析：这种题目切不可仓促下笔，需要根据题目给出的条件分析清楚其中潜藏的规律。最好的方法就是使用输入输出样例当中的正确样例进行代入当然也可以自行多加一些样例来让结果更直观。此题的条件一可以说是一目了然，就没有代入的必要了。重点在于条件二和条件三。</p><p>条件二：任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举出以下皆正确的样例：</p><pre><code>PATAPATAAAPATAAAAAPATAAAAAAAPATAAAA...</code></pre><p>从中可以得出：在字符’PAT’的前面和后面添加任意相等个数的字符’A’即可满足条件二。</p><p>条件三：如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举以下样例：</p><pre><code>PATPAATPAAAAATAPATAAPAATAAAPAAATAAAAAPATAAAAPAATAAAAAAPAAATAAAAAA</code></pre><p>总结来说：只能有一个P一个T，中间末尾和开头可以随便插入A。但是必须满足开头的A的个数 * 中间的A的个数 = 结尾的A的个数。</p><pre><code>#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() {    int n, p = 0, t = 0;    string s;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) {        cin &gt;&gt; s;        map&lt;char, int&gt; m;        for(int j = 0; j &lt; s.size(); j++) {            m[s[j]]++;            if (s[j] == &apos;P&apos;) p = j;            if (s[j] == &apos;T&apos;) t = j;        }        if(m[&apos;P&apos;] == 1 &amp;&amp; m[&apos;A&apos;] != 0 &amp;&amp; m[&apos;T&apos;] == 1 &amp;&amp; m.size() == 3 &amp;&amp; p * (t-p-1) == s.length()-t-1)            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符串中必须仅有P, A, T这三种字符，不可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1002 写出这个数</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1002-写出这个数/</id>
    <published>2018-04-21T03:10:23.000Z</published>
    <updated>2018-04-21T03:12:13.025Z</updated>
    
    <content type="html"><![CDATA[<p>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100。</p><p>输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。</p><pre><code>输入样例：1234567890987654321123456789输出样例：yi san wu</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  string s;  cin &gt;&gt; s;  string str[10] = { &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; };  int sum = 0;  for (int i = 0;i &lt; s.length();i++) {    sum += (s[i] - &apos;0&apos;);  }  string number = to_string(sum);  for (int i = 0;i &lt; number.length();i++) {    cout &lt;&lt; str[number[i] - &apos;0&apos;];    if (i &lt; (number.length()-1)) cout &lt;&lt; &quot; &quot;;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100。&lt;/p&gt;
&lt;p&gt;输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1001 害死人不偿命的(3n+1)猜想</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1001-害死人不偿命的(3n+1)猜想/</id>
    <published>2018-04-21T02:26:45.000Z</published>
    <updated>2018-04-21T02:30:24.438Z</updated>
    
    <content type="html"><![CDATA[<pre><code>卡拉兹(Callatz)猜想：</code></pre><p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p><p>输出格式：输出从n计算到1需要的步数。</p><pre><code>输入样例：3输出样例：5</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {    int n, num = 0;    cin &gt;&gt; n;    while (n != 1) {        if (n % 2 == 0) n /= 2;        else n = (3 * n + 1) / 2;        num++;    }    cout &lt;&lt; num;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;卡拉兹(Callatz)猜想：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>最长不下降子序列</title>
    <link href="http://www.echodemo.cc/2018/04/21/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/21/最长不下降子序列/</id>
    <published>2018-04-21T01:35:56.000Z</published>
    <updated>2018-04-21T02:03:39.927Z</updated>
    
    <content type="html"><![CDATA[<p>在一个数字序列中，找到一个最长的子序列(可以不连续)，使得这个子序列是不下降(非递减)的。</p><p>分析：此题如若采用暴力的方法来解答，即对于每个元素有取或是不取两种选择，时间复杂度可以达到O(2^n)。</p><p>令dp[i]表示以A[i]结尾的最长不下降子序列长度(和最大连续子序列和问题一样，以A[i]结尾是强制的要求)。此时会有两种情况：一种是存在A[i]之前的元素A<a href="j&lt;i">j</a>，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp<a href="需要说明的是，这个dp[i]是边界条件或者是A[j]前面的元素在以A[i]结尾的LIS形成的dp[i]">i</a>,那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列(dp[i]=dp[j]+1)；另一种是A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS，此时的长度为1。则其状态转移方程为：dp[i]=max(1,dp[j]+1)(j=1,2,…,i-1&amp;&amp;A[j]&lt;A[i])，其边界条件就为：dp[i]=1(1&lt;=i&lt;=n)。其整体复杂度为O(n^2)。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;const int N=100;int A[N],dp[N];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;A[i];    }    int num=-1;    for(int i=1;i&lt;=n;i++){        dp[i]=1;//边界初始条件        for(int j=1;j&lt;i;j++){            if((A[i]&gt;=A[j])&amp;&amp;(dp[j]+1&gt;dp[i])){                dp[i]=dp[j]+1;            }        }        num=max(num,dp[i]);    }    cout&lt;&lt;num;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个数字序列中，找到一个最长的子序列(可以不连续)，使得这个子序列是不下降(非递减)的。&lt;/p&gt;
&lt;p&gt;分析：此题如若采用暴力的方法来解答，即对于每个元素有取或是不取两种选择，时间复杂度可以达到O(2^n)。&lt;/p&gt;
&lt;p&gt;令dp[i]表示以A[i]结尾的最长不下降子序列
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大连续子序列的和</title>
    <link href="http://www.echodemo.cc/2018/04/20/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%92%8C/"/>
    <id>http://www.echodemo.cc/2018/04/20/最大连续子序列的和/</id>
    <published>2018-04-20T14:59:34.000Z</published>
    <updated>2018-04-20T15:33:51.949Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数字序列A1，A2，…，An，求i,j(1&lt;=i&lt;=j&lt;=n)，使得Ai+…+Aj最大，输出这个最大的和。</p><p>分析：这个问题如若暴力来做，枚举i,j需要O(n^2)的复杂度，而计算A[i]+…+A[j]需要O(n)的复杂度，因此总的复杂度为O(n^3)。就算采用记录前缀和的方法(预处理S[i]=A[0]+A[1]+…+A[i],这样A[i]+…+A[j]=S[j]-S[i-1])使计算的时间变为O(1)，总的复杂度仍然有O(n^2)。</p><p>这里介绍动态规划的做法，复杂度为O(n)。令状态dp[i]表示以A[i]作为末尾的连续序列的最大和(这里的连续指的是从第一个元素开始)。其实所要求的最大和就是dp数组中的最大值。也就是说求dp[i]时，只要dp[i-1]小于零就舍弃前面的和，直接取A[i]的值作为dp[i]即可；而如果dp[i-1]大于零，dp[i]就等于dp[i-1]+A[i]。于是得到dp[i]=max(A[i],dp[i-1]+A[i])。而边界就是dp[0]=A[0]。</p><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10010;int A[maxn], dp[maxn];int main() {    int n;    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; A[i];    }    dp[0] = A[0];//边界    for (int i = 0;i &lt; n;i++) {        dp[i] = max(A[i], dp[i - 1] + A[i]);//状态转移方程    }    int k = 0;    for (int i = 1;i &lt; n;i++) {        if (dp[i] &gt; dp[k])            k = i;    }    cout &lt;&lt; dp[k];    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数字序列A1，A2，…，An，求i,j(1&amp;lt;=i&amp;lt;=j&amp;lt;=n)，使得Ai+…+Aj最大，输出这个最大的和。&lt;/p&gt;
&lt;p&gt;分析：这个问题如若暴力来做，枚举i,j需要O(n^2)的复杂度，而计算A[i]+…+A[j]需要O(n)的复杂度，因此总的复杂
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://www.echodemo.cc/2018/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.echodemo.cc/2018/04/20/动态规划/</id>
    <published>2018-04-20T04:38:20.000Z</published>
    <updated>2018-04-20T04:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：</p><pre><code>int F(int n){    if(n==0||n==1) return 1;    else return F(n-1)+F(n-2);}</code></pre><p>然而上述代码会涉及很多的重复计算，由于没有对中间计算的结果进行保存，实际复杂度会高达O(2^n)。这里通过开一个数组来对已计算出来的数据进行保存。</p><pre><code>int dp[max];int F(int n){    if(n==0||n==1) return 1;    if(dp[n]!=-1) return dp[n];    else{        dp[n]=F(n-1)+F(n-2);        return dp[n];    }}</code></pre><p>这样可以将复杂度从O(2^n)降到O(n)。如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有重叠子问题。因此，一个问题必须拥有重叠子问题，才能使用动态规划进行求解。</p><p>2、动态规划的递推写法：其使用的计算方式是自底向上，即从边界开始，不断向上解决问题，直到解决了目标问题为止；而递归写法是自顶向下，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止。以经典的数塔问题为例</p><p>首先开一个二维数组array[i][j]对每层的数据进行存放，由于除第一层之外，每一层都至少会有一条重合的路径。不妨零dp[i][j]表示从第i行第j个数字出发到达最底层的所有路径中能得到的最大和。也就会有dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j]。这里把dp[i][j]称为问题的状态，把这个式子称为状态转移方程。数塔的边界是dp[n][j]==array[n][j]，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn=1000;int array[maxn][maxn],dp[maxn][maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=i;j++){            cin&gt;&gt;array[i][j];//初始化数塔        }    }    for(int i=1;i&lt;=n;i++){//边界        dp[n][i]=array[n][i];    }    for(int i=n-1;i&gt;=1;i--){        for(int j=1;j&lt;=i;j++){            dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j];//状态转移方程        }    }    cout&lt;&lt;dp[1][1];    return 0}</code></pre><p>如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么就称这个问题拥有最优子结构。因此，一个问题必须拥有最优子结构，才能使用动态规划进行求解。</p><p>3、两组概念的区分</p><p>(1)分治和动态规划</p><p>分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题。</p><p>(2)贪心和动态规划</p><p>贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程对数塔问题而言，贪心法从最上层开始，每次选择左下和右上两个数字中较大的一个，一直到最底层得到最后的结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶下下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，他总是会考虑所有的子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士割腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int F(int n){
    if(n==0||n==1) return 1;
    else return
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1002 A+B for Polynomials</title>
    <link href="http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/"/>
    <id>http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/</id>
    <published>2018-04-13T13:49:02.000Z</published>
    <updated>2018-04-13T13:57:54.726Z</updated>
    
    <content type="html"><![CDATA[<p>This time, you are supposed to find A+B where A and B are two polynomials.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p><p>Output Specification:</p><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><pre><code>Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output3 2 1.5 1 2.9 0 3.2</code></pre><p>此题在一开始写的时候没有注意到当输出系数不为零的个数为0时的情况，故导致格式错误。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main() {    double a[1001] = { 0.0 }, b[1001] = { 0.0 }, c[1001] = { 0.0 };    int m, n;    cin &gt;&gt; m;    for (int i = 0;i &lt; m;i++) {//初始化第一个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; a[j];        c[j] += a[j];    }    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {//初始化第二个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; b[j];        c[j] += b[j];    }    int num = 0;    for (int i = 0;i &lt; 1001;i++) {//计算系数非零的个数        if (c[i] != 0) num++;    }    cout &lt;&lt; num;    if (num != 0) cout &lt;&lt; &quot; &quot;;//这里需要注意    for (int i = 1000;i &gt;= 0;i--) {        if (c[i] == 0) continue;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;        printf(&quot;%.1f&quot;, c[i]);        num--;        if (num != 0) cout &lt;&lt; &quot; &quot;;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;/p&gt;
&lt;p&gt;Each input file contains on
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1001 A+B Format</title>
    <link href="http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/"/>
    <id>http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/</id>
    <published>2018-04-12T09:09:21.000Z</published>
    <updated>2018-04-12T09:51:44.778Z</updated>
    
    <content type="html"><![CDATA[<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><p>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p><p>Output Specification:</p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><pre><code>Sample Input-1000000 9Sample Output-999,991</code></pre><p>此题使用如下代码在PAT测试时出现一个段错误。如有大佬光临寒舍，还望多多指教。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;using namespace std;int main() {    int a, b,sum=0;    cin &gt;&gt; a &gt;&gt; b;    sum = a + b;    if (sum &lt; 0) cout &lt;&lt; &quot;-&quot;;//和为负数，就先把负号输出    sum = (sum &lt; 0) ? -sum : sum;//求绝对值    stack&lt;char&gt; s;    int num = 0;    while (sum) {        s.push((sum % 10)+&apos;0&apos;);//从最低位开始入栈        num++;//统计sum中各个位入栈的个数        if (num % 3 == 0) s.push(&apos;,&apos;);//每当sum的位入栈三次，就把‘，’入栈        sum /= 10;    }    if (s.top() == &apos;,&apos;) s.pop();//如果全栈最顶为‘，’，则直接出栈    while (!s.empty()) {        cout &lt;&lt; s.top();//输出栈顶元素        s.pop();//栈顶元素出栈    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless ther
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2018/04/08/梦境/</id>
    <published>2018-04-08T04:45:29.000Z</published>
    <updated>2018-04-08T04:47:49.996Z</updated>
    
    <content type="html"><![CDATA[<p>夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一种方式，人在极度的恐惧当中，往往会表现出最本真的自己，没有压抑也没有伪装。人需要有所畏惧，有所敬畏，生于忧患，死于安乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1053 Path of Equal Weight</title>
    <link href="http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/"/>
    <id>http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/</id>
    <published>2018-04-08T02:12:36.000Z</published>
    <updated>2018-04-08T02:29:46.326Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p><p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt;= 100, the number of nodes in a tree, M (&lt; N), the number of non-leaf nodes, and 0 &lt; S &lt; 230, the given weight number. The next line contains N positive numbers where Wi (&lt;1000) corresponds to the tree node Ti. Then M lines follow,each in the format:</p><pre><code>ID K ID[1] ID[2] ... ID[K]</code></pre><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</p><p>Output Specification:</p><p>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p><p>Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &lt;= k &lt; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 &gt; Bk+1.</p><pre><code>Sample Input:20 9 2410 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 200 4 01 02 03 0402 1 0504 2 06 0703 3 11 12 1306 1 0907 2 08 1016 1 1513 3 14 16 1717 2 18 19Sample Output:10 5 2 710 4 1010 3 3 6 210 3 3 6 2</code></pre><p>题目大意：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be t
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>树的静态写法和遍历</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A0%91%E7%9A%84%E9%9D%99%E6%80%81%E5%86%99%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://www.echodemo.cc/2018/04/08/树的静态写法和遍历/</id>
    <published>2018-04-08T02:01:52.000Z</published>
    <updated>2018-04-08T02:04:13.825Z</updated>
    
    <content type="html"><![CDATA[<p>1、存储结构</p><p>由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态分配。</p><pre><code>struct node{    typename data;//数据域    vector&lt;typename&gt; child;//指针域，存放所有子节点的下标}Node[maxn];//节点数组，maxn为节点的上限个数</code></pre><p>2、新建一个节点</p><pre><code>int index=0;int newNode(int x){    Node[index].data=x;//数据域为x    Node[index].child.clear();//清空子节点    return index++;//返回节点下标，并令index自增}</code></pre><p>3、先根遍历</p><pre><code>void preOrder(int root){    cout&lt;&lt;Node[root].data&lt;&lt;&quot; &quot;;//访问当前节点    for(int i=0;i&lt;Node[root].child.size();i++){        preOrder(Node[root].child[i]);//递归访问节点root的所有子节点    }}</code></pre><p>4、层序遍历</p><pre><code>void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre><p>如果需要计算每个节点的层次，存储结构和层序遍历如下：</p><pre><code>struct node{    int layer;    typename data;    vector&lt;typename&gt; child;}void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    Node[root].layer=1;    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            Node[Node[now].child[i]].layer=Node[now].layer+1;//子节点的层数加1            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、存储结构&lt;/p&gt;
&lt;p&gt;由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>平水韵(入声)</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E5%B9%B3%E6%B0%B4%E9%9F%B5(%E5%85%A5%E5%A3%B0)/"/>
    <id>http://www.echodemo.cc/2018/04/07/平水韵(入声)/</id>
    <published>2018-04-07T13:41:30.000Z</published>
    <updated>2018-04-07T13:52:25.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、一屋"><a href="#1、一屋" class="headerlink" title="1、一屋"></a>1、一屋</h2><p>竹 屋 谷 目 木 熟 菊 腹 哭 服 肉 独 福 速 逐 禄 鹿 麓 肃 轴 牧 宿[住宿] 卜 陆 六 族 筑 毂 祝 沐 斛 馥 穀 犊 掬 缩 築 牍 叔 读[读书] 粥 簇 蹙 复[往来也，返也] 育 秃 覆 碌 復 伏 穆 渎 戮 淑 蓄 縠 矗 扑 幅 镞 菽 漉 竺 燠 蓿 蔌 撲 瀑 曲[酒曲] 簌 椟 睦 鵩 鞠 鹜 觫 蹴 簏 蝠 黩 郁 霂 塾 澳 谡 夙 辘 餗 麴 恧 仆[群飞貌] 畜 榖 衄 洑 濮 蔔 槭 樕 毓 辐 朴 複 孰 匊 倏 浊 舳 醭 讟 樸 輻 鬻 僇 煜 角 蝮 稑 暴[日乾也] 箙 昱 彧 槲 曝 啄 鞫 朒 盝 韣 匐 睩 琭 龊 蓼 蹜 滀 毣 忸 鵴 瀫 俶 踧 袱 鹔 柷 澓 髑 輹 柚 搐 摝 瘯 慉 殰 鏕 碡 副[剖也，判也，裂也] 囿 菔 茯 薁 剭 螰 苜 踀 喌 嘼 蔟 虙 趚 骕 蹗 鱐 楅 贕 鵚 簶 閦 噈 缪[与穆同] 稢 虪 穋 觳 朷 告 葍 腛 勠 鋉 瑴 縬 濲 摍 藗 焀 蓛 熇 遬 汋[激水声也] 蹼 唷 唂 橚 趢 儥 蜟 拲 娽 坶 蔛 涑 樚 鶝 踾 跾 豖 匑 翏 錥 圥 鴔 趗 栜 棴 鮛 楘 蚞 襡 艒 纀 蕧 栿 獛 熝 嬻 躹 鵱 蔍 茿 剹 諔 踿 喐 韇 蓫 沑 鱁 蟏 梀 惐 梮 皾 莥 逳 箼 荲 騼 宓 騳 驧 潚 畐 斀 稪 萺 莤 玊 哊 鉐 鵦 癁 鉃 粶 丵 焂 埱 坴 襆 敊 涋 粷 喅 蓻 鱳 瓄珿  軮 鳆 踓 剢 犕 鑟 蔋 椈 嗀 聏 琡 鞪 鏉 蘛 鼀 疛 巈 淕 絥 鄜 齱 璛 淯 璹 樢 婅 蒮 斣 穙 鍙 趜 雮 偪 阿[阿谁] 疁 骲 篴 媨 罜 殐 掓 稶 嚛 磩 槒 膔 栯 礇 炑 鄐 鳪 轐 殧 塶 螜 閰 媉 棛 篫 諨 摵 椱 砡 樎 鎐 誎 垘 苖 婌 泦 椂 鐭 攴 堉 嗖 鯥 觷 觻</p><pre><code>其它僻字：</code></pre><p>䘵 䩮 䮷 䱙 䎘 䍡 䉛 䃤 䛢 㳤 㰗 㜚 䞱 䃙 㕰 㰲 㓘 䑿 㚆 䫝 㽤 㥔 䙒 㶖 䜡 㲫 㩋 㧅 䟿 䥮 䘻 㓐 䢱 䟟 䋭 䢗 㑉 䗇 䴪 䇚 䃞 㪩 䑁 䔎 㦇 䊾 䄾 䘐 䋹 㜙 㮋 䏋 㗤 㤢 䗛 㥌 䶊 䪁 㠅 㣎 㜅 㬼 䐨 㼾 䧤 䎌 䡜 䕮 䈸 䜯 䫳 㾄 䃚 㘲 䏱 㝛 䨱 䵈 㾥 㻃 㒔 䪕 䟮 䌒 䎼 㖨 㴼 䮱 䳱 㡔 㵀 䨹 㞺 䞽 㑐 㛬 䙯 㪶 㯟 䤋 㙏 䗱 䚼 䎑 㯈 㜈 䛙 䜼 䱡 䐿 㑛 㯷 䐁 䀰 㣃 㷤 㺉 䀲 㹼 㪖 䖡 㽇 㾇 㞘 㬘 䇍 㦽 𨌥 𪇰 𥪋 𪘏 𩶫 𠱙 𩋟 𣖫 𡡐 𧼭 𣨍 𩑒 𥲒 𥉑 𥳇 𡰿 𪃃 𣤶 𦪇 𤞞</p><h2 id="2、二沃"><a href="#2、二沃" class="headerlink" title="2、二沃"></a>2、二沃</h2><p>绿 玉 俗 烛 足 续 粟 束 促 辱 局 鹄 躅 欲 录 蜀 触 毒 浴 狱 旭 瞩 箓 属 酷 渌 醁 笃 沃 曲 赎 褥 斸 勖 督 嘱 溽 梏 缛 鹆 纛 菉 騄 蠋 蓐 瘃 峪 趣 牿 顼 仆 鄏 幞 裻 告 挶 鳿 喾 襮 歜 輂 斶 锔 鋈 逯 藚 媷 臅 虑 憟 匤 熇 臛 旮[同旭] 蛐 欘 趢 犦 哫 灟 拲 娽 傉 彳 鸀 駶 軉 筁 蝳 蠾 趗 髷 镤 薥 鋊 脨 砡 檋 琟 輍 頶 俈 捁 泶 斀 珛 钃 搙 潥 隺 絭 悎 觷 螸 傶 襡 钰 洬 嚛 錊 噣 孎 錖 誎 嗕 斣 襆 疁 梮 捒 蔋 鶮</p><pre><code>其它僻字：</code></pre><p>䠱 䪅 㯮 㒒 䒼 䟉 㮂 䥔 䌚 㙇 䞖 䶜 䎤 䌵 䜹 㻿 䞝 䧊 䕽 䙱 䐂 䳔 䡞 䚄 䑑 䅶 䋰 䚛 䛤 㫽 䱚 䴰 㩴 䴆 㿥 㔄 䧼 䅇 㦺 䈞 𤌍 𧰵 𧛔 𩌮 𤞞</p><h2 id="3、三觉"><a href="#3、三觉" class="headerlink" title="3、三觉"></a>3、三觉</h2><p>学 岳 朔 幄 渥 角 濯 邈 握 璞 剥 觉[知觉] 琢 确 卓 壳 雹 擢 鷟 槊 斲 荦 捉 驳 浊 喔 啄 榷 桷 数 [频数] 朴 駮 灂 诼 乐[音乐] 龊 樸 埆 搉 啅 镯 较 倬 珏 戳 鸑 涿 翯 鸴 跑 桌 踔 娖 鸐 硞 峃 椓 擉 药 浞 謈 悫 搦 碻[同确] 鋜 豰 懪 穱 欶 爆 瞀 瓝 偓 瑴 韄 嚗 傕 箾 穛 噣 眊 觳 搠 斠 斮 龌 掿 捔 趵 礐 蒴 烞 晫 洬 嗍 鵫 墣 蠗 窇 鞄 籗 瓁 悎 瞐 鞪 皃 汋 隺 鎙 劰 燢 豿 娕 礭 仢 欘 韷 泶 飑 矠 骲 楃 斀 丵 瞨 墧 鳆 硺 觷 腛 燩 棹[树 枝 直 上 貌] 钋 鑡 簎 菿 龏 敩 攴 顜 齺 篧 捳 髉 琸 珿 犦 籱 搻 壆 鳪 媉 齱 殐</p><pre><code>其它僻字：</code></pre><p>㧻 㲉 㩧 䃗 䓎 㙾 㰌 㓸 䂍 㮶 㼎 䈏 䑈 䁷 㰒 䃕 䪨 㔬 䮸 㱿 䦠 㙸 㺪 㹒 㿺 㺟 㪬 䇶 㱋 㹊 䨌 㴶 䡈 㦝 䥤 䮓 㵡 䥃 䠎 𥢔 𢁁 𩣡 𪑱 𦢊 𥭖 𢷏 𩺽 𥭓 𧲐 𧞐 𤓊 𧣚</p><h2 id="4、四质"><a href="#4、四质" class="headerlink" title="4、四质"></a>4、四质</h2><p>日 笔 室 一 失 密 术 实 術 疾 逸 律 毕 匹 膝 出 帙 漆 栗 溢 诘 七 橘 必 述 秩 吉 蜜 恤 瑟 乙 质 栉 秫 虱 蟀 荜 悉 慄 黜 弼 叱 潏 嵂 嫉 汩 朮 谧 戌 昵 窒 篥 镒 率 侄 怵 锧 骘 壹 卒[终也] 筚 绌 节 佚 苾 鹬 轶 跸 驲 茁 抶 桎 唧 姪 崒 獝 繂 沭 疋 韠 遹 繘 泆 罼 鳦 袐 铚 衵 蟋 凓 飋 聿 飶 霱 咥 蒺 袟 蔤 沏 泌 鴥 蛭 佾 訹 珌 妷 挃 鞸 礩 厔 耴 尼[近也，止也] 茟 肸 熚 觱 堲 翐 紩 桼 傈 瀄 踤 窋 姞 駜 溧 晊 帅 捽 矞 佶 拮 鷅 銊 馝 璱 饆 佖 荗 膟 鴄 眣 瓆 鬻 摔 圪 咭 沕 疙 宓 蛣 滭 枇[枇杷] 鉥 郅 鹎 銡 楖 怸 螲 怭 铋 滗 趌 黢 鱊 痆 窸 齣 滵 柣 庢 呹 箻 鷝 秷 峚 狤 珬 欪 祑 胵 螏 逫 蠠 秖 抳 塛 榓 跮 恎 絉 鮅 欰 炢 咰 趉 袕 揤 浂 擳 銉 肷 柫 衹 眰 比[比次也] 鏎 腟 僁 焌 搮 恄 箤 燏 鴓 笜 怷 麜 臷 鲒 豑 犵 臸 秪[与秖通，适也] 蝍 詄 瑮 郆 縪 妼 琗 寽 祇[适也，仅仅也] 嬄 宲 鶐 炪 鴶 邲 祗[与祇通，适也] 胇 欥 洷 柒 暨 彃 淧 樒 膣 魓 槉 鞊 櫍 驈 蹫 欯 釰 芛</p><pre><code>其它僻字：</code></pre><p>䫻 䁥 㗚 䘌 䭿 䬆 䟆 䎉 㘉 㾁 䮡 㔕 㯃 䢖 䫕 㵥 䮇 㪤 㺩 㻎 䒤 䏘 䑇 㓖 䶡 䵒 䢞 㗧 䬹 㻫 䬛 䳳 㟳 䔁 䩛 䢦 㚕 㣟 䬄 䣛 㴵 㮿 㜱 㜼 䱃 㑁 㤕 䢤 㞊 㫘 㣰 䄶 㻶 䔞 㳑 䌏 䡃 㧒 㢶 䤎 㳚 㰵 㗭 㘍 㳼 㮚 䱣 䟈 䏄 䆝 䘤 㔑 㢸 䜉 䳀 䰬 㺷 䋖 䜠 㳴 䖩 㻭 䵑 䢕 㗌 䟣 䤉 㖅 㑵 㲺 㤜 𥠈 𪗨 𥣮 𡢑 𧾣 𧫤 𧗿 𦝭 𦳯 𧽻 𢘍 𧾢 𩋡 𪗻</p><h2 id="5、五物"><a href="#5、五物" class="headerlink" title="5、五物"></a>5、五物</h2><p>物 佛 屈 拂 绂 乞 黻 綍 勿 绋 祓 诎 郁 讫 屹 茀 韨 倔 黦 咈 弗 歘 怫 髴 芴 欻 仡 蔚 刜 沕 崛 不[与弗同] 吃[言蹇难也] 掘 熨 岪 汔 迄 坲 镼 釳 厥[突厥] 魆 肸 艴[色怒也] 尉 岉 沷 菀 昒 忔 鶌 粅 灪 帗 炥 誳 鮄 芞 柭 爩 紑 嶏 蛂 昲 冹 莔 烼 袦 虳 柫 弡 翇 趉 伆 鉘 乀 砩 阢 笰 甶 芾 惌</p><pre><code>其它僻字：</code></pre><p>㗵 䘿 㭾 䏌 䎢 㷉 䵥 䭮 㐹 䖇 䁌 㻕 䒗 䰴 䛥 㪄 䞞 䠇 䞷 㠨 𠜾 𨧱 𧿳</p><h2 id="6、六月"><a href="#6、六月" class="headerlink" title="6、六月"></a>6、六月</h2><p>月 发 發 骨 阙 没 髮 窟 忽 兀 伐 谒 袜 樾 钺 笏 粤 蕨 突 襪 渤 惚 歇 勃 殁 罚 筏 越 窣 曰 阀 蹶 柮 讷 卒[士卒] 屼 劂 橛 猝 獗 羯 杌 矻 矹 竭 卼 滑[乱也] 鹘 軏 腯 搰 咄 淈 垡 硉 蠍 崒 纥 揭 碣 汨 馞 撅 峍 蟨 核 掘 哕 刖 愲 狘 扢 凸 暍 孛 浡 嗢 堀 鷢 揬 悖 讦 捽 曶 榾 泏 扤 鳜 蚏 抇 阏 龁 抐 瞂 胐 麧 玥 蜶 匫 钀 莈 不 厥 崛 脖 唿 昒 饽 鹁 棁 囫 镢 犵 钠 腽 淴 怢 馉 艴 猲 蓇 桲 葧 椊 葖 稡 阢 昢 瘚 侓 馧[馧馞] 饳 蚎 荸 鈯 嶡 絗 縎 鼵 鶟 杚 枂 颰 冹 榲 趃 亅 埣 坺 顝 熓 怴 朏 籺 摕 侼 欮 堨 迌 趉 寣 揾 瞃 囝 憠 宊 殨 笜 舭 郣 捸 璏 抈 殟 橃 沷 熭 碿 藅 鋍 尳 湥 岄 垏 鍎 歾 琷 鍻 啒 瘟[心闷貌] 糏 哱 犻 貀 鼿 榲 挬</p><pre><code>其它僻字：</code></pre><p>㪍 䬂 䓤 䎳 㷎 㶿 䞘 䨚 䑔 䬍 䥟 䓛 㖀 㫚 䴯 䚝 㪐 䦍 䟠 㻠 䎀 䖓 䘚 䣹 㳷 㩿 㐳 䩐 㧾 㟑 䪬 㵐 㒴 䡇 䝆 䑢 㨡 䀜 䯇 䟜 㬞 䇅 䂗 䁫 㘺 㴾 䯿 䋐 䙠 䭯 㔜 㵠 䍪 䠈 㲞 㞽 㧮 㾶 㛘 㽾 䮩 䪲 㕹 㛲 𣔻 𩨳 𧉦 𩑡 𢷒 𢪏 𧽸 𩗓 𥝖 𪁽 𪘧</p><h2 id="7、七曷"><a href="#7、七曷" class="headerlink" title="7、七曷"></a>7、七曷</h2><p>阔 末 活 脱 渴 豁 钵 夺 闼 葛 割 沫 聒 抹 遏 拨 泼 达 括 秣 剌 跋 辣 魃 怛 萨 蝎 斡 轕 栝 撮 筈 挞 茇 躠 撒 捋 喝 頞 臈 鹖 敚 褐 鞨 掇 拶 鱍 粝 囋 喇 獭 钹 适[疾也] 鞑 靺 澾 髺 裰 妺 拔 阏 噶 剟 跶 曷 軷 毼 摋 袯 越 咄 蘖 哒 獦 呾 泧 嶱 酦 犮 胺 炟 胈 焥 荙 繓 鸹 捾 暍 鏺 丐 挖 轹 碣 捺 咱 叭 侻 饐 齾 妲 嶭 笪 齃 猲 瘌 鵽 蛞 蝲 敠 靼 嵑 濊 帓 枺 粖 姡 頢 攥 囐 揦 蟽 茉 鼥 癹 礤 萿 毲 秳 癶 莌 妭 頱 濣 趏 蛶 睕 柭 嬒 餲 炥 魩 秡 狚 冭 灒 懖 羍 磆 刽 洝 昩 橃 堨 坺 奯 鬝 匃 驋 攃 汰 痥 燤 螛 咹 幯 湏 颰 仴 鲅 蔎 眓 襊 橽 歇 馛 葀 佸 昲 噧 揧 鮵 啈 蹳 捝 炦 攋 抈 骱 皌 鶷 枂 砞 瓎 脟 懀 眜</p><pre><code>其它僻字：</code></pre><p>䌨 㔇 䯋 䡾 䴲 䅥 䍨 䟯 㦫 䄑 㳨 䁊 㸊 䒷 㓉 㵶 㿣 㞈 㕲 䫘 䏞 䟦 䶛 㻝 䟛 䢌 䄆 㵧 㣵 䦢 䯏 䵣 㧊 㒓 䣶 㶬 䯦 㮫 䣪 䱫 䦚 䈓 䕣 䃮 㿹 㣞 䖧 䳁 㵣 㺚 䱅 䯺 䳚 㞉 㖕 㭮 䣮 㩵 䬴 𡾲 𥻦 𣁳 𤁢 𤷈 𤫵 𦮀 𥽘 𨣱 𧘟 𩩲 𤸎 𠯑 𥄕 𥄗 𦤦 𩒲 𩢛 𠱥 𧙕 𤀤 𤃴 𣎵 𤿫 𪘼</p><h2 id="8、八黠"><a href="#8、八黠" class="headerlink" title="8、八黠"></a>8、八黠</h2><p>札 刹 八 察 辖 黠 轧 戛 杀 煞 刮 猾 哳 扎 恝 揠 瞎 秸 滑 圠 楬 拔 蚻 肭 擦 嘎 茁 嗗 窡 刷 齾 铡 妠 豽 扴 鬝 扒[刨，挖] 铩 稭 榝 螖 搳 颉 劼 娺 圿 秳 痆 帓 汃 鹘 帕 獭 捺 咶 刖 紥 鸹 錣 磍 鴶 擖 砎 捌 朳 哵 鶷 傄 礣 劜 窫 詙 鲒 聐 磆 柭 菝 詚 蠿 猰 颳 耫 捾 糪 忦 硈 揳 玐 骱 眣 摖 鱊 咭 閁 捖 帴 睰 釛 嗐 縖 袺 檫 趏 仈 歇 螛 袹 鵽 叭 釟 貀</p><pre><code>其它僻字：</code></pre><p>䀣 㗫 㓤 䕓 䝟 䦪 㮖 㔍 䴳 㓞 䫄 䀨 㨸 䃰 䶪 䱻 䯉 㑻 䓭 䥷 㭭 䦖 䵵 㪴 㕯 㳐 䚴 䂒 㺴 䆯 㔠 䤢 䰲 𡇼 𪙻 𤫶 𪆰 𪈟 𪇷 𦤙 𠝚 𥴭 𩮁</p><h2 id="9、九屑"><a href="#9、九屑" class="headerlink" title="9、九屑"></a>9、九屑</h2><p>雪 别 绝 灭 血 结 拙 热 穴 洁 铁 裂 列 烈 缺 辙 诀 杰 舌 悦 节 彻 说 设 屑 决 哲 冽 劣 咽[呜咽] 阅 切 澈 折 缬 阕 辍 孽 鳖 玦 瞥 窃 啜 鴂 爇 埒 绁 齧 垤 截 撷 挈 跌 耋 泄 掣 嵲 泬 谲 歇 撤 吷 糵 孑 涅 迭 餮 撇 亵 薛 蔑 洌 鐍 竭 抉 蕝 瓞 桀 惙 噎 拽 浙 卨 楔 臬 契 歠 闑 闭 絜 缀 蠛 僣 臲 褉 页 觖 襭 霓 篾 碣 绖 揭 捏 蹩 衊 凸 蘖 巀 昳 岊 媟 呐 驖 莂 隉 轶 緤 晢 颉 哔 楶 朅 蛚 禼 茁 趐 刷 掇 苶 嶭 焫 茢 捩 锲 揲 蜇 摰 咥 讦 蜺 渫 瘪 碟 拮 醊 棁 搣 疖 蠥 蠘 丿 锊 蛭 桔 鷩 橇 迾 趹 蛣 槷 偈 辥 悊 颲 幭 挒 嫳 棳 篞 馝 絬 准[颊权也] 覈 佚 批 褐 谳 姪 踅 憋 龁 帨 剟 咧 紒 屮 唰 瀎 詄 趔 硩 潎 蟞 奊 跮 蠽 咇 僪 蠮 蚗 爡 刔 襒 畷 蒛 蛥 嵥 糏 蔎 懱 芵 鐅 瞲 蛈 僁 醛 掜 蝢 逫 鱴 櫗 囐 藒 孓 赽 趃 袺 啘 蛂 鲒 胅 鈌 鴷 脟 敜 駃 蠿 齛 罬 烲 砓 栨 彆 蠞 夨 呭 滊 臷 幯 鱊 猰 揳 螲 聺 勶 镻 棙 潱 爄 摕 狤 迼 聅 鄨 笍 湀 洯 眓 攦 劽 坲 乴 鮤 朳 莭 恎 叕 靼 滐 粖 姴 趌 蛶 魝 痥 袕 郣 覕 炦 洇 捌 緳 瞮 尐 榝 稧 柭 妜 蛞 擳 栵 諁 籺 蛪 歽 矞[同谲] 詍 睙 搩 靾 炔 眣 蜹 疶 敠 哾 桖 怢 戜 疀 麧 鑖 眜 苵 嵽 巁 眰 揊 炪 哷 坹 櫍 瘛 鴓 虌 徶 疦 馛 砄 毻 燤 櫭 菍 暼 娎 剈 翓</p><pre><code>其它僻字：</code></pre><p>㧙 㙞 䨮 䁾 䥫 䆷 㿱 䫾 㗧 䕵 䖦 䚢 䞵 㴮 㛃 㬯 㔢 㴪 䇷 㩪 㴽 䌩 㝂 㲳 䫎 䘊 㘿 㓭 䅀 䭇 㯙 㳿 䋉 䂼 䒸 㮮 䌘 䂐 䳤 㭞 㓗 䙽 䩤 䦑 䪼 䆕 䊦 䱑 㸞 㩢 䦬 䊝 㖶 㢼 㸹 㤠 䯵 㐖 㨝 㬚 㭩 䮕 㭈 䩧 㖏 㔃 㔡 䍳 䫼 㦢 䆢 㘶 䟹 䛎 㹟 䠥 䋢 䤿 䏟 䭱 䝌 䟙 㔎 䘷 䒆 䘁 䓆 䨆 䏳 䟾 䞰 㼤 䀗 㣯 䩏 㒝 䏐 㕞 㸅 㓶 䈼 㞕 䥕 䏲 䲙 䐼 㽟 𡿖 𧤾 𢴲 𣧵 𠱕 𡿪 𧎩 𧧸 𩖶 𢗗 𢯳 𢲼 𥉓 𠻜 𥈾 𩠻 𨵪 𤊾 𩢾 𨆳 𥄎 𪏺</p><h2 id="10、十药"><a href="#10、十药" class="headerlink" title="10、十药"></a>10、十药</h2><p>落 薄 鹤 阁 壑 寞 郭 托 酌 漠 泊 略 脚 雀 却 廓 昨 託 跃 洛 弱 缚 恶 鹊 作 萼 乐[哀乐] 约 诺 索 爵 削 钥 橐 络 着 博 错 箔 铄 著[同着] 藿 谑 箨 虐 柝 幕 灼 铎 嚼 礴 霍 怍 鹗 药 愕 瘼 烁 凿 屩 若 酢 籥 锷 讬[同托] 搏 酪 勺 崿 粕 噱 攫 杓 斫 度[谋也] 鳄 蠖 雘 彴 各 掠 莫 貉 涸 镬 谔 绰 疟 鄂 穫 瀹 垩 恪 珞 拓 笮 魄 摸 骆 膊 椁 爚 膜[肉膜] 箬 矱 扩 噩 萚 雒 玃 烙 缴 搁 堮 镈 蠚 泺 获 妁 遌 鞟 焯[明亮] 腭 龠 彍 泽[星名] 爝 格[树枝也] 獲 蒻 亳 钁 艧 饦 礿 礡 矍 醵 咢 襮 躩 蹻 跞 臛 镆 郝 硌 皭 霩 臄 篗 皵 臒 鑮 熇[与謞同] 踱 芍 岝 矐 郤 皬 轹 柞 嗃 煿 蒪 蒦 糳 悫 斮 汋 攉 靃 謞 欂 漷 戄 瞙 飵 鄀 汑 鄚 蝁 猎 躇[超也] 昔 琧 燋 暯 婥 厝 咯 逴 喏 胳 迮 鷇 貜 颚 犦 隺 鐯 瀖 碏 袼 嚯 鮥 猼 喥 彠 辵 婼 硸 袥 烵 凙 矆 楉 馲 鄗 峈 縸 沰 剒 胉 嚩 磭 馎 貈 嗼 杔 崞 毭 剫 笿 矌 犳 曤 鞒 踖 焲 櫎 蘁 偔 娋 莡 稓 慔 謶 蛒 仢 藃 莋 櫮 鎍 岞 秨 逽 魠 敫 覨 劐 斱 擆 狛 搻 鶸 彏 圴 嚛 鈼 撗 谻 櫡 湂 扚 葃 鑩 棤 檴 噋 矡 鱳 籱 溹 嫋[长貌] 擽 庹 庴 縒 矺 癋 妰 詻 嬳 龥 跅 仛 纅 铬 蹃 趞 蠼 鶮 鹱 茖 繑 禚 铂 墌 癨 塻 蠌 牔 鬕 婩 砟 檡 挄 鰝 苲 佫 侂 籗 渃 蘥 鸙 溺</p><pre><code>其它僻字：</code></pre><p>䋏 㟧 㠋 㹱 䨥 㜰 䱜 䭦 䮤 㓢 㸕 㒂 䧄 䖃 㦜 㦡 㿑 㦍 䨰 䎰 㬦 㚟 㤞 䎊 䖼 㕡 䌇 㸲 㪾 㗥 㨯 䶳 䪙 㮙 㨼 䨣 䈷 㴖 䅴 㘀 䣤 䖛 㩱 䝫 䂄 䚥 㷾 㲋 䁨 䯨 䫷 䧐 䟑 䶈 䶅 䠯 㖸 㬍 㓵 䁻 㤩 䥬 䛚 䀩 䥣 䗚 䌎 䐘 㰛 䣞 㕁 䅵 䲵 䮬 䬪 㤰 䍸 㱳 㗉 䙏 䐞 䰊 㗁 䇥 䇎 䅂 䤕 㷬 䂮 㑼 䧿 䈅 䖋 㖾 䖈 䋤 䐾 䞢 䢲 㗘 䉟 䄸 䨋 𦞦 𧎾 𧕋 𧍷 𧊜 𠶸 𥴮 𤻲 𢜭 𢱢 𪙍 𩌏 𨷲 𥽿 𠠎 𤄶 𤡯 𩍿 𧤽 𩟓 𧘑</p><h2 id="11、十一陌"><a href="#11、十一陌" class="headerlink" title="11、十一陌"></a>11、十一陌</h2><p>客 白 石 迹 碧 夕 宅 尺 席 隔 策 惜 役 屐 陌 璧 益 伯 赤 癖 柏 窄 百 驿 剧 脉 辟 戟 翮 隙 迫 掷 液 僻 责 麦 昔 释 舄 积 额 厄 泽 册 帛 坼 易[变易] 逆 赫 革 籍 脊 择 拍 谪 帻 碛 掖 拆 魄 瘠 格 斥 腋 奕 擘 怿 绎 获 画[卦画也] 獲 索 磔 译 适 珀 射 舶 藉 汐 弈 檗 蹠 膈 硕 绤 鶒 蹐 啧 轭 貊 只 帼 炙 扼 赜 馘 螫 箦 骼 蜴 斁 穸 阨 唶 帟 摘 疫 划[划破] 埸 踯 襫 虢 蝈 峄 哑[笑声] 摭 核 刺[穿也，伤也] 奭 嚇 襞 腊 祏 覈[同核] 擿 咋 薜 摵 迮 栅 躄 亦 湱 擗 虩 霢 借 踖 磶 搦 蓦 穫 醳 鲫 嗌 槅 騞 嚄 剨 婳 峉 筴 鬲 阸 媳 掴 鹡 喀 塉 耤 齸 莫[静也] 齰 嗝 砉 蚱 潟 觡 圛 粣 鼫 翟 愬 鸊 啯 齚 撠 貘 睗 洦 呃[鸡声。] 霸[古与魄同] 謮 晹 縌  詻 橶 敀 滆 郤 霹 睪 胔 啪 哧 柞[除木] 硅 嘀 虴 徦 蛨 佰 礉 檡 塥 缂 礋 漍 乇 覤 鸅 墌 簂 皟 蕮 蚅 茖 腘 郄 舴 蹃 曎 襗 鐴 鉐 榒 帞 銆 雿 箣 鯣 躤 襀 垎 嗼 鲌 嵴 捇 擌 諽 庴 獈 砈 趞 膉 潪 枙 鳠 扸 鳽 杔 瞔 炈 疒 覞 歵 鈠 厏 頙 銏 犱 焃 檘 澅 燚 苩 岶 茦 蚸 拺 嚿 袹 臵 樍 讗 簎 諎 谻 呄 鰿 焟 楁 嬕 跅 丮 釽 铬 躆 蚇 眲 馲 坄 籷 狛 厝 慖 啋 脨 廦 焲 焬 熤 絔 啙 墿 糪 痬 棤 溹 矠 蠌 烢 凙 褯 聑 矺 鏼 棭 謋 獥 貖 洓 葃 泎 窢 莋 劐 掝 憡 聻 厇 礊 韄 嫧 燡 罊 雃 虉 挀 豛 胉 啇 蛒 瞁 煂 搩 瘷 揢 蒚 鶪 屰 焷 耫 碦 覛 豟 閴</p><pre><code>其它僻字：</code></pre><p>㶁 㗲 㫺 㡿 䘸 䇲 䵂 㧖 㽚 㛭 㦴 䐙 䶦 㥽 䄷 䘔 䃒 㮦 䩹 䳭 䕉 㼟 䐱 㟙 䳆 㩍 䂹 䊞 䘑 㮝 䱮 䛿 㜋 䜺 㑊 㹮 䟄 䬉 䮮 䂸 䐸 䳮 䁺 㡯 㝜 䨛 㘌 㣂 㖪 䮰 㩇 䡛 䧍 䌟 䕪 䭆 㘁 㦎 㠛 㿟 䙐 䈿 䖌 㗆 䰜 䪂 䚂 㭙 䤨 㿭 䲽 䞠 㶠 䣢 䨫 䖨 㣱 䁤 䦝 㴁 䭞 䊂 㳻 㵹 䦴 㼣 㒀 㾊 㦦 䞟 㴒 䂝 䞦 䪝 𠙆 𦒧 𡩡 𤗮 𤖼 𢅰 𤁰 𢓜 𩹺 𡄴 𦵪 𥬰 𡍩 𢮎 𢷾 𢼛 𢯹 𦌠 𢫦 𥆛 𪐏</p><h2 id="12、十二锡"><a href="#12、十二锡" class="headerlink" title="12、十二锡"></a>12、十二锡</h2><p>壁 寂 笛 敌 滴 历 觅 激 戚 檄 绩 击 锡 的 雳 沥 砾 涤 觌 鹢 枥 镝 析 惕 狄 淅 荻 皪 羃 溺 栎 甓 晰 幂 籴 劈 阒 逖 剔 吃 迪 靮 嫡 皙 菂 觋 呖 趯 甋 瓅 霓 鵙 艗 幕 踢 篴 惄 适 轹 阋 汨[汨罗] 焱 郦 鴃 蹢 籊 殈 赥 鼊 摘 蜥 疬 樀 澼 轣 裼 鼜 鬲 倜 礰 緆 秝 翟 鼏 覭 簚 糸 吊 狊 坜 蚸 繴 薂 濗 砳 焃 霹 墒 砉 攦 踧 墼 悐 鶪 幦 虉 磿 幎 嚁 瓋 毄 焬 鐴 菥 譤 苈 塓 湨 鹝 啇 玓 馰 熐 釽 漃 憵 鱳 纅 扸 樍 撽 儮 苖 爏 讈 扚 欫 椺 墑 漞 趘 冖 仢 儥 銢 頔 轚 燩 覛 硩 礕 靋 觻 磩 镉 肑 綼 糑 惁 敫 蒚 犑 獥 婥 蓨 蓧 瞁 歒 廦 鸄 虳 郹 鼳 鄓 蔋 擽 盢 梑</p><pre><code>其它僻字：</code></pre><p>䍥 䍽 㰅 㭊 䓇 䢮 䥶 䤙 㿨 㣙 䟐 䤨 䢰 䚫 㤸 㢩 䴞 䨤 䵠 㻺 䗩 䣓 䮥 㲻 䂆 䖑 䔉 㦘 㹍 㒪 䳬 䁶 㔏 䮭 㬏 䞶 䚐 㛫 䰛 䑀 㱤 䈪 㱹 䌐 㽁 䨀 㱸 㺡 䚍 䟏 㷴 䯜 𪒄 𦸗 𣒃 𡫁 𣤢 𥍧 𥍠 𥍟 𠴫 𣤩 𥛚 𤄎 𦵦</p><h2 id="13、十三职"><a href="#13、十三职" class="headerlink" title="13、十三职"></a>13、十三职</h2><p>色 得 息 国 力 极 翼 侧 直 黑 忆 墨 域 识[知识] 测 棘 职 臆 贼 刻 食 逼 北 恻 默 德 饰 勒 惑 稷 特 则 即 拭 织 蚀 仄 匿 陟 穑 亿 塞[闭塞] 式 植 抑 殖 敕 亟 克 弋 熄 肋 昃 忒 慝 蜮 轼 饬 啬 踣 阈 泐 殛 嘿 洫 翊 薏 赩 湜 纆 僰 屴 杙 愊 寔 崱 裓 墄 匐 罭 愎 嶷 偪 螣[螟螣] 剋 埴 尅 棫 襋 衋 劾 唧 轖 淢 湢 遫 扐 蠈 緎 淂 蟘 幅 或 恧 荝 栻 鷘 鲗 翌 畟 副 仂 餩 醷 侐 釴 鲫 腷 繶 竻 膱 芅 癔 瀷 蒠 淔 稄 戫 蟔 稙 樴 堲 蝍 菔 犆 趩 堛 掝 蕀 蛡 忑 嫟 恜 瘜 黓 楅 冒 蘵 惐 腘 赲 嘚 稫 脦 煏 玏 戠 溭 穓 鉓 遈 棏 蔷 烒 鶝 艒 鲾 禃 潩 捗 畐 霬 噫 皕 嫼 皀 嬂 謋 琙 捑 骮 揤 蚮 爅 熤 踾 浳 螚 蟙 鳨 釛 澺 垘 鄎 氻 潶 艻 閄 朸 臸 忇 諽 檍 焏 悈 窢 茍 烅 嚜 鉽 侙 殕 懎 慗 揊 熼 鳓 阞 懝 繬</p><pre><code>其它僻字：</code></pre><p>㳁 㥾 㚤 㘈 䰥 䁿 䈟 㔴 䵗 䘃 㤫 㮩 㥂 㱇 䄩 䐚 䙷 䯆 䁼 䅞 䧗 㕵 䘅 㯤 䵱 㞃 䬎 㝶 䱛 䭒 㢞 㭲 㷵 㻷 䗷 䞳 㱄 䐈 䖁 㘠 㹄 䩯 䘝 㧹 㥁 䴬 㷶 㽣 㔹 㴧 䦗 㚜 䣧 䎪 䮙 㫯 㥛 㯰 㥀 㥶 䮠 䦼 㮨 㵓 䁇 㞋 䉢 䆐 䤭 𪀦 𧏾 𤜜 𡍫 𥇛 𪂉 𤗚 𩋉 𪑝 𥇙</p><h2 id="14、十四缉"><a href="#14、十四缉" class="headerlink" title="14、十四缉"></a>14、十四缉</h2><p>急 立 入 湿 集 泣 及 邑 十 涩 拾 蛰 习 笠 粒 汲 给 吸 袭 揖 什 级 执 隰 挹 絷 汁 戢 葺 岌 浥 缉 辑 悒 翕 熠 笈 伋 楫 噏 濈 歙 裛 潗 唈 蕺 槢 廿 潝 霫 芨 霵 钑 褶 啃 漐 苙 鳛 湆 礏 飁 雭 圾 煜 闟 砬 歰 熻 鵖 湁 俋 咠 卙 慹 鷑 譅 雴 骉 彶 箿 礘 叺 瓡 岦 鴔 鏶 偮 翜 釞 淁 趇 騽 喅 鴗 蓻 謺 嶯 漝 皀 嬆 湒 譶 馵 鉝 孴 卌 諿</p><pre><code>其它僻字：</code></pre><p>䏉 㴕 㦻 㤂 㙷 㪧 䦹 㠍 䁯 㬛 㵫 䔼 㴔 䶘 䶋 㗊 䩰 䮶 䏠 㲸 㽺 䓃 㣬 䒁 䭂 䉗 㡮 㧀 㱞 㙫 㘊 㿇 䏩 㬤 㗱 䐕 㒊 䇼 䅤 㒆 䲯 䔱 㕸 䙄 㞚 㩉 㞏 㗩 䁒 𧤏 𩆭 𧚨 𩾳</p><h2 id="15、十五合"><a href="#15、十五合" class="headerlink" title="15、十五合"></a>15、十五合</h2><p>合 榻 塔 答 杂 阖 衲 匝 纳 飒 榼 閤 踏 沓 蛤 鸽 盍 遝 荅 塌 蹋 盒 搭 鞳 拉 腊 蜡 帀 蒳 靸 漯 嗑 趿 嗒 噆 鎝 咂 阘 遢 剳 卡 溘 誻 匌 嚃 拓 馺 罨 镴 搕 唈 韐 岋 濌 褟 涾 耠 軜 盖 卅 磕[石声] 哈 瘩 碜 褡 嘁 鲽 瞌 钑 欱 狧 耷 錔 鮯 鞜 鳎 匎 溻 颌 歞 砵 菈 鰪 砐 匒 傝 崉 雥 囃 詥 溚 篕 魶 峇 鉔 峆 鑉 譶 痷 魳 罯 磼 畗 魼 圾 鞥 矺 抸 廅 毾 礘 佮 砝 魥 熆 笚 鎉 翋 龖 儑 姶 磖 拹 笝 殧 柆 铪 硆 厒 榙 枼 韴 遪</p><pre><code>其它僻字：</code></pre><p>䬃 䕹 㔩 䑽 㷈 㗳 䗶 䑥 䂰 䗘 䍇 㛥 䐦 㹺 㧁 㯓 䵬 㕇 䈳 䌈 䐛 䂿 䪏 䧻 㿯 䵽 㕉 䫦 䈫 䈋 䑜 䃳 䶁 䍝 䪞 㕎 㨥 䶀 䙣 䳴 㭼 㠷 㧺 㥺 䢔 䪺 㛕 㾑 䜚 㿴 㽂 䨿 䑪 㝓 㯚 䪚 䞙 㚫 䓠 㰰 䆟 㡴 𩣯 𪘁 𩋊 𨅔 𥁋 𣣹 𦑶 𤎞 𨜴 𤸱 𩎕 𢕬 𧪞 𢶍 𨃚 𡄋</p><h2 id="16、十六叶"><a href="#16、十六叶" class="headerlink" title="16、十六叶"></a>16、十六叶</h2><p>叶 葉 接 蝶 叠 捷 涉 帖 箧 惬 颊 堞 妾 铗 侠 睫 鬣 牒 靥 浃 屧 蹑 荚 协 摄 贴 慑 燮 挟 楫 馌 烨 摺 镊 躞 谍 晔 猎 蹀 捻 辄 跕 嗫 氎 躐 詟 艓 擪 屟 褶 褋 惵 梜 怗 聂 箑 裛 衱 喋 呫 韘 苶 楪 折 炸 笈 籋 襵 歙 鞢 鍱 魇 霎 厌 婕 偞 菨 崨 倢 椄 讘 欇 筴 邋 鲽 熀 蛱 擸 颞 儠 擛 踥 牃 踕 謵 緁 僷 滠 犣 聗 鎑 錜 銸 徢 惗 穕 帹 蠂 痷 鱲 脻 迠 萐 敜 慹 綊 謺 鮿 鯜 埝 挕 踂 瞱 淁 瞸 獦 鑈 聑 褺 鏶 昅 揞 巤 煠 疌 踗 劦 誱 寁 唊 蓻 枼 殜 霅[霅霅，震电貌] 帇 蓵 渫</p><pre><code>其它僻字：</code></pre><p>㲲 㫸 䩞 䈉 䐑 䌖 㱌 䢡 䳖 㪑 䁋 䜆 䝃 䵿 㩎 䇣 䜲 䝱 䐲 㸎 䧪 㡇 㬪 㢵 䤮 䪓 㤴 㥈 䴑 㥦 䪉 㴇 䭟 㢎 㩸 㯿 䯀 㤐 㰼 㭯 㳧 㙷 㚔 䛟 䝓 䈎 䜓 䌰 㑙 㾜 㚲 㼪 㩶 㼲 䌌 㤲 㰔 㒤 䠟 䁽 㨩 㷸 㛍 㽊 䝕 䴴 䥡 䌜 𣶏 𦣀 𢬴 𦔮 𤍞 𪑧 𦀖 𤑻 𣀳 𨓊 𪔪 𩣘 𤗽 𦔼</p><h2 id="17、十七洽"><a href="#17、十七洽" class="headerlink" title="17、十七洽"></a>17、十七洽</h2><p>业 法 甲 劫 峡 怯 洽 匣 压 狎 乏 鸭 插 狭 锸 嶪 夹 闸 押 袷 柙 帢 唼 歃 掐 劄 呷 恰 裌 翣 胛 硖 邺 霎 陜 霅 箑 嗋 祫 眨 跲 啑 郏 恊 鵊 扱 凹 胁 鞈 搯 熁 玾 喋 愶 筴 岬 胠 葜 烚 渫 擖 姂 庘 哈 钾 萐 嚈 魻 圔 喢 蜐 饸 譗 姶 湆 魥 鉣 驜 呿 翜 韐 疀 笚 埉 厒 笝 煠 殗 搚 痷 铪 唊 欱[与歃同。尝也] 翈 昅 磼 曱 珨 鸈 魼 歰 嶯 澲 砝 疺 圶 抾 帹 炠 筪 拹 殜 餣 舺 殎 垥 偛</p><pre><code>其它僻字：</code></pre><p>䶎 㡊 㰱 䬊 䆘 㭘 㵊 㕅 㛼 㳌 䖎 㡋 䎎 䛅 䨐 䧨 䕛 䤶 䛽 㘝 㹤 䂲 䮢 㗼 㽠 䞩 㾀 㙝 㴙 㮑 䱒 䀴 㓣 䮜 䖖 䀷 䀫 䩡 䘥 䲜 㘡 㾎 䁆 䁍 㑢 㿓 㸣 㵤 䶝 㭱 㷅 𢘉 𣣲 𩌍 𢂷 𤴼 𠗨</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、一屋&quot;&gt;&lt;a href=&quot;#1、一屋&quot; class=&quot;headerlink&quot; title=&quot;1、一屋&quot;&gt;&lt;/a&gt;1、一屋&lt;/h2&gt;&lt;p&gt;竹 屋 谷 目 木 熟 菊 腹 哭 服 肉 独 福 速 逐 禄 鹿 麓 肃 轴 牧 宿[住宿] 卜 陆 六 族 筑 毂 祝 
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1020 Tree Traversals</title>
    <link href="http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/"/>
    <id>http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/</id>
    <published>2018-04-07T08:14:39.000Z</published>
    <updated>2018-04-07T09:00:09.858Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><pre><code>Sample Input:72 3 1 5 7 6 41 2 3 4 5 6 7Sample Output:4 1 6 3 5 7 2</code></pre><p>题目大意：给出二叉树的后序和中序序列，输出这棵二叉树的层序序列。(所有的二叉树节点的数据都是互不相等的正整数)</p><p>分析：根据二叉树的后序和中序序列可以重建二叉树，再对重建好的二叉树进行层序遍历。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;queue&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}int n;int j=0;void layerorder(node* root) {    queue&lt;node*&gt; q;//存储节点地址的队列    q.push(root);//根节点入队    while (!q.empty()) {        node* now = q.front();        q.pop();//将队首元素出队        cout &lt;&lt; now-&gt;data;//访问队首元素        j++;        if(j&lt;n) cout&lt;&lt;&quot; &quot;;        if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);//如果左子树不空，将左子树入队        if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);//如果右子树不空，将左子树入队    }}int main() {    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    layerorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存空间    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are s
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>由中序和后序序列输出先序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由中序和后序序列输出先序序列/</id>
    <published>2018-04-07T07:55:20.000Z</published>
    <updated>2018-04-07T08:40:36.703Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void preorder(node* root) {//先序遍历二叉树    if (root == NULL) {        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    preorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由先序和中序序列输出后序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由先序和中序序列输出后序序列/</id>
    <published>2018-04-07T06:58:11.000Z</published>
    <updated>2018-04-07T08:39:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int pre[],int in[],int preL, int preR, int inL, int inR) {//根据先序序列和中序序列重建二叉树    if (preL&gt;preR) return NULL;//如果先序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = pre[preL];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == pre[preL]) {//在中序序列中找到根节点            break;        }    }    int numLeft = k - inL;//左子树的节点个数    //左子树的先序序列区间为[preL+1,preL+numLeft],中序序列区间为[inL,k-1]    root-&gt;lchild = create(pre,in,preL + 1, preL + numLeft, inL, k - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的先序序列区间为[preL+numLeft+1,preR],中序序列区间为[k+1,inR]    root-&gt;rchild = create(pre,in,preL + numLeft + 1, preR, k + 1, inR);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void postorder(node* root) {//后序遍历二叉树    if (root == NULL) {        return;//递归边界    }    postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *pre = new int[n];//new一个变长的int型数组    int *in = new int[n];    for (int i = 0;i &lt; n;i++) {//输入先序序列        cin &gt;&gt; pre[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int preL = 0,inL = 0, preR = n - 1, inR = n - 1;    postorder(create(pre,in,preL, preR, inL, inR));    delete[] in;//释放内存    delete[] pre;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.echodemo.cc/2018/04/07/二叉树的基本操作/</id>
    <published>2018-04-07T04:01:09.000Z</published>
    <updated>2018-04-07T08:39:29.646Z</updated>
    
    <content type="html"><![CDATA[<p>1、二叉树的存储结构</p><pre><code>struct node {    typename data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};</code></pre><p>2、新建一个二叉树节点</p><pre><code>node* newNode(int n) {    node* Node = new node;//申请一个node型变量的地址空间    Node-&gt;data = n;//节点权值为n    Node-&gt;lchild = Node-&gt;rchild = NULL;//初始状态下左右孩子为空    return Node;//返回新建节点的地址}</code></pre><p>3、查找二叉树中节点数据域为x的节点，并将他们的数据域修改为newdata</p><pre><code>void search(node* root, int x, int newdata) {    if (root == NULL) {        return;//空树，死胡同(递归边界)    }    if (root-&gt;data == x) {        root-&gt;data = newdata;    }    search(root-&gt;lchild, x, newdata);//往左子树搜索x    search(root-&gt;rchild, x, newdata);//往右子树搜索x}</code></pre><p>4、二叉树节点的插入(二叉树节点的插入位置就是数据域在二叉树中查找失败的位置)</p><pre><code>void insert(node* &amp;root, int x) {    if (root == NULL) {        root = newNode(x);//空树，说明查找失败，也即插入的位置(递归边界)        return;    }    if (由二叉树的性质，x应该插在左子树) {        insert(root-&gt;lchild, x);//往左子树搜索(递归式)    }    else {        insert(root-&gt;rchild, x);//往右子树搜索(递归式)    }}</code></pre><p>这里的根节点指针root需要使用引用&amp;，这样才能直接修改原变量的值。与search函数不同的是，search函数中修改的是指针root指向的内容，而不是root本身，而对指针指向的节点内容的修改是不需要加引用的。一般来说，如果函数中需要新建节点，即对二叉树的结构做出修改，就需要加引用；如果只是修改当前已有节点的内容，或仅仅是遍历树，就不需要加引用。</p><p>5、二叉树的创建(其实就是二叉树节点的插入过程)</p><pre><code>node* create(int data[], int n) {    node* root = NULL;//新建空根节点    for (int i = 0;i &lt; n;i++) {        insert(root, data[i]);    }    return root;//返回根节点}</code></pre><p>6、二叉树的先序遍历(递归)</p><pre><code>void preorder(node* root){    if(root==NULL){        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}</code></pre><p>7、二叉树的中序遍历(递归)</p><pre><code>void inorder(node* root){    if(root==NULL){        return;//递归边界    }        inorder(root-&gt;lchild);//访问左子树    cout&lt;&lt;root-&gt;data;//访问根节点    inorder(root-&gt;rchild);//访问右子树}</code></pre><p>8、二叉树的后序遍历(递归)</p><pre><code>void postorder(node* root){    if(root==NULL){        return;//递归边界    }        postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}</code></pre><p>9、二叉树的层序遍历</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL) q.push(now-&gt;lchild);//左子树非空        if(now-&gt;rchild!=NULL) q.push(now-&gt;rchild);//右子树非空    }}</code></pre><p>如果需要计算每个节点所处的层次，二叉树节点的定义如下：</p><pre><code>struct node{    typename data;//数据域    int layer;//层次    node* lchild;//左指针域    node* rchild;//右指针域}</code></pre><p>此时的层序遍历为：</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    root-&gt;layer=1;//根节点的层数为1    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL){//左子树非空            now-&gt;lchild-&gt;layer=now-&gt;layer+1;//左孩子的层数为当前层数加1            q.push(now-&gt;lchild);        }        if(now-&gt;rchild!=NULL){//右子树非空            now-&gt;rchild-&gt;layer=now-&gt;layer+1;//右孩子的层数为当前层数加1            q.push(now-&gt;rchild);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、二叉树的存储结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct node {
    typename data;//数据域
    node* lchild;//指向左子树根节点的指针
    node* rchild;//指向右子树根节点的指针
};
&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
