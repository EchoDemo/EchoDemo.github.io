<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-28T05:18:28.377Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>致临安</title>
    <link href="http://www.echodemo.cc/2018/04/28/%E8%87%B4%E4%B8%B4%E5%AE%89/"/>
    <id>http://www.echodemo.cc/2018/04/28/致临安/</id>
    <published>2018-04-28T03:03:11.000Z</published>
    <updated>2018-04-28T05:18:28.377Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;――――题记</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起临安，我会想起什么呢？虽然彼此素未谋面。但我在许嵩的《断桥残雪》里；在柳永的《望海潮》中；从“暖风熏得游人醉，直把杭州作汴州”和“小楼一夜听春雨，深巷明朝卖杏花”那里面窥见的临安城是如此地楚楚动人，惹人喜爱。曾经这样想过：选择了一座城是否就选择了一种生活的方式？后来，自己给出的答案是肯定的。因为外界环境从始至终都会或多或少地影响一个人的心情和状态。再者我想：如果可以在自己喜欢的城市里柴米油盐地生活，便是一种极大的愉悦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;喜欢一座城，可以具备一定的缘由，或许也可以不问因果。我对杭州起初的向往就像三毛之于撒哈拉一样，怀着一种非此地不居的想法，犹如冥冥之中的神秘引力，让我们彼此惺惺相（吸）。还记得多年以前《新白娘子传奇》中那断桥上的油纸伞吗？还记得杨万里的那句“接天莲叶无穷碧，映日荷花别样红”吗？这其中哪个是我第一次接触到的有关于杭州的记忆，我又是从什么时候起拥有了对杭州的执念，这些都难以追溯。但我知道是什么促进了，加强了甚至是升华了我对杭州的喜爱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杭州自秦朝设县治以来已有2200多年的历史，曾是吴越国和南宋的都城，因风景秀丽，素有“人间天堂”的美誉。杭州之名从“秦时明月汉时关”里属会稽郡的钱唐，到东汉属吴郡的钱唐，到三国和两晋时期属吴郡但却归于古扬州钱唐，再到后来隋朝时期“杭州”二字的首次登台，再到为避唐朝国号之讳将此“唐”改为彼“塘”。就这样等到五代十国时期一过，由于先前运河的修建，水利的兴修。杭州便迎来了在中国历史上的全盛时期，也就是宋王朝。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，正如你所看到的，上面这一大段大多都是百度百科里的东西。我所想抓住的便是其中的一个宋字。从北宋到南宋，用“钱塘自古繁华”一句来讲我想是恰当的。这些从张择端的《清明上河图》中便可见一斑。谈及北宋，作为苏子瞻这位诗词大文豪的铁杆粉丝，我想这里对他的记录是必不可少的。苏子瞻是四川眉州眉山人，凭借其清心洒脱、豪放不羁的文采征服了当时的文坛领袖欧阳修。在欧阳修的赏识之下，作为初唐宰相苏味道之后的苏子瞻，作为后来唐宋八大家苏氏一家独占三个名额的苏子瞻。顿时便名声大噪。无奈当时王安石变法如火如荼，但苏子瞻的很多师友，包括他自己在内也与王安石集团政见不和。于是遭受排挤在所难免。熙宁四年（1071年），苏子瞻上书皇帝谈论新法之弊病。遭王安石集团之不满，于是请求出京任职，被授为杭州通判。此后历经乌台诗案，被贬黄州。后因神宗驾崩，哲宗即位，高太后把持朝政（其对苏子瞻颇为赏识）。因此，从复为朝奉郎知登州（蓬莱），到以礼部郎中被召还朝，到升为起居舍人，到中书舍人，再到升翰林学士、知制诰，知礼部贡举。虽然苏子瞻一路高歌猛进，但当他发现司马光集团与原来的王安石集团不过是一丘之貉时，便再次向朝廷提出谏议，也因此再次遭受排挤。元祐四年也就是公元1089年，苏子瞻再度自求外调，任龙图阁学士、知杭州。苏子瞻这两次为官在杭州一共呆了5年，这五年我想应是他仕途当中最快乐的时光。远离了政治的中心，远离了朝局，没有了勾心斗角、尔虞我诈。有的是关心民瘼，赈济灾民，兴修水利，浚治西湖。因此也深受杭州百姓的爱戴。他也在闲暇之余，纵情山水之间，其足迹遍及西湖山水、园林、寺庙等等。留下了颇多的传说、题名、碑刻和诗词。作为诗人和词人，这无疑是一种莫大的享受。可以说苏子瞻为杭州的历史和文化底蕴增添了浓墨重彩的一笔。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起苏堤当然还有白堤，说起词人当然还有柳永，说起诗人当然还有陆游，除了北宋当然还有南宋。靖康之变后，徽钦二帝被俘，北宋沦亡，为金朝所灭。宋高宗赵构定都临安府。或许曾经的宋高宗也为临安的气质所折服才愿意在此偏安一隅吧。想起800多年前的岳鹏举怀着满腔的热血和报国之志踏上这片美丽而又繁华的土地，是否也会驻足回望，为临安的所有而惊艳。常年征战在外的他；身处军营和刀光剑影里的他；写下气势磅礴，英勇而悲壮的《满江红》的他；到头来却被奸佞所诬陷，高宗所猜忌的他。是否也曾在满月的夜里，想着能够和家人在类似于临安的城里共度余生。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对杭州的眷恋，想来与这些早已故去却一直存在的烟云有着莫大的关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1009 说反话</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1009-说反话/</id>
    <published>2018-04-26T13:09:20.000Z</published>
    <updated>2018-04-26T14:13:25.331Z</updated>
    
    <content type="html"><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p><p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p><pre><code>输入样例：Hello World Here I Come输出样例：Come I Here World Hello</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。&lt;/p&gt;
&lt;p&gt;输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1008 数组元素循环右移问题</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1008-数组元素循环右移问题/</id>
    <published>2018-04-26T12:55:19.000Z</published>
    <updated>2018-04-26T12:57:47.143Z</updated>
    
    <content type="html"><![CDATA[<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数,<br>之间用空格分隔。</p><p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><pre><code>输入样例：6 21 2 3 4 5 6输出样例：5 6 1 2 3 4</code></pre><p>题目代码：本题需要注意的是当移动的次数为0，为N或者大于N的特殊情况。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main() {  int N, M;  cin &gt;&gt; N &gt;&gt; M;  vector&lt;int&gt; a(N);  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; a[i];  }  if (M != 0 &amp;&amp; M != N) {    if (M &gt; N) M = M%N;    reverse(a.begin(), a.begin() + N - M);//将前面的N-M位进行反转    reverse(a.begin() + N - M, a.end());//将后面的M位进行反转    reverse(a.begin(), a.end());//将整个数组进行反转  }  for (int i = 0;i &lt; N;i++) {    cout &lt;&lt; a[i];    if (i &lt; N - 1) cout &lt;&lt; &quot; &quot;;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个数组A中存有N（N&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&amp;gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1007 素数对猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1007-素数对猜想/</id>
    <published>2018-04-26T12:18:15.000Z</published>
    <updated>2018-04-26T12:18:47.987Z</updated>
    
    <content type="html"><![CDATA[<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p><p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p><pre><code>输入样例：20输出样例：4</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;bool isPrime(int n) {//判定是否为素数  if (n &lt;= 1) return false;  for (int i = 2;i*i &lt;= n;i++) {    if (n % i == 0) return false;  }  return true;}int main() {  int n, num = 0;  cin &gt;&gt; n;  for (int i = 5;i &lt;= n;i++) {    if (isPrime(i - 2) &amp;&amp; isPrime(i))      num++;//如果相差2的两个数均为素数，则num自增1  }  cout &lt;&lt; num;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&amp;gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&amp;lt; 105)，请计算不超过N的满足猜想的素数对的个数。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1006 换个格式输出整数</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1006-换个格式输出整数/</id>
    <published>2018-04-26T03:39:02.000Z</published>
    <updated>2018-04-26T03:43:20.267Z</updated>
    
    <content type="html"><![CDATA[<p>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。</p><p>输出格式：每个测试用例的输出占一行，用规定的格式输出n。</p><pre><code>输入样例1：234输出样例1：BBSSS1234输入样例2：23输出样例2：SS123</code></pre><p>题目代码：此题也可以直接输出没有必要创建一个string类型的数据。个十百位也可以使用数组来进行保存。</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  int n, g, s = 0, b = 0;  cin &gt;&gt; n;  g = n % 10;//个位  n /= 10;  if (n) s = n % 10;//十位  n /= 10;  if (n) b = n % 10;//百位  string str;  while (b) {    str += &apos;B&apos;;    b--;  }  while (s) {    str += &apos;S&apos;;    s--;  }  for (int i = 1;i &lt;= g;i++) {    str +=(i+&apos;0&apos;);  }  cout &lt;&lt; str;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&amp;lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1005 继续(3n+1)猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1005-继续(3n+1)猜想/</id>
    <published>2018-04-26T03:11:34.000Z</published>
    <updated>2018-04-26T03:13:24.838Z</updated>
    
    <content type="html"><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p><p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p><pre><code>输入样例：63 5 6 7 8 11输出样例：7 6</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool cmp(int a, int b) {  return a &gt; b;}int arr[10000];//全局数组默认值为0int main() {  int k, n;  cin &gt;&gt; k;  vector&lt;int&gt; v(k);  for (int i = 0;i &lt; k;i++) {    cin &gt;&gt; n;    v[i] = n;//初始化动态数组    while (n != 1) {      if (n % 2 == 0)        n /= 2;      else        n = (3 * n + 1) / 2;      arr[n] = 1;//将所有元素会覆盖的值加入arr当中,1表示覆盖过    }  }  sort(v.begin(), v.end(), cmp);//将动态数组元素从大到小排序  //用于判定是否输出空格(此处由于无法预知未曾遍历的数组元素当中是否存在没有被覆盖的情况，只好将空格的输出判定放在已经确定的未被覆盖元素之前)  int flag = 0;  for (int i = 0;i &lt; v.size();i++) {//遍历整个数组    if (!arr[v[i]]) {      if (flag == 1) cout &lt;&lt; &quot; &quot;;      cout &lt;&lt; v[i];      flag = 1;    }      }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。&lt;/p&gt;
&lt;p&gt;当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>我喜欢夜是寂静的</title>
    <link href="http://www.echodemo.cc/2018/04/25/%E6%88%91%E5%96%9C%E6%AC%A2%E5%A4%9C%E6%98%AF%E5%AF%82%E9%9D%99%E7%9A%84/"/>
    <id>http://www.echodemo.cc/2018/04/25/我喜欢夜是寂静的/</id>
    <published>2018-04-25T14:11:09.000Z</published>
    <updated>2018-04-25T14:18:24.864Z</updated>
    
    <content type="html"><![CDATA[<p>我喜欢夜是寂静的</p><p>那遥远的地方跑过来的黑夜</p><p>喃喃地呼唤我</p><p>将我揽入她的怀抱</p><p><br><br>她也叫来昏黄的路灯</p><p>挂在我的头上</p><p>头顶再遥远的地方</p><p>淡淡的星子在闪</p><p>四周里安静无声，那是因为</p><p>夜，也喜欢我是寂静着的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我喜欢夜是寂静的&lt;/p&gt;
&lt;p&gt;那遥远的地方跑过来的黑夜&lt;/p&gt;
&lt;p&gt;喃喃地呼唤我&lt;/p&gt;
&lt;p&gt;将我揽入她的怀抱&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;她也叫来昏黄的路灯&lt;/p&gt;
&lt;p&gt;挂在我的头上&lt;/p&gt;
&lt;p&gt;头顶再遥远的地方&lt;/p&gt;
&lt;p&gt;淡淡的星子在闪&lt;/p&gt;
&lt;p&gt;四
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 二进制中有多少个1</title>
    <link href="http://www.echodemo.cc/2018/04/23/LintCode-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/"/>
    <id>http://www.echodemo.cc/2018/04/23/LintCode-二进制中有多少个1/</id>
    <published>2018-04-23T08:59:23.000Z</published>
    <updated>2018-04-23T09:13:06.117Z</updated>
    
    <content type="html"><![CDATA[<p>计算在一个 32 位的整数的二进制表示中有多少个 1.</p><p>样例</p><pre><code>给定 32 (100000)，返回 1给定 5 (101)，返回 2给定 1023 (1111111111)，返回 10</code></pre><p>代码一：此题如果采用的是移位的方法，那么这里唯一需要注意的是当给定的测试用例是负数的时候要先计算位于负号位的1，然后转化为正整数之后再进行移位的操作和计数。</p><pre><code>int countOnes(int num) {    int count = 0;    if (num &lt; 0) {        count++;        num = num ^ 0x80000000;    }    while (num &gt; 0) {        if (num &amp; 1) {            count++;          }        num = num &gt;&gt; 1;    }    return count;}</code></pre><p>代码二：这种方法还是比较巧妙，这里的数字本身和减一之后的数相与让我想起了计算数是否为2的幂次的程序。</p><pre><code>int countOnes(int num){    int count = 0;    while(num){        num = num &amp; (num-1);        count++;    }    return count;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算在一个 32 位的整数的二进制表示中有多少个 1.&lt;/p&gt;
&lt;p&gt;样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 32 (100000)，返回 1

给定 5 (101)，返回 2

给定 1023 (1111111111)，返回 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码一
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LintCode" scheme="http://www.echodemo.cc/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1004 成绩排名</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1004-成绩排名/</id>
    <published>2018-04-21T11:57:45.000Z</published>
    <updated>2018-04-25T14:58:45.338Z</updated>
    
    <content type="html"><![CDATA[<p>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p><p>输入格式：每个测试输入包含1个测试用例，格式为</p><pre><code>第1行：正整数n第2行：第1个学生的姓名 学号 成绩第3行：第2个学生的姓名 学号 成绩... ... ...第n+1行：第n个学生的姓名 学号 成绩</code></pre><p>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p><p>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p><pre><code>输入样例：3Joe Math990112 89Mike CS991301 100Mary EE990830 95输出样例：Mike CS991301Joe Math990112</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {    int n, score, maxscore = -1, minscore = 101;    string name, number, maxname, minname, maxnumber, minnumber;    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; name &gt;&gt; number &gt;&gt; score;        if (score &gt; maxscore) {            maxscore = score;            maxname = name;            maxnumber = number;        }        if (score &lt; minscore) {            minscore = score;            minname = name;            minnumber = number;        }    }    cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnumber &lt;&lt; endl;    cout &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnumber;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，格式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第1行：正整数n
第2行：第1个学生的姓名 学号 成绩
第3行：第2个学生的姓名 学号 成绩
... .
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1003 我要通过！</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1003-我要通过！/</id>
    <published>2018-04-21T07:32:58.000Z</published>
    <updated>2018-04-25T14:58:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：</p><ol><li><p>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</p></li><li><p>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</p></li><li><p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</p></li></ol><p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p><p>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p><p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p><pre><code>输入样例：8PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA输出样例：YESYESYESYESNONONONO</code></pre><p>分析：这种题目切不可仓促下笔，需要根据题目给出的条件分析清楚其中潜藏的规律。最好的方法就是使用输入输出样例当中的正确样例进行代入当然也可以自行多加一些样例来让结果更直观。此题的条件一可以说是一目了然，就没有代入的必要了。重点在于条件二和条件三。</p><p>条件二：任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举出以下皆正确的样例：</p><pre><code>PATAPATAAAPATAAAAAPATAAAAAAAPATAAAA...</code></pre><p>从中可以得出：在字符’PAT’的前面和后面添加任意相等个数的字符’A’即可满足条件二。</p><p>条件三：如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举以下样例：</p><pre><code>PATPAATPAAAAATAPATAAPAATAAAPAAATAAAAAPATAAAAPAATAAAAAAPAAATAAAAAA</code></pre><p>总结来说：只能有一个P一个T，中间末尾和开头可以随便插入A。但是必须满足开头的A的个数 * 中间的A的个数 = 结尾的A的个数。</p><pre><code>#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() {    int n, p = 0, t = 0;    string s;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) {        cin &gt;&gt; s;        map&lt;char, int&gt; m;        for(int j = 0; j &lt; s.size(); j++) {            m[s[j]]++;            if (s[j] == &apos;P&apos;) p = j;            if (s[j] == &apos;T&apos;) t = j;        }        if(m[&apos;P&apos;] == 1 &amp;&amp; m[&apos;A&apos;] != 0 &amp;&amp; m[&apos;T&apos;] == 1 &amp;&amp; m.size() == 3 &amp;&amp; p * (t-p-1) == s.length()-t-1)            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符串中必须仅有P, A, T这三种字符，不可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1002 写出这个数</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1002-写出这个数/</id>
    <published>2018-04-21T03:10:23.000Z</published>
    <updated>2018-04-21T03:12:13.025Z</updated>
    
    <content type="html"><![CDATA[<p>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100。</p><p>输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。</p><pre><code>输入样例：1234567890987654321123456789输出样例：yi san wu</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  string s;  cin &gt;&gt; s;  string str[10] = { &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; };  int sum = 0;  for (int i = 0;i &lt; s.length();i++) {    sum += (s[i] - &apos;0&apos;);  }  string number = to_string(sum);  for (int i = 0;i &lt; number.length();i++) {    cout &lt;&lt; str[number[i] - &apos;0&apos;];    if (i &lt; (number.length()-1)) cout &lt;&lt; &quot; &quot;;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。&lt;/p&gt;
&lt;p&gt;输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100。&lt;/p&gt;
&lt;p&gt;输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1001 害死人不偿命的(3n+1)猜想</title>
    <link href="http://www.echodemo.cc/2018/04/21/PAT-B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/21/PAT-B1001-害死人不偿命的(3n+1)猜想/</id>
    <published>2018-04-21T02:26:45.000Z</published>
    <updated>2018-04-21T02:30:24.438Z</updated>
    
    <content type="html"><![CDATA[<pre><code>卡拉兹(Callatz)猜想：</code></pre><p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p><p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p><p>输出格式：输出从n计算到1需要的步数。</p><pre><code>输入样例：3输出样例：5</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {    int n, num = 0;    cin &gt;&gt; n;    while (n != 1) {        if (n % 2 == 0) n /= 2;        else n = (3 * n + 1) / 2;        num++;    }    cout &lt;&lt; num;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;卡拉兹(Callatz)猜想：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>最长不下降子序列</title>
    <link href="http://www.echodemo.cc/2018/04/21/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/21/最长不下降子序列/</id>
    <published>2018-04-21T01:35:56.000Z</published>
    <updated>2018-04-21T02:03:39.927Z</updated>
    
    <content type="html"><![CDATA[<p>在一个数字序列中，找到一个最长的子序列(可以不连续)，使得这个子序列是不下降(非递减)的。</p><p>分析：此题如若采用暴力的方法来解答，即对于每个元素有取或是不取两种选择，时间复杂度可以达到O(2^n)。</p><p>令dp[i]表示以A[i]结尾的最长不下降子序列长度(和最大连续子序列和问题一样，以A[i]结尾是强制的要求)。此时会有两种情况：一种是存在A[i]之前的元素A<a href="j&lt;i">j</a>，使得A[j]&lt;=A[i]且dp[j]+1&gt;dp<a href="需要说明的是，这个dp[i]是边界条件或者是A[j]前面的元素在以A[i]结尾的LIS形成的dp[i]">i</a>,那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列(dp[i]=dp[j]+1)；另一种是A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS，此时的长度为1。则其状态转移方程为：dp[i]=max(1,dp[j]+1)(j=1,2,…,i-1&amp;&amp;A[j]&lt;A[i])，其边界条件就为：dp[i]=1(1&lt;=i&lt;=n)。其整体复杂度为O(n^2)。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;const int N=100;int A[N],dp[N];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;A[i];    }    int num=-1;    for(int i=1;i&lt;=n;i++){        dp[i]=1;//边界初始条件        for(int j=1;j&lt;i;j++){            if((A[i]&gt;=A[j])&amp;&amp;(dp[j]+1&gt;dp[i])){                dp[i]=dp[j]+1;            }        }        num=max(num,dp[i]);    }    cout&lt;&lt;num;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个数字序列中，找到一个最长的子序列(可以不连续)，使得这个子序列是不下降(非递减)的。&lt;/p&gt;
&lt;p&gt;分析：此题如若采用暴力的方法来解答，即对于每个元素有取或是不取两种选择，时间复杂度可以达到O(2^n)。&lt;/p&gt;
&lt;p&gt;令dp[i]表示以A[i]结尾的最长不下降子序列
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大连续子序列的和</title>
    <link href="http://www.echodemo.cc/2018/04/20/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%92%8C/"/>
    <id>http://www.echodemo.cc/2018/04/20/最大连续子序列的和/</id>
    <published>2018-04-20T14:59:34.000Z</published>
    <updated>2018-04-20T15:33:51.949Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数字序列A1，A2，…，An，求i,j(1&lt;=i&lt;=j&lt;=n)，使得Ai+…+Aj最大，输出这个最大的和。</p><p>分析：这个问题如若暴力来做，枚举i,j需要O(n^2)的复杂度，而计算A[i]+…+A[j]需要O(n)的复杂度，因此总的复杂度为O(n^3)。就算采用记录前缀和的方法(预处理S[i]=A[0]+A[1]+…+A[i],这样A[i]+…+A[j]=S[j]-S[i-1])使计算的时间变为O(1)，总的复杂度仍然有O(n^2)。</p><p>这里介绍动态规划的做法，复杂度为O(n)。令状态dp[i]表示以A[i]作为末尾的连续序列的最大和(这里的连续指的是从第一个元素开始)。其实所要求的最大和就是dp数组中的最大值。也就是说求dp[i]时，只要dp[i-1]小于零就舍弃前面的和，直接取A[i]的值作为dp[i]即可；而如果dp[i-1]大于零，dp[i]就等于dp[i-1]+A[i]。于是得到dp[i]=max(A[i],dp[i-1]+A[i])。而边界就是dp[0]=A[0]。</p><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10010;int A[maxn], dp[maxn];int main() {    int n;    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; A[i];    }    dp[0] = A[0];//边界    for (int i = 0;i &lt; n;i++) {        dp[i] = max(A[i], dp[i - 1] + A[i]);//状态转移方程    }    int k = 0;    for (int i = 1;i &lt; n;i++) {        if (dp[i] &gt; dp[k])            k = i;    }    cout &lt;&lt; dp[k];    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数字序列A1，A2，…，An，求i,j(1&amp;lt;=i&amp;lt;=j&amp;lt;=n)，使得Ai+…+Aj最大，输出这个最大的和。&lt;/p&gt;
&lt;p&gt;分析：这个问题如若暴力来做，枚举i,j需要O(n^2)的复杂度，而计算A[i]+…+A[j]需要O(n)的复杂度，因此总的复杂
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://www.echodemo.cc/2018/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.echodemo.cc/2018/04/20/动态规划/</id>
    <published>2018-04-20T04:38:20.000Z</published>
    <updated>2018-04-20T04:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：</p><pre><code>int F(int n){    if(n==0||n==1) return 1;    else return F(n-1)+F(n-2);}</code></pre><p>然而上述代码会涉及很多的重复计算，由于没有对中间计算的结果进行保存，实际复杂度会高达O(2^n)。这里通过开一个数组来对已计算出来的数据进行保存。</p><pre><code>int dp[max];int F(int n){    if(n==0||n==1) return 1;    if(dp[n]!=-1) return dp[n];    else{        dp[n]=F(n-1)+F(n-2);        return dp[n];    }}</code></pre><p>这样可以将复杂度从O(2^n)降到O(n)。如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有重叠子问题。因此，一个问题必须拥有重叠子问题，才能使用动态规划进行求解。</p><p>2、动态规划的递推写法：其使用的计算方式是自底向上，即从边界开始，不断向上解决问题，直到解决了目标问题为止；而递归写法是自顶向下，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止。以经典的数塔问题为例</p><p>首先开一个二维数组array[i][j]对每层的数据进行存放，由于除第一层之外，每一层都至少会有一条重合的路径。不妨零dp[i][j]表示从第i行第j个数字出发到达最底层的所有路径中能得到的最大和。也就会有dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j]。这里把dp[i][j]称为问题的状态，把这个式子称为状态转移方程。数塔的边界是dp[n][j]==array[n][j]，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn=1000;int array[maxn][maxn],dp[maxn][maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=i;j++){            cin&gt;&gt;array[i][j];//初始化数塔        }    }    for(int i=1;i&lt;=n;i++){//边界        dp[n][i]=array[n][i];    }    for(int i=n-1;i&gt;=1;i--){        for(int j=1;j&lt;=i;j++){            dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j];//状态转移方程        }    }    cout&lt;&lt;dp[1][1];    return 0}</code></pre><p>如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么就称这个问题拥有最优子结构。因此，一个问题必须拥有最优子结构，才能使用动态规划进行求解。</p><p>3、两组概念的区分</p><p>(1)分治和动态规划</p><p>分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题。</p><p>(2)贪心和动态规划</p><p>贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程对数塔问题而言，贪心法从最上层开始，每次选择左下和右上两个数字中较大的一个，一直到最底层得到最后的结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶下下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，他总是会考虑所有的子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士割腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int F(int n){
    if(n==0||n==1) return 1;
    else return
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1002 A+B for Polynomials</title>
    <link href="http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/"/>
    <id>http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/</id>
    <published>2018-04-13T13:49:02.000Z</published>
    <updated>2018-04-13T13:57:54.726Z</updated>
    
    <content type="html"><![CDATA[<p>This time, you are supposed to find A+B where A and B are two polynomials.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p><p>Output Specification:</p><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><pre><code>Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output3 2 1.5 1 2.9 0 3.2</code></pre><p>此题在一开始写的时候没有注意到当输出系数不为零的个数为0时的情况，故导致格式错误。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main() {    double a[1001] = { 0.0 }, b[1001] = { 0.0 }, c[1001] = { 0.0 };    int m, n;    cin &gt;&gt; m;    for (int i = 0;i &lt; m;i++) {//初始化第一个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; a[j];        c[j] += a[j];    }    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {//初始化第二个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; b[j];        c[j] += b[j];    }    int num = 0;    for (int i = 0;i &lt; 1001;i++) {//计算系数非零的个数        if (c[i] != 0) num++;    }    cout &lt;&lt; num;    if (num != 0) cout &lt;&lt; &quot; &quot;;//这里需要注意    for (int i = 1000;i &gt;= 0;i--) {        if (c[i] == 0) continue;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;        printf(&quot;%.1f&quot;, c[i]);        num--;        if (num != 0) cout &lt;&lt; &quot; &quot;;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;/p&gt;
&lt;p&gt;Each input file contains on
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1001 A+B Format</title>
    <link href="http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/"/>
    <id>http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/</id>
    <published>2018-04-12T09:09:21.000Z</published>
    <updated>2018-04-12T09:51:44.778Z</updated>
    
    <content type="html"><![CDATA[<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><p>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p><p>Output Specification:</p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><pre><code>Sample Input-1000000 9Sample Output-999,991</code></pre><p>此题使用如下代码在PAT测试时出现一个段错误。如有大佬光临寒舍，还望多多指教。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;using namespace std;int main() {    int a, b,sum=0;    cin &gt;&gt; a &gt;&gt; b;    sum = a + b;    if (sum &lt; 0) cout &lt;&lt; &quot;-&quot;;//和为负数，就先把负号输出    sum = (sum &lt; 0) ? -sum : sum;//求绝对值    stack&lt;char&gt; s;    int num = 0;    while (sum) {        s.push((sum % 10)+&apos;0&apos;);//从最低位开始入栈        num++;//统计sum中各个位入栈的个数        if (num % 3 == 0) s.push(&apos;,&apos;);//每当sum的位入栈三次，就把‘，’入栈        sum /= 10;    }    if (s.top() == &apos;,&apos;) s.pop();//如果全栈最顶为‘，’，则直接出栈    while (!s.empty()) {        cout &lt;&lt; s.top();//输出栈顶元素        s.pop();//栈顶元素出栈    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless ther
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2018/04/08/梦境/</id>
    <published>2018-04-08T04:45:29.000Z</published>
    <updated>2018-04-08T04:47:49.996Z</updated>
    
    <content type="html"><![CDATA[<p>夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一种方式，人在极度的恐惧当中，往往会表现出最本真的自己，没有压抑也没有伪装。人需要有所畏惧，有所敬畏，生于忧患，死于安乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1053 Path of Equal Weight</title>
    <link href="http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/"/>
    <id>http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/</id>
    <published>2018-04-08T02:12:36.000Z</published>
    <updated>2018-04-08T02:29:46.326Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p><p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt;= 100, the number of nodes in a tree, M (&lt; N), the number of non-leaf nodes, and 0 &lt; S &lt; 230, the given weight number. The next line contains N positive numbers where Wi (&lt;1000) corresponds to the tree node Ti. Then M lines follow,each in the format:</p><pre><code>ID K ID[1] ID[2] ... ID[K]</code></pre><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</p><p>Output Specification:</p><p>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p><p>Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &lt;= k &lt; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 &gt; Bk+1.</p><pre><code>Sample Input:20 9 2410 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 200 4 01 02 03 0402 1 0504 2 06 0703 3 11 12 1306 1 0907 2 08 1016 1 1513 3 14 16 1717 2 18 19Sample Output:10 5 2 710 4 1010 3 3 6 210 3 3 6 2</code></pre><p>题目大意：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be t
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>树的静态写法和遍历</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A0%91%E7%9A%84%E9%9D%99%E6%80%81%E5%86%99%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://www.echodemo.cc/2018/04/08/树的静态写法和遍历/</id>
    <published>2018-04-08T02:01:52.000Z</published>
    <updated>2018-04-08T02:04:13.825Z</updated>
    
    <content type="html"><![CDATA[<p>1、存储结构</p><p>由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态分配。</p><pre><code>struct node{    typename data;//数据域    vector&lt;typename&gt; child;//指针域，存放所有子节点的下标}Node[maxn];//节点数组，maxn为节点的上限个数</code></pre><p>2、新建一个节点</p><pre><code>int index=0;int newNode(int x){    Node[index].data=x;//数据域为x    Node[index].child.clear();//清空子节点    return index++;//返回节点下标，并令index自增}</code></pre><p>3、先根遍历</p><pre><code>void preOrder(int root){    cout&lt;&lt;Node[root].data&lt;&lt;&quot; &quot;;//访问当前节点    for(int i=0;i&lt;Node[root].child.size();i++){        preOrder(Node[root].child[i]);//递归访问节点root的所有子节点    }}</code></pre><p>4、层序遍历</p><pre><code>void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre><p>如果需要计算每个节点的层次，存储结构和层序遍历如下：</p><pre><code>struct node{    int layer;    typename data;    vector&lt;typename&gt; child;}void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    Node[root].layer=1;    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            Node[Node[now].child[i]].layer=Node[now].layer+1;//子节点的层数加1            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、存储结构&lt;/p&gt;
&lt;p&gt;由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
