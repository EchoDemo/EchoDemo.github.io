<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-03-27T11:54:38.037Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三月二十七号</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E4%B8%89%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8F%B7/"/>
    <id>http://www.echodemo.cc/2018/03/27/三月二十七号/</id>
    <published>2018-03-27T11:51:27.000Z</published>
    <updated>2018-03-27T11:54:38.037Z</updated>
    
    <content type="html"><![CDATA[<p>奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量的传递与引导，人与自然需要一定的联结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/27/《眠空》摘句(二)/</id>
    <published>2018-03-27T11:29:09.000Z</published>
    <updated>2018-03-27T11:30:11.879Z</updated>
    
    <content type="html"><![CDATA[<p>1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。仿佛一种强悍的无法屈服的意愿。</p><p>2、我们最终所得到的训练无非是，面对无所知、无常、虚妄，时时抚平心绪，保持警惕、平静、坚强、有方向地活下去。并且静观这个世间所有破落的碎片擦身而过。</p><p>3、人的生活需要公园。它为日常生活提供一处停顿。停顿意味暂时没有心念，没有目标，略作小憩，与己共存。</p><p>4、如果要做到不伤害他人，前提是不要对他人抱有期待。同时也不让他人抱有对你的期待。做到后一条更为困难。这意味着在某些时刻，你必须显示你自己真实的立场，而没有一丝自私的隐藏或者造作。</p><p>5、有时，我们爱人，是取悦自己渴望被爱的欲求；对他人的提供，是试图填补内在匮乏的需求；憎恶或攻击他人，是被对方提醒了不愿意被揭示的遮蔽的暗处；愤恨或者狂躁，联结着内心长期积累的软弱和无力。。。自我战争不过是冲突于牢笼之中。</p><p>6、时间很重要，物证很重要。它们会使某些曾经被蒙蔽或忽略的情感，在很久之后被澄清和浮出。我也会手写书信给生命中真正重要的人。只为了让他或她，在以后某天终会明白我的心。</p><p>7、摘完杏，和农夫闲聊。他说果实在树上，阳光的温度或突降的暴雨都会给予它影响。每一天它的内在都在发生变化，都在面临无常。所以，及时地摘下并享用它即是最好的方式。</p><p>8、人由自我限制而生发的对他人的狭窄念头，毫发无损于对方，只使自己捉襟见肘。若能置身事外，才不会画地为牢。</p><p>9、当下享受是最好的态度。接受无常，接纳完整的存在，而不试图重新塑造，也不扭曲自己和他人。关系第一原则，应是允许他人以独立和自愿的方式存在。期望是自以为是的权力。</p><p>10、在一本书里，读者感受到作者的精神方式、观念、特质，觉得与之契合，有共鸣，遂在心里把他当作一个知己。他们之间的关系，有时会比生活中实际相处的人抵达更为深邃的心灵限度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(三)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(三)/</id>
    <published>2018-03-26T10:10:23.000Z</published>
    <updated>2018-03-26T10:15:01.624Z</updated>
    
    <content type="html"><![CDATA[<p>1、define与const的区别</p><p>(1)define在预处理阶段进行替换;const在编译时确定其值。</p><p>(2)用define可以定义一些简单的函数，const是不可以定义函数的。</p><p>(3)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的。</p><p>(4)define无类型，不进行类型安全检查，可能会产生意想不到的错误;const有数据类型,编译时会进行类型检查。</p><p>(5)define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大;const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。</p><p>(6)宏定义的作用范围仅限于当前文件;而const对象在默认状态下，只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字(在声明和定义时都要加。</p><p>2、构造函数不能为虚函数，而析构函数可以且常常是虚函数</p><p>(1)如果构造函数是虚函数，那么就需要通过vtable来调用，但此时面对一块raw memeory是找不到vtable的，vtable是在构造函数中才初始化的，而不是在其之前。因此构造函数不能为虚函数。</p><p>(2)析构函数可以是虚函数,此时vtable已经初始化了,况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p><p>3、虚函数和纯虚函数的作用与区别</p><p>(1)虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不重写基类中的此函数。</p><p>(2)纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数。它不能直接实例化，需要派生类来实现函数定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、define与const的区别&lt;/p&gt;
&lt;p&gt;(1)define在预处理阶段进行替换;const在编译时确定其值。&lt;/p&gt;
&lt;p&gt;(2)用define可以定义一些简单的函数，const是不可以定义函数的。&lt;/p&gt;
&lt;p&gt;(3)用define定义的常量是不可以用指针变量去
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(二)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(二)/</id>
    <published>2018-03-26T07:12:01.000Z</published>
    <updated>2018-03-26T10:09:55.799Z</updated>
    
    <content type="html"><![CDATA[<p>1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。</p><p>2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。</p><p>3、构造函数初始化时必须采用初始化列表的一共有三种情况</p><pre><code>(1)需要初始化的数据成员是对象(继承时调用基类构造函数)(2)需要初始化const修饰的类成员(3)需要初始化引用成员数据*由于static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的。static const成员也不在初始化列表中。*static属于类，它在未实例化的时候就已经存在了，而构造函数的初始化列表，只有在实例化的时候才执行。*static成员不属于对象。我们在调用构造函数自然是创建对象，一个跟对象没直接关系的成员没有必要初始化。</code></pre><p>4、实参可以是任何类型（可以是常量，变量或表达式），但是形参却不能是表达式。C语言中最简单的数据类型包括整型、实型(实型又称浮点数或者实数)、字符型。在C语言中，没有专门的逻辑型数据类型，而是用0和1来表示逻辑值。</p><p>5、类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐。基类中存在虚函数时，派生类会继承基类的虚函数(虚函数也是类的成员函数)，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。(指向虚函数的指针为4个字节)</p><p>6、fork()与clone的区别</p><p>函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；clone()函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可以通过参数设定选择的，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。</p><p>7、关于浅复制和深复制</p><p>所谓浅复制，就是在构造函数当中直接为复制的对象的数据成员赋值。在很多情况下，这是可以的。创建新的对象，要为对象的数据成员分配存储空间，直接赋值就将值保存在相应的空间中。但是如果在构造函数当中出现了指针类型的数据成员时，也按照上面那样直接赋值而未经过地址的分配就会在调试的时候出错，这种指针被称为“野指针”。解决这样的问题的方法，就是在构造函数中，为指针类型的成员，分配专门的空间。以这条规则构建的复制，称作为深复制。</p><p>8、C语言中的未定义行为(Undefined Behavior)</p><p>未定义行为是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。</p><p>9、C++面向对象的三个基本特征(封装、继承和多态)</p><p>(1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行。封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p><p>(2)继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>(3)多态：是对于不同对象接收相同消息时产生不同的动作。允许将子类类型的指针赋值给父类类型的指针。在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上。</p><p>*封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现接口重用！</p><p>10、虚函数如何实现的</p><pre><code>(1)虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针。(2)在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。(3)实际上在编译的时候，编译器会自动加上虚表。(4)虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函数重新定义。(5)虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。(6)必须通过基类类型的引用或指针进行函数调用才会发生多态。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。&lt;/p&gt;
&lt;p&gt;2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Windows中个人常用快捷键</title>
    <link href="http://www.echodemo.cc/2018/03/26/Windows%E4%B8%AD%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.echodemo.cc/2018/03/26/Windows中个人常用快捷键/</id>
    <published>2018-03-26T03:10:27.000Z</published>
    <updated>2018-03-26T03:13:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ctrl类</p><pre><code>(1)撤消操作：Ctrl+Z(2)复制选定文本：Ctrl+C(3)粘贴选定文本：Ctrl+V(4)剪切选定文本：Ctrl+X(5)打开新窗口：Ctrl+N(6)关闭当前所在窗口：Ctrl+W(7)恢复关闭的窗口：ctrl+shift+T(8)新建文件夹：Ctrl+Shift+N(9)选择文档或窗口中的所有项目：Ctrl+A(10)在本应用下的窗口之间进行切换：Ctrl+Tab</code></pre><p>2、Windows类</p><pre><code>(1)电脑锁屏：Windows+L(2)显示和隐藏桌面：Windows+D(3)打开任务视图：Windows+Tab(4)打开“运行”对话框：Windows+R(5)打开文件资源管理器：Windows+E(6)添加虚拟桌面：Windows+Ctrl+D(7)关闭你正在使用的虚拟桌面：Windows+Ctrl+F4(8)在你于右侧创建的虚拟桌面之间切换：Windows+Ctrl+向右键(9)在你于左侧创建的虚拟桌面之间切换：Windows+Ctrl+向左键    </code></pre><p>3、其他</p><pre><code>(1)刷新当前窗口：F5(2)在所有打开的应用之间进行切换：Alt+Tab</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Ctrl类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)撤消操作：Ctrl+Z

(2)复制选定文本：Ctrl+C

(3)粘贴选定文本：Ctrl+V

(4)剪切选定文本：Ctrl+X


(5)打开新窗口：Ctrl+N

(6)关闭当前所在窗口：Ctrl+W

(7)恢复关
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="http://www.echodemo.cc/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>指针和引用的区别</title>
    <link href="http://www.echodemo.cc/2018/03/25/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.echodemo.cc/2018/03/25/指针和引用的区别/</id>
    <published>2018-03-25T11:23:26.000Z</published>
    <updated>2018-03-26T07:22:21.218Z</updated>
    
    <content type="html"><![CDATA[<p>(1)可以有const指针，但是没有const引用。</p><p>(2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;&a;是不合法的)。</p><p>(3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。</p><p>(4)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</p><p>(5)指针可以是空值，可以在任何时候被初始化。而引用不可以为空且在被创建的时候，必须初始化。此处引用类似于const的指针。</p><p>(6)指针和引用的自增(++)运算意义不一样。指针自增是所指的数据类型变量的下一个数据类型的地址。而引用是引用所指向的变量的值加1。</p><p>(7)”sizeof(引用)”得到的是所指向的变量(对象)的大小(即引用的sizeof为所引用的对象在内存中分配空间的大小(单位字节))，而”sizeof(指针)”得到的是指针本身的大小。在C++当中，存放一个地址和一个int类型的大小相同：4字节。即sizeof(指针)=4。</p><p>(8)指针是一个变量，只不过这个变量存储的是一个地址，是指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。引用变量的主要作用是用作函数的形参，通过将引用变量用作形参，函数将使用原始数据，而不是其副本。</p><p>注意：要把引用的&amp;和取地址运算符&amp;区分开来，引用并不是取地址的意思，引用符号是类型标识的一部分。由于引用是产生变量的别名，故常量不可使用引用。指针变量其实是unsigned类型的整数，这也解释了为什么在C++当中指针类型的变量的sizeof就是4个字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(1)可以有const指针，但是没有const引用。&lt;/p&gt;
&lt;p&gt;(2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;amp;&amp;a;是不合法的)。&lt;/p&gt;
&lt;p&gt;(3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(一)</title>
    <link href="http://www.echodemo.cc/2018/03/25/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/03/25/C++中的问题整理(一)/</id>
    <published>2018-03-25T11:19:51.000Z</published>
    <updated>2018-03-26T01:12:10.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别"><a href="#1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别" class="headerlink" title="1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?"></a>1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?</h3><p>答：对于#include&lt;filename.h&gt;,编译器从标准库路径开始搜索filename.h,而对于#include “filename.h”,编译器从用户的工作路径开始搜索filename.h。</p><h3 id="2、在C-程序中调用被C编译器编译后的函数-为什么要加extern“C”"><a href="#2、在C-程序中调用被C编译器编译后的函数-为什么要加extern“C”" class="headerlink" title="2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?"></a>2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?</h3><p>答：C++语言支持函数重载,C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为:void foo(int x, int y);该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int 之类的名字。C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。</p><h3 id="3、一个类有基类、内部有一个其他类的成员对象-构造函数的执行顺序是怎样的"><a href="#3、一个类有基类、内部有一个其他类的成员对象-构造函数的执行顺序是怎样的" class="headerlink" title="3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?"></a>3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?</h3><p>答：先执行基类的(如果基类当中有虚基类,要先执行虚基类的,其他基类则按照声明派生类时的顺序依次执行),再执行成员对象的,最后执行自己的。</p><h3 id="4、New-delete与malloc-free的区别是什么？"><a href="#4、New-delete与malloc-free的区别是什么？" class="headerlink" title="4、New/delete与malloc/free的区别是什么？"></a>4、New/delete与malloc/free的区别是什么？</h3><p>(1)new/delete是C++的操作符，而malloc/free是C中的函数。</p><p>(2)new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p><p>(3)new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。</p><p>(4)new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。</p><h3 id="5、Struct和class的区别是什么？"><a href="#5、Struct和class的区别是什么？" class="headerlink" title="5、Struct和class的区别是什么？"></a>5、Struct和class的区别是什么？</h3><pre><code>答：struct中成员变量和成员函数默认访问权限是public,class是private。</code></pre><h3 id="6、多态有哪些分类？"><a href="#6、多态有哪些分类？" class="headerlink" title="6、多态有哪些分类？"></a>6、多态有哪些分类？</h3><p>答：多态可以分为编译时多态和运行时多态。编译时多态可以通过函数的重载来实现，具体表现在根据参数的个数和类型的不同选择合适的同名函数。运行时多态通过虚函数实现，就是运行时根据对象类型自动选择正确的调用函数(也叫动态绑定)。模板属于编译时多态性，因为编译时自动根据模板生成模板函数。虚函数的动态绑定仅在基类指针或引用绑定派生类对象时发生。如果函数的形参不是指针或者引用，则调用哪个类的函数就已经确定。</p><h3 id="7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？"><a href="#7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？" class="headerlink" title="7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？"></a>7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？</h3><pre><code>(1)默认情况下，编译器的对齐系数为8(2)内存对齐：就是每个成员的起始位置必须是对齐系数与成员自身大小二者中较小者的整数倍。(3)内存补齐：取结构体或类的成员中最大的那个值，与对齐系统相比，取二者中的较小者。然后保证整个对象结尾地址的下一个地址是较小者的整数倍。(4)结构体对齐除了第1点之外还要求结构体数组也必须是对齐的，也就是说每个相邻的结构体内部都是对齐的。可以看一下这篇文章:http://www.cppblog.com/cc/archive/2006/08/01/10765.html</code></pre><h3 id="8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。"><a href="#8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。" class="headerlink" title="8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。"></a>8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。</h3><h3 id="9、const-有什么用途？"><a href="#9、const-有什么用途？" class="headerlink" title="9、const 有什么用途？"></a>9、const 有什么用途？</h3><p>(1)可以定义const常量。</p><p>(2)const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。被const修饰的函数定义体的函数能被const或者非const对象调用，但是const对象只能调用被const修饰过定义体的函数。</p><h3 id="10、什么是内联函数？"><a href="#10、什么是内联函数？" class="headerlink" title="10、什么是内联函数？"></a>10、什么是内联函数？</h3><p>(1)编译器使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存。例如：如果程序在10个不同的地方调用了同一个内联函数，则该程序将包含该代码的10个副本。</p><p>(2)在函数声明之前加上关键字inline或者在函数定义之前加上inline。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别&quot;&gt;&lt;a href=&quot;#1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>诗词入门(一)</title>
    <link href="http://www.echodemo.cc/2018/03/24/%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/03/24/诗词入门(一)/</id>
    <published>2018-03-24T15:52:33.000Z</published>
    <updated>2018-03-25T05:28:14.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、格律"><a href="#1、格律" class="headerlink" title="1、格律"></a>1、格律</h2><p>(1)平仄:单个汉字发音的音调</p><p>a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平。四声当中平声属于平仄当中的平声,而另外三声上、去、入则属于平仄中的仄声。</p><p><img src="/images/2018/3/1.jpg" alt="&quot;平仄&quot;"></p><p>b、古代汉语的四声和今天普通话的声调种类不完全相同。上图中的黑色线条对古代汉语四声和现代汉语四声的连接是比较容易区分的：平声分为阴平和阳平，其中阴平对应现代汉语中的第一声，而阳平则对应现代汉语中的第二声；属于仄声的上声对应现代汉语中的第三声；属于仄声的去声则对应现代汉语中的第四声。</p><p>c、上图中用灰色线条连接起来的有关属于仄声的入声的演化是学习近体诗中平仄最让人费解的了。虽然现代江浙、福建、广东、广西、湖南和江西等处还保存着入声，北方也有不少地方保存着入声这一个调类。但在普通话当中，入声字已经不复存在了。而是分别演化进了现代汉语中的一、二、三、四声中去(也就是派进了古代汉语中的平、上、去三声当中，也称之为‘入派三声’)。当然对于演化成现代汉语中的三、四声的字我们无需担心(因为三、四声所对应的上声和去声本就是属于古代汉语中的仄声)，所以令我们困惑的就是演化成现代汉语中一、二声的入声字(即入声演化为平声的情况)。而这一障碍是需要依靠查字典或者韵书才能消除的。</p><p>d、这里引用大家耳熟能详的柳宗元的《江雪》作为例子来说明入派三声</p><pre><code>《江雪》柳宗元千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。这里的绝(jue)、灭(mie)、雪(xue)都是入声字，分别演化分布于平、上、去三声当中。</code></pre><p>e、古仄今平、古平今仄和可平可仄。</p><pre><code>古仄今平：就是上面提到过的入声派入平声。例：黑、白、竹、屋、绝、笛。。。古平今仄：俱(ju第一声)、论(lun第二声)语可平可仄：看;听;骑(qi)马(平)、一骑(ji)红尘妃子笑(仄)*素师说，在读近体诗的时候要么用方言，要么用普通话。不要四不像。</code></pre><p>(2)韵律:诗从平水韵，词从词林正韵。不可用中华新韵(完全丢弃了入声的概念)，中原音韵。</p><h2 id="2、体式"><a href="#2、体式" class="headerlink" title="2、体式"></a>2、体式</h2><p>(1)诗体</p><p><img src="/images/2018/3/2.jpg" alt="&quot;诗体&quot;"></p><p>一般而言，我们当下所说的古诗指的是诗体当中的古体诗。古体诗不受平仄的束缚，但是受韵的束缚(这是在沈佺期和宋之问等人在以沈约、谢眺等为代表的永明体基础上，从原来的讲求四声发展到只辨平仄，从消极的“回忌声病”发展到悟出积极的平仄规律，又由原来只讲求一句一联的音节、协调发展到全篇平仄的粘对，以及中间二联必须上下句属对，从而形成完整的律诗。规范了格律之后脱离出来的体裁)。</p><p>那诗体中的近体诗(也叫今体诗)就是我们当下学习的诗体。它不但受平仄的束缚，而且受到押韵的束缚。其中由八句组成的称之为律诗，四句组成的称之为绝句。在律诗当中又有五律(每句五个字)和七律(每句七个字)之分，相应的绝句也有五绝和七绝之分。</p><p>(2)词体</p><p><img src="/images/2018/3/3.jpg" alt="&quot;词体&quot;"></p><h2 id="3、诗律-以杜甫的登高为例"><a href="#3、诗律-以杜甫的登高为例" class="headerlink" title="3、诗律(以杜甫的登高为例)"></a>3、诗律(以杜甫的登高为例)</h2><p><img src="/images/2018/3/4.jpg" alt="&quot;登高&quot;"></p><p>上图中的竖线表示仄声，横线表示平声，三角形表示押韵。在一首诗当中有四联，分别为首联(第一、二句)、颔联(第三、四句)、颈联(第五、六句)和尾联(第七、八句)。一联的前一句称之为出句，后一句称之为对句。</p><pre><code>(1)一三五不论，二四六分明。第一、三、五字不考虑平仄，第二、四、六字平仄分明。(2)一句之内平仄相间，一联之间平仄相对(不符合即为：失对)，两联之间平仄相粘(上一联对句和下一联出句的平仄一致。不符合即为：失粘)(3)首句可入韵可不入韵(4)不入韵的句末必为仄*三平尾和三仄尾是大忌(此时的五须论，五律和七律皆如此)*平起还是仄起看的是首联出句的第二个字。</code></pre><h2 id="4、作业"><a href="#4、作业" class="headerlink" title="4、作业"></a>4、作业</h2><pre><code>(1)在唐诗三百首当中找出一首诗：平起首句不入韵的七言律诗，抄写一遍标注平仄、押韵。(2)预习拗救</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、格律&quot;&gt;&lt;a href=&quot;#1、格律&quot; class=&quot;headerlink&quot; title=&quot;1、格律&quot;&gt;&lt;/a&gt;1、格律&lt;/h2&gt;&lt;p&gt;(1)平仄:单个汉字发音的音调&lt;/p&gt;
&lt;p&gt;a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>论文参考文献标准格式要求</title>
    <link href="http://www.echodemo.cc/2018/03/24/%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82/"/>
    <id>http://www.echodemo.cc/2018/03/24/论文参考文献标准格式要求/</id>
    <published>2018-03-24T07:50:23.000Z</published>
    <updated>2018-03-25T05:14:53.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、参考文献的分类"><a href="#1、参考文献的分类" class="headerlink" title="1、参考文献的分类"></a>1、参考文献的分类</h2><p>按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类:</p><pre><code>(1)引文文献是著者在撰写或编辑论著的过程中,为正文中的直接引语(如数据、公式、理论、观点、图表等)或间接引语而提供的有关文献信息资源。(2)阅读型文献是著者在撰写或编辑论著的过程中,曾经阅读过的文献信息资源。(3)推荐型文献通常是专家或教师为特定读者、特定目的而提供的、可供读者查阅的文献信息资源。</code></pre><h2 id="2、文献类型和标识代码"><a href="#2、文献类型和标识代码" class="headerlink" title="2、文献类型和标识代码"></a>2、文献类型和标识代码</h2><p>参考文献目前共有16个文献类型和标识代码:普通图书M,会议录C,汇编G,报纸N,期刊J,学位论文D,报告R,标准S,专利P,数据库DB,计算机程序CP,电子公告EB,档案A,舆图CM,数据集DS,其他Z.凡无法归属于前15个类型的文献,均可以用Z来标志。</p><h2 id="3、参考文献格式要求"><a href="#3、参考文献格式要求" class="headerlink" title="3、参考文献格式要求"></a>3、参考文献格式要求</h2><p>1、参考文献按正文部分标注的序号依次列出,并在序号中加[]。</p><p>2、对于常见的各类参考文献标注方法如下:</p><pre><code>(1)著作:作者姓名,题名[M].出版地:出版者,出版年.(2)期刊论文:作者姓名.题名[J].期刊名称,年,卷(期):页码.(3)会议论文集:作者姓名.题名[C]//论文集名称,会议地点,会议日期.(4)学位论文:作者姓名.题名[D].出版地:出版者,出版年.(5)专利文献:专利申请者或所有者姓名.专利题名:专利国别,专利号[P].公告日期或公开日期.获取路径.(6)电子文献:作者姓名.题名[文献类型标志(含文献载体标志)见其它].出版地:出版者,出版年(更新或修改日期),获取路径.(7)报告:作者姓名. 题名[R].出版地:出版者,出版年.(8)标准:标准号.题名[S].出版地:出版者,出版年.</code></pre><p>3、同一著作中作者姓名不超过3名时,全部照录,超过3名时,只著录前3名作者,其后加“, 等”。</p><p>4、其他:数据库(DB),计算机程序(GP),光盘(CD),联机网络(OL)。</p><h2 id="4、参考文献著录格式"><a href="#4、参考文献著录格式" class="headerlink" title="4、参考文献著录格式"></a>4、参考文献著录格式</h2><p>参考文献按在正文中出现的先后次序列表于文后;表上以“参考文献:” (左顶格) 或“[参考文献]”(居中)作为标识;参考文献的序号左顶格,并用数字加方括号表示,如[1], [2],…,以与正文中的指示序号格式一致. 参照ISO690及ISO 6 9 0-2,每一参考文献条目的最后均以结束. 各类参考文献条目的编排格式及示例如下:</p><p>a.专著、论文集、学位论文、报告</p><pre><code>[序号]主要责任者. 文献题名[文献类型标识].出版地:出版者,出版年.[1]刘国钧,陈绍业,王凤者. 图书馆目录[M].北京:高等教育出版社,1957.[2]辛希孟. 信息技术与信息服务国际研讨会论文集:A集[C].北京:中国社会科学出版社,1994.[3]张筑生. 微分半动力系统的不变集[D].北京:北京大学数学系数学研究所,1983.[4]冯西桥. 核反应堆压力管道与压力容器的LBB分析[R].北京:清华大学核能技术设计研究院,1997.[5]尼葛洛庞帝. 数字化生存[M].胡泳,范海燕,译. 海口:海南出版社,19%.</code></pre><p>b.期刊文章</p><pre><code>[序号]主要责任者. 文献题名[J].刊名,年,卷 (期) :起止页码.[5]何龄修. 读顾城《南明史》[J].中国史研究,1998, (3) :167-173.[6]金显贺,王昌长,王忠东,等·一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版) , 1993, 33 (4) :62-67.</code></pre><p>c.论文集中的析出文献</p><pre><code>[序号]析出文献主要责任者. 析出文献题名[A].原文献主要责任者 (任选}.原文献题名[C].出版地:出版者,出版年. 析出文献起止页码.[7]钟文发·非线性规划在可燃毒物配置中的应用[A].赵玮. 运筹学的理论与应用-中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996.468-471.</code></pre><p>d.报纸文章</p><pre><code>[序号]主要责任者. 文献题名[N].报纸名,出版日期 (版次) .[8]谢希德. 创造学习的新思路[N].人民日报,1998-12-25 (10) .</code></pre><p>e.国际、国家标准</p><pre><code>[序号]标准编号,标准名称[S].[9]GB/T 16159-1996, 汉语拼音正词法基本规则[S].</code></pre><p>f.专利</p><pre><code>[序号]专利所有者,专利题名[P].专利国别:专利号,出版日期.[10]姜锡洲. 一种温热外敷药制备方案[P].中国专利:881056073, 1989-07-26.</code></pre><p>g.电子文献</p><pre><code>[序号]主要责任者. 电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址,发表或更新日期/引用曰期 (任选) .[11]学术堂. 论文参考文献标准格式要求[EB/OL].http://www.lunwenstudy.com/cankaowenxian/130239.html.2018-03-14.[12]万锦堃. 中国大学学报论文文摘 (1983-1993) .英文版[D B/C D].北京:中国大百科全书出版社,19%.</code></pre><p>h.各种未定义类型的文献</p><pre><code>[序号]主要责任者. 文献题名[Z].出版地:出版者,出版年.</code></pre><h2 id="5、文内参考文献标注格式"><a href="#5、文内参考文献标注格式" class="headerlink" title="5、文内参考文献标注格式"></a>5、文内参考文献标注格式</h2><p>文内所列参考文献应限于作者直接阅读过的、最主要的、且为发表在正式出版物上的文章.私人通信和未发表 (含待发表) 的著作及论文,一般不宜作为参考文献. 参考文献还应注重权威性和时效性.文内标注参考文献时应按文献出现的先后顺序用阿拉伯数字连续编码,并将序号置于方括号中.可根据具体情况分别按下述3种格式之一标注.</p><pre><code>(1) 文中已标明原始文献作者姓名时,序号标注于作者姓名右上角.　　　　例如：Vairaktaris等[7]研究表明,MMP-9-1562C/T基因多态性与口腔癌关系密切.　　(2) 正文未标明作者或非原始文献作者时,序号标注于引用内容的句末.　　　　例如：……在中枢神经系统中具有保护神经的作用,减少缺氧、缺血对动物脑神经元的损害[1].　　(3) 正文直接述及文献序号时则将之作为语句的组成部分时不用角码标注.　　　　例如：肱动脉超声检查的方法见文献[2].　　</code></pre><p>　　<br>文中多次引用同一参考文献,只在第一次出现时编排序号 (在参考文献表中也只出现一次) , 其他处使用同一序号；如果多次引用的是同一参考文献的不同页的内容,则应参考文献表中按引用顺序一一列出页码.若某一问题使用了多篇文献说明,这时将各文献的序号在一个方括号内全部列出,中间加逗号,若遇连续序号,则在起止序号中间加“-”表示.如：……组织型RAS激活也成为心肌肥厚、心肌纤维化、心腔扩大、心力衰竭的主要因素[1,3,9-10].　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、参考文献的分类&quot;&gt;&lt;a href=&quot;#1、参考文献的分类&quot; class=&quot;headerlink&quot; title=&quot;1、参考文献的分类&quot;&gt;&lt;/a&gt;1、参考文献的分类&lt;/h2&gt;&lt;p&gt;按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类:&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="参考文献" scheme="http://www.echodemo.cc/tags/%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"/>
    
  </entry>
  
  <entry>
    <title>C++中的成员变量、全局变量和局部变量</title>
    <link href="http://www.echodemo.cc/2018/03/22/C++%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <id>http://www.echodemo.cc/2018/03/22/C++中的成员变量和全局变量和局部变量/</id>
    <published>2018-03-22T11:56:53.000Z</published>
    <updated>2018-03-24T11:08:29.709Z</updated>
    
    <content type="html"><![CDATA[<p>1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。</p><pre><code>注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。存储:堆(当前对象对应的堆的存储空间中)存储在堆中的数据,不会被自动释放,只能程序员手动释放。</code></pre><p>2、全局变量:写在函数和大括号外部的变量,称之为全局变量。</p><pre><code>作用域:从定义的那一行开始,一直到文件末尾。全局变量可以先定义再初始化,也可以定义的同时初始化。存储:静态区。程序一启动就会分配存储空间,直到程序结束才会释放。</code></pre><p>3、局部变量:写在函数或者代码块中的变量,称之为局部变量。</p><pre><code>作用域:从定义的那一行开始,一直到遇到大括号或者return。局部变量可以先定义再初始化,也可以定义的同时初始化。存储:栈。存储在栈中的数据有一个特点,系统会自动给我们释放。</code></pre><p>*全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</p><p>*非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。

存储:堆(当前对象对应的堆的存储空间中)存储在堆
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(一)</title>
    <link href="http://www.echodemo.cc/2018/03/22/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/03/22/《眠空》摘句(一)/</id>
    <published>2018-03-22T02:07:52.000Z</published>
    <updated>2018-03-25T05:16:05.614Z</updated>
    
    <content type="html"><![CDATA[<p>1、文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关。但从记录中回溯，可看到自我构建和行进的一个过程。</p><p>2、感情的结果最终是一种理性。是人的天性不具备足够的留恋，还是前进的生活强迫抛却蜕除下来的旧壳？我们远比自己想象的更为无情和客观。</p><p>3、他说，要善待自己，放下和消融内在积存的创伤。它们使你沉重而不够轻盈，要不断去清洗。我说，我在你面前仿佛一览无余。他说，人是有很多面的，哪有一览无余。你对我来说，始终是一个没有答案的谜语。但你的谜题措辞优美。</p><p>4、应尽量保持真实和自在地去生活。不违背不辜负，无需他人旁观，更无需他人同情。只需始终忠于自我。</p><p>5、不知道杭州苏堤白堤的花开了没有，柳树绿了没有。想孤身前往去看一场花事。如果午后微雨突袭，你恰好渡船而过，不妨让我们在春柳拂面的桥头相见。</p><p>6、自我摧毁是有快感的，所有下堕的行为都伴随着快感。摔破一个罐子与长时间塑造和建设一个罐子，前者让你享受到更为强大的自我妄想，觉得自己具有力量。但事实并非如此，行动应该携带和突破重力而上升。</p><p>7、男女不管关系性质如何，有些原则不能随意更改，底线不能突破。一旦突破，破镜难圆。感情忌讳懈怠及理所当然，至少要始终保持尊重、克制、发力、欣赏及感恩之心。</p><p>8、一个印第安巫师说，如果让儿童目睹一次葬礼，抚摸死人的尸体，会驯服孩子内心的浅薄和顽劣不羁。他获得了真正的灵魂的成长。死亡是最需要被学习和认识的内容。</p><p>9、泛滥的感情方式，不严格区分对象，只以获取难易作为是否前进的指标。对待不同的人，所给予的内容完全重复，是一次批量化生产之后的零售生意。润滑一些的方式，无非是让不同客户拿到这只被复制的点心盒子，产生为自己特制的幻觉。始乱终弃，以满足欲望为前提，不管这欲望是虚荣、寂寞、爱欲、证明还是其他。这何尝不是一种乏味而肤浅的恋爱方式。无法视对方为独特个体，因此也无法获取来自对方的源泉和力量(也许这是不需要的东西，他们要的只是乐趣)。把对方视为猎物，忽略人的内在生命，以占有和征服为目的。低级的方式决定这关系没有创造力，不具有可追索的深度。是对生命能量的贬低和消费。</p><p>10、奥修说，死去的人，将在他生前所爱的人身上收回他的能量，这些能量会被他带走。因此，那个被爱着的人，会感觉到自己的身心被挖掉一块。这一块区域将始终是空的，是匮乏的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关。但从记录中回溯，可看到自我构建和行进的一个过程。&lt;/p&gt;
&lt;p&gt;2、感情的结果最终是一种理性。是人的天性不具备足够的留恋，还是前进的生活强迫抛却蜕除下来的旧壳？我们远比自己想象的更为无情和客观。&lt;/
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>自省</title>
    <link href="http://www.echodemo.cc/2018/03/22/%E8%87%AA%E7%9C%81/"/>
    <id>http://www.echodemo.cc/2018/03/22/自省/</id>
    <published>2018-03-22T02:05:44.000Z</published>
    <updated>2018-03-24T11:09:09.995Z</updated>
    
    <content type="html"><![CDATA[<p>连续几日在图书馆的自习，对面的人换了又换，然而他(她)们都有一个令人心生厌恶之处：吃零食或者喝牛奶不断产生的声响和气味。对旁人的感受持漠然的态度。对此，虽完全可以凭借自身的力量尽量避免，但从中自身须得到反省：在生活中，是否具有其他不当的行为让他人感到不适(包括除图书馆以外的场所)。答案是有。有些是一时半会无法去除的缺点，有些是当下即可做到的修改。这些都需要内心的自持和坚韧才能实现，结果要交给时间去检验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;连续几日在图书馆的自习，对面的人换了又换，然而他(她)们都有一个令人心生厌恶之处：吃零食或者喝牛奶不断产生的声响和气味。对旁人的感受持漠然的态度。对此，虽完全可以凭借自身的力量尽量避免，但从中自身须得到反省：在生活中，是否具有其他不当的行为让他人感到不适(包括除图书馆以外的
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>水流众生</title>
    <link href="http://www.echodemo.cc/2018/03/22/%E6%B0%B4%E6%B5%81%E4%BC%97%E7%94%9F/"/>
    <id>http://www.echodemo.cc/2018/03/22/水流众生/</id>
    <published>2018-03-22T01:57:12.000Z</published>
    <updated>2018-03-25T05:15:50.204Z</updated>
    
    <content type="html"><![CDATA[<p>李健的《水流众生》是诞生在他西藏的旅途中的，他的歌，总是充满了灵性与自然。在平淡当中述说，却又蕴含深切的主题。这首歌是写给他自己的，也是写给众生的，同时还是写给这个社会的。当今社会物质的极大丰富满足不了人们的欲望，对物质无止境的追求、对自然的过分索取导致人们都迷失了自我，深陷其中，无法自拔却并不自知。李健为了寻求他的解脱之法，于是踏上旅途，当然他的旅途不是我们当下传统意义上的旅行，不是组团或者邀约三五好友匆匆赶赴著名的旅游景点拍照留恋而后又匆匆而归的旅行。他的旅途是内心和自然的相互倾听和感受。当然，最终他还是从自然里、在旅途中找到了自我，看见了辽阔的。每一个人都需要反省，自我观照，在水自成旋涡之前及时转身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;李健的《水流众生》是诞生在他西藏的旅途中的，他的歌，总是充满了灵性与自然。在平淡当中述说，却又蕴含深切的主题。这首歌是写给他自己的，也是写给众生的，同时还是写给这个社会的。当今社会物质的极大丰富满足不了人们的欲望，对物质无止境的追求、对自然的过分索取导致人们都迷失了自我，深
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1051 Pop Sequence</title>
    <link href="http://www.echodemo.cc/2018/03/21/PAT-A1051-Pop-Sequence/"/>
    <id>http://www.echodemo.cc/2018/03/21/PAT-A1051-Pop-Sequence/</id>
    <published>2018-03-21T09:18:43.000Z</published>
    <updated>2018-03-24T11:08:17.863Z</updated>
    
    <content type="html"><![CDATA[<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><pre><code>Sample Input:5 7 51 2 3 4 5 6 73 2 1 7 5 6 47 6 5 4 3 2 15 6 4 3 7 2 11 7 6 5 4 3 2Sample Output:YESNONOYESNO</code></pre><p>题目大意：给出size为M大小的栈，分别把1…N入栈，给出K组出栈顺序，问入栈出栈顺序是否顺利。</p><p>分析：先把需要判断的序列放进一维数组当中，给出数组的当前下标为0，然后1…N顺序入栈，如果元素入栈之后，栈的size大于M，则此序列不符合；如果栈的size小于等于M，在while循环中如果栈非空且其值等于此时的数组元素，则栈顶元素出栈，数组的下标自增一位。以上所有步骤进行K次。</p><p>注意：能用一维数组时尽量别用二维数组</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;stdlib.h&gt;using namespace std;int main() {    int M, N, K;    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;    vector&lt;int&gt; a(N);//定义可变长的一维数组    stack&lt;int&gt; st;//引入STL中的栈    for (int i = 0;i &lt; K;i++) {//一共有K组数据        while (!st.empty()) st.pop();//清空栈        for (int j = 0;j &lt; N;j++) {//读入一组数据            cin &gt;&gt; a[j];        }        int n=0;        for (int x = 1;x &lt;= N;x++) {            st.push(x);            if (st.size() &gt; M) {//序列有误                break;            }else{                while (!st.empty() &amp;&amp; st.top() == a[n]) {//如果栈非空且栈顶元素等于当前的序列当前位置值就把顶部元素出栈，验证序列后移一位                    st.pop();                    n++;                }            }        }        if (!st.empty())            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        else            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell i
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL基础</title>
    <link href="http://www.echodemo.cc/2018/03/21/MYSQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.echodemo.cc/2018/03/21/MYSQL基础/</id>
    <published>2018-03-21T02:21:25.000Z</published>
    <updated>2018-03-21T02:27:15.818Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql是最流行的关系型数据库管理系统(关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。)，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。</p><h1 id="1、MYSQL的特点"><a href="#1、MYSQL的特点" class="headerlink" title="1、MYSQL的特点"></a>1、MYSQL的特点</h1><pre><code>(1)Mysql是开源的，所以你不需要支付额外的费用。(2)Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。(3)MySQL使用标准的SQL数据语言形式。(4)Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。(5)Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。</code></pre><h1 id="2、MYSQL的管理"><a href="#2、MYSQL的管理" class="headerlink" title="2、MYSQL的管理"></a>2、MYSQL的管理</h1><h2 id="1-为MYSQL数据库中的user表添加新用户"><a href="#1-为MYSQL数据库中的user表添加新用户" class="headerlink" title="(1)为MYSQL数据库中的user表添加新用户"></a>(1)为MYSQL数据库中的user表添加新用户</h2><pre><code>root@host# mysql -u root -pEnter password:*******mysql&gt; use mysql;Database changedmysql&gt; INSERT INTO user           (host, user, password,            select_priv, insert_priv, update_priv)            VALUES (&apos;localhost&apos;, &apos;guest&apos;,            PASSWORD(&apos;guest123&apos;), &apos;Y&apos;, &apos;Y&apos;, &apos;Y&apos;);Query OK, 1 row affected (0.20 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT host, user, password FROM user WHERE user = &apos;guest&apos;;+-----------+---------+------------------+| host      | user    | password         |+-----------+---------+------------------+| localhost | guest | 6f8c114b58f2ce9e |+-----------+---------+------------------+1 row in set (0.00 sec)</code></pre><p>注意需要执行FLUSH PRIVILEGES语句。 这个命令执行后会重新载入授权表。如果你不使用该命令，你就无法使用新创建的用户来连接MYSQL服务器，除非你重启MYSQL服务器。</p><p>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：</p><pre><code>Select_privInsert_privUpdate_privDelete_privCreate_privDrop_privReload_privShutdown_privProcess_privFile_privGrant_privReferences_privIndex_privAlter_priv</code></pre><p>另外一种添加用户的方法为通过SQL的GRANT命令，以下命令会给指定数据库TUTORIALS添加用户zara，密码为zara123 。</p><pre><code>root@host# mysql -u root -p password;Enter password:*******mysql&gt; use mysql;Database changedmysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP    -&gt; ON TUTORIALS.*    -&gt; TO &apos;zara&apos;@&apos;localhost&apos;    -&gt; IDENTIFIED BY &apos;zara123&apos;;*MySQL的SQL语句以分号 (;) 作为结束标识。</code></pre><h2 id="2-管理MySQL的命令"><a href="#2-管理MySQL的命令" class="headerlink" title="(2)管理MySQL的命令"></a>(2)管理MySQL的命令</h2><h3 id="a、USE-数据库名-选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。"><a href="#a、USE-数据库名-选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。" class="headerlink" title="a、USE 数据库名;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。"></a>a、USE 数据库名;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</h3><pre><code>mysql&gt; use RUNOOB;Database changed</code></pre><h3 id="b、SHOW-DATABASES-列出MySQL数据库管理系统当前的数据库列表。"><a href="#b、SHOW-DATABASES-列出MySQL数据库管理系统当前的数据库列表。" class="headerlink" title="b、SHOW DATABASES;列出MySQL数据库管理系统当前的数据库列表。"></a>b、SHOW DATABASES;列出MySQL数据库管理系统当前的数据库列表。</h3><pre><code>mysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || RUNOOB             || cdcol              || mysql              || onethink           || performance_schema || phpmyadmin         || test               || wecenter           || wordpress          |+--------------------+10 rows in set (0.02 sec)</code></pre><h3 id="c、SHOW-TABLES-显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。"><a href="#c、SHOW-TABLES-显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。" class="headerlink" title="c、SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。"></a>c、SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。</h3><pre><code>mysql&gt; use RUNOOB;Database changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_runoob |+------------------+| employee_tbl     || runoob_tbl       || tcount_tbl       |+------------------+3 rows in set (0.00 sec)</code></pre><h3 id="d、SHOW-COLUMNS-FROM-数据表-显示数据表的属性，属性类型，主键信息-，是否为-NULL，默认值等其他信息。"><a href="#d、SHOW-COLUMNS-FROM-数据表-显示数据表的属性，属性类型，主键信息-，是否为-NULL，默认值等其他信息。" class="headerlink" title="d、SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。"></a>d、SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</h3><pre><code>mysql&gt; SHOW COLUMNS FROM runoob_tbl;+-----------------+--------------+------+-----+---------+-------+| Field           | Type         | Null | Key | Default | Extra |+-----------------+--------------+------+-----+---------+-------+| runoob_id       | int(11)      | NO   | PRI | NULL    |       || runoob_title    | varchar(255) | YES  |     | NULL    |       || runoob_author   | varchar(255) | YES  |     | NULL    |       || submission_date | date         | YES  |     | NULL    |       |+-----------------+--------------+------+-----+---------+-------+4 rows in set (0.01 sec)</code></pre><h3 id="e、SHOW-INDEX-FROM-数据表-显示数据表的详细索引信息，包括PRIMARY-KEY（主键）。"><a href="#e、SHOW-INDEX-FROM-数据表-显示数据表的详细索引信息，包括PRIMARY-KEY（主键）。" class="headerlink" title="e、SHOW INDEX FROM 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。"></a>e、SHOW INDEX FROM 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。</h3><pre><code>mysql&gt; SHOW INDEX FROM runoob_tbl;+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table      | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| runoob_tbl |          0 | PRIMARY  |            1 | runoob_id   | A         |           2 |     NULL | NULL   |      | BTREE      |         |               |+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+1 row in set (0.00 sec)</code></pre><h3 id="f、SHOW-TABLE-STATUS-LIKE-FROM-db-name-LIKE-‘pattern’-G-该命令将输出Mysql数据库管理系统的性能及统计信息。"><a href="#f、SHOW-TABLE-STATUS-LIKE-FROM-db-name-LIKE-‘pattern’-G-该命令将输出Mysql数据库管理系统的性能及统计信息。" class="headerlink" title="f、SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G;该命令将输出Mysql数据库管理系统的性能及统计信息。"></a>f、SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G;该命令将输出Mysql数据库管理系统的性能及统计信息。</h3><pre><code>mysql&gt; SHOW TABLE STATUS  FROM RUNOOB;   # 显示数据库 RUNOOB 中所有表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;;     # 表名以runoob开头的表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;\G;   # 加上 \G，查询结果按列打印</code></pre><h1 id="3、数据库的基本操作语句"><a href="#3、数据库的基本操作语句" class="headerlink" title="3、数据库的基本操作语句"></a>3、数据库的基本操作语句</h1><h2 id="1-创建数据表"><a href="#1-创建数据表" class="headerlink" title="(1)创建数据表"></a>(1)创建数据表</h2><pre><code>CREATE TABLE table_name (column_name column_type);root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_tbl(   -&gt; runoob_id INT NOT NULL AUTO_INCREMENT,   -&gt; runoob_title VARCHAR(100) NOT NULL,   -&gt; runoob_author VARCHAR(40) NOT NULL,   -&gt; submission_date DATE,   -&gt; PRIMARY KEY ( runoob_id )   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.16 sec)mysql&gt;*如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL，在操作数据库时如果输入该字段的数据为NULL ，就会报错。*AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。*PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。*ENGINE 设置存储引擎，CHARSET 设置编码。</code></pre><h2 id="2-删除数据表"><a href="#2-删除数据表" class="headerlink" title="(2)删除数据表"></a>(2)删除数据表</h2><pre><code>DROP TABLE table_name ;root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; DROP TABLE runoob_tblQuery OK, 0 rows affected (0.8 sec)mysql&gt;查看一下：mysql&gt; show tables;Empty set (0.01 sec)</code></pre><h2 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="(3)插入数据"></a>(3)插入数据</h2><pre><code>INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1,value2,...valueN );root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; INSERT INTO runoob_tbl     -&gt; (runoob_title, runoob_author, submission_date)    -&gt; VALUES    -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl    -&gt; (runoob_title, runoob_author, submission_date)    -&gt; VALUES    -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl    -&gt; (runoob_title, runoob_author, submission_date)    -&gt; VALUES    -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;);Query OK, 1 rows affected (0.00 sec)mysql&gt;*如果数据是字符型，必须使用单引号或者双引号，如：&quot;value&quot;。*使用箭头标记-&gt;不是SQL语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写SQL语句，SQL语句的命令结束符为分号 ;。</code></pre><h2 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="(4)查询数据"></a>(4)查询数据</h2><pre><code>SELECT column_name,column_name FROM table_name [WHERE Clause][LIMIT N][ OFFSET M];select * from runoob_tbl;SELECT * from runoob_tbl WHERE runoob_author=&apos;菜鸟教程&apos;;*查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。*SELECT 命令可以读取一条或者多条记录。你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据*你可以使用 WHERE 语句来包含任何条件。例如使用 AND 或者 OR 指定一个或多个条件。WHERE子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。WHERE子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。*你可以使用 LIMIT 属性来设定返回的记录数。*你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</code></pre><h2 id="5-更新数据表"><a href="#5-更新数据表" class="headerlink" title="(5)更新数据表"></a>(5)更新数据表</h2><pre><code>UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause];mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;Query OK, 1 rows affected (0.01 sec)mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;+-----------+--------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+--------------+---------------+-----------------+| 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      |+-----------+--------------+---------------+-----------------+1 rows in set (0.01 sec)*你可以同时更新一个或多个字段。*你可以在 WHERE 子句中指定任何条件。*你可以在一个单独表中同时更新数据。</code></pre><h2 id="6-删除MySQL数据表中的记录"><a href="#6-删除MySQL数据表中的记录" class="headerlink" title="(6)删除MySQL数据表中的记录"></a>(6)删除MySQL数据表中的记录</h2><pre><code>DELETE FROM table_name [WHERE Clause];mysql&gt; use RUNOOB;Database changedmysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;Query OK, 1 row affected (0.23 sec)*如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。*你可以在 WHERE 子句中指定任何条件*您可以在单个表中一次性删除记录。</code></pre><h2 id="7-删除，添加或修改表字段"><a href="#7-删除，添加或修改表字段" class="headerlink" title="(7)删除，添加或修改表字段"></a>(7)删除，添加或修改表字段</h2><pre><code>删除：ALTER TABLE alter_tbl  DROP columnname;删除指定字段添加：ALTER TABLE alter_tbl ADD new_column_name new_typename AFTER columnname;指定添加位置修改： ALTER TABLE alter_tbl MODIFY columnname new_typename;修改字段类型       ALTER TABLE alter_tbl CHANGE oldcolumnname newcolumnname newtypename;修改字段及类型       ALTER TABLE alter_tbl RENAME TO alter_tb2;修改表名</code></pre><h2 id="8-UNION操作符"><a href="#8-UNION操作符" class="headerlink" title="(8)UNION操作符"></a>(8)UNION操作符</h2><pre><code>SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions];*expression1, expression2, ... expression_n: 要检索的列。*tables: 要检索的数据表。*WHERE conditions: 可选， 检索条件。*DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。*ALL: 可选，返回所有结果集，包含重复数据。</code></pre><h2 id="9-排序"><a href="#9-排序" class="headerlink" title="(9)排序"></a>(9)排序</h2><pre><code>SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]];SELECT * from runoob_tbl ORDER BY submission_date ASC;SELECT * from runoob_tbl ORDER BY submission_date DESC;*你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。*你可以设定多个字段来排序。*你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列。*你可以添加 WHERE...LIKE 子句来设置条件。</code></pre><h2 id="10-GROUP-BY语法"><a href="#10-GROUP-BY语法" class="headerlink" title="(10)GROUP BY语法"></a>(10)GROUP BY语法</h2><pre><code>SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name;SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;将数据表按名字进行分组，并统计每个人有多少条记录</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mysql是最流行的关系型数据库管理系统(关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。)，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1052 Linked List Sorting</title>
    <link href="http://www.echodemo.cc/2018/03/20/PAT-A1052-Linked-List-Sorting/"/>
    <id>http://www.echodemo.cc/2018/03/20/PAT-A1052-Linked-List-Sorting/</id>
    <published>2018-03-20T08:09:22.000Z</published>
    <updated>2018-03-24T11:08:11.263Z</updated>
    
    <content type="html"><![CDATA[<p>A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains a positive N (&lt; 105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1.Then N lines follow, each describes a node in the format:</p><pre><code>Address Key next</code></pre><p>where Address is the address of the node in memory, Key is an integer in [-105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.</p><p>Output Specification:</p><p>For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.</p><pre><code>Sample Input:5 0000111111 100 -100001 0 2222233333 100000 1111112345 -1 3333322222 1000 12345Sample Output:5 1234512345 -1 0000100001 0 1111111111 100 2222222222 1000 3333333333 100000 -1</code></pre><p>题目大意：给出一个静态链表，将链表按照数据域data的值从小到大进行排序，然后把排序后的静态链表上的结点从头结点顺序输出。</p><p>分析：建立存储静态节点的结构体数组，从首节点开始的顺序(直到-1)遍历整个静态链表，将在静态链表中节点的flag标记为true，并且统计count(有效结点的个数)大小，这里是因为有的你输入的节点根本不在静态链表上。之后将静态链表进行排序，这里需要进行二次排序：如果两个节点中有一个节点的标志位为false就把它移动到后面(reuturn a.flag&gt;b.flag)，否则就按照节点数据域从小到大进行排序(return a.data&lt;b.data)。最后只输出前count个静态链表节点。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;const int maxn = 100010;struct Node {    int address;    int data;    int next;    bool flag;}node[maxn];bool cmp(Node a, Node b) {    if (a.flag == false || b.flag == false) {        return a.flag &gt; b.flag;//将无效节点放到后面    }    else {        return a.data &lt; b.data;//按照数据域的顺序从大到小排列    }}int main() {    int n, x;    cin &gt;&gt; n &gt;&gt; x;    int address, data, next;    for (int i = 0;i&lt;n;i++) {//初始化静态链表        cin &gt;&gt; address &gt;&gt; data &gt;&gt; next;        node[address].address = address;        node[address].data = data;        node[address].next = next;    }    for (int i = 0;i &lt; maxn;i++) {        node[i].flag = false;//初始化标志位    }    int count = 0;    while (x != -1) {//遍历静态链表，对有效的节点进行标记，同时统计有效节点的个数(因为存在一些你输入的节点但是不在链表上情况)        node[x].flag = true;        count++;        x = node[x].next;    }    if (count == 0) {//如果头结点为-1，即链表中没有节点        cout &lt;&lt; &quot;0 -1&quot; &lt;&lt; endl;    }    else {        sort(node, node + maxn, cmp);//筛选有效节点，按data从小到大排列        printf(&quot;%d %05d\n&quot;, count, node[0].address);        for (int i = 0;i &lt; count;i++) {        if (i==count-1)            printf(&quot;%05d %d -1\n&quot;, node[i].address, node[i].data);        else            printf(&quot;%05d %d %05d\n&quot;, node[i].address, node[i].data, node[i+1].address);        }    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1032 Sharing</title>
    <link href="http://www.echodemo.cc/2018/03/20/PAT-A1032-Sharing/"/>
    <id>http://www.echodemo.cc/2018/03/20/PAT-A1032-Sharing/</id>
    <published>2018-03-20T02:58:51.000Z</published>
    <updated>2018-03-24T11:08:02.658Z</updated>
    
    <content type="html"><![CDATA[<p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, “loading” and “being” are stored as showed in Figure 1.You are supposed to find the starting position of the common suffix (e.g. the position of “i” in Figure 1).</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (&lt;= 105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1.<br>Then N lines follow, each describes a node in the format:</p><pre><code>Address Data Next</code></pre><p>where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node.</p><p>Output Specification:</p><p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output “-1” instead.</p><pre><code>Sample Input 1:11111 22222 967890 i 0000200010 a 1234500003 g -112345 D 6789000002 n 0000322222 B 2345611111 L 0000123456 e 6789000001 o 00010Sample Output 1:67890Sample Input 2:00001 00002 400001 a 1000110001 s -100002 a 1000210002 t -1Sample Output 2:-1</code></pre><p>题目大意：求两个存储英语单词的字母链表的首个公共结点的地址。如果没有，就输出-1</p><p>分析：本题是在链表当中寻找起始公共节点的位置且地址的范围比较小，此处选择使用静态链表来处理。用结构体数组进行存储，node[i]表示地址为i的结点，data表示值，next为下一个结点的地址，flag表示第一条链表有没有该结点。遍历第一条链表，将访问过的结点的flag都标记为true，当遍历第二条结点的时候，如果遇到了true的结点就输出并结束程序，没有遇到就输出-1。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct Node {    char data;    int next;    bool flag;//用于判断公共节点的初始位置}node[100010];void Create(int n) {//创建一个静态链表    int address, next;    char data;    for (int i = 0;i &lt; 100010;i++) {//初始化链表节点的标志为false        node[i].flag = false;    }    for (int i = 0;i &lt; n;i++) {        cin &gt;&gt; address &gt;&gt; data &gt;&gt; next;        node[address].data = data;        node[address].next = next;    }}int main() {    int x, y, n,i;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;    Create(n);//创建一个静态链表    for (i = x;i != -1;i = node[i].next) {//将第一个单词走过的节点的标志位设为true        node[i].flag = true;    }    for (i = y;i != -1;i = node[i].next) {        if (node[i].flag == true) {            printf(&quot;%5d&quot;, i);//如果此时的节点的标志位为true说明是公共节点            system(&quot;pause&quot;);            return 0;        }    }    printf(&quot;-1&quot;);//否则输出-1    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words sha
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://www.echodemo.cc/2018/03/19/%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.echodemo.cc/2018/03/19/链表/</id>
    <published>2018-03-19T13:13:34.000Z</published>
    <updated>2018-03-20T08:09:00.754Z</updated>
    
    <content type="html"><![CDATA[<p>链表属于线性表中的一种数据结构，它由若干个节点组成(每个节点代表一个元素)，且节点在内存中的存储位置通常是不连续的。这里我们先来了解动态链表，动态链表的两个节点之间一般通过一个指针来从一个节点指向另一个节点 ，因此动态链表的节点一般由两部分构成，即数据域和指针域：</p><pre><code>struct node{    int data;    node* next;};</code></pre><p>(1)创建一个动态链表：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {    int data;    node* next;};node* create(int Array[]) {    node *p, *pre, *head;//pre保存当前节点的前驱节点，head为头结点    head = new node;//创建头结点    head-&gt;next = NULL;//头结点不需要数据，且指针域指向NULL    pre = head;//记录pre为head    for (int i = 0;i &lt; 5;i++) {        p = new node;//新建节点        p-&gt;data = Array[i];//将Array[i]赋给新建的节点作为数据域，也可以cin输入        p-&gt;next = NULL;//新节点的指针域设为NULL        pre-&gt;next = p;//前驱节点的指针域设为当前新建节点的地址        pre = p;//把p设为pre，作为下一个节点的前驱节点    }    return head;//返回头结点指针}int main() {    int Array[5] = { 5,3,6,1,2 };    node* L = create(Array);//新建链表，返回头指针head给L    L = L-&gt;next;//从第一个节点开始有数据域    while (L != NULL) {        cout &lt;&lt; L-&gt;data &lt;&lt; endl;//输出每个节点的数据域        L = L-&gt;next;    }    system(&quot;pause&quot;);    return 0;}</code></pre><p>(2)动态链表查找元素：</p><pre><code>int search(node* head, int x) {    int count = 0;//计数器    node* p = head-&gt;next;//指向链表的第一个节点    while (p != NULL) {//遍历整个链表        if (p-&gt;data == x) count++;//当节点数据域为x时，则count++        p = p-&gt;next;//指向下一个节点    }    return count;}</code></pre><p>(3)动态链表插入元素：</p><pre><code>void insert(node* head, int pos, int x) {    node* p = head;//指向链表的头节点    for (int i = 0;i &lt; pos - 1;i++) {//遍历到链表的pos-1的位置，即插入位置的前一个节点位置        p = p-&gt;next;    }    node* q = new node;//新建节点    q-&gt;data = x;//其数据域为x    q-&gt;next = p-&gt;next;//新节点的下一个节点指向原先插入位置的节点    p-&gt;next = q;//前一个位置的节点指向新节点}</code></pre><p>(4)动态链表删除元素：</p><pre><code>void del(node* head, int x) {    node* p = head;//指向链表的头结点    node* q = p-&gt;next;//指向链表的第一个节点    while (q != NULL) {        if (q-&gt;data == x) {//数据域为x，删除q节点            p-&gt;next = q-&gt;next;//删除q节点            delete(q);//释放内存空间            q = p-&gt;next;        }else {//数据域不为x，p、q节点同时后移一位            p = q;            q = q-&gt;next;        }    }}</code></pre><p>以上所述都是动态链表的范畴，需要指针来建立节点之间的连接关系。而对于有些问题来说，节点的地址是比较小的整数(例如5位数的地址)，这样就没有必要去建立动态链表，而应该使用方便得多的静态链表。静态链表的实现原理是hash，即通过建立一个结构体数组，并令数组的下标直接表示节点的地址，以此来达到直接访问数组中的元素就能访问节点的效果。需要注意的是：在使用静态链表时，尽量不要把结构体类型名和结构体变量名取成相同的名字。其定义方法如下：</p><pre><code>struct Node{    typename date;//数据域    int next;//指针域    XXX;//节点的某个性质，不同的题目会有不同的设置}node[maxn];</code></pre><p>其中的next是一个int型的整数，用来存放下一个节点的地址(事实上就是数组下标)，例如：如果初始节点的地址为11111，第二个节点的地址为22222，第三个节点的地址为33333，且第三个节点为链表末尾，那么整个静态链表的节点就可以通过下面的写法连接起来：</p><pre><code>node[11111].next=22222;node[22222].next=33333;node[33333].next=-1;//-1对应动态链表中的NULL，表示没有后继节点</code></pre><p>一般来说，静态链表的初始化需要对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字(而常常需要小于所能达到的数字)，例：</p><pre><code>for(int i=0;i&lt;maxn;i++){    node[i].XXX=0;}</code></pre><p>一般的题目都会给出一条静态链表的首节点的地址，因此我们可以依据这个地址来遍历得到整条链表。这一步同时也是对节点性质XXX进行标记，并且对有效节点的个数进行计数的时候，例如对节点是否在链表上这个性质来说，当我们遍历链表时，就可以把XXX置为1。</p><pre><code>int p=begin,count=0;while(p!=-1){//-1代表静态链表结束    XXX=1;    count++;    p=node[p].next;}</code></pre><p>由于使用静态链表时时直接采用地址映射的方式，这就会使得数组小标的不连续。而很多时候题目给出的节点并不都是有效节点(即不在静态链表上的节点)。为了能够可控地访问有效节点，一般都需要对数组进行排序来把有效节点移动到数组的左端。这里我们用到上面所提及的XXX，这也就是为什么在XXX进行初始化时要取比正常取值要小的值。因为无效节点并不会执行XXX=1这一步，因此一定比有效节点的XXX小。于是在写sort函数的排序函数cmp时就可以在cmp的两个参数节点中有无效节点时按XXX从大到小排序，这样就能把有效节点全部移动到数组左端。当然，在cmp函数中还可以有第二级的排序，例如：题目可能要求把链表按节点顺序排序，此时就需要在cmp函数中建立第二级的排序：</p><pre><code>bool cmp(Node a,Node b){    if(a.XXX==-1||b.XXX==-1){//如果有节点是无效节点，就把它放到数组的后端        return a.XXX&gt;b.XXX;    }else{//否则就按节点的数据域从大到小排序        return a.data&gt;b.data;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链表属于线性表中的一种数据结构，它由若干个节点组成(每个节点代表一个元素)，且节点在内存中的存储位置通常是不连续的。这里我们先来了解动态链表，动态链表的两个节点之间一般通过一个指针来从一个节点指向另一个节点 ，因此动态链表的节点一般由两部分构成，即数据域和指针域：&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C/C++申请动态内存</title>
    <link href="http://www.echodemo.cc/2018/03/19/C-C++%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://www.echodemo.cc/2018/03/19/C-C++申请动态内存/</id>
    <published>2018-03-19T12:01:44.000Z</published>
    <updated>2018-03-26T08:01:26.986Z</updated>
    
    <content type="html"><![CDATA[<p>(1)malloc函数</p><p>malloc函数是C语言中#include&lt;stdlib.h&gt;头文件下用于申请动态内存的函数，其返回类型是申请的同变量类型的指针，其基本用法如下：</p><pre><code>typename* p=(typename*)malloc(sizeof(typename));int* p=(int*)malloc(sizeof(int));node* p=(node*)malloc(sizeof(node));</code></pre><p>这个写法的解释如下：以需要申请的内存空间大小(即sizeof(node))为malloc函数的参数，这样malloc函数就会向内存申请一块大小为sizeof(node)的空间，并且返回指向这块空间的指针。但是此时这个指针是一个为确定类型的指针void*，因此需要把它强制转换成node<em>型的指针，在malloc之前加上(node</em>)。再把这个指针赋给node*型的指针变量p，就成功地申请了一块node类型大小的内存空间。如果申请失败，则会返回空指针NULL。申请失败一般在使用malloc申请了较大动态数组时发生。</p><p>在使用完malloc开辟出来的空间后必须将其释放，否则会造成内存的泄露。malloc函数需要使用free函数来进行内存的释放。假设需要释放的内存空间的指针变量为p，则：free(p);就可以实现内存的释放了。</p><p>(2)new运算符</p><p>new是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变量类型的指针，其基本用法如下：</p><pre><code>typename* p=new typename;int* p=new int;node* p=new node;</code></pre><p>相比于malloc函数来说，new的写法要简洁得多。另外，如果new运算符申请动态空间失败，则会启动异常机制处理而不是像malloc那样返回NULL。和malloc一样的是：申请失败一般是在申请了较大动态数组时发生。与此同时，new运算符也有对应的释放内存函数：delete(p);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(1)malloc函数&lt;/p&gt;
&lt;p&gt;malloc函数是C语言中#include&amp;lt;stdlib.h&amp;gt;头文件下用于申请动态内存的函数，其返回类型是申请的同变量类型的指针，其基本用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typename* p=(typename*)
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="C" scheme="http://www.echodemo.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Codeup 1918 简单计算器</title>
    <link href="http://www.echodemo.cc/2018/03/19/Codeup-1918-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/03/19/Codeup-1918-简单计算器/</id>
    <published>2018-03-19T09:29:23.000Z</published>
    <updated>2018-03-24T11:07:15.385Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。</p><p>输入：</p><p>测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p><p>输出：</p><p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p><p>样例输入：</p><pre><code>30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 * 6 + 51 / 29 + 79 * 87 + 57 * 920</code></pre><p>样例输出：</p><pre><code>12178.21</code></pre><p>分析：本题需要分两个步骤进行解答：一是中缀表达式转化为后缀表达式；二是计算后缀表达式。</p><p>步骤一：</p><pre><code>(1)分别设立一个操作符栈和一个队列，操作符栈用来暂时存放操作符，而队列则用来存放后缀表达式。(2)从左到右扫描中缀表达式。(3)如果碰到操作数(这里的操作数可能占几位，所以需要一位一位读取再合并)，就把操作数处理之后加入后缀表达式中。如果碰到的是操作符，就将其优先级与操作符栈的栈顶元素比较：如果优先级高于栈顶操作符则直接入栈；如果优先级小于或等于栈顶操作符，则将操作符栈的操作符不断弹出到后缀表达式，直到其优先级高于栈顶操作符为止。(4)重复执行(2)(3)步骤，直到中缀表达式扫描完为止，之后若操作符栈中还有元素，则将他们依次弹出至后缀表达式当中。</code></pre><p>步骤二：</p><pre><code>从左到右扫描后缀表达式，如果是操作数，则压入栈中；如果是操作符，就连续弹出两个操作数(这里先弹出的是第二操作数，后弹出的是第一操作数)，然后进行操作符的运算，生成的新操作符压入栈中。反复执行，直到后缀表达式扫描完毕。此时栈中只剩下一个数，就是计算结果。</code></pre><p>注意：</p><pre><code>(1)操作数的类型需要设置为double型。(2)为了便于在后缀表达式中判断出队的是操作符还是操作数，这里使用了具有操作数、操作符和判别两者类型的bool类型的结构体，当然，在这种情况之下就需要引进STL中的queue和stack容器来存储相应的结构体类型的数据。(3)另外还需要引进STL中的map容器，从而来定义操作符所对应的优先级。</code></pre><p>具体的程序如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;struct node {    double num;//操作数    char op;//操作符    bool flag;//true表示操作数，false表示操作符};string s;queue&lt;node&gt; q;//定义node类型的队列用于存储后缀表达式stack&lt;node&gt; st;//定义node类型的栈用于在转化为后缀表达式时暂存操作符和在计算后缀表达式时存储操作数map&lt;char, int&gt; op;//map用于匹配操作符和优先级数字void Change() {//将中缀表达式转化为后缀表达式    node temp;    for (string::iterator it = s.begin();it != s.end();it++) {//删除字符串当中的空格        if (*it == &apos; &apos;) s.erase(it);    }    for (int i = 0;i &lt; s.length();) {        if (s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) {//如果是数字的话            temp.flag = true;//标记为数字            temp.num = s[i++] - &apos;0&apos;;            while (i&lt;s.length()&amp;&amp;s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) {                temp.num = temp.num * 10 + (s[i++] - &apos;0&apos;);            }            q.push(temp);//将操作数压入后缀表达式队列        }else {//如果是操作符            temp.flag = false;            while (!st.empty() &amp;&amp; op[s[i]] &lt;= op[st.top().op]) {//如果栈不空且当前操作符的优先级小于等于栈顶的优先级                q.push(st.top());//将栈顶元素放入后缀表达式队列                st.pop();//栈顶元素出栈            }            temp.op = s[i++];            st.push(temp);//将此操作符入栈        }    }    while (!st.empty()) {//如果栈中还有操作符就把它们都放入后缀表达式队列        q.push(st.top());        st.pop();    }}double Calculate() {//计算后缀表达式    double temp1=0, temp2=0;    node temp;    while (!st.empty()) st.pop();//将栈清空    while (!q.empty()) {        if (q.front().flag == true) st.push(q.front());//如果是操作数就直接入栈        else {//如果是操作符            temp2 = st.top().num;//取第二个操作数            st.pop();//栈顶元素出栈            temp1 = st.top().num;//取第一个操作数            st.pop();            if (q.front().op == &apos;+&apos;) temp.num = temp1 + temp2;            else if (q.front().op == &apos;-&apos;) temp.num = temp1 - temp2;            else if (q.front().op == &apos;*&apos;) temp.num = temp1*temp2;            else temp.num = temp1 / temp2;            temp.flag = true;            st.push(temp);//将本次的计算结果压入栈中        }        q.pop();//将该操作符或者操作数出队列    }    return st.top().num;//返回后缀表达式的计算结果}int main() {    op[&apos;+&apos;] = op[&apos;-&apos;] = 1;//map设定操作符的优先级    op[&apos;*&apos;] = op[&apos;/&apos;] = 2;    while (getline(cin, s), s != &quot;0&quot;) {        while (!st.empty()) st.pop();//初始化栈        Change();//将中缀表达式转化为后缀表达式        printf(&quot;%.2f\n&quot;,Calculate());//计算后缀表达式    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;p&gt;读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="Codeup" scheme="http://www.echodemo.cc/tags/Codeup/"/>
    
  </entry>
  
</feed>
