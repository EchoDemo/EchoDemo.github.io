<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2019-04-13T14:12:47.210Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://www.echodemo.cc/2019/04/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/13/Java内存模型/</id>
    <published>2019-04-13T10:02:45.000Z</published>
    <updated>2019-04-13T14:12:47.210Z</updated>
    
    <content type="html"><![CDATA[<center>君不见，黄河之水天上来，奔流到海不复回。</center><br><center>君不见，高堂明镜悲白发，朝如青丝暮成雪。</center><br><center>人生得意须尽欢，莫使金樽空对月。</center><br><center>天生我材必有用，千金散尽还复来。</center><br><center>—-李白《将进酒》</center><hr><h3 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h3><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型（Memory Model），然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><h4 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h4><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><hr><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。下图为一个CPU双核的缓存结构。</p><p><img src="/images/2019/4/scache.png" alt="&quot;CPU双核缓存结构&quot;"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><h4 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h4><p>上面提到在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><hr><h3 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h3><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><pre><code>1、原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。2、可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。3、有序性即程序执行的顺序按照代码的先后顺序执行。</code></pre><p>有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><hr><h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><hr><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="/images/2019/4/jmm1.png" alt="&quot;java内存模型&quot;"></p><p>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p>所以，再来总结下，<strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p><hr><h3 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h3><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码，在Java中对应的关键字就是synchronized。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;君不见，黄河之水天上来，奔流到海不复回。&lt;/center&gt;&lt;br&gt;&lt;center&gt;君不见，高堂明镜悲白发，朝如青丝暮成雪。&lt;/center&gt;&lt;br&gt;&lt;center&gt;人生得意须尽欢，莫使金樽空对月。&lt;/center&gt;&lt;br&gt;&lt;center&gt;天生我材必有用，千金散尽还
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构、Java内存模型和Java对象模型</title>
    <link href="http://www.echodemo.cc/2019/04/13/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2019/04/13/JVM内存结构、Java内存模型和Java对象模型/</id>
    <published>2019-04-13T07:40:51.000Z</published>
    <updated>2019-04-13T10:01:14.168Z</updated>
    
    <content type="html"><![CDATA[<center>休对故人思故国，且将新火试新茶，诗酒趁年华。—-苏轼《望江南》</center><hr><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下：</p><p><img src="/images/2019/4/jvmstructure.png" alt="&quot;java内存结构&quot;"></p><p>以上是JVM规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。根据JVM规范，JVM把内存划分成了这几个区域<strong>（其中，方法区和堆是所有线程共享的）：</strong></p><pre><code>1.方法区（Method Area）2.堆区（Heap）3.虚拟机栈（JVM Stack）4.本地方法栈（Native Method Stack）5.PC寄存器（The PC Register）</code></pre><hr><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC（Garbage Collection）。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。</p><p>在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation），一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在方法区上进行GC，条件相当苛刻而且困难。</p><p>如图中所示，运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</p><h4 id="堆区（Heap）"><a href="#堆区（Heap）" class="headerlink" title="堆区（Heap）"></a>堆区（Heap）</h4><p>堆区是GC最频繁的，也是理解GC机制最重要的区域。<strong>堆区由所有线程共享，在虚拟机启动时创建。</strong>堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。</p><h4 id="Java虚拟机栈（JVM-Stack）"><a href="#Java虚拟机栈（JVM-Stack）" class="headerlink" title="Java虚拟机栈（JVM Stack）"></a>Java虚拟机栈（JVM Stack）</h4><p>虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。</p><p>局部变量表中存储着和方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：<strong>内存空间可以在编译期间就确定，运行时不再改变。</strong></p><p>虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。</p><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，<strong>虚拟机栈执行Java方法，本地方法栈执行native方法。</strong>在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。</p><h4 id="PC寄存器（The-PC-Register）"><a href="#PC寄存器（The-PC-Register）" class="headerlink" title="PC寄存器（The PC Register）"></a>PC寄存器（The PC Register）</h4><p>PC寄存器（The PC Register）是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变PC寄存器（程序计数器）的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。</p><p>每个PC寄存器只能记录一个线程的行号，因此它是线程私有的。如果程序当前正在执行的是一个java方法，则PC寄存器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则寄存器的值为空，此内存区是唯一不会抛出OutOfMemoryError的区域。</p><hr><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿。在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p><p>Java内存模型（Java Memory Model）简称JMM。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，它描述了一组规则或规范，这个规范定义了一个线程在对共享变量进行写入时对另一个线程是可见的。</p><p>简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。下面是JMM抽象示意图：</p><p><img src="/images/2019/4/jmm.png" alt="&quot;java内存模型&quot;"></p><hr><h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>我们都知道Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。这个关于Java对象自身的存储模型称之为Java对象模型。</p><p>在HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。下面是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p><p><img src="/images/2019/4/OOPKlass.jpg" alt="&quot;java对象模型&quot;"></p><p>从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，我们再来区分下JVM内存结构、 Java内存模型 以及Java对象模型这三个概念：JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。Java对象模型和Java对象在虚拟机中的表现形式有关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;休对故人思故国，且将新火试新茶，诗酒趁年华。—-苏轼《望江南》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="内存模型" scheme="http://www.echodemo.cc/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中碰到的问题</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中碰到的问题/</id>
    <published>2019-04-13T07:05:47.000Z</published>
    <updated>2019-04-13T06:29:55.472Z</updated>
    
    <content type="html"><![CDATA[<center>我把天空和大地打扫地干干净净，归还一个陌不相识的人。—-海子《黎明》</center><hr><h3 id="在使用group-by时碰到的问题"><a href="#在使用group-by时碰到的问题" class="headerlink" title="在使用group by时碰到的问题"></a>在使用group by时碰到的问题</h3><p>(1)选择列表中的列无效，因为该列没有包含在聚合函数或者group by子句中。</p><pre><code>select id,name,count(0) as cx from student group by id order by cx desc</code></pre><p>其中name会无效，因为该列没有包含在聚合函数或者group by子句当中。也就是说：在select需要查询语句中选中的字段，必须出现在group by子句中。我们还需注意的是：group by和order by一起使用时，order by要在group by的后面。</p><p>(2)每个 group by 表达式必须至少包含一个不是外部引用的列。</p><pre><code>select  count(0)，nothing  from student group by nothing having name=&apos;echodemo&apos;</code></pre><p>出错的原因是因为group by语句所跟的内容一般是数据表中的字段或者数据表的表达式，因为上边的句子中在group by后边使用的是数据表中不存在的字段且也不是数据表的表达式，为外部实例，所以才会报上变得错误。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我把天空和大地打扫地干干净净，归还一个陌不相识的人。—-海子《黎明》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;在使用group-by时碰到的问题&quot;&gt;&lt;a href=&quot;#在使用group-by时碰到的问题&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/乐观锁与悲观锁/</id>
    <published>2019-04-13T06:30:39.000Z</published>
    <updated>2019-04-13T06:26:00.617Z</updated>
    
    <content type="html"><![CDATA[<center>死亡不是真的逝去，遗忘才是永恒的消亡。—-李·昂克里奇《寻梦环游记》</center><hr><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。而乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>其实无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。乐观锁和悲观锁的概念不仅仅是关系型数据库系统所具有的，像memcache、hibernate、tair等都有类似的概念。</p><p>针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p><hr><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p><p>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p><h4 id="在数据库中，悲观锁的流程如下："><a href="#在数据库中，悲观锁的流程如下：" class="headerlink" title="在数据库中，悲观锁的流程如下："></a>在数据库中，悲观锁的流程如下：</h4><p>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p><h4 id="MySQL-InnoDB中使用悲观锁"><a href="#MySQL-InnoDB中使用悲观锁" class="headerlink" title="MySQL InnoDB中使用悲观锁"></a>MySQL InnoDB中使用悲观锁</h4><p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0。</p><pre><code>//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work;</code></pre><p>上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p><h4 id="优点与不足"><a href="#优点与不足" class="headerlink" title="优点与不足"></a>优点与不足</h4><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。</p><hr><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p><h4 id="使用版本号实现乐观锁"><a href="#使用版本号实现乐观锁" class="headerlink" title="使用版本号实现乐观锁"></a>使用版本号实现乐观锁</h4><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><pre><code>//1.查询出商品信息select (status,status,version) from t_goods where id=#{id}//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};</code></pre><h4 id="优点与不足-1"><a href="#优点与不足-1" class="headerlink" title="优点与不足"></a>优点与不足</h4><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;死亡不是真的逝去，遗忘才是永恒的消亡。—-李·昂克里奇《寻梦环游记》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。而乐观并发控制(乐观锁)和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的读锁和写锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%9A%84%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中的读锁和写锁/</id>
    <published>2019-04-13T05:50:17.000Z</published>
    <updated>2019-04-13T05:52:41.530Z</updated>
    
    <content type="html"><![CDATA[<center>即使明天早上，枪口和血淋淋的太阳，让我交出自由、青春和笔，我也绝不会交出这个夜晚。—-北岛《履历》</center><hr><p>本文提到的读锁和写锁都是MySQL数据库的MyISAM引擎支持的表级锁。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享锁与排他锁。其实共享锁指的就是读锁！互斥锁、排他锁、独占锁值得都是写锁。</p><hr><h3 id="重点知识回顾"><a href="#重点知识回顾" class="headerlink" title="重点知识回顾"></a>重点知识回顾</h3><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB存储引擎采用的是页面锁(page-level locking)，但也支持表级锁;InnoDB存储引擎既支持行级锁(row-level locking)，也支持表级锁，但默认情况下是采用行级锁。</p><pre><code>表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。页面锁:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><hr><h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p>MyISAM 存储引擎只支持表锁，MySQL 的表级锁有两种模式:表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。</p><p>对于读操作，可以增加读锁，一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。（当一个请求在读数据时，其他请求也可以读，但是不能写，因为一旦另外一个线程写了数据，就会导致当前线程读取到的数据不是最新的了。这就是不可重复读现象）</p><p>对于写操作，可以增加写锁，一旦数据表被加上写锁，其他请求无法在对该表增加读锁和写锁。（当一个请求在写数据时，其他请求不能执行任何操作，因为在当前事务提交之前，其他的请求无法看到本次修改的内容。这有可能产生脏读、不可重复读和幻读）</p><h4 id="读锁和写锁都是阻塞锁。"><a href="#读锁和写锁都是阻塞锁。" class="headerlink" title="读锁和写锁都是阻塞锁。"></a>读锁和写锁都是阻塞锁。</h4><p>如果t1对数据表增加了写锁，这时t2请求对数据表增加写锁，t2并不会直接返回，而是会一直处于阻塞状态，直到t1释放了对表的锁，这时t2便有可能加锁成功，获取到结果。</p><h4 id="表锁的加锁-解锁方式"><a href="#表锁的加锁-解锁方式" class="headerlink" title="表锁的加锁/解锁方式"></a>表锁的加锁/解锁方式</h4><p>MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。如果用户想要显示的加锁可以使用以下命令：</p><pre><code>锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…]解锁表：UNLOCK TABLES </code></pre><p>在用 LOCK TABLES 给表显式加表锁时,必须同时取得所有涉及到表的锁。在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表;如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。</p><pre><code>//对表test_table增加读锁：LOCK TABLES test_table READUNLOCK test_table//对表test_table增加写锁：LOCK TABLES test_table WRITEUNLOCK test_table</code></pre><p>当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错!</p><p>比如如下SQL语句：</p><pre><code>select a.first_name,b.first_name, from actor a,actor b where a.first_name = b.first_name;</code></pre><p>该Sql语句中，actor表以别名的方式出现了两次，分别是a,b，这时如果要在该Sql执行之前加锁就要使用以下Sql:</p><pre><code>lock table actor as a read,actor as b read;</code></pre><hr><h4 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h4><p>上文提到过 MyISAM 表的读和写是串行的,但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别可以为0、1或2。</p><p>1、当concurrent_insert设置为0时,不允许并发插入。</p><p>2、当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL的默认设置。</p><p>3、当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录。可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。</p><hr><h4 id="MyISAM的锁调度"><a href="#MyISAM的锁调度" class="headerlink" title="MyISAM的锁调度"></a>MyISAM的锁调度</h4><p>前面讲过,MyISAM 存储引擎的读锁和写锁是互斥的,读写操作是串行的。那么,一个进程请求某个MyISAM 表的读锁,同时另一个进程也请求同一表的写锁,MySQL 如何处理呢? 答案是写进程先获得锁。</p><p>不仅如此,即使读请求先到锁等待队列,写请求后到,写锁也会插到读锁请求之前!这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因,因为,大量的更新操作会造成查询操作很难获得读锁,从而可能永远阻塞。这种情况有时可能会变得非常糟糕!不过幸好我们可以通过 一些设置来调节 MyISAM 的调度行为。</p><pre><code>1、通过指定启动参数low-priority-updates,使MyISAM引擎默认给予读请求以优先的权利。 2、通过执行命令SET LOWPRIORITYUPDATES=1,使该连接发出的更新请求优先级降低。 3、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性,降低该语句的优先级。</code></pre><p>另外,MySQL也提供了一种折中的办法来调节读写冲突,即给系统参数max_write_lock_count 设置一个合适的值,当一个表的读锁达到这个值后,MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;即使明天早上，枪口和血淋淋的太阳，让我交出自由、青春和笔，我也绝不会交出这个夜晚。—-北岛《履历》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文提到的读锁和写锁都是MySQL数据库的MyISAM引擎支持的表级锁。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的共享锁与排他锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/MySQL%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E4%BB%96%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/MySQL中的共享锁与排他锁/</id>
    <published>2019-04-13T05:17:06.000Z</published>
    <updated>2019-04-13T05:26:38.066Z</updated>
    
    <content type="html"><![CDATA[<center>从别后，忆相逢，几回魂梦与君同。—-晏几道《鹧鸪天》</center><hr><p>在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。</p><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。</p><pre><code>SELECT ... LOCK IN SHARE MODE;</code></pre><p>在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><p>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。</p><pre><code>SELECT ... FOR UPDATE;</code></pre><p>在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB还有两个表锁：</p><p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。</p><p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p><pre><code>注：意向锁是InnoDB自动加的，不需要用户干预。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;从别后，忆相逢，几回魂梦与君同。—-晏几道《鹧鸪天》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的行级锁、表级锁、页级锁</title>
    <link href="http://www.echodemo.cc/2019/04/13/Mysql%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81/"/>
    <id>http://www.echodemo.cc/2019/04/13/Mysql中的行级锁、表级锁、页级锁/</id>
    <published>2019-04-13T03:07:56.000Z</published>
    <updated>2019-04-13T05:27:41.090Z</updated>
    
    <content type="html"><![CDATA[<center>我的建议是：出发吧。给你的宇宙套上马鞍，看它会变成什么样？—-《瑞克和莫蒂》</center><hr><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><hr><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><pre><code>特点:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</code></pre><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><pre><code>特点:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</code></pre><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>表级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。</p><pre><code>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><hr><h3 id="MySQL常用存储引擎的锁机制"><a href="#MySQL常用存储引擎的锁机制" class="headerlink" title="MySQL常用存储引擎的锁机制"></a>MySQL常用存储引擎的锁机制</h3><pre><code>MyISAM和MEMORY采用表级锁(table-level locking)。BDB采用页面锁(page-level locking)或表级锁，默认为页面锁。InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。</code></pre><h4 id="Innodb中的行锁与表锁"><a href="#Innodb中的行锁与表锁" class="headerlink" title="Innodb中的行锁与表锁"></a>Innodb中的行锁与表锁</h4><p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？</p><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p><h4 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h4><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p><p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p><p>当两个事务同时执行，一个锁住了主键索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><p>有多种方法可以避免死锁，这里只介绍常见的三种:</p><pre><code>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我的建议是：出发吧。给你的宇宙套上马鞍，看它会变成什么样？—-《瑞克和莫蒂》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。在DBMS中，可以按照锁的粒度把数据库锁分为
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库的读现象浅析</title>
    <link href="http://www.echodemo.cc/2019/04/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E7%8E%B0%E8%B1%A1%E6%B5%85%E6%9E%90/"/>
    <id>http://www.echodemo.cc/2019/04/13/数据库的读现象浅析/</id>
    <published>2019-04-13T02:18:27.000Z</published>
    <updated>2019-04-13T02:31:43.220Z</updated>
    
    <content type="html"><![CDATA[<center>别怕美好的一切会消失，咱们先来让它存在。—-王小波《爱你就像爱生命》</center><hr><p>“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据,那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p><p>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。<br>　　<br>幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;别怕美好的一切会消失，咱们先来让它存在。—-王小波《爱你就像爱生命》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
      <category term="数据库" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Limit的用法</title>
    <link href="http://www.echodemo.cc/2019/04/13/Limit%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2019/04/13/Limit的用法/</id>
    <published>2019-04-13T02:08:26.000Z</published>
    <updated>2019-04-13T02:14:22.412Z</updated>
    
    <content type="html"><![CDATA[<center>春天来得很慢，春天才有浪漫。 —-deca joins《夜间独白》</center><hr><pre><code>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</code></pre><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><pre><code>SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.//如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;春天来得很慢，春天才有浪漫。 —-deca joins《夜间独白》&lt;/center&gt;

&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的事件处理</title>
    <link href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://www.echodemo.cc/2019/04/05/Redis中事件处理/</id>
    <published>2019-04-05T02:20:00.000Z</published>
    <updated>2019-04-13T02:34:36.602Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</p><p>文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字（Socket）操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</p><p>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p><pre><code>注：TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。</code></pre><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><h4 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h4><p>文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器；当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。下图是Redis线程模型：</p><p><img src="/images/2019/4/IO.png" alt="&quot;redis线程模型&quot;"></p><p>文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p>（1）文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>（2）I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。如果你不太清楚IO多路复用程序可以阅读我的这篇博客：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">Redis中的IO多路复用</a></p><p><img src="/images/2019/4/socket.png" alt="&quot;socket&quot;"></p><p>（3）文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p><p>（4）事件处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件分为以下两类：</p><pre><code>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次;周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。</code></pre><p>时间事件主要由以下三个属性组成：</p><pre><code>id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大;when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间;timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</code></pre><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><p>如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达;</p><p>如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。(现在的Redis主要使用这个)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：&lt;/p&gt;
&lt;p&gt;文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字（Socket）操作的抽象。服务器与客户端（或者其他服务器）
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初识Redis</title>
    <link href="http://www.echodemo.cc/2019/04/05/%E5%88%9D%E8%AF%86Redis/"/>
    <id>http://www.echodemo.cc/2019/04/05/初识Redis/</id>
    <published>2019-04-05T01:49:17.000Z</published>
    <updated>2019-04-13T02:29:37.637Z</updated>
    
    <content type="html"><![CDATA[<center>你身体里的每一粒原子都来自一颗爆炸了的恒星。形成你左手的原子和形成你右手的原子也许来自不同的恒星。这是我所知的物理学中最富有诗意的事情：你们都是星辰。—-劳伦斯·克劳斯《一颗原子的时空之旅》</center><hr><h3 id="1，盛赞Redis"><a href="#1，盛赞Redis" class="headerlink" title="1，盛赞Redis"></a>1，盛赞Redis</h3><p>Redis（REmote Dictionary Server）的前身是一个叫做LLOOGG的网站，在2008年，Redis的作者在开发该网站时，需要实现一个高性能的队列功能，最开始是使用MySQL来实现的， 但后来发现无论如何优化SQL语句都无法使网站的性能提高上去，他决定做一个专属于LLOOGG的数据库 。</p><p>Redis是一种基于键值对（key-value）的NoSQL数据库。NoSQL(NoSQL = Not Only SQL )。是对不同于传统的关系型数据库的数据库管理系统的统称。高可扩展性，分布式计算，低成本，架构的灵活性等特性。</p><p><img src="/images/2019/4/nosql.png" alt="&quot;NoSQL数据库分类&quot;"></p><p>国外的Twitter、 Instagram、Stack Overflow、GitHub，国内像新浪微博、阿里巴巴、腾讯、百度、搜狐、优酷土豆、美团、小米、唯品会等公司都是 Redis的使用者。</p><h3 id="2-Redis特性"><a href="#2-Redis特性" class="headerlink" title="2,Redis特性"></a>2,Redis特性</h3><pre><code>1、速度快2、基于键值对的数据结构服务器3、丰富的功能4、简单稳定5、客户端语言多6、持久化7、主从复制8、高可用和分布式</code></pre><p>（1）速度快</p><p>Redis的所有数据都是存放在内存当中。它是完全基于内存，其绝大部分请求是纯粹的内存操作。</p><p>Redis使用了单线程架构。避免了不必要的上下文切换和竞争条件，从而不存在多进程或者多线程切换导致的CPU消耗问题，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p>采用了非阻塞I/O多路复用机制。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，此时程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流。阻塞式I/O如果要接收更多的连接，就必须创建更多的线程。在I/O复用模式下大量的连接统统都可以过来直接注册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。这就是I/O复用与传统的阻塞式I/O最大的不同。也正是I/O复用的精髓所在。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。具体的关于I/O多路复用可以查看我的这篇文章：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a></p><p>Redis是用C语言实现的。一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。</p><p>（2）基于键值对的数据结构服务器</p><p>与很多键值对数据库不同的是，Redis中的值不仅可以是字符串，而且还可以是具体的数据结构，Redis它主要提供了5种数据结构：字符串（String）、哈希（Hash)、列表（List）、集合（Set）、有序集合（Sorted Set），同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种神奇的“数据结构”，并且随着 LBS（Location Based Service，基于位置服务）的不断发展，Redis3.2版本中加入有关GEO（地理信息定位）的功能，在这些数据结构的帮助下，不仅提高了开发的效率，而且适用于更多的应用场景。</p><p>（3）丰富的功能</p><pre><code>1、提供了键过期功能，可以用来实现缓存。2、提供了发布订阅功能，可以用来实现消息系统。3、支持Lua脚本功能，可以利用Lua创造出新的Redis命令。4、提供了简单的事务功能，能在一定程度上保证事务特性。5、提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到 Redis，减少了网络的开销。</code></pre><p>（4）简单稳定</p><p>Redis的源码很少，早期版本的代码只有2万行左右，3.0版本以后由于添加了集群特性，代码增至5万行左右，也就意味着普通的开发和运维人员完全可以“吃透”它。</p><p>Redis使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。</p><p>Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖 libevent这样的系统类库），Redis自己实现了事件处理的相关功能。</p><p>（5）客户端语言多</p><p>Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入到 Redis，几乎涵盖了主流的编程语言，例如Java、PHP、 Python、C、C++、Nodejs等。</p><p>（6）持久化</p><p>我们都知道的是：将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失。Redis提供了两种持久化方式用来将内存的数据保存到硬盘：RDB和 AOF。</p><p>RDB(Redis DataBase)是在某个时间点将数据（Database中的key-value的二进制形式数据）写入一个临时的rdb文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。它是通过配置Redis在n秒内如果超过m个key被修改就执行一次RDB操作，这中持久化的方式也叫做snapshots。RDB是间隔一段时间进行持久化，如果在持久化之间发生故障，会发生数据的丢失，所以这种方式更适合数据要求不严谨的时候。</p><p>AOF(Append Only File)把数据的每一条修改命令都追加到aof文件。该“日志文件”保存了历史所有的操作过程，虽然可以保证数据的不易丢失，但是这样也造成了其文件势必会比rdb文件大很多，且aof文件中存储的是命令，导致其恢复的速度变慢。</p><p>（7）主从复制</p><p>Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。</p><p>（8）高可用和分布式</p><p>Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis 节点的故障发现和故障自动转移。Redis从3.0版本正式提供了分布式实现 Redis Cluster，它是Redis真正的分布式实现，提供了高可用、读写和容量的扩展性。</p><p>3，Redis使用场景</p><p>（1）缓存</p><p>Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</p><p>（2）排行榜系统</p><p>Redis提供了列表和有序集合数据结构。</p><p>（3）计数器应用</p><p>传统关系型数据库如果并发量很大，为了保证数据的实时性，对其性能是一种很大的挑战。Redis天然支持计数功能而且计数的性能也非常好。</p><p>（4）社交网络</p><p>由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存点赞，推送，下拉刷新等类型的数据，而Redis提供的数据结构可以相对比较容易地实现这些功能。</p><p>（5）消息队列系统</p><p>Redis提供了发布订阅功能和阻塞队列的功能。</p><p>（6）Redis不适合的场景</p><p>不适合存储大规模的数据和冷数据。</p><p>4，安装Redis</p><p>（1）在Linux上安装Redis</p><pre><code>$ wget http://download.redis.io/releases/redis-3.0.7.tar.gz $ tar xzf redis-3.0.7.tar.gz $ ln -s redis-3.0.7 redis $ cd redis $ make $ make install1、下载Redis指定版本的源码压缩包到当前目录。2、解压缩Redis源码压缩包。3、建立一个redis目录的软连接，指向redis-3.0.7。这是为了不把redis目录固定在指定版本上，有利于Redis未来版本升级， 是安装软件的一种好习惯。4、进入redis目录。5、编译（编译之前确保操作系统已经安装gcc）。6、安装。将Redis的相关运行文 件放到/usr/local/bin/下，这样就可以在任意目录下执行Redis的命令。</code></pre><p>（2）在Windows上安装Redis</p><p>5，启动、操作、关闭Redis</p><p>启动Redis服务</p><p>（1）默认配置</p><pre><code>$ redis-server</code></pre><p>（2）运行启动</p><pre><code>$ redis-server --configKey1 configValue1 --configKey2 configValue2</code></pre><p>（3）配置文件启动</p><pre><code>$ redis-server /opt/redis/redis.conf</code></pre><p>Redis命令行客户端</p><p>（1）交互式方式</p><pre><code>$ redis-cli -h 127.0.0.1 -p 6379 $ 127.0.0.1:6379&gt; set hello world$ OK$ 127.0.0.1:6379&gt; get hello$ &quot;world&quot;</code></pre><p>（2）命令方式</p><pre><code>$ redis-cli -h 127.0.0.1 -p 6379 get hello$ &quot;world&quot;</code></pre><p>注：如果没有-h参数，那么默认连接127.0.0.1；如 果没有-p，那么默认6379端口，也就是说如果-h和-p都没写就是连接 127.0.0.1：6379这个Redis实例。</p><p>停止Redis服务</p><p>Redis提供了shutdown命令来停止Redis服务，如果要停掉127.0.0.1上 6379端口上的Redis服务：</p><pre><code>$ redis-cli shutdown</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;你身体里的每一粒原子都来自一颗爆炸了的恒星。形成你左手的原子和形成你右手的原子也许来自不同的恒星。这是我所知的物理学中最富有诗意的事情：你们都是星辰。—-劳伦斯·克劳斯《一颗原子的时空之旅》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;1，盛赞Redis&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的I/O多路复用</title>
    <link href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2019/04/05/Redis中的IO多路复用/</id>
    <published>2019-04-05T01:10:56.000Z</published>
    <updated>2019-04-13T02:38:14.070Z</updated>
    
    <content type="html"><![CDATA[<center>人真正活过的那段生命仅仅是一小部分。其余的部分不能算是生命，仅仅是时间而已。—-伊坂幸太郎《死神的精确度》</center><hr><p>在谈I/O多路复用机制之前，我们先来讲讲阻塞I/O和非阻塞I/O。</p><h3 id="1、阻塞I-O"><a href="#1、阻塞I-O" class="headerlink" title="1、阻塞I/O"></a>1、阻塞I/O</h3><p>我们常用的IO操作（比如read和write）都是阻塞I/O，也就是说当你调用read时，如果没有收到数据的返回，那么线程或者进程就会被挂起，直到收到数据。阻塞的意思，就是一直等着。阻塞I/O就是等着数据返回，进行读写操作。通过应用的函数进行调用，但是内核一直没有返回，就一直等着。应用的函数长时间处于等待数据返回的状态，我们就称之为阻塞I/O。</p><h3 id="2、非阻塞I-O"><a href="#2、非阻塞I-O" class="headerlink" title="2、非阻塞I/O"></a>2、非阻塞I/O</h3><p>非阻塞IO是通过fcntl（POSIX）或ioctl（Unix）设为非阻塞模式。此时，当你调用read时，如果有数据收到，就返回数据；如果没有数据收到，就立刻返回一个错误。这样的话就不存在线程的阻塞了，但是你还是要不断的轮询来读取或写入。相当于你去查看有没有数据，告诉你没有，过一会再来吧！应用过一会再来问，有没有数据？没有数据，会有一个返回。但是依旧很不好。应用必须得过一会来一下，问问内核有木有数据啊。</p><h3 id="3、I-O多路复用"><a href="#3、I-O多路复用" class="headerlink" title="3、I/O多路复用"></a>3、I/O多路复用</h3><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路复用是指使用一个线程来检查多个Socket的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。什么意思呢？就是派一个代表，同时监听多个文件描述符是否有数据到来。等着等着，如果有数据，就告诉某某你的数据来啦！赶紧来处理吧。</p><p>我们先来看一张JDK的基于I/O多路复用技术的NIO实现的图片，如下：</p><p><img src="/images/2019/4/selector.png" alt="&quot;JDK的基于I/O多路复用技术的NIO实现&quot;"></p><p>从图片中我们可以看到，很多的网络连接都向Selector进行注册，Selector会对已经向它注册了的网络连接进行轮询监控，一旦发现某个网络连接有了数据的返回，便通过SelectKey通知相应的Channel。从而达到多路复用的目的。</p><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换。下面是redis线程模型，如图所示：</p><p><img src="/images/2019/4/IO.png" alt="&quot;redis线程模型&quot;"></p><p>我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。更详细的关于redis中的事件处理请参见我的这篇文章：<a href="http://www.echodemo.cc/2019/04/05/Redis%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">Redis中的事件处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;人真正活过的那段生命仅仅是一小部分。其余的部分不能算是生命，仅仅是时间而已。—-伊坂幸太郎《死神的精确度》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;在谈I/O多路复用机制之前，我们先来讲讲阻塞I/O和非阻塞I/O。&lt;/p&gt;
&lt;h3 id=&quot;1、阻塞I-O&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="http://www.echodemo.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JSONField注解</title>
    <link href="http://www.echodemo.cc/2019/03/07/2019-03-7-JSONField%E6%B3%A8%E8%A7%A3/"/>
    <id>http://www.echodemo.cc/2019/03/07/2019-03-7-JSONField注解/</id>
    <published>2019-03-07T13:03:32.000Z</published>
    <updated>2019-04-05T01:18:06.102Z</updated>
    
    <content type="html"><![CDATA[<p>1、JSONField介绍</p><pre><code>package com.alibaba.fastjson.annotation;public @interface JSONField {// 配置序列化和反序列化的顺序，1.1.42版本之后才⽀持int ordinal() default 0;// 指定字段的名称String name() default &quot;&quot;;// 指定字段的格式，对⽇期格式有⽤String format() default &quot;&quot;;// 是否序列化boolean serialize() default true;// 是否反序列化boolean deserialize() default true;}</code></pre><h4 id="若属性是私有的，必须有set-方法。否则无法反序列化。"><a href="#若属性是私有的，必须有set-方法。否则无法反序列化。" class="headerlink" title="若属性是私有的，必须有set*方法。否则无法反序列化。"></a>若属性是私有的，必须有set*方法。否则无法反序列化。</h4><p>2、JSONField配置方式</p><p>（1）配置在getter/setter⽅法上。</p><pre><code>public class A {    private int id;    @JSONField(name=&quot;ID&quot;)    public int getId() {return id;}    @JSONField(name=&quot;ID&quot;)    public void setId(int value) {this.id = id;}}</code></pre><p>（2）配置在属性上</p><pre><code>public class A {    @JSONField(name=&quot;ID&quot;)    private int id;    public int getId() {return id;}    public void setId(int value) {this.id = id;}}</code></pre><p>（3）使⽤format配置⽇期格式化</p><pre><code>public class A {    // 配置date序列化和反序列使⽤yyyyMMdd日期格式    @JSONField(format=&quot;yyyyMMdd&quot;)    public Date date;}</code></pre><p>（4）使⽤serialize/deserialize指定字段不序列化</p><pre><code>public class A {    @JSONField(serialize=false)    public Date date;}</code></pre><p>（5）使⽤ordinal指定字段的顺序</p><pre><code>public static class VO {    @JSONField(ordinal = 3)    private int f0;    @JSONField(ordinal = 2)    private int f1;    @JSONField(ordinal = 1)    private int f2;}</code></pre><h4 id="缺省fastjson序列化一个java-bean，是根据fieldName的字母序进⾏序列的你可以通过ordinal指定字段的顺序。这个特性需要1-1-42以上版本。"><a href="#缺省fastjson序列化一个java-bean，是根据fieldName的字母序进⾏序列的你可以通过ordinal指定字段的顺序。这个特性需要1-1-42以上版本。" class="headerlink" title="缺省fastjson序列化一个java bean，是根据fieldName的字母序进⾏序列的你可以通过ordinal指定字段的顺序。这个特性需要1.1.42以上版本。"></a>缺省fastjson序列化一个java bean，是根据fieldName的字母序进⾏序列的你可以通过ordinal指定字段的顺序。这个特性需要1.1.42以上版本。</h4><p>（6）使用serializeUsing制定属性的序列化类</p><p>在fastjson 1.2.16版本之后，JSONField⽀持新的定制化配置serializeUsing，可以单独对某一个类的某个属性定制序列化。</p><pre><code>import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.annotation.JSONField;import com.alibaba.fastjson.serializer.JSONSerializer;import com.alibaba.fastjson.serializer.ObjectSerializer;import java.io.IOException;import java.lang.reflect.Type;public class MyTest {    public static class A {        @JSONField(serializeUsing = AValueSerializer.class)        public int value;    }    public static class AValueSerializer implements ObjectSerializer {        @Override        public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType,                          int features) throws IOException {            Integer value = (Integer) object;            String text = value + &quot;元&quot;;            serializer.write(text);        }    }    public static void main(String[] args) {        A obj = new A();        obj.value = 100;        String json = JSON.toJSONString(obj);        System.out.println(json);    }}</code></pre><p>（7）JSONField jsonDirect</p><p>在fastjson-1.2.12版本中，JSONField⽀持⼀个新的配置项jsonDirect，它的作⽤是：当你有⼀个字段是字符串类型，⾥⾯是json格式数据，你希望直接输出，⽽不是经过转义之后再输出。</p><pre><code>import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.annotation.JSONField;import com.alibaba.fastjson.serializer.JSONSerializer;import com.alibaba.fastjson.serializer.ObjectSerializer;import java.io.IOException;import java.lang.reflect.Type;public class MyTest {    public static void main(String[] args) {        B b = new B();        b.id = 9999;        b.value = &quot;{}&quot;;        String json = JSON.toJSONString(b);        System.out.println(json);    }    public static class B{        public int id;        @JSONField(jsonDirect = true)        public String value;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、JSONField介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.alibaba.fastjson.annotation;
public @interface JSONField {
// 配置序列化和反序列化的顺序，1.1.42版本之后才⽀持
int or
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浏览器错误码</title>
    <link href="http://www.echodemo.cc/2019/02/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <id>http://www.echodemo.cc/2019/02/17/浏览器错误码/</id>
    <published>2019-02-17T03:16:28.000Z</published>
    <updated>2019-02-17T03:27:54.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、1XX"><a href="#1、1XX" class="headerlink" title="1、1XX"></a>1、1XX</h3><pre><code>100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。</code></pre><h3 id="2、2XX"><a href="#2、2XX" class="headerlink" title="2、2XX"></a>2、2XX</h3><pre><code>200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）：服务器成功处理了请求，但没有返回任何内容。 205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 206（部分内容）：服务器成功处理了部分 GET 请求。</code></pre><h3 id="3、3xx-（重定向）"><a href="#3、3xx-（重定向）" class="headerlink" title="3、3xx （重定向）"></a>3、3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><pre><code>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</code></pre><h3 id="4、4xx（请求错误）"><a href="#4、4xx（请求错误）" class="headerlink" title="4、4xx（请求错误）"></a>4、4xx（请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><pre><code>400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。 404（未找到）：服务器找不到请求的网页。 405（方法禁用）：禁用请求中指定的方法。 406（不接受）：无法使用请求的内容特性响应请求的网页。 407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408（请求超时）：服务器等候请求时发生超时。 409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。 411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）：请求的格式不受请求页面的支持。 416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。 417（未满足期望值）：服务器未满足”期望”请求标头字段的要求。</code></pre><h3 id="5、5xx（服务器错误）"><a href="#5、5xx（服务器错误）" class="headerlink" title="5、5xx（服务器错误）"></a>5、5xx（服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><pre><code>500（服务器内部错误）：服务器遇到错误，无法完成请求。 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、1XX&quot;&gt;&lt;a href=&quot;#1、1XX&quot; class=&quot;headerlink&quot; title=&quot;1、1XX&quot;&gt;&lt;/a&gt;1、1XX&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《房思琪的初恋乐园》摘句</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E6%88%BF%E6%80%9D%E7%90%AA%E7%9A%84%E5%88%9D%E6%81%8B%E4%B9%90%E5%9B%AD%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2019/02/16/《房思琪的初恋乐园》摘句/</id>
    <published>2019-02-16T06:50:48.000Z</published>
    <updated>2019-02-16T06:25:24.309Z</updated>
    
    <content type="html"><![CDATA[<p>1、刚刚在饭桌上，思琪用面包涂奶油的口气对妈妈说：“我们的家教好像什么都有，就是没有性教育。”妈妈诧异地看着她，回答：“什么性教育？性教育是给那些需要性的人。所谓教育不就是这样吗？”思琪一时间明白了，在这个故事中父母将永远缺席，他们旷课了，却自以为是还没开学。</p><p>2、他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。罪恶感是古老而血统纯正的牧羊犬。</p><p>3、思琪在家一面整理行李，一面用一种天真的口吻对妈妈说：“听说学校有个同学跟老师在一起。”“谁？”“不认识。”“这么小年纪就这么骚。”思琪不说话了。她一瞬间决定从此一辈子不说话了。她脸上挂着天真的表情把桌上的点心。</p><p>4、思琪的声音像一盘冷掉的菜肴，她说：“怡婷，我早已不是我自己了，那是我对自己的乡愁。”</p><p>5、整个中学生涯，她拒绝过许多中学生，一些高中生，几个大学生。她每次都说这一句“对不起，我真的没办法喜欢你”，一面说一面感觉木木的脸皮下有火烧上来。</p><p>其实是我配不上你们。我是馊掉的橙子汁和浓汤，我是爬满虫卵的玫瑰和百合，我是一个灯火流丽的都市里明明存在却没有人看得到也没有人需要的北极星。</p><p>6、为什么这个世界是这个样子？为什么所谓教养就是受苦的人该闭嘴？为什么打人的人上电视上广告广告牌？姐姐，我好失望，但我不是对你失望，这个世界，或是生活、命运，或叫它神，或无论叫它什么，它好差劲，我现在读小说，如果读到赏善罚恶的好结局，我就会哭，我宁愿大家承认人间有一些痛苦是不能和解的，我最讨厌人说经过痛苦才成为更好的人，我好希望大家承认有些痛苦是毁灭的，我讨厌大团圆的抒情传统，讨厌王子跟公主在一起，正面思考是多么媚俗！可是姐姐，你知道我更恨什么吗？我宁愿我是一个媚俗的人，我宁愿无知，也不想要看过世界的背面。</p><p>7、其实我第一次想到死的时候就已经死了。人生如衣物，如此容易被剥夺。</p><p>8、我要等等我灵魂的双胞胎，她被你丢弃在十三岁，也被我遗忘在十三岁，我要躺在那里等她，等她赶上我，我要跟她在一起。抱住他的小腿。</p><p>9、怡婷，你才十八岁，你有选择，你可以假装世界上没有人以强暴小女孩为乐；假装从没有小女孩被强暴；假装思琪从不存在；假装你从未跟另一个人共享奶嘴、钢琴，从未有另一个人与你有一模一样的胃口和思绪，你可以过一个资产阶级和平安逸的日子；假装世界上没有精神上的癌；假装世界上没有一个地方有铁栏杆，栏杆背后人人精神癌到了末期；你可以假装世界上只有马卡龙、手冲咖啡和进口文具。但是你也可以选择经历所有思琪曾经感受过的痛楚，学习所有她为了抵御这些痛楚付出的努力，从你们出生相处的时光，到你从日记里读来的时光。你要替思琪上大学，念研究所，谈恋爱，结婚，生小孩，也许会被退学，也许会离婚，也许会死胎。但是，思琪连那种最庸俗、呆钝、刻板的人生都没有办法经历。你懂吗？你要经历并牢牢记住她所有的思想、思绪、感情、感觉，记忆与幻想、她的爱、讨厌、恐惧、失重、荒芜、柔情和欲望，你要紧紧拥抱着思琪的痛苦，你可以变成思琪，然后，替她活下去，连思琪的份一起好好地活下去。</p><p>10、忍耐不是美德，把忍耐当成美德是这个伪善的世界维持它扭曲的秩序的方式，生气才是美德。<br>11、我怕消费任何一个房思琪。我不愿伤害她们。不愿猎奇。不愿煽情。我每天写八个小时，写的过程中痛苦不堪，泪流满面。写完以后再看，最可怕的就是：我所写的、最可怕的事，竟然是真实发生过的事。而我能做的只有写。女孩子被伤害了。女孩子在读者读到这段对话的当下也正在被伤害。而恶人还高高挂在招牌上。我恨透了自己只会写字。”</p><h4 id="感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。"><a href="#感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。" class="headerlink" title="感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。"></a>感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、刚刚在饭桌上，思琪用面包涂奶油的口气对妈妈说：“我们的家教好像什么都有，就是没有性教育。”妈妈诧异地看着她，回答：“什么性教育？性教育是给那些需要性的人。所谓教育不就是这样吗？”思琪一时间明白了，在这个故事中父母将永远缺席，他们旷课了，却自以为是还没开学。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《不止代码》摘句(二)</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2019/02/16/《不止代码》摘句(二)/</id>
    <published>2019-02-16T06:04:31.000Z</published>
    <updated>2019-02-16T06:11:04.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是架构？"><a href="#什么是架构？" class="headerlink" title="什么是架构？"></a>什么是架构？</h3><p>在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义：</p><p>1、组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。</p><p>2、组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如 RPC 框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。</p><p>3、组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。</p><p>4、组织全局，对外输出：架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。</p><p>很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。</p><h3 id="架构目标需要适应业务的发展"><a href="#架构目标需要适应业务的发展" class="headerlink" title="架构目标需要适应业务的发展"></a>架构目标需要适应业务的发展</h3><p>架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单 300 万，基于对未来的可能预测，明年可能有 3000 万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到 2 个 9 还是 3 个 9。回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。</p><p>另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader 问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以<br>不久 leader 就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。</p><p>当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。</p><h3 id="从价值出发－找寻学习与工作的新思路"><a href="#从价值出发－找寻学习与工作的新思路" class="headerlink" title="从价值出发－找寻学习与工作的新思路"></a>从价值出发－找寻学习与工作的新思路</h3><p>迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？明确自身的业务相关主体：找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。</p><p>向前一步，为更大的价值负责：不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。</p><p>像架构师一样思考，用价值找寻重心：人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。学会连接，构建体系：前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是架构？&quot;&gt;&lt;a href=&quot;#什么是架构？&quot; class=&quot;headerlink&quot; title=&quot;什么是架构？&quot;&gt;&lt;/a&gt;什么是架构？&lt;/h3&gt;&lt;p&gt;在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《不止代码》摘句(一)</title>
    <link href="http://www.echodemo.cc/2019/02/16/%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2019/02/16/《不止代码》摘句(一)/</id>
    <published>2019-02-16T05:57:20.000Z</published>
    <updated>2019-02-16T15:21:50.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一阶段：大学毕业3到5年"><a href="#第一阶段：大学毕业3到5年" class="headerlink" title="第一阶段：大学毕业3到5年"></a>第一阶段：大学毕业3到5年</h3><p>● 基础的 Java 知识：你会开始看《Java 编程思想》、《Effective Java》。</p><p>● 高质量代码进阶知识：你会开始看《重构：改善既有代码的设计》、《代码大全》、《编程珠玑》。</p><p>● 常用的主流框架：比如 SSH 相关的《Spring 实战》、《Spring Boot 实战》、《Hibernate 实战 ( 第 2 版 )》。当然，这些书已经不够了，你会通过 Google、Baidu 大量地浏览在线的资源：Apache 官网、Spring 官网、Hibernate 官网。你会去 StackOverflow 问问题或找答案。</p><p>● 系统设计与算法知识：《系统分析与设计方法》、《设计模式》、《需求分析与系统设计》、《面向对象分析与设计》、《UML 用户指南》、《算法导论》</p><p>● 其他知识：比如数据库调优、缓存框架、NoSQL 数据库、日志框架等等</p><p>在这5年间，快速地完成这些基础知识的学习，并能在项目中快速地学以致用。不仅自身能获得比较高的成就感，而且实际的用人的单位、猎头也会非常喜欢这类熟练工。</p><p>从大部分人的实际发展轨迹看，这个阶段发展快的人和正常发展速度的人，差别还不是很大。比如，发展非常快的人，从毕业就入职阿里的 P5 到P7（注：阿里内部职称评级），可能三年就可以做到。发展速度正常的人，可能需要 5-6 年也可以到 P7。也就是说，这个阶段正常发展速度的同学也仅仅比发展速度快的人慢 2-3 年而已。</p><p>这 2 到 3 年的差距，是可以通过有针对性的学习、重大项目的历练等完成这些知识的学习。无非是，有的同学会严格要求自己，有严格的学习计划；有的同学赶早参加了一些重点的、痛苦的项目得到了锻炼。只要是做技术的，其实迟早都会经历过，都会成长起来。</p><h3 id="第二阶段：大学毕业-5-到-10-年"><a href="#第二阶段：大学毕业-5-到-10-年" class="headerlink" title="第二阶段：大学毕业 5 到 10 年"></a>第二阶段：大学毕业 5 到 10 年</h3><p>很多本科同学，特别是研究生同学。在毕业 10 年后，就已经到了 34、35 岁左右了。也是前段时间网上广泛讨论的所谓 34+ 岁现象。其实，年龄并不是问题的真正原因。真正的原因还是在于自身“竞争力”是否符合这个年龄所应该具备的。到了这个年龄的人，往往已经不是“个人贡献者”了，而是“团队贡献者”。团<br>队贡献者可能是带团队的 TL，也可能是个架构师，在技术决策上具有团队影响力和话语权。</p><h4 id="那么，为什么这些人能管理团队或者有影响力呢？"><a href="#那么，为什么这些人能管理团队或者有影响力呢？" class="headerlink" title="那么，为什么这些人能管理团队或者有影响力呢？"></a>那么，为什么这些人能管理团队或者有影响力呢？</h4><p>从公司的经营视角看，一个管理团队的人，他必须为业务的成功负责。说个大白话，一个 TL 管了 N 个人，他至少要能保证大家输出所产生的价值，至少要高于这个团队的工资、奖金、五险一金、OPEX、CAPEX 等等吧。这个 TL 为了大家输出得有价值，他是不是需要能：</p><p>● 能对所负责领域的业务特点、发展趋势、友商竞争分析有很好的洞察？能知道这个业务领域的客户是谁？他们的需求是什么？他们的痛点是什么？所以，这个 TL 应该需要学习《咨询的奥秘》、《探索需求》、《系统化思维导论》。对于技术型的 TL，还应该了解《成为技术领导者：掌握全面解决问题的方法》。</p><p>● 服务于特定领域的客户，我们需要能了解我们的客户企业架构、业务知识。要了解清楚规划的产品、服务，什么才是客户所需要的。那么，从理论上，我们是否应该学习一些 TOGAF、NGOSS、ITIL 等业务理论以及业务知识？</p><p>● 作为 TL， 是否有必要能将自己对于市场的洞察转换成业务规划，并能向自己的老板（或者投资人）说清楚、讲明白？并争取到老板的同意，包括资金、人力资源等。对于，能否把事情讲明白，我们可能需要学习《金字塔原理》，并能非常清晰、有逻辑性地进行表达与沟通。当然，有些业务发展的事不一定特别有逻辑，是需要摸索、尝试，那么你是否能将一个不确定的领域说服老板并获得支持，我们又需要什么？《博弈论》、《影响力》等。</p><p>● 获得老板支持后，就需要开始带着兄弟们干活了。作为带头人，你看我们是否需要能将业务趋势、客户痛点进行业务建模好让团队的 PD、技术都能理解？在做业务进一步深入分析，可能就需要学习《领域驱动设计 : 软件核心复杂性应对之道》、《实现领域驱动设计》、《企业应用架构模式》、《恰如其分的软件架<br>构》等等。</p><p>● 做完业务设计后，开始要带着团队做技术方案设计、接口设计以及编码实现等。这个过程，TL 又需要具备软件项目管理的能力。无论是《PMBOK 指南》，还是《敏捷软件开发》、《人月神话》、《程序开发心理学》，相信总归还是会有点帮助的。</p><p>● 对于一些有国际化要求的，还需要再学习英语吧！</p><p>● 嗯，还需要有个好的身体，还需要经常锻炼，学习科学的健身吧（说起来自己脸红）。至少我明白了一个道理，以前我都是跟自己说，等这段时间过了，闲下来去锻炼一下。其实，我发现，越是忙的时候，越需要锻炼身体！</p><p>● 另外，在这 10 年内，比较关键的是——你还经历过什么有挑战的业务、技术、产品、平台等方面的成功与失败经验？在这些经历里，你可能会遇到这些困难与挑战：团队磨合的挑战、技术方案上的争执、平台优先 or 业务优先的博弈、低落的团队氛围、个人的低谷等等。这些困难与挑战，你是退缩了？还是有成长？在带团队时，再次面临这些挑战时，这时你是否有解或者有勇气了？</p><p>发现没有？毕业 10 年后，作为一个团队贡献者，你可能需要具备这些能力，并且还远远不止。而且，更可悲的时，当毕业 10 年后，突然发现自己不具备这个能力时（比如晋升失败时发现了），这些能力GAP就不再是 2 到 3 年就能追得上的了。我见过一些有准备的同学，他们给自己的目标是在毕业第 7 年就要具备这些能力，他有严格的学习计划、实践计划、甚至是冒险的创业经历。当他到第 10 年这个点时，这些高阶技能很可能已经有 3 年的实践经验了。如果我们没有做好准备，10 年后，如何和这批人竞争？这些软、硬知识，从十年这个时间刻度倒排，学习计划、实践计划的执行还是很紧张的。所以，从现在开始给自己制定一个严格的学习计划、严格执行，多实践吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一阶段：大学毕业3到5年&quot;&gt;&lt;a href=&quot;#第一阶段：大学毕业3到5年&quot; class=&quot;headerlink&quot; title=&quot;第一阶段：大学毕业3到5年&quot;&gt;&lt;/a&gt;第一阶段：大学毕业3到5年&lt;/h3&gt;&lt;p&gt;● 基础的 Java 知识：你会开始看《Java 编
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>RequestBody注解</title>
    <link href="http://www.echodemo.cc/2019/02/11/RequestBody%E6%B3%A8%E8%A7%A3/"/>
    <id>http://www.echodemo.cc/2019/02/11/RequestBody注解/</id>
    <published>2019-02-11T12:53:31.000Z</published>
    <updated>2019-02-11T13:52:27.982Z</updated>
    
    <content type="html"><![CDATA[<p>1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。</p><p>2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p><p>3、在后端的同一个接收方法里，@RequestBody 与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</p><p>4、当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、数组、集合、对象等等(即:当@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。</p><p>5、如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值)，如果没有xxx名的话，那么请求会出错，报400。如果参数前不写@RequestParam(xxx)的话，那么前端可以有也可以没有对应的xxx名字，如果有xxx名的话，那么就会自动匹配；没有的话，请求也能正确发送。</p><p>6、如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求:</p><p>(1)后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时,会根据json字符串中的key来匹配对应实体类的属性,如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性,这一条会在本节末尾详细分析。</p><p>(2)json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””,如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。json字符串中，如果value为null的话，后端对应收到的就是null。</p><p>(3)如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中;要么写value时，必须有值，null  或””都行。千万不能有类似”stature”:,这样的写法。</p><p>7、举例说明</p><p>(1)创建User类：</p><pre><code>package com.aspire.entity;/** * 用户实体类模型 * * @author JustryDeng * @date 2018年7月6日 上午1:55:59 */@Datapublic class User {    private String name;    private Integer age;    private String gender;    private String motto;    @Override    public String toString() {        return age + &quot;岁&quot; + gender + &quot;人[&quot; + name + &quot;]的座右铭居然是: &quot; + motto + &quot;!!!&quot;;    }}</code></pre><h4 id="注：-Data注解请见Lombok"><a href="#注：-Data注解请见Lombok" class="headerlink" title="注：@Data注解请见Lombok"></a>注：@Data注解请见<a href="http://www.echodemo.cc/2019/02/01/Lombok/">Lombok</a></h4><p>(2)创建Team类：</p><pre><code>package com.aspire.entity;import java.util.List;/** * 小组测试实体类模型 * * @author JustryDeng * @date 2018年7月8日 下午11:23:51 */@Datapublic class Team {    private Integer id;    private String teamName;    private List&lt;String&gt; honors;    private List&lt;User&gt; teamMembers;    /**     * 重写toString     *      * @see java.lang.Object#toString()     */    @Override    public String toString() {        // 遍历出小组所获荣耀        StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;);        for (String honor : honors) {            sbHonors.append(honor);            sbHonors.append(&quot;\n&quot;);        }        sbHonors.append(&quot;荣耀end----\n&quot;);        // 遍历出小组成员        StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;);        for (User user : teamMembers) {            sbMembers.append(user.toString());            sbMembers.append(&quot;\n&quot;);        }        sbMembers.append(&quot;成员end----\n&quot;);        return &quot;小组id:&quot; + id + &quot;\n&quot; + &quot;小组名字:&quot; + teamName + &quot;\n&quot; + &quot;小组所获荣誉:&quot;                    + sbHonors + &quot;\n&quot; + &quot;小组成员:&quot; + sbMembers;    }}</code></pre><p>(3)@RequestBody直接以String接收前端传过来的json数据:</p><pre><code>@RequestMapping(&quot;mytest0&quot;)public String myTestController0(@RequestBody String jsonString) {    System.out.println(jsonString);    return jsonString;}</code></pre><p>(4)@RequestBody以简单对象接收前端传过来的json数据(SpringMVC会智能的将符合要求的数据装配进该User对象中):</p><pre><code>@RequestMapping(&quot;mytest1&quot;)public String myTestController1(@RequestBody User user) {    System.out.println(user.toString());    return user.toString();}</code></pre><p>(5)以较复杂的Team对象接收前端传过来的json数据 (SpringMVC会智能的将符合要求的数据装配进该Teamr对象中):</p><pre><code>@RequestMapping(&quot;mytest2&quot;)public String myTestController2(@RequestBody Team team) {    System.out.println(team.toString());    return team.toString();}</code></pre><p>(6)@RequestBody与简单的@RequestParam()同时使用:</p><pre><code>@RequestMapping(&quot;mytest3&quot;)public String myTestController3(@RequestBody User user, @RequestParam(&quot;token&quot;) String token) {    System.out.println(user.toString());    System.out.println(token);    return token + &quot;&gt;&gt;&gt;&quot; + user.toString();}</code></pre><p>(7)@RequestBody与复杂的@RequestParam()同时使用:</p><pre><code>@RequestMapping(&quot;mytest5&quot;)public String myTestController5(@RequestBody User user, @RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays) {    System.out.println(user.toString());    StringBuffer sb = new StringBuffer();    for (String array : arrays) {        sb.append(array);        sb.append(&quot;  &quot;);        System.out.println(array);    }    return sb.toString() + user.toString();}</code></pre><p>(8)@RequestBody接收请求体中的json数据;不加注解接收URL中的数据并组装为对象:</p><pre><code>@RequestMapping(&quot;mytest4&quot;)public String myTestController4(@RequestBody User user1,  User user2) {    System.out.println(user1.toString());    System.out.println(user2.toString());    return user2.toString() + &quot;\n&quot; + user1.toString();}</code></pre><h4 id="注：该文章转载自-RequestBody的使用"><a href="#注：该文章转载自-RequestBody的使用" class="headerlink" title="注：该文章转载自@RequestBody的使用"></a>注：该文章转载自<a href="https://blog.csdn.net/justry_deng/article/details/80972817" target="_blank" rel="noopener">@RequestBody的使用</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。&lt;/p&gt;
&lt;p&gt;2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。&lt;/p&gt;
&lt;p&gt;3、在后端的
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>System进程占用80端口</title>
    <link href="http://www.echodemo.cc/2019/02/11/System%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A880%E7%AB%AF%E5%8F%A3/"/>
    <id>http://www.echodemo.cc/2019/02/11/System进程占用80端口/</id>
    <published>2019-02-11T12:38:43.000Z</published>
    <updated>2019-02-11T12:52:18.034Z</updated>
    
    <content type="html"><![CDATA[<p>80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，主要用于WWW（World Wide Web）即万维网传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入“:80”了。</p><p>8080、8001等端口其实本质上没什么区别，而且它们本身无实际意义，只是用于代理服务器端口来代理服务，如tomcat、nginx、IIS等。大部分服务提供方都默认使用8080端口用于WWW代理服务，因此经常会发现8080端口被占用的情况。但我们可以通过修改配置文件来解决端口占用问题，如改成8001等。</p><p>1、在windows的cmd窗口中输入：netstat -ano|findstr “80”。查看80端口占用对应的PID。再使用：tasklist发现是System进程占用了80端口。接下来不管是在任务管理器中找到System进程后，选中，结束进程，还是直接在窗口中输入：taskkill /pid (pid号) -f。发现都无法解决。原来System进程它是Windows页面内存管理进程，拥有0级优先权，没有它系统无法启动。 也就是说，System进程是无法关闭的，如果你强行结束system进程树会直接导致蓝屏。</p><h3 id="2、后来发现是SqlServer的Reporting-Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。"><a href="#2、后来发现是SqlServer的Reporting-Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。" class="headerlink" title="2、后来发现是SqlServer的Reporting Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。"></a>2、后来发现是SqlServer的Reporting Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，主要用于WWW（World Wide Web）即万维网传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok</title>
    <link href="http://www.echodemo.cc/2019/02/01/Lombok/"/>
    <id>http://www.echodemo.cc/2019/02/01/Lombok/</id>
    <published>2019-02-01T13:28:32.000Z</published>
    <updated>2019-02-11T13:10:43.109Z</updated>
    
    <content type="html"><![CDATA[<p>Lombok项目是一个Java库，它能够自动嵌入到你的IDE编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有val特性等。它基本上支持所有主流的 IDE 开发工具及编译构建工具。比如Eclipse、IDEA、Myeclipse等等。</p><p>在IDEA中安装该插件，首先去下载好和你的IDEA版本匹配的包，打开Settings，点击plugins，选择Install plugin from disk导入下载好的包导入即可。（在 IDEA 中安装 Lombok 插件，这样在使用 Lombok 的时候就不会编译报错。）最后要在Maven 的依赖配置中引入lombok依赖。</p><p>1、添加 @Getter 和 @Setter 注解用在 Java Bean 类上面，无需生成 get/ set 方法，会自动生成所有的 get/ set 方法及一个默认的构造方法。</p><p>2、@ToString使用在类上，默认生成所有非静态字段以下面的格式输出。</p><p>3、@NoArgsConstructor用在类上，用来生成一个默认的无参构造方法。</p><p>4、@RequiredArgsConstructor用在类上，使用类中所有带有 @NonNull 注解和 final 类型的字段生成对应的构造方法。</p><p>5、@AllArgsConstructor用在类上，生成一个所有参数的构造方法，默认不提供无参构造方法。</p><p>6、@Data用在类上，等同于下面这几个注解合集。</p><pre><code>@Getter@Setter@RequiredArgsConstructor@ToString@EqualsAndHashCode</code></pre><p>7、@Value用在类上，等同于下面这几个注解合集。</p><pre><code>@Getter@FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE)@AllArgsConstructor@ToString@EqualsAndHashCode</code></pre><p>8、@NonNull用在属性上，用于字段的非空检查，如果传入到 set 方法中的值为空，则抛出空指针异常，该注解也会生成一个默认的构造方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lombok项目是一个Java库，它能够自动嵌入到你的IDE编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有val特性等。它基本上支持所有主流的 IDE 开发工具及编译构建工具。比如Eclipse、IDEA、Myeclipse等等。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="杂说" scheme="http://www.echodemo.cc/tags/%E6%9D%82%E8%AF%B4/"/>
    
  </entry>
  
</feed>
