<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-07-27T16:17:45.709Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的线程模型</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的线程模型/</id>
    <published>2018-07-27T16:04:49.000Z</published>
    <updated>2018-07-27T16:17:45.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念了解"><a href="#1、概念了解" class="headerlink" title="1、概念了解"></a>1、概念了解</h3><p>(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。</p><p>(2)进程是运行中的程序，是动态的概念。每个进程有独立的资源空间。</p><p>(3)线程是轻量级的进程，是程序执行流的最小单位，是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。</p><p>(4)多线程是在单个程序中可以同时运行多个不同的线程执行不同的任务。一个进程可以包含一个或者多个线程。一个程序实现多个代码同时交替运行就需要产生多个线程。线程本身不拥有系统资源，与同属一个进程的其他线程共享所在进程所拥有的资源。同一进程中的多个线程之间可以并发执行。CPU会随机抽出时间，让我们的程序一会做这件事，一会做另外一件事情。多线程的目的在于，最大限度地利用CPU资源，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p><p>(5)Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。Java是纯面向对象语言，Java的线程模型也是面向对象的。</p><p>(6)创建线程的方式有两种：第一，通过继承Thread类创建线程，普通Java类如继承自Thread类，就成为一个线程类，并可通过该类的start方法来启动线程，执行线程代码。Thread子类可直接实例化，但在子类中必须覆盖run方法才能真正运行线程的代码。第二，通过实现Runnable接口创建线程，实现Runnable接口的类必须借助Thread类才能创建线程(本质上还是通过继承Thread来实现)。通过Runnable接口创建线程分为两步：创建实现Runnable接口的类的实例；创建一个Thread类对象，将第一步实例化得到的Runnable对象作为参数传入Thread类的构造方法。最后通过Thread类的start方法启动线程。</p><h3 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h3><p>(1)举例一：通过继承Thread类创建线程</p><pre><code>package com.iotek.threadtest;public class HelloThreadDemo {    public static void main(String[] args) {        HelloThread h1HelloThread = new HelloThread(&quot;A&quot;);        //h1HelloThread.setName(&quot;线程1&quot;);//自定义线程名字        h1HelloThread.start();//启动线程就会调用run方法        HelloThread h2HelloThread = new HelloThread(&quot;B&quot;);        //h1HelloThread.setName(&quot;线程2&quot;);        h2HelloThread.start();    }}class HelloThread extends Thread{    public HelloThread(String name) {        super(name);    }    @Override    public void run(){        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(2)举例二：通过实现Runnable接口创建线程</p><pre><code>package com.iotek.threadtest;public class HelloRunnableDemo {    public static void main(String[] args) {        HelloRunnable helloRunnable = new HelloRunnable();        Thread thread = new Thread(helloRunnable,&quot;A&quot;);        thread.start();        Thread thread2 = new Thread(helloRunnable,&quot;B&quot;);        thread2.start();    }}/** * Runnable接口优于Thread的地方 * 1、避免单继承的局限，一个类可以实现多个接口，但只能继承一个类。 * 2、适合资源的共享。 * @author 紫苏半夏 * */class HelloRunnable implements Runnable{    @Override    public void run() {        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(3)举例三：Runnable接口适合资源的共享</p><pre><code>package com.iotek.threadtest;public class SharedDataThreadDemo {    public static void main(String[] args) {        /*TicketThread ticketThread1 = new TicketThread(&quot;一号窗口&quot;);        ticketThread1.start();        TicketThread ticketThread2 = new TicketThread(&quot;二号窗口&quot;);        ticketThread2.start();*/        TicketRunnable ticketRunnable = new TicketRunnable();        Thread thread = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread.start();        Thread thread1 = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread1.start();    }}/*class TicketThread extends Thread{    private int ticket = 5;    public TicketThread(String name){        super(name);    }    @Override    public void run(){        while (true) {            System.out.println(this.getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}*/class TicketRunnable implements Runnable{    private int ticket = 5;    @Override    public void run(){        while (true) {            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、概念了解&quot;&gt;&lt;a href=&quot;#1、概念了解&quot; class=&quot;headerlink&quot; title=&quot;1、概念了解&quot;&gt;&lt;/a&gt;1、概念了解&lt;/h3&gt;&lt;p&gt;(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。&lt;/p&gt;
&lt;p&gt;(2)进程是运行中的程序，是动态的概
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(二)</title>
    <link href="http://www.echodemo.cc/2018/07/26/Java%E5%8F%8D%E5%B0%84API(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/07/26/Java反射API(二)/</id>
    <published>2018-07-26T09:59:35.000Z</published>
    <updated>2018-07-27T00:26:16.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student对象。通过反射复制此Student对象。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>通过反射机制来获取类的属性和方法。通过反射来生成对象，并通过反射来调用其set方法来对属性进行赋值以达到复制对象的目的。最后对复制成功的对象信息进行打印。</p><h3 id="3、方案实施"><a href="#3、方案实施" class="headerlink" title="3、方案实施"></a>3、方案实施</h3><pre><code>(1)创建Student类。(2)创建一个Student对象。(3)获取Student对象所属类型的Class对象。(4)通过调用class.newInstance方法来构建一个目标对象。(5)获取class对象中的get和set方法。(6)调用源对象的get方法获取属性值。(7)调用目标对象的set方法来设置属性值。(8)打印目标对象的数据。</code></pre><h3 id="4、案例实现"><a href="#4、案例实现" class="headerlink" title="4、案例实现"></a>4、案例实现</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import javax.activation.FileDataSource;import org.omg.CORBA.portable.ValueBase;public class ReflectionExampleDemo {    public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        Student student = new Student(1, &quot;EchoDemo&quot;, 22);        Student student2 = (Student) ObjectCopyUtil.copyObj(student);        System.out.println(&quot;复制对象成功&quot;);        System.out.println(student2.toString());    }}/** * 这是一个拷贝对象的工具类，内部提供了一个拷贝对象的方法，接收源对象。 * @author 紫苏半夏 * */class ObjectCopyUtil{    public static Object copyObj(Object obj) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        //获取student对象所对应类型的Class对象(也就是Student类所对应的对象)        Class&lt;?&gt; classType = obj.getClass();        //通过class对象的newInstance方法来构建一个目标对象        Object objCopy = classType.newInstance();        //获取Class对象的get和set方法        for(Field field : classType.getDeclaredFields()){            /*//得到属性所对应的get和set方法            String getMethodName = &quot;get&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            String setMethodName = &quot;set&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            //调用源对象的get方法获取属性值            Method getMethod = classType.getDeclaredMethod(getMethodName, new Class[]{});            Object value = getMethod.invoke(obj, new Object[]{});            //调用源对象的set方法给属性赋值            Method setMethod = classType.getDeclaredMethod(setMethodName, new Class[]{field.getType()});            setMethod.invoke(obj, new Object[]{value});*/            //直接获取源对象的值            field.setAccessible(true);            Object value = field.get(obj);            field.set(objCopy, value);        }        return objCopy;    }}//声明一个学生类class Student{    private int id;    private String name;    private int age;    public Student(){    }    public Student(int id, String name, int age) {        super();        this.id = id;        this.name = name;        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(一)</title>
    <link href="http://www.echodemo.cc/2018/07/24/Java%E5%8F%8D%E5%B0%84API(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/07/24/Java反射API(一)/</id>
    <published>2018-07-24T10:18:29.000Z</published>
    <updated>2018-07-26T10:04:53.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-lang-reflect库"><a href="#1、Java-lang-reflect库" class="headerlink" title="1、Java.lang.reflect库"></a>1、Java.lang.reflect库</h3><p>Class类和java.lang.reflect类库一起对反射的概念进行支持。在java.lang包下：Class<t>:表示一个正在运行的Java应用程序中的类和接口，是Reflection的起源。在java.lang.reflect包下：Field类：代表类的成员变量(也称之为类的属性)；Method类：代表类的方法；Constructor类：代表类的构造方法；Array类：提供动态创建数组，以及访问数组的元素的静态方法。</t></p><h3 id="2、通过反射实例化对象"><a href="#2、通过反射实例化对象" class="headerlink" title="2、通过反射实例化对象"></a>2、通过反射实例化对象</h3><p>(1)平常情况我们通过new Object来生成一个类的实例，但有时候我们没法直接new，只能通过反射动态生成。</p><p>(2)实例化无参构造函数的对象，两种方式：</p><pre><code>Class.newInstace();Class.getConstructor(new Class[]{}).newInstance(new Object[]{});</code></pre><p>(3)实例化带参构造函数的对象</p><pre><code>Class.getConstructor(Class&lt;?&gt;...parameterTypes).newInstance(Object...initargs);</code></pre><h3 id="3、通过反射获取并调用方法"><a href="#3、通过反射获取并调用方法" class="headerlink" title="3、通过反射获取并调用方法"></a>3、通过反射获取并调用方法</h3><p>(1)获得当前类以及超类的public Method</p><pre><code>Method[] arrMethods=classType.getMethods();</code></pre><p>(2)获得当前类申明的所有Method</p><pre><code>Method[] arrMethods=classTyep.getDeclaredMethods();</code></pre><p>(3)获得当前类以及超类指定的public Method</p><pre><code>Method method=classType.getMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(4)获得当前类申明的指定的Method</p><pre><code>Method method=classType.getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(5)通过反射动态运行指定Method</p><pre><code>Object  obj=method.invoke(Object obj,Object...args);</code></pre><h3 id="4、通过反射获取并调用属性"><a href="#4、通过反射获取并调用属性" class="headerlink" title="4、通过反射获取并调用属性"></a>4、通过反射获取并调用属性</h3><p>(1)获得当前类以及超类的public Field</p><pre><code>Field[] arrFields=classType.getFields();</code></pre><p>(2)获得当前类申明的所有Field</p><pre><code>Field[] arrFields=classFields=classType.getDeclaredFields();</code></pre><p>(3)获得当前类以及超类指定的public Field</p><pre><code>Field field=classType.getField(String name);</code></pre><p>(4)获得当前类申明的指定的Field</p><pre><code>Field field=classType.getDeclaredField(String name);</code></pre><p>(5)通过反射动态设定Field的值</p><pre><code>field.set(Object obj,Object value);</code></pre><p>(6)通过反射动态获取Field的值</p><pre><code>Object obj=field.get(Object obj);</code></pre><h3 id="5、举例"><a href="#5、举例" class="headerlink" title="5、举例"></a>5、举例</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionAPIDemo {    public static void main(String[] args) throws Exception{        /**         * 只要用到反射，先获得Class对象。没有方法能够获得当前类的超类的private方法和属性，         * 你必须通过getSuperclass()找到超类以后再去尝试获得。通常情况下，即使是当前类，         * private属性或者方法也是不能访问的，你需要设置压制权限setAccessible(true)来         * 取得private的访问权。但这样的话，就破坏了面向对象的规则，所以除非万不得已，尽量少用。         */        //获取Emploee这个类所关联的class对象        Class&lt;?&gt; classType=Class.forName(&quot;com.iotek.reflect.Emploee&quot;);        //通过反射机制来构造一个Emploee的实例对象(默认调用无参的构造方法)        Emploee emploee=(Emploee)classType.newInstance();        //调用指定的构造方法来实例化对象        Constructor&lt;?&gt; constructor=classType.getConstructor(new Class[]{});        Emploee emploee2=(Emploee)constructor.newInstance(new Object[]{});        System.out.println(emploee);        System.out.println(emploee2);        //调用指定的构造方法来实例化对象(调用带参数的构造方法)        Constructor&lt;?&gt; constructor1=classType.getConstructor(new Class[]{String.class,int.class});        Emploee emploee3=(Emploee)constructor1.newInstance(new Object[]{&quot;zhangsan&quot;,30});        System.out.println(emploee3);        //获取class对象指定的方法，包括私有的        Method method=classType.getDeclaredMethod(&quot;toString&quot;, new Class[]{});        System.out.println(method.getName());        //方法的调用        String desc=(String) method.invoke(emploee, new Object[]{});        System.out.println(desc);        //获取class对象指定的所有方法，包括私有的(私有的是默认不能被访问的)        Method[] methods = classType.getDeclaredMethods();        for(Method method2 : methods){            method2.setAccessible(true);//私有的可以访问了            System.out.println(method2.getName()+&quot;--&gt;&quot;+method2.getModifiers());        }        //获取Class对象所指定的属性，包括私有的(私有的默认是不能被访问的)        Field field = classType.getDeclaredField(&quot;nameString&quot;);        field.setAccessible(true);//可访问了        field.set(emploee, &quot;李四&quot;);        System.out.println(field.get(emploee));    }}class Emploee{    private String nameString;    private int age;    public Emploee(){        System.out.println(&quot;无参构造法方法&quot;);    }    public Emploee(String nameString, int age) {        super();        this.nameString = nameString;        this.age = age;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Emploee [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="6、使用反射机制来创建一维数组和二维数组"><a href="#6、使用反射机制来创建一维数组和二维数组" class="headerlink" title="6、使用反射机制来创建一维数组和二维数组"></a>6、使用反射机制来创建一维数组和二维数组</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Array;public class ReflectionArrayDemo {    public static void main(String[] args) throws ClassNotFoundException {        //创建一个一维数组(String)        Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);        Object obj = Array.newInstance(classType,5);        Array.set(obj, 3, &quot;abc&quot;);        System.out.println(Array.get(obj, 3));        //创建二维数组(3行3列)        int[] dimens={3,3};        Object obj1 = Array.newInstance(int.class, dimens);        Object obj2 = Array.get(obj1, 2);//获取第三行(它是一个一维数组)        Array.setInt(obj2, 2, 5);//给指定位置赋值        int[][] obj3 = (int[][])obj1;        System.out.println(obj3[2][2]);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Java-lang-reflect库&quot;&gt;&lt;a href=&quot;#1、Java-lang-reflect库&quot; class=&quot;headerlink&quot; title=&quot;1、Java.lang.reflect库&quot;&gt;&lt;/a&gt;1、Java.lang.reflect库&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的反射</title>
    <link href="http://www.echodemo.cc/2018/07/23/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://www.echodemo.cc/2018/07/23/Java中的反射/</id>
    <published>2018-07-23T13:22:33.000Z</published>
    <updated>2018-07-23T13:24:10.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、反射概述"><a href="#1、反射概述" class="headerlink" title="1、反射概述"></a>1、反射概述</h3><p>(1)反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>(2)JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。包括其访问修饰符、父类、实现的接口、属性和方法的所有信息，并可在运行时创建对象、修改属性(包括私有的)、调用方法(包括私有的)。</p><h3 id="2、反射机制"><a href="#2、反射机制" class="headerlink" title="2、反射机制"></a>2、反射机制</h3><p>(1)直接创建对象不就行了吗？为什么要用反射机制？这里涉及动态和静态的概念。</p><pre><code>静态编译：在编译时确定类型，绑定对象，如：Student stu=new Student(&quot;zhangsan&quot;,30);动态编译：在运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现类多态的应用，用以降低类之间的耦合性。Class.forName(&quot;com.mysql.Driver.class&quot;).newInstance();</code></pre><p>(2)优缺点</p><pre><code>优点：反射机制可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中缺点：反射机制对性能有影响，使用反射机制基本上是一种解释操作，这类操作总是慢于直接执行的相同操作。</code></pre><p>(3)功能</p><pre><code>a、在运行时判断任意一个对象所属的类。b、在运行时构造任意一个类的对象。c、在运行时判断任意一个类所具有的成员变量和方法。d、在运行时调用任意一个对象的方法。</code></pre><h3 id="3、Class对象"><a href="#3、Class对象" class="headerlink" title="3、Class对象"></a>3、Class对象</h3><p>Class对象是Reflection故事的起源。要想操纵类中的属性和方法，都必须从获取Class对象开始。</p><p>(1)类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译一个新类，就会产生与之对应的一个Class对象。</p><p>(2)Class类没有公共构造方法。Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的方法自动构造的，因此不能显示地声明一个Class对象。</p><p>(3)获取Class对象的方式</p><p><img src="/images/2018/7/5.jpg" alt="&quot;获取class对象的方式&quot;"></p><p>(4)举例</p><pre><code>package com.iotek.classtype;public class ClassDemo {    public static void main(String[] args) {        //通过对象名.getClass()        Employee employee=new Employee(&quot;zhangsan&quot;, 30);        Class&lt;?&gt; classTypeClass=employee.getClass();//问号代表可以接收任意类型的Class对象        System.out.println(classTypeClass.getName());//获取Class对象的名字        System.out.println(classTypeClass.getSuperclass().getName());//获取父类的Class对象的名字        //类名.class        Class&lt;?&gt; classTypeClass2=Employee.class;        System.out.println(classTypeClass2.getName());//获取Class对象的名字        System.out.println(classTypeClass2.getSuperclass().getName());//获取父类的Class对象的名字        //使用Class.forName()        try {            Class&lt;?&gt; classTypeClass3=Class.forName(&quot;com.iotek.classtype.Employee&quot;);            System.out.println(classTypeClass3.getName());//获取Class对象的名字            System.out.println(classTypeClass3.getSuperclass().getName());//获取父类的Class对象的名字        } catch (Exception e) {            e.printStackTrace();        }        //获取基本数据类型的Class对象(基本数据类型没有父类)        Class&lt;?&gt; classTypeClass4=int.class;        System.out.println(classTypeClass4.getName());//获取Class对象的名字        //通过基本数据类型的包装类来获取对应的基本数据类型所对应的Class对象        Class&lt;?&gt; classTypeClass5=Double.TYPE;        System.out.println(classTypeClass5.getName());//获取Class对象的名字        //获取基本数据类型的包装类的Class对象        Class&lt;?&gt; classTypeClass6=Double.class;        System.out.println(classTypeClass6.getName());//获取Class对象的名字        System.out.println(classTypeClass6.getSuperclass().getName());//获取父类的Class对象的名字    }}class Employee{    private String nameString;    private int age;    public Employee(String nameString, int age) {        super();        this.nameString = nameString;        this.age = age;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、反射概述&quot;&gt;&lt;a href=&quot;#1、反射概述&quot; class=&quot;headerlink&quot; title=&quot;1、反射概述&quot;&gt;&lt;/a&gt;1、反射概述&lt;/h3&gt;&lt;p&gt;(1)反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的观察者模式和Swing</title>
    <link href="http://www.echodemo.cc/2018/07/23/Java%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8CSwing/"/>
    <id>http://www.echodemo.cc/2018/07/23/Java中的观察者模式和Swing/</id>
    <published>2018-07-23T11:20:45.000Z</published>
    <updated>2018-07-23T12:17:24.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、观察者模式定义"><a href="#1、观察者模式定义" class="headerlink" title="1、观察者模式定义"></a>1、观察者模式定义</h3><p>对象间的一种一对多的依赖关系。当一方的对象改变状态时，所有的依赖者都会得到通知并被自动更新。也称之为依赖(Dependents)、发布-订阅(Publish-Subscribe)模式。</p><h3 id="2、观察者模式意图"><a href="#2、观察者模式意图" class="headerlink" title="2、观察者模式意图"></a>2、观察者模式意图</h3><p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使得各个类紧密耦合，导致可重用性的降低。观察者模式是使得任意数目的观察者不必知道彼此的存在，且主题发生变化时都可以得到主题的通知，而同步改变状态。是一种松散耦合，具有更好的可重用性。</p><h3 id="3、观察者模式组成"><a href="#3、观察者模式组成" class="headerlink" title="3、观察者模式组成"></a>3、观察者模式组成</h3><p><img src="/images/2018/7/3.jpg" alt="&quot;观察者模式&quot;"></p><pre><code>a、主题(Subject)：知道它的观察者(观察者必须实现特定接口)，可以有任意多观察者。提供注册和注销观察者的接口。b、观察者(Observer)：为那些在主题发生变化时需要获得通知的对象定义一个更新(update)接口。c、ConcreteSubject(具体主题)：保持实际状态数据，当状态发生变化时通知各观察者。d、ConcreteObserver(具体观察者)：维持一个指向具体主题对象的引用。</code></pre><h3 id="4、观察者模式示例"><a href="#4、观察者模式示例" class="headerlink" title="4、观察者模式示例"></a>4、观察者模式示例</h3><p>(1)男朋友接口</p><pre><code>package com.iotek.observer;public interface IBoyFriend {    void update(String msg);//更新信息}</code></pre><p>(2)女生接口</p><pre><code>package com.iotek.observer;public interface IGirl {    void attachBoyFriend(IBoyFriend boyFriend);//注册一个男朋友    void deleteBoyFriend(IBoyFriend boyFriend);//删除一个男朋友    void notifyBoyFriend();//通知所有男朋友}</code></pre><p>(3)女生实现类</p><pre><code>package com.iotek.observer;import java.util.ArrayList;import java.util.List;public class PrettyGirl implements IGirl {    private List&lt;IBoyFriend&gt; boyList=new ArrayList&lt;IBoyFriend&gt;();    private String msg=&quot;我生病了&quot;;    @Override    public void attachBoyFriend(IBoyFriend boyFriend) {        boyList.add(boyFriend);    }    @Override    public void deleteBoyFriend(IBoyFriend boyFriend) {        if(boyList.size()&gt;0){            boyList.remove(boyFriend);        }    }    @Override    public void notifyBoyFriend() {        for(int i=0;i&lt;boyList.size();i++){            IBoyFriend boyFriend=boyList.get(i);            boyFriend.update(msg);        }    }}</code></pre><p>(4)三个男朋友实现类</p><pre><code>package com.iotek.observer;public class LiBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;我现在没空&quot;);        }    }}package com.iotek.observer;public class WangBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;和我无关，我不认识你！&quot;);        }    }}package com.iotek.observer;public class ZhangBoyFriend implements IBoyFriend {    @Override    public void update(String msg) {        if(msg.equals(&quot;我生病了&quot;)){            System.out.println(&quot;我马上过来&quot;);        }    }}</code></pre><p>(5)测试类</p><pre><code>package com.iotek.observer;public class Test {    public static void main(String[] args) {        //实例化三个男朋友        ZhangBoyFriend zhnagBoyFriend=new ZhangBoyFriend();        LiBoyFriend liBoyFriend=new LiBoyFriend();        WangBoyFriend wangBoyFriend=new WangBoyFriend();        //实例化女生类，并且添加三个男朋友，删除一个男朋友        PrettyGirl girl=new PrettyGirl();        girl.attachBoyFriend(wangBoyFriend);        girl.attachBoyFriend(zhnagBoyFriend);        girl.attachBoyFriend(liBoyFriend);        girl.deleteBoyFriend(wangBoyFriend);        //女生发出信息        girl.notifyBoyFriend();    }}</code></pre><h3 id="5、Swing介绍"><a href="#5、Swing介绍" class="headerlink" title="5、Swing介绍"></a>5、Swing介绍</h3><p>(1)Java1.2引入称为Swing的新的GUI组件库。它是一个用于开发Java应用程序用户界面的开发工具包。</p><p>(2)Swing控件是用纯Java语言编写而成的，不依赖于本地操作系统的GUI，Swing控件可以跨平台运行。独立于本地平台的Swing控件被称为轻量级控件，而依赖于本地的AWT控件被称为重量级控件。</p><p>(3)它以抽象窗口工具包(AWT)为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。</p><p>(4)工具包中所有的包都是以Swing作为名称，例如：javax.swing，javax.swing.event。</p><h3 id="6、Swing框架"><a href="#6、Swing框架" class="headerlink" title="6、Swing框架"></a>6、Swing框架</h3><p><img src="/images/2018/7/4.jpg" alt="&quot;观察者模式&quot;"></p><h3 id="7、开发Swing图形界面主要步骤"><a href="#7、开发Swing图形界面主要步骤" class="headerlink" title="7、开发Swing图形界面主要步骤"></a>7、开发Swing图形界面主要步骤</h3><pre><code>导入Swing包--&gt;设置顶层容器--&gt;设置按钮和标签等Swing组件--&gt;将组件添加至容器中--&gt;处理事件。</code></pre><h3 id="8、简单示例"><a href="#8、简单示例" class="headerlink" title="8、简单示例"></a>8、简单示例</h3><pre><code>package com.iotek.observer;import javax.swing.JFrame;import javax.swing.JLabel;public class SwingTest {    public static void main(String[] args) {        JFrame frame=new JFrame(&quot;Hello Swing&quot;);//设置一个顶级容器        JLabel label=new JLabel(&quot;你好，Swing&quot;);//创建一个Swing组件        frame.getContentPane().add(label);//将组件添加到容器内容窗格        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//单击关闭按钮时可以关闭窗口        frame.setSize(300,200);        frame.setVisible(true);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、观察者模式定义&quot;&gt;&lt;a href=&quot;#1、观察者模式定义&quot; class=&quot;headerlink&quot; title=&quot;1、观察者模式定义&quot;&gt;&lt;/a&gt;1、观察者模式定义&lt;/h3&gt;&lt;p&gt;对象间的一种一对多的依赖关系。当一方的对象改变状态时，所有的依赖者都会得到通知并被自
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的AWT事件处理</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT事件处理/</id>
    <published>2018-07-22T14:57:37.000Z</published>
    <updated>2018-07-22T15:05:46.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、AWT事件处理基本概念"><a href="#1、AWT事件处理基本概念" class="headerlink" title="1、AWT事件处理基本概念"></a>1、AWT事件处理基本概念</h3><p>AWT事件的处理过程中，主要涉及三类对象。</p><p>(1)Event(事件)：用户对组件的一个操作，称之为一个事件，以类的形式出现，例如，键盘操作对应的事件类是KeyEvent。其实例在该事件发生时由系统自动产生。每一种事件都对应专门的监听者。</p><p>(2)Event Source(事件源)：事件发生的场所，通常就是各个组件，例如按钮Button。事件源自己不处理事件，而是把在其自身所有可能发生的事件委托给事件监听器来处理。</p><p>(3)Event Monitor(事件监听器)：接收事件对象并对其进行处理的类的对象，通常其中某个成员方法对事件进行相应的处理。</p><h3 id="2、事件"><a href="#2、事件" class="headerlink" title="2、事件"></a>2、事件</h3><p>AWT的相关事件继承于java.awt.AWTEvent类，这些事件分为两大类：低级事件和高级事件。</p><p>(1)低级事件是指基于<strong>组件和容器</strong>的事件，当一个组件发生事件，如鼠标进入、点击、拖放或组件的窗口开关等时，触发了组件事件。如：组件事件、容器事件、窗口事件、焦点事件、键盘事件、鼠标事件。</p><p>(2)高级事件是基于<strong>语义</strong>的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类。比如，按下按钮和在TextField中按Enter键会触发ActionEvent事件，滑动滚动条会触发AdjustmentEvent事件，选中项目列表的某一条会触发ItemEvent事件。</p><h3 id="3、事件监听器"><a href="#3、事件监听器" class="headerlink" title="3、事件监听器"></a>3、事件监听器</h3><p>事件监听器通常是一个类，该类必须实现与该事件类型相对应的接口。对应的接口被称之为事件监听器接口。事件监听器接口类的名称与事件类的名称相对应，例如：MouseEvent事件类的监听器接口名为MouseListener。</p><h3 id="4、事件适配器类"><a href="#4、事件适配器类" class="headerlink" title="4、事件适配器类"></a>4、事件适配器类</h3><p>Java语言为一些事件监听提供了适配器(Adapter)。我们可以通过继承事件对应的Adapter类，重写所需要的方法，无关的方法则不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序代码。java.awt.event包中定义的事件适配器类包括以下7个：MouseAdapter(鼠标适配器)、MouseMotionAdapter(鼠标运动适配器)、KeyAdapter(键盘适配器)、WindowAdapter(窗口适配器)、ComponentAdapter(组件适配器)、ComtainerAdapter(容器适配器)、FocusAdapter(焦点适配器)。</p><h3 id="5、示例"><a href="#5、示例" class="headerlink" title="5、示例"></a>5、示例</h3><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class ListenerDemo {    public static void main(String[] args) {        MyFrame7 frame7=new MyFrame7(&quot;Listener&quot;);    }}class MyFrame7 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame7(String title){        super(title);        init();        registerListener();    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }    private void registerListener(){        /*         * 产生一个事件监听器对象，给四个按钮注册同一个事件监听器。         */        BtnListener btnListener=new BtnListener();        btn_1.addActionListener(btnListener);        btn_2.addActionListener(btnListener);        btn_3.addActionListener(btnListener);        btn_4.addActionListener(btnListener);        lb_1.addMouseMotionListener(new MouseMotionAdapter() {            @Override            public void mouseMoved(MouseEvent e) {                lb_1.setText(e.getX()+&quot;:&quot;+e.getY());            }        });        lb_2.addMouseListener(new MouseAdapter() {            @Override            public void mouseExited(MouseEvent e) {                System.out.println(&quot;鼠标移出&quot;);            }            @Override            public void mouseEntered(MouseEvent e) {                System.out.println(&quot;鼠标移入&quot;);            }        });        tf_contentField.addKeyListener(new KeyAdapter() {            @Override            public void keyPressed(KeyEvent e) {                System.out.println(e.getKeyChar());            }        });        this.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });    }    class BtnListener implements ActionListener{        @Override        public void actionPerformed(ActionEvent e) {            /*System.out.println(e.getActionCommand());            System.out.println(e.getSource());*/            Object object=e.getSource();//获得当前点击的事件源            if(object==btn_1){                cardLayout.first(card_panel);//获得第一张            }else if(object==btn_2){                cardLayout.previous(card_panel);//获得前一张            }else if(object==btn_3){                cardLayout.next(card_panel);//获得下一张            }else{                cardLayout.last(card_panel);//获得最后一张            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;a href=&quot;#1、AWT事件处理基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;/a&gt;1、AWT事件处理基本概念&lt;/h3&gt;&lt;p&gt;AWT事件的处理过程中，主要涉及三类对象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的布局管理器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的布局管理器/</id>
    <published>2018-07-22T05:30:27.000Z</published>
    <updated>2018-07-22T06:26:27.868Z</updated>
    
    <content type="html"><![CDATA[<p>1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、<br>GridBagLayout网格包布局管理器。</p><p>2、容器中组件的布局通常由布局管理器控制。每个Container(比如一个Panel或一个Frame)都有一个与它相关的缺省布局管理器，Panel容器默认是FlowLayout，Frame容器默认是BorderLayout，我们可以通过调用setLayout()来改变布局管理器。</p><p>3、我们可以通过设置空布局管理器，来控制组件的大小和位置。可以调用setLayout(null)。在设置空布局管理器之后，必须对所有的组件调用setLocation()，setSize()或者setBounds()，将它们定位在容器中。</p><p>4、FlowLayout布局管理器：流程布局通常用于布置面板中的按钮。 它可以水平排列按钮，直到不再有按钮在同一行上。 线对齐由align属性确定。 可能的值是：LEFT、RIGHT、CENTER、LEADING、TRAILING。</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class FlowLayoutDemo {    public static void main(String[] args) {        MyFrame3 frame3=new MyFrame3(&quot;FlowLayout&quot;);        frame3.init();    }}class MyFrame3 extends Frame{    public MyFrame3(String title){        super(title);    }    public void init(){        //FlowLayout layout=new FlowLayout();//构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。         //FlowLayout layout=new FlowLayout(FlowLayout.LEFT);//构造一个新的 FlowLayout左对齐和默认的5单位水平和垂直间隙。         FlowLayout layout=new FlowLayout(FlowLayout.RIGHT,50,50);//构造一个新的 FlowLayout右对齐和默认的5单位水平和垂直间隙均为50。         this.setLayout(layout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));//添加按钮        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.add(new Button(&quot;btn8&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>5、BorderLayout布局管理器：边界布局设置了一个容器，安排和调整其组件，以适应五个区域：北，南，东，西和中心。 每个区域可以含有不超过一个部件，并且通过相应的常数确定： NORTH ， SOUTH ， EAST ， WEST和CENTER 。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class BorderLayoutDemo {    public static void main(String[] args) {        MyFrame4 frame4=new MyFrame4(&quot;BorderLayout&quot;);        frame4.init();    }}class MyFrame4 extends Frame{    public MyFrame4(String title){        super(title);    }    public void init(){        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;),BorderLayout.EAST);//添加按钮在东边        this.add(new Button(&quot;btn2&quot;),BorderLayout.WEST);        this.add(new Button(&quot;btn3&quot;),BorderLayout.NORTH);        this.add(new Button(&quot;btn4&quot;),BorderLayout.SOUTH);        this.add(new Button(&quot;btn5&quot;),BorderLayout.CENTER);        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>6、GridLayout布局管理器：它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。当行数和列数都被设置为非零值时，无论是通过构造函数还是setRows和setColumns方法，都会忽略指定的列数。而是从指定的行数和布局中的组件总数确定列的数量。因此，例如，如果已经指定了三行和两列，并且将九个组件添加到布局，则它们将显示为三列三列。仅当行数设置为零时，才指定列数影响布局。 </p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.GridLayout;public class GridLayoutDemo {    public static void main(String[] args) {        MyFrame5 frame5=new MyFrame5(&quot;GridLayout&quot;);        frame5.init();    }}class MyFrame5 extends Frame{    public MyFrame5(String title){        super(title);    }    public void init(){        //GridLayout gridLayout=new GridLayout();//在单个行中创建一个每个组件的默认值为一列的网格布局。         //GridLayout gridLayout=new GridLayout(3,2);//创建具有指定行数和列数的网格布局。        GridLayout gridLayout=new GridLayout(3,2,10,10);//创建具有指定行数和列数的网格布局，且指定水平和垂直间隔。        this.setLayout(gridLayout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>7、 CardLayout布局管理器：它将容器中的每个组件视为一张卡。 一次只能看到一张卡片，容器就是一堆卡片。添加到CardLayout对象的第一个组件是首次显示容器时的可见组件。卡片的顺序由容器自己的组件对象的内部顺序决定。CardLayout定义了一组允许应用程序顺序翻转这些卡片或显示指定卡片的方法。 addLayoutComponent(java.awt.Component, java.lang.Object)方法可用于将字符串标识符与给定卡相关联，以便快速随机访问。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;public class CardLayoutDemo {    public static void main(String[] args) {        MyFrame6 frame6=new MyFrame6(&quot;CardLayout&quot;);        frame6.init();    }}class MyFrame6 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame6(String title){        super(title);    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、&lt;br&gt;G
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的AWT框架和容器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT框架和容器/</id>
    <published>2018-07-22T03:47:02.000Z</published>
    <updated>2018-07-23T00:27:14.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、GUI概述"><a href="#1、GUI概述" class="headerlink" title="1、GUI概述"></a>1、GUI概述</h3><p>(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通过GUI能方便友好地进行交互。在Java语言中，JFC(Java Foundation Classed)是开发GUI的API集，它主要包括以下几个部分：</p><pre><code>a、AWT(抽象窗口工具包)：Java开发用户界面最初的工具包，是建立JFC的主要基础。b、Swing组件：建立在AWT之上，新的，功能更强大的图形组件包。c、JAVA2D：实现高质量的二维图形。......</code></pre><h3 id="2、AWT框架"><a href="#2、AWT框架" class="headerlink" title="2、AWT框架"></a>2、AWT框架</h3><p>(1)在java.awt包中包含了一个完整的类集以支持GUI程序的设计。awt所提供的控件一般称之为重量级控件，因为awt主要依靠本地方法(操作系统所提供的图形库)来实现其功能，基于此Java为了实现一次编译到处运行的概念，awt就不得不通过牺牲功能来实现(取各个操作系统的交集)。其中的类及相互关系可以用下图来描述。</p><p><img src="/images/2018/7/2.jpg" alt="&quot;类的相互关系&quot;"></p><p>(2)Component类是最核心的类，它是构成Java图形用户界面的基础，大部分组件都是有该类派生出来的。Component类主要由基本组件和容器(Container)组件组成。容器组件组要分为Window容器和Panel容器。</p><p>(3)Frame容器</p><p>a、Window是能独立存在的容器，它有一个子类Frame，它是一个带有标题和缩放角的窗口。</p><p>b、Frame有一个构造方法Frame(String title)。</p><p>c、你可以通过add()方法，在Frame容器中加入其它的组件。</p><p>d、Frame容器有默认的布局管理器。</p><p>e、Frame被创建后，是不可见的。</p><p>f、示例</p><pre><code>package com.iotek.awt;import java.awt.Color;import java.awt.Frame;public class FrameDemo1 {    public static void main(String[] args) {        MyFrame1 myFrame1=new MyFrame1(&quot;标题&quot;);        myFrame1.init();    }}class MyFrame1 extends Frame{    public MyFrame1(String title){        super(title);    }    public void init(){        //this.setSize(300,300);//设置窗体的宽和高        this.setBounds(100, 100, 300, 300);//移动并调整此组件的大小。         this.setBackground(Color.GREEN);//给窗体设置背景颜色        this.setVisible(true);//设置窗体可见    }}</code></pre><p>(4)Panel容器</p><p>a、Panel只能存在于其它的容器(Window或者其子类)中才能显示出来。</p><p>b、通过Panel的默认构造方法Panel()可以创建一个Panel。</p><p>c、示例</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.Panel;public class FrameDemo2 {    public static void main(String[] args) {        MyFrame2 myFrame2=new MyFrame2(&quot;我的窗体&quot;);        myFrame2.init();    }}class MyFrame2 extends Frame{    public MyFrame2(String title){        super(title);    }    public void init(){        this.setSize(300, 300);        this.setBackground(Color.GREEN);        this.setLayout(null);//去掉窗体的默认布局管理器        Panel panel=new Panel();        panel.setLayout(null);//去掉panel容器的默认布局管理器        panel.setBackground(Color.blue);        panel.setBounds(0, 0, 200, 200);//移动并调整此组件的大小。         Button btn1=new Button(&quot;clickMe&quot;);        btn1.setBounds(0, 0, 100, 100);        btn1.setBackground(Color.red);        panel.add(btn1);//添加按钮到面板中        this.add(panel);//把panel加到窗体中        this.setVisible(true);//让窗体显示    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、GUI概述&quot;&gt;&lt;a href=&quot;#1、GUI概述&quot; class=&quot;headerlink&quot; title=&quot;1、GUI概述&quot;&gt;&lt;/a&gt;1、GUI概述&lt;/h3&gt;&lt;p&gt;(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>雨中漫步</title>
    <link href="http://www.echodemo.cc/2018/07/22/%E9%9B%A8%E4%B8%AD%E6%BC%AB%E6%AD%A5/"/>
    <id>http://www.echodemo.cc/2018/07/22/雨中漫步/</id>
    <published>2018-07-22T01:42:05.000Z</published>
    <updated>2018-07-24T10:51:59.826Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下着小雨的清晨，去楼下吃一碗汤粉，和着鲜红的辣酱，调至自己喜欢的口味，把汤都喝完。在幽深的小巷子里面一个人缓慢地走着，两旁是高大的法国梧桐。想起当年的蒋中正因为宋美龄的一句话，便在六朝古都的金陵广种法国梧桐。或许这是政治手段的表现手法，亦或许这只是传言、是虚假的。但此刻的我宁愿相信他对她的渴慕是真实的，是带着恋人之间的浪漫的。树叶上汇聚的雨点滴落在伞上，发出清脆的轻响，日光暗淡幽然，小巷仍然向前延伸。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下着小雨的清晨，去楼下吃一碗汤粉，和着鲜红的辣酱，调至自己喜欢的口味，把汤都喝完。在幽深的小巷子里面一个人缓慢地走着，两旁是高大的法国梧桐。想起当年的蒋中正因为宋美龄的一句话，便在六朝古都的
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Collections</title>
    <link href="http://www.echodemo.cc/2018/07/21/Java%E4%B8%AD%E7%9A%84Collections/"/>
    <id>http://www.echodemo.cc/2018/07/21/Java中的Collections/</id>
    <published>2018-07-21T11:33:19.000Z</published>
    <updated>2018-07-21T11:34:33.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Collections类及常用API"><a href="#1、Collections类及常用API" class="headerlink" title="1、Collections类及常用API"></a>1、Collections类及常用API</h3><p>(1)Collections类集工具类，定义了若干用于类集和映射(Map)的算法，这些算法被定义为静态方法。</p><p>(2)常用方法：public static void sort(List<t> list);public static int binarySearch(List<t> list,T key);public static void reverse(List&lt;?&gt; list);public static void shuffle(List&lt;?&gt; list);public static vodi swap(List&lt;?&gt; list,int i,int j);public static <t> void fill(List&lt;? super T&gt; list,T obj);</t></t></t></p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CollectionsDemo1 {    public static void main(String[] args) {        List&lt;String&gt; nList=new ArrayList&lt;String&gt;();        nList.add(&quot;chenhao&quot;);        nList.add(&quot;zhangsan&quot;);        nList.add(&quot;lisi&quot;);        nList.add(&quot;wangwu&quot;);        nList.add(&quot;rose&quot;);        nList.add(&quot;mary&quot;);        System.out.println(&quot;操作前&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;交换顺序后&quot;);        Collections.swap(nList, 1, 2);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;自然排序后&quot;);        Collections.sort(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;打乱顺序后&quot;);        Collections.shuffle(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;填充后&quot;);        Collections.fill(nList, &quot;chenhao&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }    }}</code></pre><h3 id="2、对ArrayList容器中的内容进行排序"><a href="#2、对ArrayList容器中的内容进行排序" class="headerlink" title="2、对ArrayList容器中的内容进行排序"></a>2、对ArrayList容器中的内容进行排序</h3><p>(1)案例介绍</p><p>ArrayList中存储了多个person对象，(此对象包含，名字，年龄，ID)要求按年龄从小到大排序，年龄相等的话再按名字的大小来排序输出。</p><p>(2)案例设计</p><p>使用ArrayList来存储Person对象，使用Collections类所提供的静态sort方法来按要求对ArrayList进行排序，最终输出排好序的结果信息。(这里需要重写Comparator方法。)</p><p>(3)代码实现</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class CollectionsDemo2 {    public static void main(String[] args) {        ArrayList&lt;Person&gt; nList=new ArrayList&lt;Person&gt;();        nList.add(new Person(&quot;zhangsan&quot;, 17, 0));        nList.add(new Person(&quot;lisi&quot;, 18, 1));        nList.add(new Person(&quot;xiaohong&quot;, 19, 2));        nList.add(new Person(&quot;chenhao&quot;, 20, 3));        nList.add(new Person(&quot;mary&quot;, 17, 4));        Collections.sort(nList,new Comparator&lt;Person&gt;(){//匿名内部类            @Override            public int compare(Person o1, Person o2) {                int x=o1.getAge()-o2.getAge();                if(x&gt;0) return 1;                else if(x&lt;0) return -1;                else{                    return o1.getNameString().compareTo(o2.getNameString());                }            }        });        for(Person person:nList){            System.out.println(person.toString());        }    }}class Person{     private String nameString;     private int age;     private int id;    public Person(String nameString, int age, int id) {        super();        this.nameString = nameString;        this.age = age;        this.id = id;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    @Override    public String toString() {        return &quot;Person [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &quot;]&quot;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Collections类及常用API&quot;&gt;&lt;a href=&quot;#1、Collections类及常用API&quot; class=&quot;headerlink&quot; title=&quot;1、Collections类及常用API&quot;&gt;&lt;/a&gt;1、Collections类及常用API&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Set</title>
    <link href="http://www.echodemo.cc/2018/07/20/Java%E4%B8%AD%E7%9A%84Set/"/>
    <id>http://www.echodemo.cc/2018/07/20/Java中的Set/</id>
    <published>2018-07-20T15:50:08.000Z</published>
    <updated>2018-07-20T15:51:07.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Set容器的特点"><a href="#1、Set容器的特点" class="headerlink" title="1、Set容器的特点"></a>1、Set容器的特点</h3><p>Set容器是一个不包含重复元素的Collection，并且最多包含一个null元素，它和List容器相反，Set容器不能保证其元素的顺序。最常用的两个Set接口的实现类是HashSet和TreeSet。</p><h3 id="2、HashSet及常用API"><a href="#2、HashSet及常用API" class="headerlink" title="2、HashSet及常用API"></a>2、HashSet及常用API</h3><p>(1)HashSet扩展AbstractSet并实现Set接口，HashSet使用散列表(又称之为哈希表)进行存储。<strong>(HashSet底层实际上维护了一个HashMap，只是我们操作的是HashMap的key，而HashMap底层维护了哈希表)</strong></p><p>(2)构造方法：HashSet();HashSet(Collection c);HashSet(int capacity);HashSet(int capacity,float fillRatio)。</p><p>(3)HashSet没有定义任何超过它的父类和接口提供的其他方法，散列集合没有确保其元素的顺序，因为散列处理通常不参与排序。</p><p>(4)举例</p><pre><code>package com.iotech.set;import java.util.HashSet;public class HashSetDemo1 {    public static void main(String[] args) {        /*HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;();        hashSet.add(&quot;zhangsan&quot;);        hashSet.add(&quot;lisi&quot;);        hashSet.add(&quot;jay&quot;);        hashSet.add(&quot;jack&quot;);        System.out.println(hashSet.add(&quot;jay&quot;));        System.out.println(hashSet);*/        HashSet&lt;Student&gt; hashSet=new HashSet&lt;Student&gt;();         System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.add(new Student(&quot;李四&quot;, 30)));        System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.size());    }}class Student{    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="3、TreeSet及常用API"><a href="#3、TreeSet及常用API" class="headerlink" title="3、TreeSet及常用API"></a>3、TreeSet及常用API</h3><p>(1)TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储，访问和检索很快。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择。<strong>(事实上，TreeSet的底层就是TreeMap实现的，只是我们操作的是TreeMap的Key)</strong></p><p>(2)构造方法：TreeSet();TreeSet(Collection c);TreeSet(Comparator comp);TreeSet(SortedSet ss)。</p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.Iterator;import java.util.TreeSet;public class TreeSetDemo1 {    public static void main(String[] args) {        TreeSet&lt;Person&gt; treeSet=new TreeSet&lt;Person&gt;();        treeSet.add(new Person(&quot;chenhao&quot;, 30));        treeSet.add(new Person(&quot;lisi&quot;, 20));        treeSet.add(new Person(&quot;wangwu&quot;, 10));        treeSet.add(new Person(&quot;rose&quot;, 40));        Iterator&lt;Person&gt; iterator=treeSet.iterator();        while(iterator.hasNext()){            Person person=iterator.next();            System.out.println(person.getName()+&quot;--&gt;&quot;+person.getAge());        }    }}class Person implements Comparable&lt;Person&gt;{    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int compareTo(Person o) {        int x=this.age-o.age;        if(x&gt;0) return 1;        else if(x&lt;0) return -1;        return 0;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Set容器的特点&quot;&gt;&lt;a href=&quot;#1、Set容器的特点&quot; class=&quot;headerlink&quot; title=&quot;1、Set容器的特点&quot;&gt;&lt;/a&gt;1、Set容器的特点&lt;/h3&gt;&lt;p&gt;Set容器是一个不包含重复元素的Collection，并且最多包含一个nul
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Map</title>
    <link href="http://www.echodemo.cc/2018/07/20/Java%E4%B8%AD%E7%9A%84Map/"/>
    <id>http://www.echodemo.cc/2018/07/20/Java中的Map/</id>
    <published>2018-07-20T13:17:34.000Z</published>
    <updated>2018-07-23T02:22:49.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Map接口详解"><a href="#1、Map接口详解" class="headerlink" title="1、Map接口详解"></a>1、Map接口详解</h3><p>(1)映射(map)是一个存储键/值对的对象。给定一个键，可以查询到它的值，键和值都是对象。</p><p>(2)键必须是唯一的，值可以重复。</p><p>(3)有些映射可以接收null键和null值，而有的不能。</p><p>(4)Map接口定义的方法：int size();boolean isEmpty();boolean containsKey(Object key);boolean containsValue(Object value);V get(Object key);V put(K key,V value);V remove(Object key);Collection<v> values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();返回包含的映射关系的Set视图，Map接口定义的entrySet()方法返回包含映射项Entry的集合(Set)，集合中元素是Map.Entry类型。</v></p><p>(5)Map.Entry接口代表映射项(键-值对)类型，是Map的嵌套类型(是Map的内部类)。</p><p>(6)Map.Entry接口定义的方法：K getKey();V getValue();V setValue(V value)。</p><h3 id="2、HashMap及常用API"><a href="#2、HashMap及常用API" class="headerlink" title="2、HashMap及常用API"></a>2、HashMap及常用API</h3><p>(1)HashMap类是基于哈希表的map接口的实现，并允许使用null键和null值。</p><p>(2)构造方法：HashMap();HashMap(Map m);HashMap(int capacity);HashMap(int capacity,float fillRatio)。</p><p>(3)HashMap实现并扩展AbstractMap，本身并没有增加任何新的方法。</p><p>(4)散列映射不保证它的元素的顺序，元素加入散列映射的顺序并不一定是它们被迭代读出的顺序。</p><p>(5)HashMap常用方法举例</p><pre><code>package com.iotech.map;import java.util.Collection;import java.util.HashMap;import java.util.Map.Entry;import java.util.Set;public class HashMapDemo1 {    public static void main(String[] args) {        //HashMap&lt;String,String&gt; hashmap=new HashMap&lt;String, String&gt;();//构造一个空的 HashMap ，默认初始容量（16）和默认负载系数（0.75）。         HashMap&lt;String,String&gt; hashmap=new HashMap&lt;String, String&gt;(1);//构造一个空的 HashMap具有指定的初始容量和默认负载因子（0.75）。         hashmap.put(&quot;jay&quot;, &quot;张三&quot;);        hashmap.put(&quot;jay&quot;, &quot;李四&quot;);        hashmap.put(&quot;rose&quot;, &quot;玫瑰&quot;);        hashmap.put(&quot;Mary&quot;, &quot;小红&quot;);        System.out.println(hashmap);        //获取map中的所有键        /*Set&lt;String&gt; keysSet=hashmap.keySet();         for(String name:keysSet){            System.out.println(name);        }*/        //获取map中的所有值        Collection&lt;String&gt; values=hashmap.values();        for(String value:values){            System.out.println(value);        }        //得到key的同时得到key所对应的值        Set&lt;String&gt; keysSet=hashmap.keySet();         for(String name:keysSet){            System.out.println(name+&quot;--&gt;&quot;+hashmap.get(name));        }        System.out.println(hashmap.size());        System.out.println(hashmap.isEmpty());        //当我们调用put(key,value)方法的时候，首先会把key和value封装到Entry这个静态内部类对象中。        //把Entry对象再添加到数组中，所以我们想获取map中的所有键值对，我们只要获取数组中的所有Entry对象，        //接下来调用Entry对象中的getkey()和getvalue()方法就能获取键值对。        Set&lt;Entry&lt;String,String&gt;&gt; entrySet=hashmap.entrySet();        for(Entry&lt;String, String&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }        /*         * hashmap调用默认构造方法会产生一个底层长度为16的Entry数组          * int hash=hash(key.hashCode());         * 首先调用key的hashCode方法来得到一个整数(哈希码)，把哈希码作为参数传到hash函数中来进行运算(散列运算)         * 得到一个整型(散列值)。hashCode()方法能够提高哈希表的性能。         * int i=indexFor(hash,table.length);         * 把散列值和数组的长度来进行运算，最终得到entry对象存放到数组的位置(下标)。         *          * hashmap内部的结构是一个数组链表结构。因为不同的key有可能算出来是相同的散列值，根据散列值计算出存放数组         * 的下标会冲突。         */    }}</code></pre><h3 id="3、哈希码的产生和使用"><a href="#3、哈希码的产生和使用" class="headerlink" title="3、哈希码的产生和使用"></a>3、哈希码的产生和使用</h3><p>(1)hashCode的常规协定：在Java应用程序执行期间，在对同一对象多次调用hashCode方法时，必须一致地返回相同的整数，前提是将对象进行equals比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p><p>(2)如果根据equals(Object)方法，两个对象是相等的那么这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。(这里的equals方法是指Object类中没有被子类重写过的equals方法)。</p><p>(3)如果根据equals(java.lang.Object)方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p><p>(4)举例</p><pre><code>package com.iotech.map;import java.util.HashMap;import java.util.Map;public class HashCodeDemo2 {    public static void main(String[] args) {        Map&lt;Student, String&gt; map=new HashMap&lt;Student, String&gt;();        map.put(new Student(&quot;jay&quot;, 20), &quot;张三&quot;);        map.put(new Student(&quot;lisi&quot;, 30), &quot;李四&quot;);        map.put(new Student(&quot;rose&quot;, 20), &quot;玫瑰&quot;);        map.put(new Student(&quot;lisi&quot;, 30), &quot;陈豪&quot;);        /*要满足student键值相等，首先需要hashCode相等，另外还需要key的equals方法相等。所以需要重写        hashCode()和equals()方法。*/        System.out.println(map);        System.out.println(map.size());    }}class Student{    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="4、TreeMap及常用API"><a href="#4、TreeMap及常用API" class="headerlink" title="4、TreeMap及常用API"></a>4、TreeMap及常用API</h3><p>(1)TreeMap类通过使用红黑树实现Map接口。</p><p>(2)TreeMap提供按排序顺序存储键/值对的有效手段，同时允许快速检索。</p><p>(3)TreeMap不像散列映射，树映射保证它的元素按关键字升序排序。</p><p>(4)TreeMap的构造方法：TreeMap();TreeMap(Comparator comp);TreeMap(Map m);TreeMap(SortedMap sm)。</p><p>(5)TreeMap实现SortedMap并且扩展AbstractMap，它本身没有定义其他的方法。</p><p>(6)举例一</p><pre><code>package com.iotech.map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;public class TreeMapDemo1 {    public static void main(String[] args) {        TreeMap&lt;String,String&gt; treeMap=new TreeMap&lt;String, String&gt;();        treeMap.put(&quot;jack&quot;, &quot;zhangsan&quot;);        treeMap.put(&quot;mary&quot;, &quot;xiaohong&quot;);        treeMap.put(&quot;rose&quot;, &quot;xiaozhang&quot;);        treeMap.put(&quot;free&quot;, &quot;xiaoming&quot;);        treeMap.put(&quot;rose&quot;, &quot;chenhao&quot;);        //TreeMap是按照键来进行排序的，而String实现了comparable接口，所以是没有问题的。        System.out.println(treeMap);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet=treeMap.entrySet();        for(Entry&lt;String, String&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }    }}</code></pre><p>(7)举例二</p><pre><code>package com.iotech.map;import java.util.Comparator;import java.util.TreeMap;public class TreeMapDemo2 {    public static void main(String[] args) {        TreeMap&lt;Person,String&gt; treeMap=new TreeMap&lt;Person,String&gt;(new Comparator&lt;Person&gt;() {            @Override            public int compare(Person o1, Person o2) {                int x=o1.getAge()-o2.getAge();                if(x&gt;0) return 1;                else if(x&lt;0) return -1;                return 0;            }        });        treeMap.put(new Person(&quot;zhangsan&quot;, 30), &quot;张三&quot;);        treeMap.put(new Person(&quot;lisi&quot;, 31), &quot;李四&quot;);        treeMap.put(new Person(&quot;rose&quot;, 32), &quot;玫瑰&quot;);        treeMap.put(new Person(&quot;zhangsan&quot;, 33), &quot;张三&quot;);        //这里的Person作为TreeMap中的键，也是需要进行排序的，所以Person类也需要继承Comparable接口，        //因此也需要重写CompareTo()方法。        System.out.println(treeMap);    }}class Person/* implements Comparable&lt;Person&gt;*/{    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    /*@Override    public int compareTo(Person o) {        int x=this.age-o.getAge();        if(x&gt;0){            return 1;        }else if(x&lt;0){            return -1;        }        return 0;    }*/}</code></pre><h3 id="5、Comparator和Comparable接口"><a href="#5、Comparator和Comparable接口" class="headerlink" title="5、Comparator和Comparable接口"></a>5、Comparator和Comparable接口</h3><p>TreeMap的key存储引用数据类型，需要满足一定条件，要么引用类型实现Comparable接口，要么为该TreeMap容器提供实现Comparator接口的比较器对象。对应上面例二的两种实现方式。</p><h3 id="6、案例讲解"><a href="#6、案例讲解" class="headerlink" title="6、案例讲解"></a>6、案例讲解</h3><p>(1)给定一个字符数组，数组中内容有重复，现要求打印输出各个字符串出现的次数。</p><p>(2)使用HashMap来设计，HashMap的key可以用来保存字符串，value用来保存字符串所对应的次数，从HashMap中获取不存在的key所对应的值为null。</p><p>(3)代码实现</p><pre><code>package com.iotech.map;import java.util.HashMap;import java.util.Map.Entry;import java.util.Set;public class HashMapTest {    public static void main(String[] args) {        String[] string={&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;,&quot;jack&quot;,&quot;zhangsan&quot;,&quot;zhangsan&quot;,&quot;wangwu&quot;};        HashMap&lt;String,Integer&gt; hashMap=new HashMap&lt;String,Integer&gt;();        for(int i=0;i&lt;string.length;i++){            if(null==hashMap.get(string[i])){                hashMap.put(string[i], 1);            }else{                hashMap.put(string[i], hashMap.get(string[i])+1);            }        }        Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet=hashMap.entrySet();        for(Entry&lt;String,Integer&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Map接口详解&quot;&gt;&lt;a href=&quot;#1、Map接口详解&quot; class=&quot;headerlink&quot; title=&quot;1、Map接口详解&quot;&gt;&lt;/a&gt;1、Map接口详解&lt;/h3&gt;&lt;p&gt;(1)映射(map)是一个存储键/值对的对象。给定一个键，可以查询到它的值，键和值都
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的迭代模式举例</title>
    <link href="http://www.echodemo.cc/2018/07/19/Java%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B/"/>
    <id>http://www.echodemo.cc/2018/07/19/Java中的迭代模式举例/</id>
    <published>2018-07-19T12:47:20.000Z</published>
    <updated>2018-07-19T12:49:53.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。自定义容器和迭代器。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>迭代器角色(Iterator)、具体迭代器角色(Concrete Iterator)、容器角色(Container)、具体容器角色(Concrete Container)。</p><p>定义具体的迭代器角色(我们可以取名为MyIterator)用来实现迭代器角色接口(如Iterator接口，在使用当中，其主要包含hasNext()方法和next()方法)。对于容器角色和具体的容器角色，可以比较直观地把List看作是容器角色，而把ArrayList看作是具体容器角色。</p><h3 id="3、具体实现"><a href="#3、具体实现" class="headerlink" title="3、具体实现"></a>3、具体实现</h3><p>(1)迭代器角色</p><pre><code>package com.iotech.myiterator;public interface Iterator&lt;T&gt; {    public boolean hasNext();//判断是否有下一个元素    public T next();//获取下一个元素的内容}</code></pre><p>(2)容器角色</p><pre><code>package com.iotech.myiterator;public interface List&lt;T&gt; {    public void add(T obj);//给具体的容器添加元素    public T get(int index);//获取指定位置上的元素    public int size();//获得容器中的元素个数    public Iterator&lt;T&gt; iterator();//得到具体的迭代器对象}</code></pre><p>(3)具体的迭代器角色</p><pre><code>package com.iotech.myiterator;public class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; {    private List list=null;    private int index=0;//访问到容器中元素的当前下标    //创建一个迭代器对象的时候接收要被迭代的具体的容器对象    public MyIterator(List&lt;T&gt; list){        this.list=list;    }    //判断是否有下一个元素    @Override    public boolean hasNext() {        return index&lt;list.size();    }    //取出下一个元素    @SuppressWarnings(&quot;unchecked&quot;)    @Override    public T next() {        return (T) list.get(index++);    }}</code></pre><p>(4)具体的容器角色</p><pre><code>package com.iotech.myiterator;public class ArrayList&lt;T&gt; implements List&lt;T&gt; {    private Object[] obj=null;//声明一个Object类型的数组(泛型是不能声明泛型数组的)    private int index;//数组的下标    private int size;//记录数组中元素的个数    public ArrayList(){        obj=new Object[10];        index=0;        size=0;    }    @Override    public void add(T obj) {        this.obj[index++]=obj;//把数据存放到数组中        size++;//元素个数加1    }    @SuppressWarnings(&quot;unchecked&quot;)    @Override    public T get(int index) {        return (T) this.obj[index];    }    @Override    public int size() {        return size;    }    @Override    public Iterator&lt;T&gt; iterator() {        return new MyIterator&lt;T&gt;(this);    }}</code></pre><p>(5)测试类</p><pre><code>package com.iotech.myiterator;public class Test {    public static void main(String[] args) {        List&lt;String&gt; nameList=new ArrayList&lt;String&gt;();        nameList.add(&quot;zhangsan&quot;);        nameList.add(&quot;lisi&quot;);        nameList.add(&quot;wangwu&quot;);        nameList.add(&quot;chenhao&quot;);        Iterator&lt;String&gt; iterator=nameList.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。自定义容器和迭代器。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的List</title>
    <link href="http://www.echodemo.cc/2018/07/18/Java%E4%B8%AD%E7%9A%84List/"/>
    <id>http://www.echodemo.cc/2018/07/18/Java中的List/</id>
    <published>2018-07-18T13:32:57.000Z</published>
    <updated>2018-07-18T16:02:40.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、List容器特点"><a href="#1、List容器特点" class="headerlink" title="1、List容器特点"></a>1、List容器特点</h3><p>List容器是有序的collection(也称之为序列)，此接口的用户可以对List容器中每个元素的插入位置进行精准地控制。用户可以根据元素的整数索引(在列表中的位置)访问元素，并搜索列表中的元素。List容器允许插入重复的值，包括null。</p><h3 id="2、ArrayList-动态数组-及常用API"><a href="#2、ArrayList-动态数组-及常用API" class="headerlink" title="2、ArrayList(动态数组)及常用API"></a>2、ArrayList(动态数组)及常用API</h3><p>(1)ArrayList类扩展了AbstractList并实现了List接口。</p><p>(2)支持可随需增长的动态数组。(以1.5倍的倍率进行扩容)</p><p>(3)ArrayList构造方法。ArrayList();ArrayList(Collection c);ArrayList(int capacity);</p><p>(4)除继承的方法之外，ArrayList常用方法。E get(int index)方法：返回此列表中指定位置上的元素；int intdexOf(Object o)：返回此列表中首次出现的指定元素的索引，或如果此列表不含该元素，则返回-1。</p><p>(5)ArrayList的常用方法举例</p><pre><code>import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ArrayListDemo1 {    public static void main(String[] args) {        /*         * 当我们调用无参构造方法来构造一个ArrayList对象的时候，它会在内部分配一个初始大小为10的一个Object类型数组。         *          * 当添加的数据容量超过数组大小的时候，会产生一个新的数组，新的数组的大小是原来数组大小的1.5倍。接着把原数组         * 中的数据拷贝到新的数组中。         */        List&lt;String&gt; nList=new ArrayList&lt;String&gt;();        nList.add(&quot;chenhao&quot;);//添加元素        nList.add(&quot;lisi&quot;);        nList.add(&quot;lisi&quot;);        nList.add(&quot;wangwu&quot;);        nList.add(1, &quot;jay&quot;);//在指定的位置添加元素        nList.add(&quot;jack&quot;);        nList.set(0, &quot;chengang&quot;);//修改指定位置的元素值        System.out.println(&quot;使用迭代器对象来进行统一的遍历&quot;);        Iterator&lt;String&gt; iterator=nList.iterator();         while (iterator.hasNext()) {            String name = iterator.next();            System.out.println(name);        }        System.out.println(&quot;使用增强for循环进行遍历&quot;);        for(String name:nList){            System.out.println(name);        }        System.out.println(&quot;********************************&quot;);        System.out.println(nList.indexOf(&quot;lisi&quot;));//查找指定元素的位置        System.out.println(nList.remove(&quot;lisi&quot;));//删除元素        System.out.println(nList.remove(0));//删除某个位置的元素        System.out.println(nList.size());//动态数组的大小        System.out.println(nList.contains(&quot;chenhao&quot;));//是否包含某个元素        System.out.println(nList.get(1));//获取指定位置的元素值        System.out.println(nList.isEmpty());//判断动态数组是否为空        nList.clear();//清空动态数组        System.out.println(nList.isEmpty());        System.out.println(&quot;********************************&quot;);    }}</code></pre><p>(6)ArrayList方法的重载举例</p><pre><code>import java.util.ArrayList;import java.util.List;public class ArrayListDemo2 {    public static void main(String[] args) {        List&lt;Student&gt; stuList=new ArrayList&lt;Student&gt;();//以学生类对象作为泛型的具体化        Student stu1=new Student(&quot;zhangsan&quot;, 10);        Student stu2=new Student(&quot;lisi&quot;, 20);        Student stu3=new Student(&quot;jack&quot;, 30);        Student stu4=new Student(&quot;mandy&quot;, 10);        Student stu5=new Student(&quot;mary&quot;, 20);        stuList.add(stu1);        stuList.add(stu2);        stuList.add(stu3);        stuList.add(stu4);        stuList.add(stu5);        Student stu6=new Student(&quot;mary&quot;, 20);        //可以通过按住Ctrl键再点击相应的方法名来查看方法的具体实现。从而搞清楚下列方法在修改equals方法之后的变化。        System.out.println(stuList.indexOf(stu6));        System.out.println(stuList.contains(stu6));        System.out.println(stuList.remove(stu6));        System.out.println(stuList.indexOf(stu5));        System.out.println(stuList.size());    }}class Student{//学生类    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object obj) {//重写equals方法，只要姓名和年龄一致则是相同的对象。        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="3、LinkedList及常用API"><a href="#3、LinkedList及常用API" class="headerlink" title="3、LinkedList及常用API"></a>3、LinkedList及常用API</h3><p>(1)LinkedList类扩展AbstractSequentialList并实现List接口。</p><p>(2)LinkedList提供了一个链表数据结构。(其中含有Node对象，并且有前引用和后引用)</p><p>(3)LinkedList有两个构造方法：LinkedList();LinkedList(Collection c);</p><p>(4)除了继承的方法之外，LinkedList类还定义了一些有用的方法用于操作和访问容器中的数据。void addFirst(E e);void addLast(E e);E removeFirst();E removeLast();</p><p>(5)由于Deque接口扩展了Queue接口，成为双端队列，而LinkedList继承了Deque接口。所以它可以提供add、poll先进先出队列的操作，以及其他堆栈和双端队列操作。</p><p>(6)LinkedList常用方法举例</p><pre><code>import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo1 {    public static void main(String[] args) {        /*         * LinkedList内部封装的是双向的链表数据结构，每个节点是一个Node对象，Node对象中封装的是你要         * 添加的元素，还有一个指向上一个Node对象的引用和下一个Node对象的引用。         *          * 不同的容器有不同的数据结构，不同的数据结构操作起来的性能是不一样的。链表数据结构做插入、删除         * 的效率较高，但查询的效率比较低。数组结构做查询的时候效率高，因为可以通过下标直接找到元素，但         * 插入和删除效率比较低，因为要做移位操作。         */        LinkedList&lt;String&gt; sList=new LinkedList&lt;String&gt;();        sList.add(&quot;zhangsan&quot;);//添加        sList.add(&quot;lisi&quot;);        sList.add(&quot;wangwu&quot;);        sList.add(&quot;rose&quot;);        sList.add(&quot;mary&quot;);        sList.add(&quot;jack&quot;);        sList.addFirst(&quot;chenhao&quot;);//添加至开头        sList.addLast(&quot;mandy&quot;);//添加至末尾        /*Iterator&lt;String&gt; iterator=sList.iterator();        while (iterator.hasNext()) {            String name = iterator.next();            System.out.println(name);        }*/        /*for(String name:sList){            System.out.println(name);        }*/        for(Iterator&lt;String&gt; iterator=sList.iterator();iterator.hasNext();){            String name=iterator.next();            System.out.println(name);        }        System.out.println(sList.removeFirst());//为空时返回异常        System.out.println(sList.size());        sList.clear();        System.out.println(sList.pollFirst());//为空时返回null    }}</code></pre><p>(7)使用LinkedList来实现栈和队列的功能</p><pre><code>import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo2 {    public static void main(String[] args) {        /*Mystack&lt;String&gt; mystack=new Mystack&lt;String&gt;();        mystack.push(&quot;zhangsan&quot;);        mystack.push(&quot;lisi&quot;);        mystack.push(&quot;wangwu&quot;);        mystack.push(&quot;zhaoliu&quot;);        mystack.pop();        mystack.pop();        Iterator&lt;String&gt; iterator = mystack.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }*/        MyQueue&lt;Integer&gt; myQueue=new MyQueue&lt;Integer&gt;();        myQueue.push(1);        myQueue.push(2);        myQueue.push(3);        myQueue.push(4);        myQueue.push(5);        myQueue.pop();        myQueue.pop();        Iterator&lt;Integer&gt; iterator=myQueue.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }}class Mystack&lt;T&gt;{//使用LinkedList来模拟栈的数据结构    private LinkedList&lt;T&gt; data=null;    public Mystack(){        data=new LinkedList&lt;T&gt;();    }    //压栈的方法    public void push(T obj){        data.addFirst(obj);    }    //出栈的方法    public T pop(){        return data.removeFirst();    }    public Iterator&lt;T&gt; iterator(){        return data.iterator();    }}class MyQueue&lt;T&gt;{//使用LinkedList来模拟队列的数据结构    private LinkedList&lt;T&gt; data=null;    public MyQueue(){        data=new LinkedList&lt;T&gt;();    }    //入队    public void push(T obj){        data.addLast(obj);    }    //出队    public T pop(){        return data.removeFirst();    }    public Iterator&lt;T&gt; iterator(){        return data.iterator();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、List容器特点&quot;&gt;&lt;a href=&quot;#1、List容器特点&quot; class=&quot;headerlink&quot; title=&quot;1、List容器特点&quot;&gt;&lt;/a&gt;1、List容器特点&lt;/h3&gt;&lt;p&gt;List容器是有序的collection(也称之为序列)，此接口的用户可以对
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的集合</title>
    <link href="http://www.echodemo.cc/2018/07/18/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>http://www.echodemo.cc/2018/07/18/Java中的集合/</id>
    <published>2018-07-18T11:29:49.000Z</published>
    <updated>2018-07-23T00:26:36.842Z</updated>
    
    <content type="html"><![CDATA[<p>1、集合框架：它是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口与类。集合框架包含了各种各样的容器，每一种容器都可以存放数据并且提供了操作容器当中数据的相关方法。</p><p>2、集合框架中不同的集合类有各自不同的数据结构，所以在使用中要根据应用的性能要求来选择不同的集合类。</p><p>3、集合类存放在java.util包中，今后进行程序编程时将大量使用集合类和相关接口。其中包括Iterable:迭代器接口；Collection：类集接口；List：列表接口；Set：数据集接口；Queue：队列；Map：键值对组合映射表。</p><p><img src="/images/2018/7/1.jpg" alt="&quot;集合框架&quot;"></p><p>(1)Iterable接口</p><p>实现该接口允许对象成为“foreach”语句的目标，即该集合对象允许迭代。类集接口Collection是Iterable的子接口，所以所有类集对象可以迭代访问，而映射Map不行。(Map并没有实现Iterable接口)</p><p>Iterator<t>iterator():功能：返回一个在一组T类型的元素上进行迭代的迭代器对象。迭代器是实现了Iterator/ListIterator接口的类的对象，可以通过遍历类集，访问操作其中的每个元素。ListIterator继承了父接口Iterator，允许双向遍历集合，并可以修改和删除元素。</t></p><p>(2)Collection接口</p><p>int size();boolean isEmpty();boolean contains(Object o);Iterator<e> iterator;Object[] toArray();boolean add(E e);boolean remove(Object o);void clear()。等等</e></p><p>(3)List、Set、Map接口</p><p>List接口扩展了Collection，有序且可重复；Set接口扩展了Collection，无序且不可重复；Map是一个存储关键字/值对的对象。映射不是Collection的子接口，所以它本身不能使用迭代器来进行遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、集合框架：它是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口与类。集合框架包含了各种各样的容器，每一种容器都可以存放数据并且提供了操作容器当中数据的相关方法。&lt;/p&gt;
&lt;p&gt;2、集合框架中不同的集合类有各自不同的数据结构，所以在使用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>成为职场人</title>
    <link href="http://www.echodemo.cc/2018/07/17/%E6%88%90%E4%B8%BA%E8%81%8C%E5%9C%BA%E4%BA%BA/"/>
    <id>http://www.echodemo.cc/2018/07/17/成为职场人/</id>
    <published>2018-07-17T10:58:27.000Z</published>
    <updated>2018-07-17T10:59:09.813Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>礼仪培训笔记</title>
    <link href="http://www.echodemo.cc/2018/07/17/%E7%A4%BC%E4%BB%AA%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.echodemo.cc/2018/07/17/礼仪培训笔记/</id>
    <published>2018-07-17T10:15:32.000Z</published>
    <updated>2018-07-17T10:50:41.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是礼仪？"><a href="#一、什么是礼仪？" class="headerlink" title="一、什么是礼仪？"></a>一、什么是礼仪？</h3><p>礼仪=礼节+原则=心理+形式</p><h3 id="二、简析服务礼仪"><a href="#二、简析服务礼仪" class="headerlink" title="二、简析服务礼仪"></a>二、简析服务礼仪</h3><p>1、顾客永远是对的（把面子留给客人，放弃自我，自主揽错）</p><p>2、永远不要辩解，服务中禁止使用推卸责任的语言。</p><p>3、注重首因效应、末轮效应。比如：缩短客人的等待时间。</p><p>4、在职场当中得体比漂亮更重要。包括面部，发型，举止，服饰，谈吐。如：不能穿短衬打领带，衬衣只买领围的大小。</p><h3 id="三、学会用眼睛说话"><a href="#三、学会用眼睛说话" class="headerlink" title="三、学会用眼睛说话"></a>三、学会用眼睛说话</h3><p>1、目光注视方式（PAC规律）</p><p>2、目光注视区域（三角定律）</p><p>3、目光注视时间规律（3~5秒）</p><p>4、目光注视的距离</p><h3 id="四、人际沟通“六到”"><a href="#四、人际沟通“六到”" class="headerlink" title="四、人际沟通“六到”"></a>四、人际沟通“六到”</h3><p>1、脑到：先三思，后言行。</p><p>2、眼到：专注，诚恳，体现尊重。</p><p>3、耳到：诚心聆听，不打岔。</p><p>4、口到：不吝啬鼓励、善意、赞美的语言。</p><p>5、心到：从他人角度理解，换位思考。</p><p>6、脚到：主动接近，距离合适。</p><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>1、服务距离：0.5~1.5米；展示距离：1~3米；引导距离：在客户左前方1~1.5米；待命距离：3米以外。</p><p>2、鞠躬距离控制：脚前方2米是15度；脚前方1.5米是30度；脚前方1.0米是45度。</p><p>3、在职场以职称论高低，在社交场合以女士为尊者，在家庭以年龄为长。</p><p>4、握手需要把握力度，距离。在不同的场合都是尊者先伸手握手。自我介绍在握手之前，且尊者后进行自我介绍。尊者有优先了解别人的权利。</p><p>5、名片：先客后主，先低后高，尊者优先收名片。尊者有优先了解别人的权利。</p><h5 id="6、先肯定全部，再否认局部。"><a href="#6、先肯定全部，再否认局部。" class="headerlink" title="6、先肯定全部，再否认局部。"></a>6、先肯定全部，再否认局部。</h5><h2 id="注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。"><a href="#注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。" class="headerlink" title="注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。"></a>注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是礼仪？&quot;&gt;&lt;a href=&quot;#一、什么是礼仪？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是礼仪？&quot;&gt;&lt;/a&gt;一、什么是礼仪？&lt;/h3&gt;&lt;p&gt;礼仪=礼节+原则=心理+形式&lt;/p&gt;
&lt;h3 id=&quot;二、简析服务礼仪&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>廊下听雨</title>
    <link href="http://www.echodemo.cc/2018/07/07/%E5%BB%8A%E4%B8%8B%E5%90%AC%E9%9B%A8/"/>
    <id>http://www.echodemo.cc/2018/07/07/廊下听雨/</id>
    <published>2018-07-07T00:39:48.000Z</published>
    <updated>2018-07-24T10:50:17.803Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小暑时节，雨一直下，且大，完全没有减弱的痕迹。坐在廊下听雨，淅淅沥沥的。树叶上浸润着雨水，轻轻地晃动着。天空一片灰濛，背后是望不到尽头的远方。仿佛时间于此刻定格，又好像自己回到了久远的过去，似曾相识里神情甚是淡然。起身取来《平凡的世界》，自己明日即将远行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;小暑时节，雨一直下，且大，完全没有减弱的痕迹。坐在廊下听雨，淅淅沥沥的。树叶上浸润着雨水，轻轻地晃动着。天空一片灰濛，背后是望不到尽头的远方。仿佛时间于此刻定格，又好像自己回到了久远的过去，
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>童年的暑假</title>
    <link href="http://www.echodemo.cc/2018/07/05/%E7%AB%A5%E5%B9%B4%E7%9A%84%E6%9A%91%E5%81%87/"/>
    <id>http://www.echodemo.cc/2018/07/05/童年的暑假/</id>
    <published>2018-07-05T02:40:32.000Z</published>
    <updated>2018-07-24T10:48:28.612Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;坐在夏天的院子里，吹着独属于清晨凉爽的风，高大的板栗树的叶子随风舞动着，新生的狗崽们自由地玩闹着，不远处也时而传来清脆悦耳的鸟鸣。此刻正在阅读的我，不由得想起童年的暑假。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信对于每一位拥有暑假的孩子来说，那都是一段令我们魂牵梦萦的时光。因为年少的我们还没能意识到知识的重要性，对于“求知”一词也就无从谈起。但我们拥有对世界的好奇心，对于某些物质的渴求。而我在那个时期的暑假是伴随着辛劳、收获与懵懂无知的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暑假刚至，便是西瓜的盛世。那时村里几乎每家每户都种西瓜（现在也一如既往，就算是没有种瓜的人家也总有瓜纷至沓来），人们在下午太阳的热辣褪去之后，拉着双轮车就往瓜地里走去。在大片的瓜地里寻找最大的西瓜，学着大人的模样在瓜的身上轻轻敲打来辨别是否可以采摘，还有搬着一个个又大又圆的西瓜走在田埂上是我的乐趣。第二天一大早，在天还未亮的时候，人们就拉着满车的西瓜往集市上赶。而我就在家中用菜刀切开自己早就精挑细选好的西瓜的头部，用调羹挖开又红又甜的瓜瓤，享受夏天清爽而又甜蜜的味道。当然也不能忘却杏子和李子给过的酸甜可口。寻觅，爬树，摇晃，然后找一泓清泉，于阴凉之地，蝉鸣的聒噪声中大饱口福是在所难免的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等到享乐的时节一过，就迎来了第一季的农忙。趁着昨夜的凉气还未完全消散，趁着火热的太阳还未升起，家家户户收拾好工具就早早地去往金黄的稻田，开始一天的劳作。早上是一天当中最佳的劳作时间，人们往往会在两至三个小时之后才会回到家中，由妇女准备饭食，其他人则负责将收割回来的稻谷搬运到楼顶或者院子里摊开晾晒。短暂而又简短的早餐过后，一天中的重要时段上午便接踵而至，这时的太阳已经普照大地。左手握稻秆，右手持镰刀，挥汗如雨下，人们顶着烈日在田地里弯腰劳作着，将一捧又一捧连着稻秆的稻穗，搭成稻谷架（以便打谷这一工序）。偶尔吹来一阵凉爽的风（有时就连风也是热的），抬起头，田野里各处响起脚踏打谷机的运作声，天上是澄澈的蓝天和白云。中场休息是我的最爱，不仅有家中甘甜的井水，还有从来都不缺的可口的西瓜，以此来解渴和补充糖分。忙到中午时分，回到家，午餐过后，小睡，便又开始了下午的忙碌。在睡意昏沉中走进烈日的暴晒里，整个人顿时就清醒了。动作重复，直至夕阳西下，此时需要派人先行回家收好早上和上午晾晒的稻谷。说到收稻谷这件事，农忙期间作为小孩子的我既渴望天空下雨又不愿天空下雨，真真是让心里纠结又矛盾。当然，除了收割稻子之外，还需要为晚稻做准备。一般是收割完一块地之后，便要犁地抛秧。抛秧这件事比割稻子有趣，自从有了育秧盘，抛秧就比插秧轻松多了。当大人们在认认真真地有间隔和规律地抛秧时，我手中的秧苗呢，可以从天而降，也可以在水田里组成各式各样的形状（此情此景，总是想起王维的“漠漠水田飞白鹭”），甚至用抛出的秧苗将他们给围起来。农忙时节一般需要持续将近一个月左右，这个月是人类与大地深切交流的日子。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;农忙过后的我就要与家中的黄牛常伴左右了。这是农耕文明里必不可少的物种，也是世世代代的农民不可缺少的战友。同样是早起，和小伙伴们赶着牛群有时往山里走，有时走向荒废的田野。清晨只是个插曲，下午才是重点。虽然烈日当头照，但我们躲在树的阴凉里，玩着各种属于我们的游戏，享受属于我们的快乐时光。童年的暑假便是在这样的日子里慢慢度过，直至开学第一课。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今的故乡，农耕的机械化时代早已如约而至，曾经面朝黄土背朝天的农人们依然即将步入收获的季节。暑假只是我童年的一个缩影，于我而言，童年是一个物质相对匮乏的时期，更谈不上阅读这一有着一定条件的事物了。或许这是现在的我对阅读和文字饱有热爱之心的缘由。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;坐在夏天的院子里，吹着独属于清晨凉爽的风，高大的板栗树的叶子随风舞动着，新生的狗崽们自由地玩闹着，不远处也时而传来清脆悦耳的鸟鸣。此刻正在阅读的我，不由得想起童年的暑假。&lt;/p&gt;
&lt;p&gt;&amp;n
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>自由与人生</title>
    <link href="http://www.echodemo.cc/2018/07/01/%E8%87%AA%E7%94%B1%E4%B8%8E%E4%BA%BA%E7%94%9F/"/>
    <id>http://www.echodemo.cc/2018/07/01/自由与人生/</id>
    <published>2018-07-01T13:49:02.000Z</published>
    <updated>2018-07-24T10:57:29.610Z</updated>
    
    <content type="html"><![CDATA[<pre><code>那些以自由为人生终极目的的人是不会真正拥有自由的，因为他们时常为自由所奴役。相反，我认为人生才是自由的目的。换言之，我们是要“自由的人生”，而不是“人生的自由”。――熊培云</code></pre><p>当我看到这句话的时候，才恍然意识到在这之前，自己的思想里追求的就是“人生的自由”，而非“自由的人生”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;那些以自由为人生终极目的的人是不会真正拥有自由的，因为他们时常为自由所奴役。相反，我认为人生才是自由的目的。换言之，我们是
要“自由的人生”，而不是“人生的自由”。――熊培云
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我看到这句话的时候，才恍然意识到在这之前，自己的
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
