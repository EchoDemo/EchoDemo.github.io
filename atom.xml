<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2020-02-09T10:18:44.192Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建私有仓库</title>
    <link href="http://www.echodemo.cc/2020/02/09/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://www.echodemo.cc/2020/02/09/搭建私有仓库/</id>
    <published>2020-02-09T09:51:12.000Z</published>
    <updated>2020-02-09T10:18:44.192Z</updated>
    
    <content type="html"><![CDATA[<p>有时候使用 Docker Hub 这样的公共仓库可能不方便，那么，用户也可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。</p><h3 id="Registry的部署"><a href="#Registry的部署" class="headerlink" title="Registry的部署"></a>Registry的部署</h3><p>1、镜像下载与启动</p><pre><code>docker pull registry// 这里的 /opt/registry 是我们本地的目录，用于存储上传的镜象，/var/lib/registry是Registry服务默认的保存镜象目录docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</code></pre><p>2、镜像运行情况查看</p><pre><code>docker ps</code></pre><p>打开浏览器输入<a href="http://127.0.0.1:5000/v2，正常返回如下数据如下：" target="_blank" rel="noopener">http://127.0.0.1:5000/v2，正常返回如下数据如下：</a></p><blockquote><p>{}</p></blockquote><h3 id="上传镜像至私有仓库并验证"><a href="#上传镜像至私有仓库并验证" class="headerlink" title="上传镜像至私有仓库并验证"></a>上传镜像至私有仓库并验证</h3><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。</p><p>1、先在本机查看已有的镜像</p><pre><code>docker images</code></pre><p>2、镜像打标记</p><p>假设在客户机上有个hello-world的镜像，我们要通过docker tag将该镜像标志为要推送到私有仓库。这里的客户端就是服务端。</p><pre><code>// 打标记docker tag hello-world 127.0.0.1:5000/hello-world// 标记成功之后查看docker image ls 127.0.0.1:5000/hello-world</code></pre><p>3、上传标记镜像</p><pre><code>docker push 127.0.0.1:5000/hello-world</code></pre><p>4、查看客户端上传的镜像目录</p><p>在浏览器中输入<a href="http://127.0.0.1:5000/v2/_catalog，正常返回如下数据如下：" target="_blank" rel="noopener">http://127.0.0.1:5000/v2/_catalog，正常返回如下数据如下：</a></p><blockquote><p>{“repositories”:{hello-world}}</p></blockquote><p>5、删除本地标记和镜像</p><pre><code>docker rmi hello-worlddocker rmi 127.0.0.1:5000/hello-world</code></pre><p>6、从私有仓库中获取镜像</p><pre><code>docker pull 127.0.0.1:5000/hello-world</code></pre><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>可能会出现无法push镜像到私有仓库的问题。这是因为我们启动的registry服务不是安全可信赖的。我们可以通过Docker的配置选项来取消这个限制。对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><pre><code>{  &quot;registry-mirror&quot;: [    &quot;https://registry.docker-cn.com&quot;  ],  &quot;insecure-registries&quot;: [    &quot;172.16.213.230:5000&quot;  ]}</code></pre><p>添加完成，重启docker服务才能生效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候使用 Docker Hub 这样的公共仓库可能不方便，那么，用户也可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。&lt;/p&gt;
&lt;h3 id=&quot;Registry的部署&quot;&gt;&lt;a href=&quot;#Registry的部
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper入门</title>
    <link href="http://www.echodemo.cc/2020/02/04/Zookeeper%E5%85%A5%E9%97%A8/"/>
    <id>http://www.echodemo.cc/2020/02/04/Zookeeper入门/</id>
    <published>2020-02-04T07:05:01.000Z</published>
    <updated>2020-02-04T08:14:34.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是ZooKeeper"><a href="#1、什么是ZooKeeper" class="headerlink" title="1、什么是ZooKeeper"></a>1、什么是ZooKeeper</h3><p>ZooKeeper 由 Yahoo 开发，后来捐赠给了 Apache ，现已成为 Apache 顶级项目。ZooKeeper 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 Paxos 算法的 ZAB 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。简单来说， ZooKeeper 是一个分布式协调服务框架。</p><p>(1)分布式和集群</p><p>有人说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— Cluster ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。</p><p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也一样提供秒杀服务，这个时候就是 Cluster 集群 。</p><p>但是，我现在换一种方式，我将一个秒杀服务 拆分成多个子服务 ，比如创建订单服务，增加积分服务，扣优惠券服务等等，然后我将这些子服务都部署在不同的服务器上 ，这个时候就是  Distributed 分布式 。</p><h3 id="2、ZooKeeper基本概念"><a href="#2、ZooKeeper基本概念" class="headerlink" title="2、ZooKeeper基本概念"></a>2、ZooKeeper基本概念</h3><p>(1)集群角色</p><pre><code>&gt; Master&gt; Follower&gt; Observer</code></pre><p>一个 ZooKeeper 集群同一时刻只会有一个 Master，其他都是 Follower 或 Observer。</p><p>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入:peerType=observer 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 :observer</p><p>(2)数据模型</p><p>zookeeper 数据存储结构与标准的 Unix 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 zookeeper 中没有文件系统中目录与文件的概念，而是 使用了 znode 作为数据节点 。znode 是 zookeeper 中的最小数据单元，每个 znode 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。</p><p>每个 znode 都有自己所属的 节点类型 和 节点状态。zookeeper的节点分两类：持久节点和临时节点</p><blockquote><p>持久节点：</p><blockquote><p>所谓持久节点是指一旦这个 树形结构上被创建了，除非主动进行对树节点的移除操作，否则这个节点将一直保存在 ZooKeeper 上。</p></blockquote><p>临时节点：</p><blockquote><p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p></blockquote></blockquote><p>(3)Watcher(事件监听器)</p><p>Watcher 为事件监听器，是 zookeeper 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端注册指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会 向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后执行相应的回调方法 。</p><p>(4)节点读写服务分工</p><p>ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。</p><p>Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><p>(5)Session</p><p>ZooKeeper 客户端和服务端是通过 TCP 长连接维持的会话机制，其实对于会话来说你可以理解为:保持连接状态 。</p><p>ZooKeeper 对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的 Watcher 事件通知。</p><h3 id="3、ZooKeeper应用的典型场景"><a href="#3、ZooKeeper应用的典型场景" class="headerlink" title="3、ZooKeeper应用的典型场景"></a>3、ZooKeeper应用的典型场景</h3><p>(1)数据发布与订阅（配置中心）</p><p>数据发布与订阅，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上,供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和动态更新。</p><p>(2)命名服务</p><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字。</p><p>其中较为常见的就是一些分布式服务框架（如RPC）中的服务地址列表。通过在ZooKeepr里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。ZooKeeper 的命名服务即生成全局唯一的ID。</p><p>(3)Master 选举</p><p>Master 选举可以说是 ZooKeeper 最典型的应用场景了。比如 HDFS 中 Active NameNode 的选举、YARN 中 Active ResourceManager 的选举和 HBase 中 Active HMaster 的选举等。</p><p>针对 Master 选举的需求，通常情况下，我们可以选择常见的关系型数据库中的主键特性来实现：希望成为 Master 的机器都向数据库中插入一条相同主键ID的记录，数据库会帮我们进行主键冲突检查，也就是说，只有一台机器能插入成功——那么，我们就认为向数据库中成功插入数据的客户端机器成为Master。</p><p>但是，如果当前选举出的 Master 挂了，那么该如何处理？谁来告诉我 Master 挂了呢？显然，关系型数据库无法通知我们这个事件。但是，ZooKeeper 可以做到！</p><p>利用 ZooKeepr 的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即 ZooKeeper 将会保证客户端无法创建一个已经存在的数据单元节点。也就是说，如果同时有多个客户端请求创建同一个临时节点，那么最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行 Master 选举了。</p><p>成功创建该节点的客户端所在的机器就成为了 Master。同时，其他没有成功创建该节点的客户端，都会在该节点上注册一个子节点变更的 Watcher，用于监控当前 Master 机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会重新进行 Master 选举。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是ZooKeeper&quot;&gt;&lt;a href=&quot;#1、什么是ZooKeeper&quot; class=&quot;headerlink&quot; title=&quot;1、什么是ZooKeeper&quot;&gt;&lt;/a&gt;1、什么是ZooKeeper&lt;/h3&gt;&lt;p&gt;ZooKeeper 由 Yahoo 开发，后
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ZooKeeper" scheme="http://www.echodemo.cc/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://www.echodemo.cc/2020/02/04/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://www.echodemo.cc/2020/02/04/正向代理和反向代理/</id>
    <published>2020-02-04T02:41:07.000Z</published>
    <updated>2020-02-04T02:48:50.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、什么是代理服务器（Proxy-Serve）？"><a href="#1、什么是代理服务器（Proxy-Serve）？" class="headerlink" title="1、什么是代理服务器（Proxy Serve）？"></a>1、什么是代理服务器（Proxy Serve）？</h3><pre><code>提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。</code></pre><h3 id="2、为什么使用代理服务器？"><a href="#2、为什么使用代理服务器？" class="headerlink" title="2、为什么使用代理服务器？"></a>2、为什么使用代理服务器？</h3><p>(1)提高访问速度</p><p>由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度。</p><p>(2)防火墙作用</p><p>由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</p><p>(3)突破访问限制</p><p>互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</p><h3 id="3、正向代理"><a href="#3、正向代理" class="headerlink" title="3、正向代理"></a>3、正向代理</h3><p>正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 </p><p>简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 </p><h3 id="4、反向代理"><a href="#4、反向代理" class="headerlink" title="4、反向代理"></a>4、反向代理</h3><p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 </p><p>理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 </p><h3 id="5、正向代理和反向代理的区别"><a href="#5、正向代理和反向代理的区别" class="headerlink" title="5、正向代理和反向代理的区别"></a>5、正向代理和反向代理的区别</h3><p>(1)位置不同</p><pre><code>正向代理，架设在客户机和目标主机之间； 反向代理，架设在服务器端；</code></pre><p>(2)代理对象不同 </p><pre><code>正向代理，代理客户端，服务端不知道实际发起请求的客户端； 反向代理，代理服务端，客户端不知道实际提供服务的服务端； </code></pre><p>(3)用途不同 </p><pre><code>正向代理，为在防火墙内的局域网客户端提供访问Internet的途径； 反向代理，将防火墙后面的服务器提供给Internet访问；</code></pre><p>(4)安全性不同 </p><pre><code>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务； 反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。</code></pre><h3 id="6、正向代理的应用"><a href="#6、正向代理的应用" class="headerlink" title="6、正向代理的应用"></a>6、正向代理的应用</h3><pre><code>1. 访问原来无法访问的资源 2. 用作缓存，加速访问速度3. 对客户端访问授权，上网进行认证4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</code></pre><h3 id="7、反向代理的应用"><a href="#7、反向代理的应用" class="headerlink" title="7、反向代理的应用"></a>7、反向代理的应用</h3><pre><code>1. 保护内网安全2. 负载均衡3. 缓存，减少服务器的压力</code></pre><p>Nginx作为较火的反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后台的服务器，决定哪台目标主机来处理当前请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、什么是代理服务器（Proxy-Serve）？&quot;&gt;&lt;a href=&quot;#1、什么是代理服务器（Proxy-Serve）？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是代理服务器（Proxy Serve）？&quot;&gt;&lt;/a&gt;1、什么是代理服务器（Pro
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://www.echodemo.cc/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx(upstream机制)的几种负载均衡策略</title>
    <link href="http://www.echodemo.cc/2020/02/04/nginx(upstream%E6%9C%BA%E5%88%B6)%E7%9A%84%E5%87%A0%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://www.echodemo.cc/2020/02/04/nginx(upstream机制)的几种负载均衡策略/</id>
    <published>2020-02-04T02:28:29.000Z</published>
    <updated>2020-02-04T02:55:46.051Z</updated>
    
    <content type="html"><![CDATA[<p>upstream机制使得Nginx以反向代理的方式运行，因此Nginx接受客户端的请求，并根据客户端的请求，Nginx选择合适的后端服务器来处理改请求。</p><h3 id="1、轮询（默认）"><a href="#1、轮询（默认）" class="headerlink" title="1、轮询（默认）"></a>1、轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，会自动剔除；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="2、指定权重"><a href="#2、指定权重" class="headerlink" title="2、指定权重"></a>2、指定权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况；</p><pre><code>upstream test {    server 10.0.0.7:80 weight=2;    server 10.0.0.8:80 weight=1;}</code></pre><h3 id="3、ip-hash（客户端ip绑定）"><a href="#3、ip-hash（客户端ip绑定）" class="headerlink" title="3、ip_hash（客户端ip绑定）"></a>3、ip_hash（客户端ip绑定）</h3><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端的服务器，可以解决session问题；</p><pre><code>upstream test {    ip_hash;    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="4、least-conn（最少连接）"><a href="#4、least-conn（最少连接）" class="headerlink" title="4、least_conn（最少连接）"></a>4、least_conn（最少连接）</h3><p>下一个请求将被分配到活动连接数量最少的服务器；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;    least_conn;}</code></pre><h3 id="5、fair（第三方）"><a href="#5、fair（第三方）" class="headerlink" title="5、fair（第三方）"></a>5、fair（第三方）</h3><p>按后端服务器的响应时间来请求分配，响应时间短的优先分配；</p><pre><code>upstream test {    fair;    server 10.0.0.7:80;    server 10.0.0.8:80;}</code></pre><h3 id="6、url-hash（第三方）"><a href="#6、url-hash（第三方）" class="headerlink" title="6、url_hash（第三方）"></a>6、url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，按每个url定向到同一个后端服务器，后端服务器为缓存时比较有效；</p><pre><code>upstream test {    server 10.0.0.7:80;    server 10.0.0.8:80;    hash $request_uri;    hash_method crc32;}</code></pre><h3 id="7、综合使用"><a href="#7、综合使用" class="headerlink" title="7、综合使用"></a>7、综合使用</h3><pre><code>upstream test {    ip_hash;    server 10.0.0.7:80 weight=10;    server 10.0.0.8:80 down（表示当前的server暂时不参加负载）;    server 10.0.0.9:80;    server 10.0.0.10:80 backup（其他所有的非backup机器down或者忙的时候，请求backup机器）;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;upstream机制使得Nginx以反向代理的方式运行，因此Nginx接受客户端的请求，并根据客户端的请求，Nginx选择合适的后端服务器来处理改请求。&lt;/p&gt;
&lt;h3 id=&quot;1、轮询（默认）&quot;&gt;&lt;a href=&quot;#1、轮询（默认）&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://www.echodemo.cc/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Git高级用法</title>
    <link href="http://www.echodemo.cc/2020/02/04/Git%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://www.echodemo.cc/2020/02/04/Git高级用法/</id>
    <published>2020-02-04T00:21:29.000Z</published>
    <updated>2020-02-04T02:28:14.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2020/2/git工作流程图.png" alt="&quot;git工作流程图&quot;"></p><h3 id="1、跳到之前的分支"><a href="#1、跳到之前的分支" class="headerlink" title="1、跳到之前的分支"></a>1、跳到之前的分支</h3><pre><code>git checkout -</code></pre><h3 id="2、查看历史"><a href="#2、查看历史" class="headerlink" title="2、查看历史"></a>2、查看历史</h3><pre><code># 每个提交在一行内显示git log --oneline# 在所有提交日志中搜索包含「homepage」的提交git log --all --grep=&apos;homepage&apos;# 获取某人的提交日志git log --author=&quot;Maxence&quot;</code></pre><h3 id="3、之前重置了一个不想保留的提交，但是现在又想要回滚"><a href="#3、之前重置了一个不想保留的提交，但是现在又想要回滚" class="headerlink" title="3、之前重置了一个不想保留的提交，但是现在又想要回滚"></a>3、之前重置了一个不想保留的提交，但是现在又想要回滚</h3><pre><code># 获取所有操作历史git reflog# 重置到相应提交git reset HEAD@{4}# ……或者……git reset --hard &lt;提交的哈希值&gt;</code></pre><h3 id="4、我把本地仓库搞得一团糟，应该怎么清理？"><a href="#4、我把本地仓库搞得一团糟，应该怎么清理？" class="headerlink" title="4、我把本地仓库搞得一团糟，应该怎么清理？"></a>4、我把本地仓库搞得一团糟，应该怎么清理？</h3><pre><code>git fetch origingit checkout mastergit reset --hard origin/master</code></pre><h3 id="5、查看我的分支和-master-的不同"><a href="#5、查看我的分支和-master-的不同" class="headerlink" title="5、查看我的分支和 master 的不同"></a>5、查看我的分支和 master 的不同</h3><pre><code>git diff master..my-branch</code></pre><h3 id="6、定制提交"><a href="#6、定制提交" class="headerlink" title="6、定制提交"></a>6、定制提交</h3><pre><code># 编辑上次提交git commit --amend -m &quot;更好的提交日志&quot;# 在上次提交中附加一些内容，保持提交日志不变git add . &amp;&amp; git commit --amend --no-edit# 空提交 —— 可以用来重新触发 CI 构建git commit --allow-empty -m &quot;chore: re-trigger build&quot;</code></pre><h3 id="7、squash-提交"><a href="#7、squash-提交" class="headerlink" title="7、squash 提交"></a>7、squash 提交</h3><p>比方说我想要 rebase 最近 3 个提交：</p><pre><code>- git rebase -i HEAD~3- 保留第一行的 pick，剩余提交替换为 squash 或 s- 清理提交日志并保存（vi 编辑器中键入 :wq 即可保存）pick 64d26a1 feat: add index.jss 45f0259 fix: update index.jss 8b15b0a fix: typo in index.js</code></pre><h3 id="8、修正"><a href="#8、修正" class="headerlink" title="8、修正"></a>8、修正</h3><p>比方说想在提交 fed14a4c 加上一些内容。</p><p><img src="/images/2020/2/git提交分支.png" alt="&quot;git工作流程图&quot;"></p><pre><code>git add .git commit --fixup HEAD~1# 或者也可以用提交的哈希值（fed14a4c）替换 HEAD~1git rebase -i HEAD~3 --autosquash# 保存并退出文件（VI 中输入 `:wq`）</code></pre><h3 id="9、rebase-的时候在每个提交上执行命令"><a href="#9、rebase-的时候在每个提交上执行命令" class="headerlink" title="9、rebase 的时候在每个提交上执行命令"></a>9、rebase 的时候在每个提交上执行命令</h3><p>如果特性很多，一个分支里可能有多个提交。如果测试失败了，你希望能找到导致测试失败的提交。这时候你可以使用 rebase –exec 命令在每个提交上执行命令。</p><pre><code># 在最近 3 个提交上运行 `npm test` 命令git rebase HEAD~3 --exec &quot;npm test&quot;</code></pre><p><img src="/images/2020/2/在每个提交上执行命令.png" alt="&quot;git工作流程图&quot;"></p><h3 id="10、暂存"><a href="#10、暂存" class="headerlink" title="10、暂存"></a>10、暂存</h3><p>暂存不止是 git stash 和 git stash pop ;)</p><pre><code># 保存所有正在追踪的文件git stash save &quot;日志信息&quot;# 列出所有的暂存项git stash list# 获取并删除暂存项git stash apply stash@{1}git stash drop stash@{1}# ……或使用一条命令……git stash pop stash@{1}</code></pre><h3 id="11、清理"><a href="#11、清理" class="headerlink" title="11、清理"></a>11、清理</h3><pre><code># 移除远程仓库上不存在的分支git fetch -p# 移除所有包含 `greenkeeper` 的分支git fetch -p &amp;&amp; git branch --remote | fgrep greenkeeper | sed &apos;s/^.\{9\}//&apos; | xargs git push origin --delete</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/2020/2/git工作流程图.png&quot; alt=&quot;&amp;quot;git工作流程图&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、跳到之前的分支&quot;&gt;&lt;a href=&quot;#1、跳到之前的分支&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 最长公共前缀</title>
    <link href="http://www.echodemo.cc/2020/01/18/LeetCode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://www.echodemo.cc/2020/01/18/LeetCode-最长公共前缀/</id>
    <published>2020-01-18T02:20:19.000Z</published>
    <updated>2020-01-18T11:41:00.979Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><pre><code>示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h3 id="题解：一个字符一个字符比较"><a href="#题解：一个字符一个字符比较" class="headerlink" title="题解：一个字符一个字符比较"></a>题解：一个字符一个字符比较</h3><pre><code>class Solution {    public String longestCommonPrefix(String[] strs) {        int strsLen = strs.length;        if (strsLen == 0) {            return &quot;&quot;;        }        int str1Len = strs[0].length();        int i = 0;        String str1 = strs[0];        for (i = 0; i &lt; str1Len; i++) {            char c = str1.charAt(i);            int k = 1;            for (int j = 1; j &lt; strsLen; j++) {                if (strs[j].length() &lt;= i)                    break;                if (c == strs[j].charAt(i))                    k++;            }            if (k == strsLen) {                continue;            } else {                break;            }        }        if (i == 0) {            return &quot;&quot;;        } else {            return str1.substring(0, i);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]
输出
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 罗马数字转整型</title>
    <link href="http://www.echodemo.cc/2020/01/12/LeetCode-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2020/01/12/LeetCode-罗马数字转整型/</id>
    <published>2020-01-12T09:04:35.000Z</published>
    <updated>2020-01-13T13:17:50.336Z</updated>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><pre><code>示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><h3 id="题解一：纯遍历（map）"><a href="#题解一：纯遍历（map）" class="headerlink" title="题解一：纯遍历（map）:"></a>题解一：纯遍历（map）:</h3><pre><code>class Solution {    public int romanToInt(String s) {        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(7);        map.put(&apos;I&apos;, 1);        map.put(&apos;V&apos;, 5);        map.put(&apos;X&apos;, 10);        map.put(&apos;L&apos;, 50);        map.put(&apos;C&apos;, 100);        map.put(&apos;D&apos;, 500);        map.put(&apos;M&apos;, 1000);        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = map.get(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = map.get(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }}</code></pre><h3 id="题解二-switch-："><a href="#题解二-switch-：" class="headerlink" title="题解二(switch)："></a>题解二(switch)：</h3><pre><code>class Solution {    public int romanToInt(String s) {        int sum = 0;        int len = s.length();        for (int i = 0; i &lt; len; i++) {            int current = getValue(s.charAt(i));            if (i == len - 1) {                sum += current;                break;            }            int right = getValue(s.charAt(i + 1));            if (current &lt; right) {                sum += (right - current);                i++;            } else {                sum += current;            }        }        return sum;    }    private int getValue(char c) {        switch (c) {            case &apos;I&apos;: return 1;            case &apos;V&apos;: return 5;            case &apos;X&apos;: return 10;            case &apos;L&apos;: return 50;            case &apos;C&apos;: return 100;            case &apos;D&apos;: return 500;            case &apos;M&apos;: return 1000;            default : return 0;        }    }}(1)执行用时 :4 ms, 在所有 Java 提交中击败了99.96%的用户(2)内存消耗 :35.9 MB, 在所有 Java 提交中击败了99.59%的用户</code></pre><p>switch语句被编译后，对应得是jvm的tableswitch指令，执行起来也就几条指令就完成了;而HashMap的get操作源码如下:</p><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    int hash = hash(key.hashCode());    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];         e != null;         e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    return null;}</code></pre><p>所以map.get执行的jvm指令肯定是要比tableswitch要多的。但是如果JVM在执行的过程中进行JIT优化会发现，map的执行速度会大大加快，而使用switch实现的方法并不会被优化。</p><h4 id="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"><a href="#所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。" class="headerlink" title="所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。"></a>所以我们可以得出结论：leetcode的代码性能测试，都是基于java原生的数据结构进行的。因此我们不能为了做算法题而做算法题，代码性能优化的过程才能让我们更了解底层的数据结构。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C      
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="http://www.echodemo.cc/2020/01/11/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.echodemo.cc/2020/01/11/docker常用命令/</id>
    <published>2020-01-11T13:00:23.000Z</published>
    <updated>2020-02-08T03:55:23.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker镜像常用命令"><a href="#docker镜像常用命令" class="headerlink" title="docker镜像常用命令"></a>docker镜像常用命令</h3><h4 id="什么是docker镜像？"><a href="#什么是docker镜像？" class="headerlink" title="什么是docker镜像？"></a>什么是docker镜像？</h4><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root文件系统。比如官方镜像centos:latest 就包含了完整的一套centos:latest最小系统的root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</strong></p><p>镜像由多层文件系统联合组成。被称之为<strong>分层存储。</strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。<strong>分层存储这一特点会在下载镜像的时候显现出来。</strong></p><h4 id="1、搜索镜像"><a href="#1、搜索镜像" class="headerlink" title="1、搜索镜像"></a>1、搜索镜像</h4><pre><code>docker search java</code></pre><h4 id="2、下载镜像"><a href="#2、下载镜像" class="headerlink" title="2、下载镜像"></a>2、下载镜像</h4><pre><code>// 由于docker search命令只能查找出是否有该镜像，不能找到该镜像支持的版本，所以我们需要通过docker hub来搜索支持的版本。进入docker hub的官网，地址：https://hub.docker.com。然后搜索需要的镜像，查看镜像支持的版本。docker pull java:8</code></pre><h4 id="3、列出镜像"><a href="#3、列出镜像" class="headerlink" title="3、列出镜像"></a>3、列出镜像</h4><pre><code>// 查看所有镜像docker images 或 docker image ls// 查看某一个指定镜像docker image ls nginx:1.14.2// 过滤匹配镜像(nginx:latest之后下载的镜像，之前用before)docker image ls -f since=nginx:latest</code></pre><h4 id="4、删除镜像"><a href="#4、删除镜像" class="headerlink" title="4、删除镜像"></a>4、删除镜像</h4><pre><code>// 指定名称删除镜像docker rmi java:8// 指定名称删除镜像（强制）docker rmi -f java:8// 强制删除所有镜像docker rmi -f $(docker images)// 删除所有未被 tag 标记和未被容器使用的镜像docker image prune// 删除所有未被容器使用的镜像docker image prune -a</code></pre><h3 id="docker容器常用命令"><a href="#docker容器常用命令" class="headerlink" title="docker容器常用命令"></a>docker容器常用命令</h3><h4 id="什么是docker容器-Container-？"><a href="#什么是docker容器-Container-？" class="headerlink" title="什么是docker容器(Container)？"></a>什么是docker容器(Container)？</h4><p>镜像（Image）和容器（Container）有紧密的关系，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</strong></p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h4 id="1、新建并启动容器"><a href="#1、新建并启动容器" class="headerlink" title="1、新建并启动容器"></a>1、新建并启动容器</h4><pre><code>docker run -it --rm -p 80:80 --name nginx -d nginx:1.17.0 /bin/bash-i: 以交互模式运行容器，通常与 -t 同时使用-t: 为容器重新分配一个伪输入终端，进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。使用 --rm 可以避免浪费空间。-p：指定端口映射，格式为：hostPort:containerPort--name：指定运行后容器的名字为nginx,之后可以通过名字来操作容器-d：表示后台运行/bin/bash:以交互模式启动一个容器,在容器内执行/bin/bash命令。</code></pre><h4 id="2、列出容器"><a href="#2、列出容器" class="headerlink" title="2、列出容器"></a>2、列出容器</h4><pre><code>// 列出运行中的容器docker ps// 列出所有容器docker ps -a</code></pre><h4 id="3、停止-启动容器"><a href="#3、停止-启动容器" class="headerlink" title="3、停止/启动容器"></a>3、停止/启动容器</h4><pre><code>// $ContainerName及$ContainerId可以用docker ps命令查询出来docker stop $ContainerName(或者$ContainerId)// 强制停止容器docker kill $ContainerName(或者$ContainerId)// 启动已停止的容器docker start $ContainerName(或者$ContainerId)// 重启容器docker restart $ContainerName(或者$ContainerId)</code></pre><h4 id="4、进入-导入-导出容器"><a href="#4、进入-导入-导出容器" class="headerlink" title="4、进入/导入/导出容器"></a>4、进入/导入/导出容器</h4><pre><code>// 进入容器（推荐）docker exec -it $ContainerId /bin/bash// 进入容器docker attach $ContainerId// 导出容器docker export $ContainerId &gt; filename.tar// 导入容器(生成镜像)cat filename.tar | docker import - $imagename:$tag</code></pre><h4 id="5、删除容器"><a href="#5、删除容器" class="headerlink" title="5、删除容器"></a>5、删除容器</h4><pre><code>// 删除指定容器docker rm $ContainerName(或者$ContainerID)// 强制删除所有容器docker rm -f $(docker ps -a -q)// 删除所有已退出或者终止的容器docker container prune</code></pre><h4 id="6、查看容器的日志"><a href="#6、查看容器的日志" class="headerlink" title="6、查看容器的日志"></a>6、查看容器的日志</h4><pre><code>docker logs $ContainerName(或者$ContainerId)</code></pre><h4 id="7、查看容器的IP地址"><a href="#7、查看容器的IP地址" class="headerlink" title="7、查看容器的IP地址"></a>7、查看容器的IP地址</h4><pre><code>docker inspect --format &apos;{{ .NetworkSettings.IPAddress }}&apos; $ContainerName(或者$ContainerId)</code></pre><h4 id="8、同步宿主机时间到容器"><a href="#8、同步宿主机时间到容器" class="headerlink" title="8、同步宿主机时间到容器"></a>8、同步宿主机时间到容器</h4><pre><code>docker cp /etc/localtime $ContainerName(或者$ContainerId):/etc/</code></pre><h4 id="9、在宿主机查看docker使用cpu、内存、网络、io情况"><a href="#9、在宿主机查看docker使用cpu、内存、网络、io情况" class="headerlink" title="9、在宿主机查看docker使用cpu、内存、网络、io情况"></a>9、在宿主机查看docker使用cpu、内存、网络、io情况</h4><pre><code>// 查看指定容器情况docker stats $ContainerName(或者$ContainerId)// 查看所有容器情况docker stats -a</code></pre><h4 id="10、进入Docker容器内部的bash"><a href="#10、进入Docker容器内部的bash" class="headerlink" title="10、进入Docker容器内部的bash"></a>10、进入Docker容器内部的bash</h4><pre><code>docker exec -it $ContainerName /bin/bash</code></pre><h3 id="修改Docker镜像的存放位置"><a href="#修改Docker镜像的存放位置" class="headerlink" title="修改Docker镜像的存放位置"></a>修改Docker镜像的存放位置</h3><h4 id="1、查看docker镜像的存放位置"><a href="#1、查看docker镜像的存放位置" class="headerlink" title="1、查看docker镜像的存放位置"></a>1、查看docker镜像的存放位置</h4><pre><code>docker info | grep &quot;Docker Root Dir&quot;</code></pre><h4 id="2、关闭Docker服务"><a href="#2、关闭Docker服务" class="headerlink" title="2、关闭Docker服务"></a>2、关闭Docker服务</h4><pre><code>systemctl stop docker</code></pre><h4 id="3、移动目录到目标路径"><a href="#3、移动目录到目标路径" class="headerlink" title="3、移动目录到目标路径"></a>3、移动目录到目标路径</h4><pre><code>mv /var/lib/docker /mydata/docker</code></pre><h4 id="4、建立软连接"><a href="#4、建立软连接" class="headerlink" title="4、建立软连接"></a>4、建立软连接</h4><pre><code>ln -s /mydata/docker /var/lib/docker</code></pre><h4 id="什么是docker仓库-Repository-？"><a href="#什么是docker仓库-Repository-？" class="headerlink" title="什么是docker仓库(Repository)？"></a>什么是docker仓库(Repository)？</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p><p>仓库名经常以两段式路径形式出现，比如jwilder/nginx-proxy，前者往往意味着Docker Registry多用户环境下的用户名，后者则是对应的软件名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;docker镜像常用命令&quot;&gt;&lt;a href=&quot;#docker镜像常用命令&quot; class=&quot;headerlink&quot; title=&quot;docker镜像常用命令&quot;&gt;&lt;/a&gt;docker镜像常用命令&lt;/h3&gt;&lt;h4 id=&quot;什么是docker镜像？&quot;&gt;&lt;a href=&quot;#什
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装MongoDB</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85MongoDB/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装MongoDB/</id>
    <published>2020-01-11T12:50:17.000Z</published>
    <updated>2020-01-11T12:51:41.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、搜索MongoDB镜像"><a href="#1、搜索MongoDB镜像" class="headerlink" title="1、搜索MongoDB镜像"></a>1、搜索MongoDB镜像</h3><pre><code>docker search mongodb</code></pre><h3 id="2、拉取MongoDB镜像"><a href="#2、拉取MongoDB镜像" class="headerlink" title="2、拉取MongoDB镜像"></a>2、拉取MongoDB镜像</h3><pre><code>docker pull mongo:4.0.14</code></pre><h3 id="3-查看本地的镜像"><a href="#3-查看本地的镜像" class="headerlink" title="3.查看本地的镜像"></a>3.查看本地的镜像</h3><pre><code>docker images mongo</code></pre><h3 id="4、启动mongo-27017为端口号"><a href="#4、启动mongo-27017为端口号" class="headerlink" title="4、启动mongo (27017为端口号)"></a>4、启动mongo (27017为端口号)</h3><pre><code>docker run -p 27017:27017 -td mongo</code></pre><h3 id="5、查看启动情况"><a href="#5、查看启动情况" class="headerlink" title="5、查看启动情况"></a>5、查看启动情况</h3><pre><code>docker ps</code></pre><h3 id="6、win10下载进行navicat连接"><a href="#6、win10下载进行navicat连接" class="headerlink" title="6、win10下载进行navicat连接"></a>6、win10下载进行navicat连接</h3><h3 id="7、进入到mongodb容器"><a href="#7、进入到mongodb容器" class="headerlink" title="7、进入到mongodb容器"></a>7、进入到mongodb容器</h3><pre><code>docker exec -it  371601d910b8  mongo admin (以管理员身份进入 371601d910b8 镜像运行id通过docker ps查看)容器停止退出，命令： exit</code></pre><h3 id="8、docker-exec进入Docker容器"><a href="#8、docker-exec进入Docker容器" class="headerlink" title="8、docker exec进入Docker容器"></a>8、docker exec进入Docker容器</h3><pre><code>sudo docker exec -it 775c7c9ee1e1 /bin/bash (-it 标准输入和关联伪终端，-it后跟容器ID，/bin/bash是命令，表示在该容器中运行该命令)</code></pre><h3 id="9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID"><a href="#9、停止docker服务-docker-stop-42141931ccd6-42141931ccd6-为容器ID" class="headerlink" title="9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)"></a>9、停止docker服务  docker stop 42141931ccd6 (42141931ccd6 为容器ID)</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;a href=&quot;#1、搜索MongoDB镜像&quot; class=&quot;headerlink&quot; title=&quot;1、搜索MongoDB镜像&quot;&gt;&lt;/a&gt;1、搜索MongoDB镜像&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;docker search mong
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="MongoDB" scheme="http://www.echodemo.cc/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>在centos7的docker当中安装RabbitMQ</title>
    <link href="http://www.echodemo.cc/2020/01/11/%E5%9C%A8centos7%E7%9A%84docker%E5%BD%93%E4%B8%AD%E5%AE%89%E8%A3%85RabbitMQ/"/>
    <id>http://www.echodemo.cc/2020/01/11/在centos7的docker当中安装RabbitMQ/</id>
    <published>2020-01-11T12:48:06.000Z</published>
    <updated>2020-01-11T12:50:15.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、访问：https-hub-docker-com"><a href="#1、访问：https-hub-docker-com" class="headerlink" title="1、访问：https://hub.docker.com/"></a>1、访问：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></h3><h3 id="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。"><a href="#2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3-7-17-management。" class="headerlink" title="2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。"></a>2、搜索rabbitmq，进入该镜像的标签页，选择一个合适的版本，这里选择3.7.17-management。</h3><h3 id="3、拉取镜像："><a href="#3、拉取镜像：" class="headerlink" title="3、拉取镜像："></a>3、拉取镜像：</h3><pre><code>docker pull rabbitmq:3.7.17-management</code></pre><h3 id="4、查看是否拉取成功"><a href="#4、查看是否拉取成功" class="headerlink" title="4、查看是否拉取成功"></a>4、查看是否拉取成功</h3><pre><code>docker images</code></pre><h3 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h3><pre><code>docker run -d -p 5672:5672 -p 15672:15672  --name rabbitmq  7601e834fa14-d：后台运行-p：映射端口-p 5672:5672 ：把主机的5672端口映射成rabbitMQ的5672端口-p 15672:15672 ： web管理界面的–name :起个名字7601e834fa14：镜像的id</code></pre><h3 id="测试是否访问成功"><a href="#测试是否访问成功" class="headerlink" title="测试是否访问成功:"></a>测试是否访问成功:</h3><pre><code>在浏览器中输入：http://安装RabbitMQ的主机IP:15672 (默认的账号密码皆为guest)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、访问：https-hub-docker-com&quot;&gt;&lt;a href=&quot;#1、访问：https-hub-docker-com&quot; class=&quot;headerlink&quot; title=&quot;1、访问：https://hub.docker.com/&quot;&gt;&lt;/a&gt;1、访问：&lt;a 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.echodemo.cc/tags/Docker/"/>
    
      <category term="RabbitMQ" scheme="http://www.echodemo.cc/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 整数反转</title>
    <link href="http://www.echodemo.cc/2020/01/11/LeetCode-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://www.echodemo.cc/2020/01/11/LeetCode-整数反转/</id>
    <published>2020-01-11T12:23:49.000Z</published>
    <updated>2020-01-11T12:42:15.257Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><pre><code>示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21</code></pre><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h3 id="题解-一-：转化为字符串，再转回整型"><a href="#题解-一-：转化为字符串，再转回整型" class="headerlink" title="题解(一)：转化为字符串，再转回整型"></a>题解(一)：转化为字符串，再转回整型</h3><pre><code>class Solution{    public static int reverse(int x) {        String str = String.valueOf(x);        String result = &quot;&quot;;        if (&apos;-&apos; == str.charAt(0)) {            result = result + &quot;-&quot;;            str = str.substring(1);        }        int strLen = str.length();        for (int i = strLen - 1; i &gt; -1; i--) {            result = result + str.charAt(i);        }        try {            int iResult = Integer.parseInt(result);            return iResult;        } catch (NumberFormatException e) {            return 0;        }    }}</code></pre><h3 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h3><pre><code>// pop operation:pop = x % 10;x /= 10;// push operation:temp = rev * 10 + pop;rev = temp;</code></pre><p>这种方法很危险，因为当 temp = rev * 10 + pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。为了便于解释，我们假设 rev 是正数。</p><pre><code>(1）如果 temp = rev * 10 + pop 导致溢出，那么一定有 rev ≥ INTMAX / 10。(2)如果 rev &gt; INTMAX / 10 ，那么 temp = rev * 10 + pop 一定会溢出。(3)如果 rev == INTMAX / 10，那么只要 pop &gt; 7，temp = rev * 10 + pop 就会溢出。当 rev 为负时可以应用类似的逻辑。class Solution {    public int reverse(int x) {        int rev = 0;        while (x != 0) {            int pop = x % 10;            x /= 10;            if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0;            if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0;            rev = rev * 10 + pop;        }        return rev;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

输入: 123
输出: 321

示例 2:

输入: -123
输出: -321

示例 3:

输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 可被5整除的二进制前缀</title>
    <link href="http://www.echodemo.cc/2020/01/11/LeetCode-%E5%8F%AF%E8%A2%AB5%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80/"/>
    <id>http://www.echodemo.cc/2020/01/11/LeetCode-可被5整除的二进制前缀/</id>
    <published>2020-01-11T12:21:29.000Z</published>
    <updated>2020-01-11T12:46:12.955Z</updated>
    
    <content type="html"><![CDATA[<p>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。</p><pre><code>示例 1：输入：[0,1,1]输出：[true,false,false]解释：输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。示例 2：输入：[1,1,1]输出：[false,false,false]示例 3：输入：[0,1,1,1,1,1]输出：[true,false,false,false,true,false]示例 4：输入：[1,1,1,0,1]输出：[false,false,false,false,false]</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><pre><code>class Solution {    public List&lt;Boolean&gt; prefixesDivBy5(int[] A) {        int len = A.length;        int sum = 0;        List&lt;Boolean&gt; result = new ArrayList&lt;&gt;(len);        for (int i = 0; i &lt; len; i++) {            sum = ((sum &lt;&lt; 1) + A[i]) % 5;            if (sum == 0) {                result.add(i, true);            } else {                result.add(i, false);            }        }        return result;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。&lt;/p&gt;
&lt;p&gt;返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 戳气球</title>
    <link href="http://www.echodemo.cc/2020/01/05/LeetCode-%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>http://www.echodemo.cc/2020/01/05/LeetCode-戳气球/</id>
    <published>2020-01-05T12:07:36.000Z</published>
    <updated>2020-01-11T12:25:32.844Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p><pre><code>示例:输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i][j]表示第i至第j个元素这个区间能获得的最大硬币数，k表示在i,j这个区间内最后戳破的气球，状态转移方程dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]<em>nums[k]</em>nums[j])</p><pre><code>    public int maxCoins(int[] nums) {        int N = nums.length;        int len = N + 2;        int[] newNums = new int[len];        newNums[0] = 1;        newNums[len -1] = 1;        for(int i = 0; i &lt; nums.length; i++){            newNums[i+1] = nums[i];        }        int[][] dp = new int[len][len];        for (int i = 0; i &lt; len; i++) {            for (int j = 0; j &lt; len; j++) {                dp[i][j] = 0;            }        }        for (int c = 2; c &lt;= len; c++) {            for (int i = 0; i &lt; len - c; i++) {                int j = i + c;                for (int k = i + 1; k &lt; j; k++) {                    dp[i][j] = Math.max(dp[i][j], newNums[i] * newNums[k] * newNums[j]                            + dp[i][k] + dp[k][j]);                }            }        }        return dp[0][len - 1];}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] &lt;em&gt; nums[i] &lt;/em&gt; nums[right] 个硬币。 这
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 查找常用字符</title>
    <link href="http://www.echodemo.cc/2019/12/21/LeetCode-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.echodemo.cc/2019/12/21/LeetCode-查找常用字符/</id>
    <published>2019-12-21T11:02:36.000Z</published>
    <updated>2019-12-21T13:06:23.748Z</updated>
    
    <content type="html"><![CDATA[<p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><pre><code>示例 1：输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]示例 2：输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;]</code></pre><h3 id="题解一（利用set和map）："><a href="#题解一（利用set和map）：" class="headerlink" title="题解一（利用set和map）："></a>题解一（利用set和map）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    // 存放第一个字符串的字符    Set&lt;Character&gt; characterSet = new HashSet&lt;&gt;(A[0].length());    // 存放第一个字符串字符出现的次数，初始值为1    Map&lt;Character, Integer&gt; a0CharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());    // 将第一个字符串中字符装载进set和map    for (int i = 0; i&lt; A[0].length(); i++) {        // 如果set里面已经有该字符，则第一个字符串map对应的字符出现次数加一        if (characterSet.contains(A[0].charAt(i))) {            a0CharacterIntegerMap.put(A[0].charAt(i), a0CharacterIntegerMap.get(A[0].charAt(i)) + 1);        } else {            // 如果没有，则将该字符都初始化进map和set            characterSet.add(A[0].charAt(i));            a0CharacterIntegerMap.put(A[0].charAt(i), 1);        }    }    // 对剩下的字符串进行处理    for (int i = 1; i &lt; A.length; i++) {        // 每个字符串字符的临时map，初始值为0        Map&lt;Character, Integer&gt; tempCharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());        for (int j = 0; j&lt; A[i].length(); j++) {            if (!tempCharacterIntegerMap.containsKey(A[i].charAt(j))) {                tempCharacterIntegerMap.put(A[i].charAt(j), 0);            }            if (characterSet.contains((A[i].charAt(j)))) {                tempCharacterIntegerMap.put(A[i].charAt(j), tempCharacterIntegerMap.get(A[i].charAt(j)) + 1);            }        }        // 将临时map和第一个字符串的map作比较并处理        for (int j = 0; j &lt; A[0].length(); j++) {            // 如果临时map没有第一个字符串map里面的字符，则第一个字符串map的该字符出现次数置为0            if (!tempCharacterIntegerMap.containsKey(A[0].charAt(j))) {                a0CharacterIntegerMap.put(A[0].charAt(j), 0);            } else {                // 如果临时map有第一个字符串map里面的字符，且临时map出现的次数更少，则取更少次数的值                if (a0CharacterIntegerMap                        .get(A[0].charAt(j)) &gt; tempCharacterIntegerMap.get(A[0].charAt(j))) {                    a0CharacterIntegerMap.put(A[0].charAt(j), tempCharacterIntegerMap.get(A[0].charAt(j)));                }            }        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    // 遍历set，取第一个字符串字符对应的出现次数    for (Character character : characterSet) {        if (a0CharacterIntegerMap.get(character) &gt; 0) {            for (int i = 0; i &lt; a0CharacterIntegerMap.get(character); i++) {                list.add(String.valueOf(character));            }        }    }    return list;}</code></pre><h3 id="题解二（抓住提示字符都是小写字母）："><a href="#题解二（抓住提示字符都是小写字母）：" class="headerlink" title="题解二（抓住提示字符都是小写字母）："></a>题解二（抓住提示字符都是小写字母）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    int[] a0 = new int[26];    for (int i = 0; i &lt; 26; i++) {        a0[i] = Integer.MAX_VALUE;    }    for (String str : A) {        // 初始化        int[] temp = new int[26];        for (int i = 0; i &lt; 26; i++) {            temp[i] = 0;        }        // 统计字符出现次数        for (char c : str.toCharArray()) {            temp[c - &apos;a&apos;]++;        }        for (int i = 0; i &lt; 26; i++) {            a0[i] = Math.min(a0[i], temp[i]);        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 26; i++) {        while (a0[i] &gt; 0) {            list.add(String.valueOf((char)(&apos;a&apos; + i)));            a0[i]--;        }    }    return list;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 两数之和</title>
    <link href="http://www.echodemo.cc/2019/12/13/LeetCode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.echodemo.cc/2019/12/13/LeetCode-两数之和/</id>
    <published>2019-12-13T14:29:40.000Z</published>
    <updated>2019-12-13T14:30:04.557Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><pre><code>示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="题解一（自写暴力破解法）："><a href="#题解一（自写暴力破解法）：" class="headerlink" title="题解一（自写暴力破解法）："></a>题解一（自写暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        int i;        int j = 0;        for (i = 0; i &lt; numsLen; i++) {            boolean k = false;            for (j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    k = true;                    break;                }            }            if (k) {                break;            }        }        int[] resultIntArray = new int[2];        resultIntArray[0] = i;        resultIntArray[1] = j;        return resultIntArray;    }}</code></pre><h3 id="题解二（官方暴力破解法）："><a href="#题解二（官方暴力破解法）：" class="headerlink" title="题解二（官方暴力破解法）："></a>题解二（官方暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        for (int i = 0; i &lt; numsLen; i++) {            for (int j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    return new int[] { i, j };                }            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><p>以上两种解法的复杂度分析：</p><p>时间复杂度：O(n^2)O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n2)。</p><p>空间复杂度：O(1)O(1)。</p><h3 id="题解三（两遍哈希表）："><a href="#题解三（两遍哈希表）：" class="headerlink" title="题解三（两遍哈希表）："></a>题解三（两遍哈希表）：</h3><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            map.put(nums[i], i);        }        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {                return new int[] { i, map.get(complement) };            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><h3 id="题解四（一遍哈希表）："><a href="#题解四（一遍哈希表）：" class="headerlink" title="题解四（一遍哈希表）："></a>题解四（一遍哈希表）：</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement)) {                return new int[] { map.get(complement), i };            }            map.put(nums[i], i);        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

给定 nums
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>临飞鸟</title>
    <link href="http://www.echodemo.cc/2019/11/30/%E4%B8%B4%E9%A3%9E%E9%B8%9F/"/>
    <id>http://www.echodemo.cc/2019/11/30/临飞鸟/</id>
    <published>2019-11-30T14:32:52.000Z</published>
    <updated>2019-12-26T14:23:49.748Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>我看着窗边的单向历一页页地薄下去<br><br>就像天边的光亮一点点地变暗<br><br>他们都在悄悄地告诉我<br><br>距离见到你又更近了一步<br><br><br><br><br>此刻，我的心在扑通扑通地跳动<br><br>右手的指头轮询地敲打着木桃色的桌面<br><br>神经递质游走的能量来自于对你的想念<br><br>是你予我的记忆陪伴我度过一个个夜晚<br><br><br><br><br>也许你不太知道的是<br><br>我想和你一起去发现杭州冬天的讯息<br><br>去看曲院风荷里一陇又一陇的残荷<br><br>傍晚在苏堤春晓的尽头看雷峰夕照的倩影<br><br>以及站在断桥残雪上看整条北山街泛红的梧桐树叶<br><br><br><br><br>所有这些，甚至是在梦里<br><br>我想这我不必告诉你<br><br>在飞鸟来临的清晨<br><br>当你看到松的沉默，雪的孤寂就能明了<br><br><br><br><br>如果定要我说点什么的话<br><br>那么我所想过的最浪漫的事情<br><br>便是与你一起看遍西湖的春夏与秋冬<br><br></center><h6 id="注：致一段还未开始就已夭折的经历"><a href="#注：致一段还未开始就已夭折的经历" class="headerlink" title="注：致一段还未开始就已夭折的经历"></a>注：致一段还未开始就已夭折的经历</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;我看着窗边的单向历一页页地薄下去&lt;br&gt;&lt;br&gt;就像天边的光亮一点点地变暗&lt;br&gt;&lt;br&gt;他们都在悄悄地告诉我&lt;br&gt;&lt;br&gt;距离见到你又更近了一步&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;此刻，我的心在扑通扑通地跳动&lt;br&gt;&lt;br&gt;右手的指头轮询地
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>秋夜</title>
    <link href="http://www.echodemo.cc/2019/09/05/%E7%A7%8B%E5%A4%9C/"/>
    <id>http://www.echodemo.cc/2019/09/05/秋夜/</id>
    <published>2019-09-05T13:45:58.000Z</published>
    <updated>2019-09-15T03:19:53.438Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>秋天的夜晚能否告诉我<br><br>有谁？曾在这样的时刻走进你的心房<br><br>倾听你的低语<br><br>聆听你的呢喃<br><br>为你沉默寡言<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;秋天的夜晚能否告诉我&lt;br&gt;&lt;br&gt;有谁？曾在这样的时刻走进你的心房&lt;br&gt;&lt;br&gt;倾听你的低语&lt;br&gt;&lt;br&gt;聆听你的呢喃&lt;br&gt;&lt;br&gt;为你沉默寡言&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2019/08/31/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2019/08/31/梦境/</id>
    <published>2019-08-30T16:27:05.000Z</published>
    <updated>2019-09-15T03:18:17.604Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>深夜里的寂静<br><br>被窗檐的滴雨打碎<br><br>一束亮光侵袭眉眼<br><br>我不记得梦中的发生<br><br>清晨，傍晚或是午后<br><br>故乡，此地还是远处<br><br>我是我不是我是我不<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;深夜里的寂静&lt;br&gt;&lt;br&gt;被窗檐的滴雨打碎&lt;br&gt;&lt;br&gt;一束亮光侵袭眉眼&lt;br&gt;&lt;br&gt;我不记得梦中的发生&lt;br&gt;&lt;br&gt;清晨，傍晚或是午后&lt;br&gt;&lt;br&gt;故乡，此地还是远处&lt;br&gt;&lt;br&gt;我是我不是我是我不&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>遐想</title>
    <link href="http://www.echodemo.cc/2019/08/27/%E9%81%90%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2019/08/27/遐想/</id>
    <published>2019-08-27T15:30:41.000Z</published>
    <updated>2019-09-15T03:16:28.181Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>请你不要呼唤我的名字<br><br>傍晚天边的晚霞<br><br>秋日晴朗的天气<br><br><br><br><br>当太阳隐没之后<br><br>你就在我的眼眸里流转<br><br>还有路边小桥下的流水<br><br>都是久违的神情<br><br><br><br><br>请你不要呼唤我的名字<br><br>西北高楼里刚燃起的灯火<br><br>手中瞬息万变的一方土地<br><br><br><br><br>当尽在眼底的繁华褪去<br><br>没有人会记得你们的名字<br><br>还有那些默默相守的时光<br><br>一切都是烟云<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;请你不要呼唤我的名字&lt;br&gt;&lt;br&gt;傍晚天边的晚霞&lt;br&gt;&lt;br&gt;秋日晴朗的天气&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;当太阳隐没之后&lt;br&gt;&lt;br&gt;你就在我的眼眸里流转&lt;br&gt;&lt;br&gt;还有路边小桥下的流水&lt;br&gt;&lt;br&gt;都是久违的神情&lt;br&gt;&lt;b
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(20)-拦截器</title>
    <link href="http://www.echodemo.cc/2019/08/04/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B020)-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/08/04/springmvc学习笔记20)-拦截器/</id>
    <published>2019-08-04T12:23:29.000Z</published>
    <updated>2019-08-04T12:41:16.157Z</updated>
    
    <content type="html"><![CDATA[<center>青山隐隐水迢迢，秋尽江南草未凋。</center><br><center>二十四桥明月夜，玉人何处教吹箫？</center><br><center>—-宋·杜牧《寄扬州韩绰判官》</center><hr><h3 id="拦截定义"><a href="#拦截定义" class="headerlink" title="拦截定义"></a>拦截定义</h3><p>定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</p><pre><code>public class HandlerInterceptor1 implements HandlerInterceptor{    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><p>可以从名称和参数看出各个接口的顺序和作用:</p><pre><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{}</code></pre><p>参数最少，只有三个。进入 Handler方法之前执行。用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行。</p><pre><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception{}</code></pre><p>多了一个modelAndView参数。进入Handler方法之后，返回modelAndView之前执行应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图。</p><pre><code>public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {}</code></pre><p>多了一个Exception的类型的参数。执行Handler完成执行此方法。应用场景：统一异常处理，统一日志处理。</p><hr><h3 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h3><p>（1）针对HandlerMapping配置</p><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。</p><pre><code>&lt;bean    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;    &lt;property name=&quot;interceptors&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt;            &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt;&lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt;</code></pre><p>一般不推荐使用。</p><p>（2）类似全局的拦截器</p><p>springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;mvc:interceptor&gt;        &lt;!-- /**表示所有url包括子url路径 --&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><hr><h3 id="拦截测试"><a href="#拦截测试" class="headerlink" title="拦截测试"></a>拦截测试</h3><p>测试多个拦截器各个方法执行时机。访问/items/queryItems.action。</p><p>（1）两个拦截器都放行</p><pre><code>DEBUG [http-apr-8080-exec-1] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSourceDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC ConnectionDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSourceHandlerInterceptor2...postHandleHandlerInterceptor1...postHandleDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name &apos;items/itemsList&apos;; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name &apos;springmvc&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemtypes&apos; of type [java.util.HashMap] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsQueryVo&apos; of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;org.springframework.validation.BindingResult.itemsQueryVo&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsList&apos; of type [java.util.ArrayList] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView &apos;items/itemsList&apos;HandlerInterceptor2...afterCompletionHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-1] - Successfully completed request</code></pre><p>总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。</p><p>（2）拦截器1放行，拦截器2不放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1放行，拦截器2 preHandle才会执行。2、拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。3、只要有一个拦截器不放行，postHandle不会执行。</code></pre><p>（3）两个拦截器都不放</p><pre><code>DEBUG [http-apr-8080-exec-9] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-9] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。2、拦截器1 preHandle不放行，拦截器2不执行。</code></pre><p>（4）拦截器1不放行，拦截器2放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>根据测试结果，对拦截器应用。</p><p>比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</p><p>比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）</p><hr><h3 id="拦截器应用-实现登陆认证"><a href="#拦截器应用-实现登陆认证" class="headerlink" title="拦截器应用(实现登陆认证)"></a>拦截器应用(实现登陆认证)</h3><p>(1)需求</p><pre><code>1、用户请求url2、拦截器进行拦截校验     （1）如果请求的url是公开地址（无需登陆即可访问的url），让放行。    （2）如果用户session 不存在跳转到登陆页面。    （3）如果用户session存在放行，继续操作。</code></pre><p>（2）登陆controller方法</p><pre><code>@Controllerpublic class LoginController {    // 登陆    @RequestMapping(&quot;/login&quot;)    public String login(HttpSession session, String username, String password)            throws Exception {        // 调用service进行用户身份验证        // ...        // 在session中保存用户身份信息        session.setAttribute(&quot;username&quot;, username);        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }    // 退出    @RequestMapping(&quot;/logout&quot;)    public String logout(HttpSession session) throws Exception {        // 清除session        session.invalidate();        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }}</code></pre><p>（3）登陆认证拦截实现</p><p>代码实现：</p><pre><code>public class LoginInterceptor implements HandlerInterceptor {    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response, Object handler) throws Exception {        //获取请求的url        String url = request.getRequestURI();        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）        //这里公开地址是登陆提交的地址        if(url.indexOf(&quot;login.action&quot;)&gt;=0){            //如果进行登陆提交，放行            return true;        }        //判断session        HttpSession session  = request.getSession();        //从session中取出用户身份信息        String username = (String) session.getAttribute(&quot;username&quot;);        if(username != null){            //身份存在，放行            return true;        }        //执行这里表示用户身份需要认证，跳转登陆页面        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request,                           HttpServletResponse response, Object handler,                           ModelAndView modelAndView) throws Exception {        System.out.println(&quot;LoginInterceptor...postHandle&quot;);    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request,                                HttpServletResponse response, Object handler, Exception ex)            throws Exception {        System.out.println(&quot;LoginInterceptor...afterCompletion&quot;);    }}</code></pre><p>拦截器配置：</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;!-- 登陆认证拦截器 --&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    ......&lt;/mvc:interceptors&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;青山隐隐水迢迢，秋尽江南草未凋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;二十四桥明月夜，玉人何处教吹箫？&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·杜牧《寄扬州韩绰判官》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;拦截定义&quot;&gt;&lt;a href=&quot;#拦截定
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
