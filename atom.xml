<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2020-01-05T12:13:32.386Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 戳气球</title>
    <link href="http://www.echodemo.cc/2020/01/05/LeetCode-%E6%88%B3%E6%B0%94%E7%90%83/"/>
    <id>http://www.echodemo.cc/2020/01/05/LeetCode-戳气球/</id>
    <published>2020-01-05T12:07:36.000Z</published>
    <updated>2020-01-05T12:13:32.386Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><pre><code>输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</code></pre><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>dp[i][j]表示第i至第j个元素这个区间能获得的最大硬币数，k表示在i,j这个区间内最后戳破的气球，状态转移方程dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]<em>nums[k]</em>nums[j])</p><pre><code>    public int maxCoins(int[] nums) {        int N = nums.length;        int len = N + 2;        int[] newNums = new int[len];        newNums[0] = 1;        newNums[len -1] = 1;        for(int i = 0; i &lt; nums.length; i++){            newNums[i+1] = nums[i];        }        int[][] dp = new int[len][len];        for (int i = 0; i &lt; len; i++) {            for (int j = 0; j &lt; len; j++) {                dp[i][j] = 0;            }        }        for (int c = 2; c &lt;= len; c++) {            for (int i = 0; i &lt; len - c; i++) {                int j = i + c;                for (int k = i + 1; k &lt; j; k++) {                    dp[i][j] = Math.max(dp[i][j], newNums[i] * newNums[k] * newNums[j]                            + dp[i][k] + dp[k][j]);                }            }        }        return dp[0][len - 1];}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] &lt;em&gt; nums[i] &lt;/em&gt; nums[right] 个硬币。 这
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 查找常用字符</title>
    <link href="http://www.echodemo.cc/2019/12/21/LeetCode-%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/"/>
    <id>http://www.echodemo.cc/2019/12/21/LeetCode-查找常用字符/</id>
    <published>2019-12-21T11:02:36.000Z</published>
    <updated>2019-12-21T13:06:23.748Z</updated>
    
    <content type="html"><![CDATA[<p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><pre><code>示例 1：输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]示例 2：输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;]</code></pre><h3 id="题解一（利用set和map）："><a href="#题解一（利用set和map）：" class="headerlink" title="题解一（利用set和map）："></a>题解一（利用set和map）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    // 存放第一个字符串的字符    Set&lt;Character&gt; characterSet = new HashSet&lt;&gt;(A[0].length());    // 存放第一个字符串字符出现的次数，初始值为1    Map&lt;Character, Integer&gt; a0CharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());    // 将第一个字符串中字符装载进set和map    for (int i = 0; i&lt; A[0].length(); i++) {        // 如果set里面已经有该字符，则第一个字符串map对应的字符出现次数加一        if (characterSet.contains(A[0].charAt(i))) {            a0CharacterIntegerMap.put(A[0].charAt(i), a0CharacterIntegerMap.get(A[0].charAt(i)) + 1);        } else {            // 如果没有，则将该字符都初始化进map和set            characterSet.add(A[0].charAt(i));            a0CharacterIntegerMap.put(A[0].charAt(i), 1);        }    }    // 对剩下的字符串进行处理    for (int i = 1; i &lt; A.length; i++) {        // 每个字符串字符的临时map，初始值为0        Map&lt;Character, Integer&gt; tempCharacterIntegerMap = new HashMap&lt;&gt;(A[0].length());        for (int j = 0; j&lt; A[i].length(); j++) {            if (!tempCharacterIntegerMap.containsKey(A[i].charAt(j))) {                tempCharacterIntegerMap.put(A[i].charAt(j), 0);            }            if (characterSet.contains((A[i].charAt(j)))) {                tempCharacterIntegerMap.put(A[i].charAt(j), tempCharacterIntegerMap.get(A[i].charAt(j)) + 1);            }        }        // 将临时map和第一个字符串的map作比较并处理        for (int j = 0; j &lt; A[0].length(); j++) {            // 如果临时map没有第一个字符串map里面的字符，则第一个字符串map的该字符出现次数置为0            if (!tempCharacterIntegerMap.containsKey(A[0].charAt(j))) {                a0CharacterIntegerMap.put(A[0].charAt(j), 0);            } else {                // 如果临时map有第一个字符串map里面的字符，且临时map出现的次数更少，则取更少次数的值                if (a0CharacterIntegerMap                        .get(A[0].charAt(j)) &gt; tempCharacterIntegerMap.get(A[0].charAt(j))) {                    a0CharacterIntegerMap.put(A[0].charAt(j), tempCharacterIntegerMap.get(A[0].charAt(j)));                }            }        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    // 遍历set，取第一个字符串字符对应的出现次数    for (Character character : characterSet) {        if (a0CharacterIntegerMap.get(character) &gt; 0) {            for (int i = 0; i &lt; a0CharacterIntegerMap.get(character); i++) {                list.add(String.valueOf(character));            }        }    }    return list;}</code></pre><h3 id="题解二（抓住提示字符都是小写字母）："><a href="#题解二（抓住提示字符都是小写字母）：" class="headerlink" title="题解二（抓住提示字符都是小写字母）："></a>题解二（抓住提示字符都是小写字母）：</h3><pre><code>@ApiOperation(&quot;LeetCode算法题测试&quot;)@RequestMapping(value = &quot;/algorithm&quot;, method = RequestMethod.POST)@ResponseBodypublic List&lt;String&gt; algorithm(String[] A) {    int[] a0 = new int[26];    for (int i = 0; i &lt; 26; i++) {        a0[i] = Integer.MAX_VALUE;    }    for (String str : A) {        // 初始化        int[] temp = new int[26];        for (int i = 0; i &lt; 26; i++) {            temp[i] = 0;        }        // 统计字符出现次数        for (char c : str.toCharArray()) {            temp[c - &apos;a&apos;]++;        }        for (int i = 0; i &lt; 26; i++) {            a0[i] = Math.min(a0[i], temp[i]);        }    }    List&lt;String&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 26; i++) {        while (a0[i] &gt; 0) {            list.add(String.valueOf((char)(&apos;a&apos; + i)));            a0[i]--;        }    }    return list;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 两数之和</title>
    <link href="http://www.echodemo.cc/2019/12/13/LeetCode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.echodemo.cc/2019/12/13/LeetCode-两数之和/</id>
    <published>2019-12-13T14:29:40.000Z</published>
    <updated>2019-12-13T14:30:04.557Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><pre><code>示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="题解一（自写暴力破解法）："><a href="#题解一（自写暴力破解法）：" class="headerlink" title="题解一（自写暴力破解法）："></a>题解一（自写暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        int i;        int j = 0;        for (i = 0; i &lt; numsLen; i++) {            boolean k = false;            for (j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    k = true;                    break;                }            }            if (k) {                break;            }        }        int[] resultIntArray = new int[2];        resultIntArray[0] = i;        resultIntArray[1] = j;        return resultIntArray;    }}</code></pre><h3 id="题解二（官方暴力破解法）："><a href="#题解二（官方暴力破解法）：" class="headerlink" title="题解二（官方暴力破解法）："></a>题解二（官方暴力破解法）：</h3><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        int numsLen = nums.length;        for (int i = 0; i &lt; numsLen; i++) {            for (int j = i + 1; j &lt; numsLen; j++) {                if ((nums[i] + nums[j]) == target) {                    return new int[] { i, j };                }            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><p>以上两种解法的复杂度分析：</p><p>时间复杂度：O(n^2)O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n2)。</p><p>空间复杂度：O(1)O(1)。</p><h3 id="题解三（两遍哈希表）："><a href="#题解三（两遍哈希表）：" class="headerlink" title="题解三（两遍哈希表）："></a>题解三（两遍哈希表）：</h3><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            map.put(nums[i], i);        }        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {                return new int[] { i, map.get(complement) };            }        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre><h3 id="题解四（一遍哈希表）："><a href="#题解四（一遍哈希表）：" class="headerlink" title="题解四（一遍哈希表）："></a>题解四（一遍哈希表）：</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><pre><code>class Solution {    public int[] twoSum(int[] nums, int target) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) {            int complement = target - nums[i];            if (map.containsKey(complement)) {                return new int[] { map.get(complement), i };            }            map.put(nums[i], i);        }        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例:

给定 nums
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>临飞鸟</title>
    <link href="http://www.echodemo.cc/2019/11/30/%E4%B8%B4%E9%A3%9E%E9%B8%9F/"/>
    <id>http://www.echodemo.cc/2019/11/30/临飞鸟/</id>
    <published>2019-11-30T14:32:52.000Z</published>
    <updated>2019-12-26T14:23:49.748Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>我看着窗边的单向历一页页地薄下去<br><br>就像天边的光亮一点点地变暗<br><br>他们都在悄悄地告诉我<br><br>距离见到你又更近了一步<br><br><br><br><br>此刻，我的心在扑通扑通地跳动<br><br>右手的指头轮询地敲打着木桃色的桌面<br><br>神经递质游走的能量来自于对你的想念<br><br>是你予我的记忆陪伴我度过一个个夜晚<br><br><br><br><br>也许你不太知道的是<br><br>我想和你一起去发现杭州冬天的讯息<br><br>去看曲院风荷里一陇又一陇的残荷<br><br>傍晚在苏堤春晓的尽头看雷峰夕照的倩影<br><br>以及站在断桥残雪上看整条北山街泛红的梧桐树叶<br><br><br><br><br>所有这些，甚至是在梦里<br><br>我想这我不必告诉你<br><br>在飞鸟来临的清晨<br><br>当你看到松的沉默，雪的孤寂就能明了<br><br><br><br><br>如果定要我说点什么的话<br><br>那么我所想过的最浪漫的事情<br><br>便是与你一起看遍西湖的春夏与秋冬<br><br></center><h6 id="注：致一段还未开始就已夭折的经历"><a href="#注：致一段还未开始就已夭折的经历" class="headerlink" title="注：致一段还未开始就已夭折的经历"></a>注：致一段还未开始就已夭折的经历</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;我看着窗边的单向历一页页地薄下去&lt;br&gt;&lt;br&gt;就像天边的光亮一点点地变暗&lt;br&gt;&lt;br&gt;他们都在悄悄地告诉我&lt;br&gt;&lt;br&gt;距离见到你又更近了一步&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;此刻，我的心在扑通扑通地跳动&lt;br&gt;&lt;br&gt;右手的指头轮询地
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>秋夜</title>
    <link href="http://www.echodemo.cc/2019/09/05/%E7%A7%8B%E5%A4%9C/"/>
    <id>http://www.echodemo.cc/2019/09/05/秋夜/</id>
    <published>2019-09-05T13:45:58.000Z</published>
    <updated>2019-09-15T03:19:53.438Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>秋天的夜晚能否告诉我<br><br>有谁？曾在这样的时刻走进你的心房<br><br>倾听你的低语<br><br>聆听你的呢喃<br><br>为你沉默寡言<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;秋天的夜晚能否告诉我&lt;br&gt;&lt;br&gt;有谁？曾在这样的时刻走进你的心房&lt;br&gt;&lt;br&gt;倾听你的低语&lt;br&gt;&lt;br&gt;聆听你的呢喃&lt;br&gt;&lt;br&gt;为你沉默寡言&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2019/08/31/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2019/08/31/梦境/</id>
    <published>2019-08-30T16:27:05.000Z</published>
    <updated>2019-09-15T03:18:17.604Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>深夜里的寂静<br><br>被窗檐的滴雨打碎<br><br>一束亮光侵袭眉眼<br><br>我不记得梦中的发生<br><br>清晨，傍晚或是午后<br><br>故乡，此地还是远处<br><br>我是我不是我是我不<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;深夜里的寂静&lt;br&gt;&lt;br&gt;被窗檐的滴雨打碎&lt;br&gt;&lt;br&gt;一束亮光侵袭眉眼&lt;br&gt;&lt;br&gt;我不记得梦中的发生&lt;br&gt;&lt;br&gt;清晨，傍晚或是午后&lt;br&gt;&lt;br&gt;故乡，此地还是远处&lt;br&gt;&lt;br&gt;我是我不是我是我不&lt;br&gt;&lt;br&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>遐想</title>
    <link href="http://www.echodemo.cc/2019/08/27/%E9%81%90%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2019/08/27/遐想/</id>
    <published>2019-08-27T15:30:41.000Z</published>
    <updated>2019-09-15T03:16:28.181Z</updated>
    
    <content type="html"><![CDATA[<center><br><br>请你不要呼唤我的名字<br><br>傍晚天边的晚霞<br><br>秋日晴朗的天气<br><br><br><br><br>当太阳隐没之后<br><br>你就在我的眼眸里流转<br><br>还有路边小桥下的流水<br><br>都是久违的神情<br><br><br><br><br>请你不要呼唤我的名字<br><br>西北高楼里刚燃起的灯火<br><br>手中瞬息万变的一方土地<br><br><br><br><br>当尽在眼底的繁华褪去<br><br>没有人会记得你们的名字<br><br>还有那些默默相守的时光<br><br>一切都是烟云<br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;br&gt;请你不要呼唤我的名字&lt;br&gt;&lt;br&gt;傍晚天边的晚霞&lt;br&gt;&lt;br&gt;秋日晴朗的天气&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;当太阳隐没之后&lt;br&gt;&lt;br&gt;你就在我的眼眸里流转&lt;br&gt;&lt;br&gt;还有路边小桥下的流水&lt;br&gt;&lt;br&gt;都是久违的神情&lt;br&gt;&lt;b
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(20)-拦截器</title>
    <link href="http://www.echodemo.cc/2019/08/04/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B020)-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/08/04/springmvc学习笔记20)-拦截器/</id>
    <published>2019-08-04T12:23:29.000Z</published>
    <updated>2019-08-04T12:41:16.157Z</updated>
    
    <content type="html"><![CDATA[<center>青山隐隐水迢迢，秋尽江南草未凋。</center><br><center>二十四桥明月夜，玉人何处教吹箫？</center><br><center>—-宋·杜牧《寄扬州韩绰判官》</center><hr><h3 id="拦截定义"><a href="#拦截定义" class="headerlink" title="拦截定义"></a>拦截定义</h3><p>定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</p><pre><code>public class HandlerInterceptor1 implements HandlerInterceptor{    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><p>可以从名称和参数看出各个接口的顺序和作用:</p><pre><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception{}</code></pre><p>参数最少，只有三个。进入 Handler方法之前执行。用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行。</p><pre><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception{}</code></pre><p>多了一个modelAndView参数。进入Handler方法之后，返回modelAndView之前执行应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图。</p><pre><code>public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {}</code></pre><p>多了一个Exception的类型的参数。执行Handler完成执行此方法。应用场景：统一异常处理，统一日志处理。</p><hr><h3 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h3><p>（1）针对HandlerMapping配置</p><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。</p><pre><code>&lt;bean    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;    &lt;property name=&quot;interceptors&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt;            &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt;&lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt;</code></pre><p>一般不推荐使用。</p><p>（2）类似全局的拦截器</p><p>springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;mvc:interceptor&gt;        &lt;!-- /**表示所有url包括子url路径 --&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><hr><h3 id="拦截测试"><a href="#拦截测试" class="headerlink" title="拦截测试"></a>拦截测试</h3><p>测试多个拦截器各个方法执行时机。访问/items/queryItems.action。</p><p>（1）两个拦截器都放行</p><pre><code>DEBUG [http-apr-8080-exec-1] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSourceDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC ConnectionDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSourceHandlerInterceptor2...postHandleHandlerInterceptor1...postHandleDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name &apos;items/itemsList&apos;; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name &apos;springmvc&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemtypes&apos; of type [java.util.HashMap] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsQueryVo&apos; of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;org.springframework.validation.BindingResult.itemsQueryVo&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsList&apos; of type [java.util.ArrayList] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView &apos;items/itemsList&apos;HandlerInterceptor2...afterCompletionHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-1] - Successfully completed request</code></pre><p>总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。</p><p>（2）拦截器1放行，拦截器2不放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1放行，拦截器2 preHandle才会执行。2、拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。3、只要有一个拦截器不放行，postHandle不会执行。</code></pre><p>（3）两个拦截器都不放</p><pre><code>DEBUG [http-apr-8080-exec-9] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-9] - Successfully completed request</code></pre><p>总结：</p><pre><code>1、拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。2、拦截器1 preHandle不放行，拦截器2不执行。</code></pre><p>（4）拦截器1不放行，拦截器2放行</p><pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-8] - Successfully completed request</code></pre><p>和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>根据测试结果，对拦截器应用。</p><p>比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</p><p>比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）</p><hr><h3 id="拦截器应用-实现登陆认证"><a href="#拦截器应用-实现登陆认证" class="headerlink" title="拦截器应用(实现登陆认证)"></a>拦截器应用(实现登陆认证)</h3><p>(1)需求</p><pre><code>1、用户请求url2、拦截器进行拦截校验     （1）如果请求的url是公开地址（无需登陆即可访问的url），让放行。    （2）如果用户session 不存在跳转到登陆页面。    （3）如果用户session存在放行，继续操作。</code></pre><p>（2）登陆controller方法</p><pre><code>@Controllerpublic class LoginController {    // 登陆    @RequestMapping(&quot;/login&quot;)    public String login(HttpSession session, String username, String password)            throws Exception {        // 调用service进行用户身份验证        // ...        // 在session中保存用户身份信息        session.setAttribute(&quot;username&quot;, username);        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }    // 退出    @RequestMapping(&quot;/logout&quot;)    public String logout(HttpSession session) throws Exception {        // 清除session        session.invalidate();        // 重定向到商品列表页面        return &quot;redirect:/items/queryItems.action&quot;;    }}</code></pre><p>（3）登陆认证拦截实现</p><p>代码实现：</p><pre><code>public class LoginInterceptor implements HandlerInterceptor {    //进入 Handler方法之前执行    //用于身份认证、身份授权    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response, Object handler) throws Exception {        //获取请求的url        String url = request.getRequestURI();        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）        //这里公开地址是登陆提交的地址        if(url.indexOf(&quot;login.action&quot;)&gt;=0){            //如果进行登陆提交，放行            return true;        }        //判断session        HttpSession session  = request.getSession();        //从session中取出用户身份信息        String username = (String) session.getAttribute(&quot;username&quot;);        if(username != null){            //身份存在，放行            return true;        }        //执行这里表示用户身份需要认证，跳转登陆页面        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);        //return false表示拦截，不向下执行        //return true表示放行        return false;    }    //进入Handler方法之后，返回modelAndView之前执行    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图    public void postHandle(HttpServletRequest request,                           HttpServletResponse response, Object handler,                           ModelAndView modelAndView) throws Exception {        System.out.println(&quot;LoginInterceptor...postHandle&quot;);    }    //执行Handler完成执行此方法    //应用场景：统一异常处理，统一日志处理    public void afterCompletion(HttpServletRequest request,                                HttpServletResponse response, Object handler, Exception ex)            throws Exception {        System.out.println(&quot;LoginInterceptor...afterCompletion&quot;);    }}</code></pre><p>拦截器配置：</p><pre><code>&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt;    &lt;!--多个拦截器,顺序执行 --&gt;    &lt;!-- 登陆认证拦截器 --&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;    &lt;/mvc:interceptor&gt;    ......&lt;/mvc:interceptors&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;青山隐隐水迢迢，秋尽江南草未凋。&lt;/center&gt;&lt;br&gt;&lt;center&gt;二十四桥明月夜，玉人何处教吹箫？&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·杜牧《寄扬州韩绰判官》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;拦截定义&quot;&gt;&lt;a href=&quot;#拦截定
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(19)-RESTful支持</title>
    <link href="http://www.echodemo.cc/2019/08/04/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(19)-RESTful%E6%94%AF%E6%8C%81/"/>
    <id>http://www.echodemo.cc/2019/08/04/springmvc学习笔记(19)-RESTful支持/</id>
    <published>2019-08-04T11:40:38.000Z</published>
    <updated>2019-08-04T12:25:39.479Z</updated>
    
    <content type="html"><![CDATA[<center>人生到处知何似，应似飞鸿踏雪泥。</center><br><center>泥上偶然留指爪，鸿飞那复计东西。</center><br><center>老僧已死成新塔，坏壁无由见旧题。</center><br><center>往日崎岖还记否，路长人困蹇驴嘶。</center><br><center>—-宋·苏轼《和子由渑池怀旧》</center><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p><p>（1）对url进行规范，写RESTful格式的url</p><pre><code>1、非REST的url：http://...../queryItems.action?id=001&amp;type=T012、REST的url风格：http://..../items/001</code></pre><p>特点：url简洁，将参数通过url传到服务端。</p><p>（2）http的方法规范</p><p>不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</p><p>（3）对http的contentType规范</p><p>请求时指定contentType，要json数据，设置成json格式的type。</p><hr><h3 id="REST的例子"><a href="#REST的例子" class="headerlink" title="REST的例子"></a>REST的例子</h3><p>查询商品信息，返回json数据。</p><p>（1）controller</p><p>定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller。输出json使用@ResponseBody将java对象输出json。</p><pre><code>//查询商品信息，输出json//itemsView/{id}里边的{id}表示表示将这个位置的参数传到@PathVariable指定名称中。//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称@RequestMapping(&quot;/itemsView/{id}&quot;)public @ResponseBody ItemsCustom itemsView(@PathVariable(&quot;id&quot;) Integer items_id)throws Exception{    //调用service查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);    return itemsCustom;}</code></pre><p>@RequestMapping(value=”/itemsView/{id}”)：{×××}占位符，请求的URL可以是/viewItems/1或/viewItems/2，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。</p><p>如果@RequestMapping中表示为/itemsView/{id}，id和形参名称一致，@PathVariable不用指定名称。</p><p>（2）REST方法的前端控制器配置</p><pre><code>&lt;!-- springmvc前端控制器，rest配置 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>（3)对静态资源的解析</p><p>配置前端控制器的url-pattern中指定/，对静态资源的解析会出现问题，报404错误。在springmvc.xml中添加静态资源解析方法。</p><pre><code>&lt;!-- 静态资源解析    包括 ：js、css、img、..     --&gt;&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;</code></pre><p>这时访问<a href="http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。" target="_blank" rel="noopener">http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;人生到处知何似，应似飞鸿踏雪泥。&lt;/center&gt;&lt;br&gt;&lt;center&gt;泥上偶然留指爪，鸿飞那复计东西。&lt;/center&gt;&lt;br&gt;&lt;center&gt;老僧已死成新塔，坏壁无由见旧题。&lt;/center&gt;&lt;br&gt;&lt;center&gt;往日崎岖还记否，路长人困蹇驴嘶。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(18)-json数据交互</title>
    <link href="http://www.echodemo.cc/2019/08/01/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(18)-json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.echodemo.cc/2019/08/01/springmvc学习笔记(18)-json数据交互/</id>
    <published>2019-08-01T15:39:09.000Z</published>
    <updated>2019-08-01T15:53:19.608Z</updated>
    
    <content type="html"><![CDATA[<center>我居北海君南海，寄雁传书谢不能。</center><br><center>桃李春风一杯酒，江湖夜雨十年灯。</center><br><center>持家但有四立壁，治病不蕲三折肱。</center><br><center>想见读书头已白，隔溪猿哭瘴溪藤。</center><br><center>—-宋·黄庭坚《寄黄几复》</center><hr><p>本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互。</p><hr><h3 id="springmvc进行json交互"><a href="#springmvc进行json交互" class="headerlink" title="springmvc进行json交互"></a>springmvc进行json交互</h3><p>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。</p><p>（1）请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。</p><p>（2）请求key/value、输出json。此方法比较常用。</p><hr><h3 id="添加json转换的依赖"><a href="#添加json转换的依赖" class="headerlink" title="添加json转换的依赖"></a>添加json转换的依赖</h3><pre><code>&lt;!-- json 转换--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;    &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>查看依赖树：</p><pre><code>[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile[INFO] |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile[INFO] |  \- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile[INFO] \- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile[INFO]    \- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile</code></pre><hr><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p>在注解适配器中加入messageConverters：</p><pre><code>&lt;!--注解适配器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;    &lt;property name=&quot;messageConverters&quot;&gt;    &lt;list&gt;    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;    &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p><strong>注意：如果使用&lt;mvc:annotation-driven /&gt;则不用定义上边的内容。</strong></p><hr><h3 id="json交互测试"><a href="#json交互测试" class="headerlink" title="json交互测试"></a>json交互测试</h3><p>显示两个按钮分别测试:</p><p>(1)jsp页面</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: brian  Date: 2016/3/7  Time: 20:49  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;json交互测试&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        //请求json，输出是json        function requestJson(){     省略    }        //请求key/value，输出是json        function responseJson(){    省略    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;&lt;input type=&quot;button&quot; onclick=&quot;responseJson()&quot; value=&quot;请求key/value，输出是json&quot;/&gt;&lt;/body&gt;</code></pre><p>(2)controller</p><pre><code>@Controllerpublic class JsonTest {    ...}</code></pre><hr><h3 id="输入json串，输出是json串"><a href="#输入json串，输出是json串" class="headerlink" title="输入json串，输出是json串"></a>输入json串，输出是json串</h3><p>使用jquery的ajax提交json串，对输出的json结果进行解析。</p><p>(1)jsp页面</p><pre><code>// 请求json，输出是jsonfunction requestJson(){    $.ajax({        type:&apos;post&apos;,        url:&apos;${pageContext.request.contextPath }/requestJson.action&apos;,        contentType:&apos;application/json;charset=utf-8&apos;,        //数据格式是json串，商品信息        data:&apos;{&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999}&apos;,        success:function(data){//返回json结果            alert(data);        }    });}</code></pre><p>(2)controller</p><pre><code>//请求json串(商品信息)，输出json(商品信息)//@RequestBody将请求的商品信息的json串转成itemsCustom对象//@ResponseBody将itemsCustom转成json输出@RequestMapping(&quot;/requestJson&quot;)public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){    //@ResponseBody将itemsCustom转成json输出    return itemsCustom;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;我居北海君南海，寄雁传书谢不能。&lt;/center&gt;&lt;br&gt;&lt;center&gt;桃李春风一杯酒，江湖夜雨十年灯。&lt;/center&gt;&lt;br&gt;&lt;center&gt;持家但有四立壁，治病不蕲三折肱。&lt;/center&gt;&lt;br&gt;&lt;center&gt;想见读书头已白，隔溪猿哭瘴溪藤。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(17)-上传图片</title>
    <link href="http://www.echodemo.cc/2019/07/31/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(17)-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>http://www.echodemo.cc/2019/07/31/springmvc学习笔记(17)-上传图片/</id>
    <published>2019-07-31T15:03:42.000Z</published>
    <updated>2019-07-31T15:25:44.253Z</updated>
    
    <content type="html"><![CDATA[<center>黄水塘里游着白鸭</center><br><center>高粱梗油青的刚高过头</center><br><center>这跳动的心怎样安插</center><br><center>田里一窄条路，八月里这忧愁？</center><center>天是昨夜雨洗过的，山岗</center><br><center>照着太阳又留一片影</center><br><center>羊跟着放羊的转进村庄</center><br><center>一大棵树荫下罩着井，又像是心！</center><center>从没有人说过八月什么话</center><br><center>夏天过去了，也不到秋天</center><br><center>但我望着田垄，土墙上的瓜</center><br><center>仍不明白生活同梦怎样的连牵</center><br><center>—-现代·林徽因《八月的忧愁》节选</center><hr><h3 id="springmvc中对多部件类型解析"><a href="#springmvc中对多部件类型解析" class="headerlink" title="springmvc中对多部件类型解析"></a>springmvc中对多部件类型解析</h3><p>在修改商品页面，添加上传商品图片功能。在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。通过在springmvc.xml中配置multipart类型解析器来完成。</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;bean id=&quot;multipartResolver&quot;      class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;    &lt;property name=&quot;maxUploadSize&quot;&gt;        &lt;value&gt;5242880&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="加入上传图片的jar"><a href="#加入上传图片的jar" class="headerlink" title="加入上传图片的jar"></a>加入上传图片的jar</h3><p>（1）添加依赖</p><pre><code>&lt;!-- 文件上传 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>（2）依赖树</p><pre><code>[INFO] \- commons-fileupload:commons-fileupload:jar:1.3.1:compile[INFO]    \- commons-io:commons-io:jar:2.2:compile</code></pre><p><strong>可以看到，其实还间接依赖了commons-io:commons-io:jar。</strong></p><h3 id="创建图片虚拟目录存储图片"><a href="#创建图片虚拟目录存储图片" class="headerlink" title="创建图片虚拟目录存储图片"></a>创建图片虚拟目录存储图片</h3><p>直接修改tomcat的配置,在conf/server.xml文件，添加虚拟目录。</p><pre><code>&lt;Context docBase=&quot;图片存放的磁盘路径&quot; path=&quot;/pic&quot; reloadable=&quot;false&quot;/&gt;</code></pre><p>注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。</p><hr><h3 id="上传图片代码"><a href="#上传图片代码" class="headerlink" title="上传图片代码"></a>上传图片代码</h3><p>(1)页面</p><pre><code>&lt;tr&gt;    &lt;td&gt;商品图片&lt;/td&gt;    &lt;td&gt;        &lt;c:if test=&quot;${items.pic !=null}&quot;&gt;            &lt;img src=&quot;/pic/${items.pic}&quot; width=100 height=100/&gt;            &lt;br/&gt;        &lt;/c:if&gt;        &lt;input type=&quot;file&quot;  name=&quot;items_pic&quot;/&gt;    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>(2)controller方法</p><p>修改：商品修改controller方法：</p><pre><code>@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @ModelAttribute(&quot;items&quot;)        @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,        BindingResult bindingResult,        MultipartFile items_pic)throws Exception {...}</code></pre><p>(3)实现</p><pre><code>// 原始名称String originalFilename = items_pic.getOriginalFilename();// 上传图片if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0){    // 存储图片的物理路径    String pic_path = &quot;D:\\tmp\\&quot;;    // 新的图片名称    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));    // 新图片    File newFile = new File(pic_path+newFileName);    // 将内存中的数据写入磁盘    items_pic.transferTo(newFile);    //将新图片名称写到itemsCustom中    itemsCustom.setPic(newFileName);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;黄水塘里游着白鸭&lt;/center&gt;&lt;br&gt;&lt;center&gt;高粱梗油青的刚高过头&lt;/center&gt;&lt;br&gt;&lt;center&gt;这跳动的心怎样安插&lt;/center&gt;&lt;br&gt;&lt;center&gt;田里一窄条路，八月里这忧愁？&lt;/center&gt;

&lt;center&gt;天是昨夜雨洗过的，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(16)-异常处理器</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(16)-异常处理器/</id>
    <published>2019-07-28T13:47:57.000Z</published>
    <updated>2019-07-28T13:58:29.224Z</updated>
    
    <content type="html"><![CDATA[<center>窗间梅熟落蒂，墙下笋成出林。</center><br><center>连雨不知春去，一晴方觉夏深。</center><br><center>—-宋·范成大《喜晴》</center><hr><p>本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置。</p><hr><h3 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h3><p>系统中异常包括两类：</p><pre><code>1、预期异常。2、运行时异常RuntimeException。</code></pre><p>前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p><p>系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。</p><p><strong>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</strong></p><hr><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>对不同的异常类型定义异常类，继承Exception。</p><pre><code>public class CustomException  extends  Exception{    //异常信息    public String message;    public CustomException(String message){        super(message);        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }}</code></pre><hr><h3 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h3><p>思路：</p><p>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</p><p>全局异常处理器处理思路：</p><p>解析出异常类型</p><pre><code>1、如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示。2、如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）。</code></pre><p>springmvc提供一个HandlerExceptionResolver接口：</p><pre><code>public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        //handler就是处理器适配器要执行Handler对象（只有method）        //解析出异常类型        //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示        //String message = null;        //if(ex instanceof CustomException){            //message = ((CustomException)ex).getMessage();        //}else{            ////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”）            //message=&quot;未知错误&quot;;        //}        //上边代码变为        CustomException customException;        if(ex instanceof CustomException){            customException = (CustomException)ex;        }else{            customException = new CustomException(&quot;未知错误&quot;);        }        //错误信息        String message = customException.getMessage();        ModelAndView modelAndView = new ModelAndView();        //将错误信息传到页面        modelAndView.addObject(&quot;message&quot;, message);        //指向错误页面        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }}</code></pre><hr><h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Brian  Date: 2016/3/4  Time: 10:51  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${message}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h3 id="在springmvc-xml配置全局异常处理器"><a href="#在springmvc-xml配置全局异常处理器" class="headerlink" title="在springmvc.xml配置全局异常处理器"></a>在springmvc.xml配置全局异常处理器</h3><pre><code>&lt;!-- 全局异常处理器只要实现HandlerExceptionResolver接口就是全局异常处理器--&gt;&lt;bean class=&quot;com.iot.learnssm.firstssm.exception.CustomExceptionResolver&quot;&gt;&lt;/bean&gt;</code></pre><p><strong>全局异常处理器只有一个，配置多个也没用。</strong></p><hr><h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。</p><p>(1)在商品修改的controller方法中抛出异常</p><pre><code>public String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {    //调用service根据商品id查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);    //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在    if(itemsCustom == null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //通过形参中的model将model数据传到页面    //相当于modelAndView.addObject方法    model.addAttribute(&quot;items&quot;, itemsCustom);    return &quot;items/editItems&quot;;}</code></pre><p>(2)在service接口中抛出异常</p><pre><code>public ItemsCustom findItemsById(Integer id) throws Exception {    Items items = itemsMapper.selectByPrimaryKey(id);    if(items==null){        throw new CustomException(&quot;修改的商品信息不存在!&quot;);    }    //中间对商品信息进行业务处理    //....    //返回ItemsCustom    ItemsCustom itemsCustom = null;    //将items的属性值拷贝到itemsCustom    if(items!=null){        itemsCustom = new ItemsCustom();        BeanUtils.copyProperties(items, itemsCustom);    }    return itemsCustom;}</code></pre><p>1、如果与业务功能相关的异常，建议在service中抛出异常。</p><p>2、与业务功能没有关系的异常，建议在controller中抛出。</p><p>上边的功能，建议在service中抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;窗间梅熟落蒂，墙下笋成出林。&lt;/center&gt;&lt;br&gt;&lt;center&gt;连雨不知春去，一晴方觉夏深。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·范成大《喜晴》&lt;/center&gt;

&lt;hr&gt;
&lt;p&gt;本文主要介绍springmvc中异常处理的思路，并展示如何自定义
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(15)-数据回显</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)-%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(15)-数据回显/</id>
    <published>2019-07-28T13:33:23.000Z</published>
    <updated>2019-07-28T13:46:51.460Z</updated>
    
    <content type="html"><![CDATA[<center>阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。</center><br><center>待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。</center><br><center>—-近代·王国维《蝶恋花·阅尽天涯离别苦》</center><hr><p>本文介绍springmvc中数据回显的几种实现方法</p><p>数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。</p><hr><h3 id="pojo数据回显方法"><a href="#pojo数据回显方法" class="headerlink" title="pojo数据回显方法"></a>pojo数据回显方法</h3><p>（1）springmvc默认对pojo数据进行回显。</p><p>pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）。使用@ModelAttribute(“items”)指定pojo回显到页面在request中的key。这里的items对应的是前端页面里面的input中的name=”items.name”中的items。</p><p>（2）@ModelAttribute还可以将方法的返回值传到页面。在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。（请注意，这里并没有指定RequestMapping）</p><pre><code>// 商品分类// itemtypes表示最终将方法返回值放在request中的key@ModelAttribute(&quot;itemtypes&quot;)public Map&lt;String, String&gt; getItemTypes() {    Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;();    itemTypes.put(&quot;101&quot;, &quot;数码&quot;);    itemTypes.put(&quot;102&quot;, &quot;母婴&quot;);    return itemTypes;}</code></pre><p>页面上可以得到itemTypes数据。</p><pre><code>&lt;td&gt;    商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt;    商品类型：    &lt;select name=&quot;itemtype&quot;&gt;        &lt;c:forEach items=&quot;${itemtypes}&quot; var=&quot;itemtype&quot;&gt;            &lt;option value=&quot;${itemtype.key }&quot;&gt;${itemtype.value }&lt;/option&gt;        &lt;/c:forEach&gt;    &lt;/select&gt;&lt;/td&gt;</code></pre><p>（3）使用最简单方法:使用model，可以不用@ModelAttribute，(对应的是小标题（1）哦！)</p><pre><code>// 可以直接使用model将提交pojo回显到页面// model.addAttribute(&quot;items&quot;, itemsCustom);</code></pre><hr><h3 id="简单类型数据回显"><a href="#简单类型数据回显" class="headerlink" title="简单类型数据回显"></a>简单类型数据回显</h3><p>使用最简单方法使用model：</p><pre><code>model.addAttribute(&quot;id&quot;, id);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。&lt;/center&gt;&lt;br&gt;&lt;center&gt;待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-近代·王国维《蝶恋花·阅尽天涯离别苦
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(14)-springmvc校验</title>
    <link href="http://www.echodemo.cc/2019/07/28/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)-springmvc%E6%A0%A1%E9%AA%8C/"/>
    <id>http://www.echodemo.cc/2019/07/28/springmvc学习笔记(14)-springmvc校验/</id>
    <published>2019-07-28T11:31:31.000Z</published>
    <updated>2019-07-28T12:35:08.839Z</updated>
    
    <content type="html"><![CDATA[<center>病起萧萧两鬓华，卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。</center><br><center>枕上诗书闲处好，门前风景雨来佳。终日向人多酝藉，木犀花。</center><br><center>—-宋·李清照《摊破浣溪沙·病起萧萧两鬓华》</center><hr><p>本文主要介绍springmvc校验，包括环境准备，校验器配置，pojo张添加校验规则，捕获和显示检验错误信息以及分组校验简单示例。</p><hr><h3 id="校验理解"><a href="#校验理解" class="headerlink" title="校验理解"></a>校验理解</h3><p>项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。</p><p>服务端校验：</p><pre><code>1、控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）。2、业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。3、持久层dao：一般是不校验的。</code></pre><hr><h3 id="springmvc校验需求"><a href="#springmvc校验需求" class="headerlink" title="springmvc校验需求"></a>springmvc校验需求</h3><p>springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。</p><p>校验思路：</p><p>页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。</p><p>具体需求：</p><p>商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。</p><hr><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我们需要三个jar包：</p><pre><code>1、hibernate-validator.jar2、jboss-logging.jar3、validation-api.jar</code></pre><p>这里我们添加maven依赖：</p><pre><code>&lt;!-- hibernate 校验 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>查看maven依赖树：</p><pre><code>[INFO] \- org.hibernate:hibernate-validator:jar:5.2.4.Final:compile[INFO]    +- javax.validation:validation-api:jar:1.1.0.Final:compile[INFO]    +- org.jboss.logging:jboss-logging:jar:3.2.1.Final:compile[INFO]    \- com.fasterxml:classmate:jar:1.1.0:compile</code></pre><p>可以看到，另外两个jar包被hibernate-validator依赖，所以不用再额外添加了。</p><hr><h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p>（1）在springmvc.xml中添加</p><pre><code>&lt;!-- 校验器 --&gt;&lt;bean id=&quot;validator&quot;      class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;    &lt;!-- hibernate校验器--&gt;    &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt;    &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt;    &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id=&quot;messageSource&quot;      class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt;    &lt;!-- 资源文件名--&gt;    &lt;property name=&quot;basenames&quot;&gt;        &lt;list&gt;            &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!-- 资源文件编码格式 --&gt;    &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot; /&gt;    &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt;    &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot; /&gt;&lt;/bean&gt;</code></pre><p>（2)校验器注入到处理器适配器中</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;                       validator=&quot;validator&quot;&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>(3)在CustomValidationMessages.properties配置校验错误信息：</p><pre><code>#添加校验的错误提示信息items.name.length.error=请输入1到30个字符的商品名称items.createtime.isNUll=请输入商品的生产日期</code></pre><hr><h3 id="在pojo中添加校验规则"><a href="#在pojo中添加校验规则" class="headerlink" title="在pojo中添加校验规则"></a>在pojo中添加校验规则</h3><p>(1)在ItemsCustom.java中添加校验规则：</p><pre><code>public class Items {    private Integer id;    //校验名称在1到30字符中间    //message是提示校验出错显示的信息    //groups：此校验属于哪个分组，groups可以定义多个分组    @Size(min=1,max=30,message=&quot;{items.name.length.error}&quot;)    private String name;    private Float price;    private String pic;    //非空校验    @NotNull(message=&quot;{items.createtime.isNUll}&quot;)    private Date createtime;)</code></pre><hr><h3 id="捕获和显示校验错误信息"><a href="#捕获和显示校验错误信息" class="headerlink" title="捕获和显示校验错误信息"></a>捕获和显示校验错误信息</h3><pre><code>@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @Validated ItemsCustom itemsCustom,        BindingResult bindingResult)throws Exception {}</code></pre><p>(1)在controller中将错误信息传到页面即可</p><pre><code>//获取校验错误信息if(bindingResult.hasErrors()){    // 输出错误信息    List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();    for (ObjectError objectError :allErrors){        // 输出错误信息        System.out.println(objectError.getDefaultMessage());    }    // 将错误信息传到页面    model.addAttribute(&quot;allErrors&quot;, allErrors);    //可以直接使用model将提交pojo回显到页面    model.addAttribute(&quot;items&quot;, itemsCustom);    // 出错重新到商品修改页面    return &quot;items/editItems&quot;;}</code></pre><p>(2)页面显示错误信息：</p><pre><code>&lt;!-- 显示错误信息 --&gt;&lt;c:if test=&quot;${allErrors!=null }&quot;&gt;    &lt;c:forEach items=&quot;${allErrors }&quot; var=&quot;error&quot;&gt;        ${ error.defaultMessage}&lt;br/&gt;    &lt;/c:forEach&gt;&lt;/c:if&gt;</code></pre><hr><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>需求： </p><p>在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验。</p><p>解决方法： </p><p>定义多个校验分组（其实是一个java接口），分组中定义有哪些规则，每个controller方法使用不同的校验分组。</p><p>1.校验分组</p><pre><code>public interface ValidGroup1 {    //接口中不需要定义任何方法，仅是对不同的校验规则进行分组    //此分组只校验商品名称长度}</code></pre><p>2.在校验规则中添加分组</p><pre><code>//校验名称在1到30字符中间//message是提示校验出错显示的信息//groups：此校验属于哪个分组，groups可以定义多个分组@Size(min=1,max=30,message=&quot;{items.name.length.error}&quot;,groups = {ValidGroup1.class})private String name;</code></pre><p>3.在controller方法使用指定分组的校验</p><pre><code>// value={ValidGroup1.class}指定使用ValidGroup1分组的校验@RequestMapping(&quot;/editItemsSubmit&quot;)public String editItemsSubmit(        Model model,        HttpServletRequest request,        Integer id,        @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,        BindingResult bindingResult)throws Exception {}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;病起萧萧两鬓华，卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。&lt;/center&gt;&lt;br&gt;&lt;center&gt;枕上诗书闲处好，门前风景雨来佳。终日向人多酝藉，木犀花。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·李清照《摊破浣溪沙·病起萧萧两鬓华》&lt;/center&gt;

&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/26/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/26/springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定/</id>
    <published>2019-07-26T14:24:12.000Z</published>
    <updated>2019-07-27T06:58:51.088Z</updated>
    
    <content type="html"><![CDATA[<center>大鹏一日同风起，扶摇直上九万里。</center><br><center>假令风歇时下来，犹能簸却沧溟水。</center><br><center>世人见我恒殊调，闻余大言皆冷笑。</center><br><center>宣父犹能畏后生，丈夫未可轻年少。</center><br><center>—-唐·李白《上李邕》</center><hr><h3 id="数组绑定"><a href="#数组绑定" class="headerlink" title="数组绑定"></a>数组绑定</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>商品批量删除，用户在页面选择多个商品，批量删除。</p><h4 id="表现层实现"><a href="#表现层实现" class="headerlink" title="表现层实现"></a>表现层实现</h4><p>关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。</p><p>（1）controller方法定义：</p><pre><code>// 批量删除 商品信息@RequestMapping(&quot;/deleteItems&quot;)public String deleteItems(Integer[] items_id) throws Exception{}</code></pre><p>(2)页面定义：</p><pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot;&gt;&lt;tr&gt;    &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;items_id&quot; value=&quot;${item.id}&quot;/&gt;&lt;/td&gt;    &lt;td&gt;${item.name }&lt;/td&gt;    &lt;td&gt;${item.price }&lt;/td&gt;    &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;    &lt;td&gt;${item.detail }&lt;/td&gt;    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/items/editItems.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><hr><h3 id="list绑定"><a href="#list绑定" class="headerlink" title="list绑定"></a>list绑定</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>通常在需要批量提交数据时，将提交的数据绑定到list<pojo>中，比如：成绩录入（录入多门课成绩，批量提交），</pojo></p><p>本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。</p><h4 id="表现层实现-1"><a href="#表现层实现-1" class="headerlink" title="表现层实现"></a>表现层实现</h4><p>(1)controller方法定义： </p><pre><code>进入批量商品修改页面(页面样式参考商品列表实现)。批量修改商品提交。</code></pre><p>使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list<pojo>属性</pojo></p><pre><code>public class ItemsQueryVo {    //商品信息    private Items items;    //为了系统 可扩展性，对原始生成的po进行扩展    private ItemsCustom itemsCustom;    //批量商品信息    private List&lt;ItemsCustom&gt; itemsList;}// 批量修改商品提交// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。@RequestMapping(&quot;/editItemsAllSubmit&quot;)public String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception {    return &quot;success&quot;;}</code></pre><p>（2）页面定义：</p><pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;    &lt;tr&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].name&quot; value=&quot;${item.name }&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].price&quot; value=&quot;${item.price }&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].createtime&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot;/&gt;&lt;/td&gt;        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].detail&quot; value=&quot;${item.detail }&quot;/&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>（3）name的格式：</p><p>对应包装pojo中的list类型属性名[下标(从0开始)].包装pojo中List类型的属性中pojo的属性名</p><p>例子：</p><p>“name=”itemsList[${status.index }].price”</p><p>可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。</p><hr><h3 id="map绑定"><a href="#map绑定" class="headerlink" title="map绑定"></a>map绑定</h3><p>也通过在包装pojo中定义map类型属性。在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。 </p><p>（1）包装类中定义Map对象如下：</p><pre><code>Public class QueryVo {    private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();      //get/set方法...}</code></pre><p>(2)页面定义如下：</p><pre><code>&lt;tr&gt;    &lt;td&gt;学生信息：&lt;/td&gt;    &lt;td&gt;        姓名：&lt;inputtype=&quot;text&quot; name=&quot;itemInfo[&apos;name&apos;]&quot;/&gt;        年龄：&lt;inputtype=&quot;text&quot; name=&quot;itemInfo[&apos;price&apos;]&quot;/&gt;        .. .. ..    &lt;/td&gt;&lt;/tr&gt;</code></pre><p>(3)Contrller方法定义如下：</p><pre><code>public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{    System.out.println(queryVo.getStudentinfo());}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;大鹏一日同风起，扶摇直上九万里。&lt;/center&gt;&lt;br&gt;&lt;center&gt;假令风歇时下来，犹能簸却沧溟水。&lt;/center&gt;&lt;br&gt;&lt;center&gt;世人见我恒殊调，闻余大言皆冷笑。&lt;/center&gt;&lt;br&gt;&lt;center&gt;宣父犹能畏后生，丈夫未可轻年少。&lt;/cen
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/26/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/26/springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定/</id>
    <published>2019-07-26T14:13:43.000Z</published>
    <updated>2019-07-26T14:20:07.138Z</updated>
    
    <content type="html"><![CDATA[<center>自君之出矣，不复理残机。</center><br><center>思君如满月，夜夜减清辉。</center><br><center>—-唐·张九龄《赋得自君之出矣》</center><hr><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>商品查询controller方法中实现商品查询条件传入。</p><hr><pre><code>第一种方法：在形参中添加HttpServletRequest request参数，通过request接收查询条件参数。第二种方法：在形参中让包装类型的pojo接收查询条件参数。</code></pre><p>分析：</p><p>页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。</p><p>如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。</p><hr><h3 id="页面参数和controller方法形参定义"><a href="#页面参数和controller方法形参定义" class="headerlink" title="页面参数和controller方法形参定义"></a>页面参数和controller方法形参定义</h3><p>（1）页面参数：</p><p>商品名称：<input name="itemsCustom.name"></p><p>注意：itemsCustom和包装pojo中的属性名一致即可。</p><p>（2）controller方法形参：</p><pre><code>public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception</code></pre><p>（3）包装类ItemsQueryVo中部分属性：</p><pre><code>public class ItemsQueryVo {    //商品信息    private Items items;    //为了系统 可扩展性，对原始生成的po进行扩展    private ItemsCustom itemsCustom;}</code></pre><p>可见，ItemsQueryVo中属性itemsCustom和页面参数中一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;自君之出矣，不复理残机。&lt;/center&gt;&lt;br&gt;&lt;center&gt;思君如满月，夜夜减清辉。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-唐·张九龄《赋得自君之出矣》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(11)-springmvc注解开发之简单参数绑定</title>
    <link href="http://www.echodemo.cc/2019/07/23/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.echodemo.cc/2019/07/23/springmvc学习笔记(11)-springmvc注解开发之简单参数绑定/</id>
    <published>2019-07-23T14:58:37.000Z</published>
    <updated>2019-07-24T15:49:31.618Z</updated>
    
    <content type="html"><![CDATA[<center>秋风起兮白云飞，草木黄落兮雁南归。</center><br><center>兰有秀兮菊有芳，怀佳人兮不能忘。</center><br><center>泛楼船兮济汾河，横中流兮扬素波。</center><br><center>箫鼓鸣兮发棹歌，欢乐极兮哀情多。</center><br><center>少壮几时兮奈老何！</center><br><center>—-两汉·刘彻《秋风辞》</center><hr><p>本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换</p><hr><h3 id="spring参数绑定过程"><a href="#spring参数绑定过程" class="headerlink" title="spring参数绑定过程"></a>spring参数绑定过程</h3><p>从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变量接收！！！！</p><p>处理器适配器调用springmvc提供参数绑定组件将key/value数据转成controller方法的形参。在springmvc早期版本使用PropertyEditor(只能将字符串转化成java对象)，后期使用converter(进行任意类型的转换)，在特殊情况下需要自定义converter。</p><hr><h3 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h3><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p><pre><code>1、HttpServletRequest：通过request对象获取请求信息。2、HttpServletResponse：通过response处理响应信息。3、HttpSession：通过session对象得到session中存放的对象。4、Model/ModelMap：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。</code></pre><hr><h3 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h3><p>通过@RequestParam对简单类型的参数进行绑定。如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</p><p>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</p><p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。</p><pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})//@RequestParam里边指定request传入参数名称(即下边的value=&quot;id&quot;)和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。public String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {}</code></pre><hr><h3 id="pojo绑定"><a href="#pojo绑定" class="headerlink" title="pojo绑定"></a>pojo绑定</h3><p>页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。</p><p>注意:这里只是要求name和形参的属性名一致，而不是要求和形参的名称一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的)</p><p>(1)页面定义：</p><pre><code>&lt;table width=&quot;100%&quot; border=1&gt;&lt;tr&gt;    &lt;td&gt;商品名称&lt;/td&gt;    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${itemsCustom.name }&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;商品价格&lt;/td&gt;    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${itemsCustom.price }&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><p>(2)controller的pojo形参的定义：</p><pre><code>public class Items {    private Integer id;    private String name;    private Float price;    private String pic;    private Date createtime;    private String detail;    ......}</code></pre><p>（3）为了防止前端传入的中文数据出现乱码问题，使用Spring提供的编码过滤器来统一编码，在web.xml中添加如下代码：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>（4）以上可以解决post请求乱码问题，对于get请求中文参数出现乱码解决方法有两个：</p><p>a、修改tomcat配置文件添加编码与工程编码一致：</p><pre><code>&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</code></pre><p>b、对接收的参数进行重新编码：</p><pre><code>String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</code></pre><p><strong>其中IOS8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8重新编码。</strong></p><hr><h3 id="自定义参数绑定实现日期类型绑定"><a href="#自定义参数绑定实现日期类型绑定" class="headerlink" title="自定义参数绑定实现日期类型绑定"></a>自定义参数绑定实现日期类型绑定</h3><p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。</p><p>将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成java.util.Date类型。需要向处理器适配器中注入自定义的参数绑定组件。</p><p>(1)自定义日期类型绑定:</p><pre><code>public class CustomDateConverter implements Converter&lt;String,Date&gt;{    public Date convert(String s) {        //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        try {            //转成直接返回            return simpleDateFormat.parse(s);        } catch (ParseException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        //如果参数绑定失败返回null        return null;    }}</code></pre><p>(2)配置方式</p><pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 自定义参数绑定 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;!-- 转换器 --&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;!-- 日期类型转换 --&gt;            &lt;bean class=&quot;com.echodemo.springmvcmybatis.controller.converter.CustomDateConverter&quot;/&gt;       &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h3 id="springmvc和struts2的区别"><a href="#springmvc和struts2的区别" class="headerlink" title="springmvc和struts2的区别"></a>springmvc和struts2的区别</h3><p>（1）springmvc基于方法开发的，struts2基于类开发的。springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。</p><p>（2）springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。</p><p>（3）经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;秋风起兮白云飞，草木黄落兮雁南归。&lt;/center&gt;&lt;br&gt;&lt;center&gt;兰有秀兮菊有芳，怀佳人兮不能忘。&lt;/center&gt;&lt;br&gt;&lt;center&gt;泛楼船兮济汾河，横中流兮扬素波。&lt;/center&gt;&lt;br&gt;&lt;center&gt;箫鼓鸣兮发棹歌，欢乐极兮哀情多。&lt;/ce
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(10)-springmvc注解开发之商品修改功能</title>
    <link href="http://www.echodemo.cc/2019/07/23/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)-springmvc%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%B9%8B%E5%95%86%E5%93%81%E4%BF%AE%E6%94%B9%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.echodemo.cc/2019/07/23/springmvc学习笔记(10)-springmvc注解开发之商品修改功能/</id>
    <published>2019-07-23T14:27:09.000Z</published>
    <updated>2019-07-23T14:57:05.667Z</updated>
    
    <content type="html"><![CDATA[<center>劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。 </center><br><center>须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。</center><br><center>—-唐·韦庄《《菩萨蛮·劝君今夜须沉醉》》</center><hr><p>本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,@RequestMapping,controller方法的返回值等。</p><hr><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><pre><code>1、进入商品查询列表页面。2、点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息。3、在商品修改页面，修改商品信息，修改后，点击提交。</code></pre><h3 id="开发mapper"><a href="#开发mapper" class="headerlink" title="开发mapper"></a>开发mapper</h3><p>1、根据id查询商品信息</p><p>2、根据id更新Items表的数据</p><hr><h3 id="开发service"><a href="#开发service" class="headerlink" title="开发service"></a>开发service</h3><p>（1）在com.echodemo.springmvcmybatis.service.ItemsService中添加两个接口。</p><pre><code>//根据id查询商品信息ItemsCustom findItemsById(Integer id) throws Exception;//修改商品信息void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;</code></pre><p>（2）在com.echodemo.springmvcmybatis.service..impl.ItemsServiceImpl中实现接口，增加itemsMapper属性。</p><pre><code>@Autowiredprivate ItemsMapper itemsMapper;public ItemsCustom findItemsById(Integer id) throws Exception {    Items items = itemsMapper.selectByPrimaryKey(id);    //中间对商品信息进行业务处理    //....    //返回ItemsCustom    ItemsCustom itemsCustom = new ItemsCustom();    //将items的属性值拷贝到itemsCustom    BeanUtils.copyProperties(items, itemsCustom);    return itemsCustom;}public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {    //添加业务校验，通常在service接口对关键参数进行校验    //校验 id是否为空，如果为空抛出异常    //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段    //updateByPrimaryKeyWithBLOBs要求必须转入id    itemsCustom.setId(id);    itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);}</code></pre><hr><h3 id="开发controller"><a href="#开发controller" class="headerlink" title="开发controller"></a>开发controller</h3><pre><code>//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action//@RequestMapping(&quot;/items&quot;)public class ItemsController {    @Autowired    private ItemsService itemsService;    //商品查询列表    @RequestMapping(&quot;/queryItems&quot;)    //实现 对queryItems方法和url进行映射，一个方法对应一个url    //一般建议将url和方法写成一样    public ModelAndView queryItems() throws Exception{        //调用service查找数据库，查询商品列表        List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null);        //返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;,itemsList);        //指定视图        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList        //modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀        modelAndView.setViewName(&quot;items/itemsList&quot;);        return modelAndView;    }    //商品信息修改页面显示    @RequestMapping(&quot;/editItems&quot;)    //限制http请求方法，可以post和get    //@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})    public ModelAndView editItems()throws Exception {        //调用service根据商品id查询商品信息        ItemsCustom itemsCustom = itemsService.findItemsById(1);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //将商品信息放到model        modelAndView.addObject(&quot;itemsCustom&quot;, itemsCustom);        //商品修改页面        modelAndView.setViewName(&quot;items/editItems&quot;);        return modelAndView;    }    //商品信息修改提交    @RequestMapping(&quot;/editItemsSubmit&quot;)    public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception {        //调用service更新商品信息，页面需要将商品信息传到此方法        itemsService.updateItems(id, itemsCustom);        //返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        //返回一个成功页面        modelAndView.setViewName(&quot;success&quot;);        return modelAndView;    }}</code></pre><hr><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>（1）URL映射</p><p>定义controller方法对应的url，进行处理器映射使用。</p><p>（2）窄化请求映射</p><pre><code>//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action@RequestMapping(&quot;/items&quot;)public class ItemsController {}</code></pre><p>（3）限制http请求方法</p><pre><code>//商品信息修改页面显示//@RequestMapping(&quot;/editItems&quot;)//限制http请求方法，可以post和get@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})public ModelAndView editItems()throws Exception {}</code></pre><hr><h3 id="controller方法的返回值"><a href="#controller方法的返回值" class="headerlink" title="controller方法的返回值"></a>controller方法的返回值</h3><p>（1）返回ModelAndView</p><p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</p><p>（2）返回string</p><p>如果controller方法返回string：</p><p>a、表示返回逻辑视图名：</p><p><strong>真正视图(jsp路径)=前缀+逻辑视图名+后缀</strong></p><pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})//@RequestParam里边指定request传入参数名称和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。//public String editItems(Model model, @RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {public String editItems(Model model)throws Exception {    //调用service根据商品id查询商品信息    ItemsCustom itemsCustom = itemsService.findItemsById(1);    //通过形参中的model将model数据传到页面    //相当于modelAndView.addObject方法    model.addAttribute(&quot;itemsCustom&quot;, itemsCustom);    return &quot;items/editItems&quot;;}</code></pre><p>b、redirect重定向</p><p>商品修改提交后，重定向到商品查询列表。</p><p>redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）</p><pre><code>//重定向到商品查询列表//return &quot;redirect:queryItems.action&quot;;</code></pre><p>c、forward页面转发</p><p>通过forward进行页面转发，浏览器地址栏url不变，request可以共享。</p><pre><code>//页面转发return &quot;forward:queryItems.action&quot;;</code></pre><p>(3)返回void</p><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p><pre><code>// 使用request转向页面，如下：request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);// 也可以通过response页面重定向：response.sendRedirect(&quot;url&quot;)// 也可以通过response指定响应结果，例如响应json数据如下：response.setCharacterEncoding(&quot;utf-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter().write(&quot;json串&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-唐·韦庄《《菩萨蛮·劝君今夜须沉醉》》&lt;/center&gt;

&lt;hr&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(9)-springmvc整合mybatis之controller</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)-springmvc%E6%95%B4%E5%90%88mybatis%E4%B9%8Bcontroller/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(9)-springmvc整合mybatis之controller/</id>
    <published>2019-07-14T13:59:39.000Z</published>
    <updated>2019-07-14T14:07:29.686Z</updated>
    
    <content type="html"><![CDATA[<center>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。 </center><br><center>长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</center><br><center>—-宋·苏轼《临江仙·夜饮东坡醒复醉》</center><hr><h3 id="配置springmvc-xml"><a href="#配置springmvc-xml" class="headerlink" title="配置springmvc.xml"></a>配置springmvc.xml</h3><p>在resources/spring文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&quot;&gt;    &lt;!-- 对于注解的Handler 可以单个配置    实际开发中建议使用组件扫描    --&gt;    &lt;!-- 可以扫描controller、service、...    这里让扫描controller，指定controller的包     --&gt;    &lt;context:component-scan base-package=&quot;com.echodemo.springmvcmybatis.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 注解的映射器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;--&gt;    &lt;!-- 注解的适配器 --&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;--&gt;    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置     mvc:annotation-driven默认加载很多的参数绑定方法，     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter     实际开发时使用mvc:annotation-driven     --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!-- 视图解析器    解析jsp,默认使用jstl,classpath下要有jstl的包    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!-- 配置jsp路径的前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;!-- 配置jsp路径的后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app  version=&quot;2.3&quot;          xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee        http://java.sun.com/xml/ns/javaee/web-app_2_3.xsd&quot;&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!-- 加载spring的容器 --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:/spring/applicationContext-*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)    --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;!--    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，            使用此种方式和实现RESTful风格的url    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，            不能根据jsp页面找到handler，会报错    --&gt;    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><p>这个文件有两个作用：</p><p>（1）配置前端控制器(DispatcherServlet)</p><p>（2）加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载spring/下的配置文件：</p><pre><code>applicationContext-dao.xmlapplicationContext-service.xmlapplicationContext-transaction.xml</code></pre><hr><h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><pre><code>package com.echodemo.springmvcmybatis.controller;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;@Controllerpublic class ItemsController {    @Autowired    private ItemsService itemsService;    // 商品查询    @RequestMapping(&quot;/queryItems&quot;)    public ModelAndView queryItems() throws Exception{        // 调用service查找数据库，查询商品列表，这里使用静态数据模拟        List&lt;ItemsCustom&gt; itemsList = new ArrayList&lt;&gt;();        itemsList = itemsService.findItemsList(null);        // 返回ModelAndView        ModelAndView modelAndView = new ModelAndView();        // 相当于request的setAttribute，在JSP页面中通过itemsList取数据        modelAndView.addObject(&quot;itemsList&quot;, itemsList);        // 指定视图        modelAndView.setViewName(&quot;items/itemsList&quot;);        System.out.println(modelAndView);        return modelAndView;    }}</code></pre><hr><h3 id="编写jsp"><a href="#编写jsp" class="headerlink" title="编写jsp"></a>编写jsp</h3><p>服务器路径为WEB-INF/jsp/items/itemsList.jsp。</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot;         pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;; charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;${pageContext.request.contextPath }/item/queryItem.action&quot; method=&quot;post&quot;&gt;    查询条件：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    商品列表：    &lt;table width=&quot;100%&quot; border=1&gt;        &lt;tr&gt;            &lt;td&gt;商品id&lt;/td&gt;            &lt;td&gt;商品名称&lt;/td&gt;            &lt;td&gt;商品价格&lt;/td&gt;            &lt;td&gt;商品描述&lt;/td&gt;            &lt;td&gt;操作&lt;/td&gt;        &lt;/tr&gt;        &lt;c:if test=&quot;${not empty itemsList}&quot;&gt;            &lt;c:forEach items=&quot;${itemsList}&quot; var=&quot;item&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;${item.id}&lt;/td&gt;                    &lt;td&gt;${item.name}&lt;/td&gt;                    &lt;td&gt;${item.price}&lt;/td&gt;                    &lt;td&gt;${item.detail}&lt;/td&gt;                    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath}/item/editItem.action?id=${item.id}&quot; &gt;修改&lt;/a&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/c:forEach&gt;        &lt;/c:if&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="部署调试"><a href="#部署调试" class="headerlink" title="部署调试"></a>部署调试</h3><p>1、idea上部署tomcat可以参考这里：<a href="http://www.echodemo.cc/2019/07/13/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1">springmvc学习笔记(1)-框架原理和入门配置</a>-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/)</p><p>2、启动之后访问：<a href="http://localhost:8080/springmvcmybatis/queryItems.action。大功告成。" target="_blank" rel="noopener">http://localhost:8080/springmvcmybatis/queryItems.action。大功告成。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。 &lt;/center&gt;&lt;br&gt;&lt;center&gt;长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《临江仙·夜饮东坡醒复醉》
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springmvc学习笔记(8)-springmvc整合mybatis之service</title>
    <link href="http://www.echodemo.cc/2019/07/14/springmvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)-springmvc%E6%95%B4%E5%90%88mybatis%E4%B9%8Bservice/"/>
    <id>http://www.echodemo.cc/2019/07/14/springmvc学习笔记(8)-springmvc整合mybatis之service/</id>
    <published>2019-07-14T13:53:41.000Z</published>
    <updated>2019-07-14T13:58:20.314Z</updated>
    
    <content type="html"><![CDATA[<center>两两归鸿欲破群，依依还似北归人。</center><br><center>遥知朔漠多风雪，更待江南半月春。</center><br><center>—-宋·苏轼《惠崇春江晚景二首·其二》</center><hr><h3 id="定义service"><a href="#定义service" class="headerlink" title="定义service"></a>定义service</h3><p>1、定义service接口</p><pre><code>package com.echodemo.springmvcmybatis.service;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.bean.ItemsQueryVo;import java.util.List;public interface ItemsService {    // 查询商品列表    List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;}</code></pre><p>2、定义service实现类</p><pre><code>package com.echodemo.springmvcmybatis.service.Impl;import com.echodemo.springmvcmybatis.bean.ItemsCustom;import com.echodemo.springmvcmybatis.bean.ItemsQueryVo;import com.echodemo.springmvcmybatis.mapper.ItemsMapperCustom;import com.echodemo.springmvcmybatis.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ItemsServiceImpl implements ItemsService {    @Autowired    private ItemsMapperCustom itemsMapperCustom;    @Override    public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {        return itemsMapperCustom.findItemsList(itemsQueryVo);    }}</code></pre><hr><h3 id="在spring容器配置service"><a href="#在spring容器配置service" class="headerlink" title="在spring容器配置service"></a>在spring容器配置service</h3><p>在resources/spring下创建applicationContext-service.xml，文件中配置service。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 商品管理的service --&gt;    &lt;bean id=&quot;itemsService&quot; class=&quot;com.echodemo.springmvcmybatis.service.Impl.ItemsServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><hr><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><p>在resources/spring下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 事务管理器        对mybatis操作数据库的事务控制，spring使用jdbc的事务控制    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 数据源            dataSource在applicationContext-dao.xml中配置了         --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 传播行为 --&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- aop --&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.echodemo.springmvcmybatis.service.Impl.*.*(..))&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;两两归鸿欲破群，依依还似北归人。&lt;/center&gt;&lt;br&gt;&lt;center&gt;遥知朔漠多风雪，更待江南半月春。&lt;/center&gt;&lt;br&gt;&lt;center&gt;—-宋·苏轼《惠崇春江晚景二首·其二》&lt;/center&gt;

&lt;hr&gt;
&lt;h3 id=&quot;定义service&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="SpringMVC" scheme="http://www.echodemo.cc/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
