<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-09-08T13:33:03.590Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《自控力》摘句</title>
    <link href="http://www.echodemo.cc/2018/09/08/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2018/09/08/《自控力》摘句/</id>
    <published>2018-09-08T13:23:43.000Z</published>
    <updated>2018-09-08T13:33:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。</p><p>2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。</p><p>3、从每章挑选一个策略，选和你的挑战最相关的一个，而不是一次尝试10种策略。</p><p>4、人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学数学，它就会越来越擅长数学。如果你让它忧虑，它就会越来越忧虑。如果你让它专注，它就会越来越专注。</p><p>5、如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</p><p>6、人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</p><p>7、如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。</p><p>8、如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。</p><p>9、自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。</p><p>10、道德许可：当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</p><p>11、只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。</p><p>12、当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？·你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？·你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？</p><p>13、我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。</p><p>14、你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？</p><p>15、这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？</p><p>16、如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。</p><p>17、你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。）</p><p>18、是什么让你的多巴胺神经元不停燃烧？你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？</p><p>19、谁在控制你的多巴胺神经元？让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。&lt;/p&gt;
&lt;p&gt;2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。&lt;/p&gt;
&lt;p&gt;3、从每章挑选一个策略，选和你的挑战最相关的一个，而
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>故乡</title>
    <link href="http://www.echodemo.cc/2018/08/22/%E6%95%85%E4%B9%A1/"/>
    <id>http://www.echodemo.cc/2018/08/22/故乡/</id>
    <published>2018-08-22T13:29:58.000Z</published>
    <updated>2018-08-27T10:55:01.049Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专程看望和问询；郑愁予的故乡是始终心系的祖国；还有一个人的故乡是他十年来力排众议在艰难的环境和地形下修筑的几十公里的山路。。。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一辆Hello共享单车，在幽暗的路上漫无目的地游荡。想起考研未果的日子，我知道，那时候选择找工作而不是二战，是因为自己在逃避，害怕再一次的失败，不知道自己的退路在哪。如今来到偌大的城市里，繁华是你。刚来的日子里满心欢喜，为自己能够来到这座城市而庆幸，把冥冥中的注定看作美好的开始。但此刻自己的内心是茫然的，故乡对我而言意味着什么，一个人需要怎样的经历和过去才能够看清？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立在公交站台旁的我，用手机写着这段文字的时候，抬头望着夜空中笼罩在云里的月，顿下来，目光又顺着车流望向灯火斑斓的远方，好像知道了点什么，转身往回走去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>音乐诗人</title>
    <link href="http://www.echodemo.cc/2018/08/19/%E9%9F%B3%E4%B9%90%E8%AF%97%E4%BA%BA/"/>
    <id>http://www.echodemo.cc/2018/08/19/音乐诗人/</id>
    <published>2018-08-19T02:46:32.000Z</published>
    <updated>2018-08-27T10:53:03.803Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，动听的曲，美的无与伦比。台上的他，于言谈举止之间无时无刻不透露着温文儒雅的气质。近来知晓他与其妻子的爱情，从两小无猜的年纪到同是清华的学子，彼此之间缘深缘浅，自是懂得，这一切都是最好的安排。据说在李健的每一张专辑里都有一首歌是写给孟小蓓的，他对她说：和你在一起的日子才叫时光。他爱咖啡，也爱清茶，更爱读书，这也是他随口而出的词句里文化深厚的原因。他的音乐如诗，爱情如诗，更是把生活过成了一首诗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>萤火虫</title>
    <link href="http://www.echodemo.cc/2018/08/18/%E8%90%A4%E7%81%AB%E8%99%AB/"/>
    <id>http://www.echodemo.cc/2018/08/18/萤火虫/</id>
    <published>2018-08-18T06:39:59.000Z</published>
    <updated>2018-08-27T10:51:45.655Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种做法，想想都是美的。以前小时候在故乡，秋天的夜晚，带着随意的瓶子跑到屋子外面去捕萤火虫，满天的星光下，是我们奔跑的身影和不尽的欢笑。那时候小，把一只又一只的萤火虫都塞进瓶中，第二天一大早起来，见到的就是它们的躯体，自己伤心极了，便下定决心不再捕捉，只是远观这些闪烁着的精灵就足够了。如今年岁见长，到远离故乡的城市里读书，再到现在的新入职场，一切都变得遥远。大概现在已经有好几年没有见到过萤火虫了。一方面是人类发展导致的环境恶化，另一方面是自己在这样的时节里和故乡难以靠近。昨天七夕，不禁想起唐代诗人杜牧那首《秋夕》“银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星”，给此时的自己又增添了一份美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺&lt;/p&gt;
&lt;p&gt;&amp;nbsp
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的XML配置</title>
    <link href="http://www.echodemo.cc/2018/08/16/MyBatis%E4%B8%AD%E7%9A%84XML%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2018/08/16/MyBatis中的XML配置/</id>
    <published>2018-08-16T07:11:29.000Z</published>
    <updated>2018-08-16T08:05:20.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、properties"><a href="#1、properties" class="headerlink" title="1、properties"></a>1、properties</h3><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。首先在同级目录下新建一个db.properties文件。</p><pre><code>&lt;!-- db.properties文件 --&gt;driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root&lt;!-- properties配置 --&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;&lt;!-- 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，如下所示： --&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;&lt;!--     1、在properties元素体内指定的属性首先被读取。    2、然后根据properties元素中的resource属性读取类路径下属性文件或根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性。    3、最后读取作为方法参数(parameterType)传递的属性，并覆盖已读取的同名属性。    4、通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。--&gt;</code></pre><h3 id="2、Setting"><a href="#2、Setting" class="headerlink" title="2、Setting"></a>2、Setting</h3><p>它们会修改MyBatis在运行时的行为方式，ibatis的全局配置参数，包括很多的性能参数(最大线程数、最大等待时间等)，通过调用这些性能参数使用ibatis达到高性能的运行。MyBatis运行时调整全局参数，相当于软件运行时的参数。(需要小心配置，配置参数会影响MyBatis的执行)</p><h3 id="3、typeAlias"><a href="#3、typeAlias" class="headerlink" title="3、typeAlias"></a>3、typeAlias</h3><pre><code>&lt;!--    1、类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。     2、自定义别名:alias别名；type类型。如果指定包中所有类都有别名，使用类名作为别名(大小写不敏感)。--&gt;&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;user&quot; type=&quot;com.entity.User&quot;/&gt;    &lt;package name=&quot;com.entity&quot;/&gt;&lt;/typeAliases&gt;</code></pre><h3 id="4、environments"><a href="#4、environments" class="headerlink" title="4、environments"></a>4、environments</h3><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。</p><pre><code>&lt;!-- 可以接受环境配置的两个方法签名 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);&lt;!-- 如果忽略了环境参数，那么默认环境将会被加载 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 在MyBatis中有两种类型的事务管理器：1、JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。2、MANAGED这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 --&gt;&lt;transactionManager type=&quot;MANAGED&quot;&gt;      &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><h3 id="5、mappers"><a href="#5、mappers" class="headerlink" title="5、mappers"></a>5、mappers</h3><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、properties&quot;&gt;&lt;a href=&quot;#1、properties&quot; class=&quot;headerlink&quot; title=&quot;1、properties&quot;&gt;&lt;/a&gt;1、properties&lt;/h3&gt;&lt;p&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Jav
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/08/15/MyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/08/15/MyBatis第一个入门程序/</id>
    <published>2018-08-15T07:37:43.000Z</published>
    <updated>2018-08-16T08:58:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>2、写一个mybatis的入门程序</p><p>(1)在Myeclipse上新建一个Java项目。首先导入jar包，在该项目下新建一个lib目录，将下列的jar包导入到lib目录下。</p><p><img src="/images/2018/8/1.jpg" alt="&quot;jar包&quot;"></p><p>(2)在该项目下创建一个与src同级的source folder，取名为config。在这其中存放xml配置文件。</p><p>1)sqlMapConfig.xml(名字是自行定义的):其中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。如下所示：这里要注意DOCTYPE首部最好是在mybatis文档当中复制粘贴，不要自己手打。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- 全局配置文件 --&gt;&lt;configuration&gt;    &lt;!-- 环境变量 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 事务管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据源 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;!-- 以下的数据库以及密码需要配置自己的 --&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射定义信息) --&gt;        &lt;mapper resource=&quot;Usermapper.xml&quot; /&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>2)Usermapper.xml(和上面的配置文件中的mappers当中的mapper是一一对应的):这个配置文件主要用于进行SQL的配置。同时记得在数据库当中创建users表，且添加数据。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml(配置SQL) --&gt;&lt;!-- namespace命名空间，为了对SQL语句进行隔离，方便管理 mapper开发dao方式，有特殊的作用。 --&gt;&lt;mapper namespace=&quot;mappertest&quot;&gt;    &lt;!--     mapper.xml文件配置的SQL语句，执行每一个SQL，都将封装为mapperStatement对象。    mapper.xml以statement为单位管理SQL语句 。    --&gt;    &lt;!-- ID唯一标识Statement --&gt;    &lt;!-- parameterType：输入参数类型，通过#{}，#{}中名称任意 --&gt;    &lt;!-- resultType：输出结果的类型，返回单条或者多条记录，指明类型 --&gt;    &lt;!-- #{}表示占位符，如果参数给出String，自动添加&apos;&apos;；${value}表示SQL语句拼接，不会自动添加&apos;&apos;。 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where id=#{id}    &lt;/select&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username=#{username}    &lt;/select&gt;    &lt;select id=&quot;findUserByName1&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username like &apos;%${value}%&apos;    &lt;/select&gt;    &lt;!-- 添加用户,传参时将大括号中填写的是属性名 --&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        &lt;!--         order设置是取SQL语句执行之前还是之后的值 。        resultType：返回类型。        keyProperty：将主键设置到属性。        last_insert_id()：获得刚插入的记录自动编号的值。        --&gt;        &lt;selectKey order=&quot;AFTER&quot; resultType=&quot;int&quot; keyProperty=&quot;id&quot;&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into users(username,age) values(#{username},#{age})    &lt;/insert&gt;    &lt;!-- 删除用户 --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from users where id=#{id}    &lt;/delete&gt;    &lt;!-- 修改用户 ，用户的ID一定需要有值--&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        update users set username=#{username},age=#{age} where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>(3)创建一个com.entity包，在此包下新建User.java文件。</p><pre><code>package com.entity;public class User {    private int id;    private String username;    private int age;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public User(){        super();    }    public User(String username, int age) {        super();        this.username = username;        this.age = age;    }    public User(int id, String username, int age) {        super();        this.id = id;        this.username = username;        this.age = age;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><p>(4)最后创建一个com.test包，创建一个APPTest.java文件，用于junit测试(记得导入junit的jar包)。</p><pre><code>package com.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.entity.User;public class AppTest {    SqlSessionFactory sqlSessionFactory = null;    @Before    public void Init() throws IOException{        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testSelectUser() {//查找数据        SqlSession sqlSession = sqlSessionFactory.openSession();        //第一个参数是Statement的id,第二个参数是SQL语句中所需要的值。        /*User user = (User)sqlSession.selectOne(&quot;findUserById&quot;, 2);        System.out.println(user.toString());*/        //List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName&quot;, &quot;EchoDemo&quot;);        List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName1&quot;, &quot;Echo&quot;);        for(User user:list){            System.out.println(user.toString());        }        sqlSession.close();    }    @Test    public void testInsertUser(){//插入数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(&quot;落叶物语&quot;,24);        sqlSession.insert(&quot;addUser&quot;, user);        sqlSession.commit();//提交        sqlSession.close();        System.out.println(&quot;当前插入用户的ID:&quot; + user.getId());    }    @Test    public void testDeleteUser(){//删除数据        SqlSession sqlSession = sqlSessionFactory.openSession();        sqlSession.delete(&quot;deleteUser&quot;,2);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testUpdateUser(){//更新数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(3,&quot;紫苏半夏&quot;,22);        sqlSession.update(&quot;updateUser&quot;, user);        sqlSession.commit();        sqlSession.close();    }}</code></pre><p>1)每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。</p><p>2)SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在以保证所有的XML解析资源开放给更重要的事情。</p><p>3)SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p>4)每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Pl
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML</title>
    <link href="http://www.echodemo.cc/2018/08/07/Java%E4%B8%AD%E7%9A%84XML/"/>
    <id>http://www.echodemo.cc/2018/08/07/Java中的XML/</id>
    <published>2018-08-07T08:50:21.000Z</published>
    <updated>2018-08-07T08:51:40.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、XML定义"><a href="#1、XML定义" class="headerlink" title="1、XML定义"></a>1、XML定义</h3><p>(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输，类似HTML，不同的是它的设计宗旨是传输数据，而非显示数据。</p><p>(2)XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。XML标签没有被预定义，开发者根据需要自行定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。</p><h3 id="2、XML文档结构"><a href="#2、XML文档结构" class="headerlink" title="2、XML文档结构"></a>2、XML文档结构</h3><p>(1)XML声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p>(2)XML根元素定义：XML文档的树形结构要求必须有一个根元素。根元素的起始标记要放在所有其他元素起始标记之前，根元素的结束标记放在其他元素的结束标记之后。</p><p>(3)XML元素：元素的基本结构由开始标记，数据内容，结束标记组成。</p><h3 id="3、XML语法规则"><a href="#3、XML语法规则" class="headerlink" title="3、XML语法规则"></a>3、XML语法规则</h3><pre><code>(1)所有XML元素都须有关闭标签。(2)XML标签对大小写敏感。(3)XML必须正确地嵌套。(4)XML文档必须有根元素。(5)XML的属性以名值对方式组成，值须加引号。(6)XML可编写注释。(7)在XML中，空格会被保留，文档中的空格不会被删节。</code></pre><h3 id="4、举例说明"><a href="#4、举例说明" class="headerlink" title="4、举例说明"></a>4、举例说明</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;    &lt;book bookno=&quot;001&quot;&gt;        &lt;title&gt;Java语言编程&lt;/title&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;80&lt;/price&gt;    &lt;/book&gt;    .    .    .&lt;/bookstore&gt;</code></pre><h3 id="5、XML-SAX解析器"><a href="#5、XML-SAX解析器" class="headerlink" title="5、XML SAX解析器"></a>5、XML SAX解析器</h3><p>(1)SAX(Simple API For XML)是一个公共的基于事件的XML文档解析标准，能够通过一个简单的、快速的方法来对XML文档进行处理，和DOM相比它所占用的系统资源更少。</p><p>(2)SAX既是一个接口，也是一个软件包。作为接口，SAX是事件驱动型XML解析的一个标准接口，对文档进行顺序扫描，当扫描到文档(document)开始、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</p><h3 id="6、SAX解析器API"><a href="#6、SAX解析器API" class="headerlink" title="6、SAX解析器API"></a>6、SAX解析器API</h3><p>(1)事件类型，大多数的SAX会产生以下类型的事件：</p><pre><code>1)在文档的开始时和结束时触发文档处理事件。2)在文档内每一XML元素接受解析的前后触发元素事件。3)任何的元数据通常由单独的事件处理。</code></pre><p>(2)举例说明</p><pre><code>&lt;doc&gt;    &lt;para&gt;Hello,iotek!&lt;/para&gt;&lt;doc&gt;其解析过程为：1)start document;2)start element:doc;3)start element.para;4)characters:Hello,iotek!;5)end element:para;6)end element:doc;7)end document;</code></pre><p>(3)解析步骤</p><pre><code>1)创建事件处理程序(即编写ContentHandler的实现类，一般继承自DefaultHandler类，采用adapter模式)2)创建SAX解析器3)将事件处理程序分配到解析器。4)对文档进行解析，将每个事件发送至事件处理程序。</code></pre><p>(4)常用接口：ContentHandler接口</p><p>1)ContentHandler是Java类包中一个特殊的SAX接口。该接口封装了一些对事件处理的方法，当XML解析器开始解析XML输入文档时，他会遇到某些特殊的事件，比如文档的开头和结束、元素开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法(回调方法)来响应该事件。</p><p>2)ContentHandler接口常用方法：</p><pre><code>void startDocument();//文档解析开始的处理。void endDocument();//文档解析结束的处理。void startElement(String uri,String localName,String qName,Attributes atts);//ElementNode开始的处理。void endElement(String uri,String localName,String qName);//ElementNode结束的处理。void character(char[] ch,int start,int length);//具体在某一节点中的处理。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、XML定义&quot;&gt;&lt;a href=&quot;#1、XML定义&quot; class=&quot;headerlink&quot; title=&quot;1、XML定义&quot;&gt;&lt;/a&gt;1、XML定义&lt;/h3&gt;&lt;p&gt;(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中反射与Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%8EAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中反射与Annotation/</id>
    <published>2018-08-06T11:41:30.000Z</published>
    <updated>2018-08-06T11:42:10.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、MetaAnnotation概念"><a href="#1、MetaAnnotation概念" class="headerlink" title="1、MetaAnnotation概念"></a>1、MetaAnnotation概念</h3><p>(1)MetaAnnotation也称为元Annotation，也是一种Annotation，可以对其他的Annotation进行注释。</p><p>(2)Java5.0提供了一些标准的MetaAnnotation：</p><pre><code>1)@Retention2)@Target3)@Documented4)@Inherited</code></pre><p>(3)@Retention:控制被Retention注释的Annotation信息的保留时间长短。</p><pre><code>@Retention(SOURCE/CLASS/RUNTIME)public/default @interface Annotation名称{...}a、SOURCE:Annotation信息在编译阶段被丢弃，仅保留在java源文件中。b、CLASS(默认):Annotation信息在编译阶段被保留，保留到class文件中，但是运行阶段不存在。c、RUNTIME:Annotation信息一直保存到运行阶段，直到退出虚拟机才被丢弃。以上三个值是java.lang.annotation.RetentionPolicy这个类所提供的枚举值。</code></pre><p>(4)@Target:表示一个Annotation的使用范围。</p><pre><code>@Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD,...})public/defalut @interface Annotation名字{...}a、TYPE:只能在类或接口或枚举上使用。b、METHOD:在方法中使用。c、FIELD:在成员变量使用。d、PARAMETER:在参数上使用。e、CONSTRUCTOR:在构造中使用。f、LOCAL_VARIABLE:在局部变量上使用。g、ANNOTATION_TYPE:只能在Annotation中使用。h、PACKAGE:只能在包中使用。</code></pre><p>(5)@Documented:想要在使用者制作JavaDoc文件的同时，也一并将Annotation的讯息加入至API文件中。</p><pre><code>@Documentedpublic/default @interface Annotation名称{...}</code></pre><p>(4)@Inherited:表示一个Annotation是否允许被其子类继承下来。</p><pre><code>@Inheritedpublic/default @inherited Annotation名称{...}</code></pre><h3 id="2、反射与Annotation"><a href="#2、反射与Annotation" class="headerlink" title="2、反射与Annotation"></a>2、反射与Annotation</h3><p>(1)一个Annotation真正起作用，必须结合反射机制，在java.lang.reflect反射包中提供AccessibleObject类来对Annotation进行操作，最常用的方法如下：</p><pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);//判断是否使用时指定的Annotation。public Annotation[] getAnnotation();//得到全部的Annotation。注：无反射，不注解。</code></pre><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;public class ReflectAnnotationDemo {    public static void main(String[] args) throws Exception {        Class&lt;?&gt; classType = Class.forName(&quot;com.iotek.annotation.AnnotationTest&quot;);        boolean flag = classType.isAnnotationPresent(Description.class);        if(flag){            Description description = classType.getAnnotation(Description.class);            System.out.println(&quot;AnnotationTest&apos;s description--&gt;&quot; + description.value());            Method[] methods = classType.getDeclaredMethods();            for(Method method:methods){                if(method.isAnnotationPresent(Author.class)){                    Author author = method.getAnnotation(Author.class);                    System.out.println(&quot;AnnotationTest&apos;s author--&gt;&quot; + author.name() + &quot; from &quot;+author.group());                }            }        }    }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documented@interface Author{    String name();    String group();}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@interface Description{    String value();}@Description(&quot;这是一个用于测试的类&quot;)class AnnotationTest{    @Author(name=&quot;EchoDemo&quot;,group=&quot;com.iotek&quot;)    public void test(){        System.out.println(&quot;test over!&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、MetaAnnotation概念&quot;&gt;&lt;a href=&quot;#1、MetaAnnotation概念&quot; class=&quot;headerlink&quot; title=&quot;1、MetaAnnotation概念&quot;&gt;&lt;/a&gt;1、MetaAnnotation概念&lt;/h3&gt;&lt;p&gt;(1)Met
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%ADAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中Annotation/</id>
    <published>2018-08-06T10:25:49.000Z</published>
    <updated>2018-08-06T10:26:23.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Annotation简介"><a href="#1、Annotation简介" class="headerlink" title="1、Annotation简介"></a>1、Annotation简介</h3><p>(1)Annotation是Java5开始引入的新特性。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素(类、方法、成员变量等)进行关联。更通俗的意思就是为程序的元素(类、方法、成员变量)加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>(2)Annotation的原理</p><p>1)Annotation其实是一种接口。通过Java反射机制中的相关API来访问annotation信息。相关类(框架或工具的类)根据这些信息来决定如何使用该程序元素或者改变他们的行为。Annotation是不会影响程序代码的执行的，无论Annotation怎么变化，代码都始终如一地执行。</p><p>2)Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。Annotation的工具统称APT(Annotation Processing Tool)。</p><h3 id="2、常见的标准Annotation"><a href="#2、常见的标准Annotation" class="headerlink" title="2、常见的标准Annotation"></a>2、常见的标准Annotation</h3><p>(1)@Override:@Override就是用来指定方法重写的，他可以强调一个子类必须要覆盖父类的方法。</p><p>(2)@Deprecated:@deprecated用于表示某个程序元素(类、方法等)已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</p><p>(3)@SuppressWarning：@SuppressWarning指示被Annotation标识的程序元素(以及在该程序元素中的所有子元素)取消显示指定的编译器警告。</p><p>(4)举例说明</p><p>1)@Override:可以防止方法名写错。</p><pre><code>package com.iotek.annotation;public class OVerrideDemo {    public static void main(String[] args) {        Apple apple = new Apple();        apple.info();    }}class Fruit{    public void info(){        System.out.println(&quot;描述水果的信息！&quot;);    }}class Apple extends Fruit{    @Override    public void info() {        System.out.println(&quot;我是苹果！&quot;);    }}</code></pre><p>2)@Deprecated:提示程序员不推荐使用</p><pre><code>package com.iotek.annotation;public class DeprecatedDemo {    public static void main(String[] args) {        Person person = new Person();        person.showInfo();    }}class Person{    @Deprecated    public void showInfo(){        System.out.println(&quot;hello person!&quot;);    }}</code></pre><p>3)@Suppresswarning:去除警告信息</p><pre><code>package com.iotek.annotation;public class SuppresswarningDemo {    public static void main(String[] args) {    }}class Container&lt;T&gt;{    private Object[] obj = null;    public Container(){        obj = new Object[10];    }    @SuppressWarnings(&quot;unchecked&quot;)    public T[] toArray(){        return (T[])obj;    }}</code></pre><h3 id="3、自定义Annotation"><a href="#3、自定义Annotation" class="headerlink" title="3、自定义Annotation"></a>3、自定义Annotation</h3><p>(1)语法</p><pre><code>访问修饰符 @interface Annotation名称{    返回类型 method() [默认值];}</code></pre><p>1)Annotation类型的方法必须声明为无参数、无异常抛出的。这些方法定义了Annotation的成员：方法名成为了成员名，而方法返回值成为了成员的类型。方法的返回类型必须要为基本数据类型、String类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一维数组。</p><p>2)方法的后面可以使用default和一个默认数值来声明成员的默认值来声明成员的默认值，null不能作为成员的默认值。在定义Annotation型态时，不能继承其他的Annotation型态或是接口。</p><p>(2)举例说明</p><pre><code>package com.iotek.annotation;//可以修饰类@MyAnnotation1public class MyAnnotation {    //可以修饰方法    @MyAnnotation1    @MyAnnotation3    public static void main(String[] args) {        //可以修饰成员变量，可以有多个注解        @MyAnnotation1        @MyAnnotation2(name=&quot;zhangsan&quot;)        @MyAnnotation3(&quot;haha&quot;)        @MyAnnotation4(sex=&quot;男&quot;,age=10)        @MyAnnotation5({&quot;haah&quot;,&quot;hehe&quot;,&quot;ee&quot;})        @MyAnnotation6(color=Color.RED)        int number = 10;    }}@interface MyAnnotation1{}@interface MyAnnotation2{    String name();}@interface MyAnnotation3{//value和默认值    String value() default &quot;lisi&quot;;//只有为value时才可以省略&quot;value=&quot;，有默认值时可以不给值。}@interface MyAnnotation4{//两个元素    String sex();    int age();}@interface MyAnnotation5{//数组    String[] value();}enum Color{    RED,BLUE,YELLOW;}@interface MyAnnotation6{//枚举类型    Color color();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Annotation简介&quot;&gt;&lt;a href=&quot;#1、Annotation简介&quot; class=&quot;headerlink&quot; title=&quot;1、Annotation简介&quot;&gt;&lt;/a&gt;1、Annotation简介&lt;/h3&gt;&lt;p&gt;(1)Annotation是Java5开始引
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中URL类的使用</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%ADURL%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中URL类的使用/</id>
    <published>2018-08-05T08:43:08.000Z</published>
    <updated>2018-08-05T08:48:25.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、URL概念"><a href="#1、URL概念" class="headerlink" title="1、URL概念"></a>1、URL概念</h3><p>URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。它由五个部分组成：</p><pre><code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#&lt;引用&gt;</code></pre><h3 id="2、URL编程"><a href="#2、URL编程" class="headerlink" title="2、URL编程"></a>2、URL编程</h3><p>(1)为了表示URL，java.net包中实现了类URL。我们可以通过下面的构造方法来初始化一个URL对象：</p><pre><code>URL(String url);//URL代表了一个绝对地址，URL对象直接指向这个资源。URL(URL baseURL,String relativeURL);//其中baseURL代表绝对地址，realtiveURL代表相对地址。URL(String protocol,String host,String file);//protocol代表通信协议，host代表主机名，file代表文件名。URL(String protocol,String host,int port,String file);</code></pre><p>(2)获取URL对象的属性：</p><pre><code>getFile();//获得URL指定资源的完整文件名。getHost();//返回主机名。getPath();//返回指定资源的文件目录和文件名。getPort();//返回端口号。getProtocol();//返回表示URL中协议的字符串对象。getRef();//返回URL的HTML文档标记，即#号标记。getUserInfo();//返回用户信息。</code></pre><p>(3)URL有两种方法可以用来访问Internet上的资源：</p><p>1)使用URL的openConnection()方法创建一个URLConnection类对象。再通过URLConnection对象获取相应的输入流和输出流。</p><p>2)利用URL类的openStream()方法。openStream()方法与指定的URL建立连接并返回InputStream类的对象。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.url;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class URLDemo {    public static void main(String[] args) throws IOException {        DownloadUtil.download(&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot;, &quot;baidu.jpg&quot;, &quot;f:\\test&quot;);        System.out.println(&quot;下载结束！&quot;);    }}class DownloadUtil{    public static void download(String urlString,String fileName,String savePath) throws IOException{        URL url = new URL(urlString);        /*URLConnection conn = url.openConnection();        InputStream inputStream = conn.getInputStream();*/        InputStream inputStream = url.openStream();        byte[] buff = new byte[1024*1024];        int len = 0;        File file = new File(savePath);        if(!file.exists()){            file.mkdirs();        }        OutputStream outputStream = new FileOutputStream(file.getAbsolutePath()+&quot;\\&quot;+fileName);        while((len = inputStream.read(buff))!=-1){            outputStream.write(buff, 0, len);        }        inputStream.close();        outputStream.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、URL概念&quot;&gt;&lt;a href=&quot;#1、URL概念&quot; class=&quot;headerlink&quot; title=&quot;1、URL概念&quot;&gt;&lt;/a&gt;1、URL概念&lt;/h3&gt;&lt;p&gt;URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于UDP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于UDP协议的Socket编程/</id>
    <published>2018-08-05T07:25:21.000Z</published>
    <updated>2018-08-05T08:47:04.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建发送端"><a href="#1、创建发送端" class="headerlink" title="1、创建发送端"></a>1、创建发送端</h3><p>(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可以手动指定。</p><p>(2)将数据进行packet包的封装，必须要指定目的地地址和端口。</p><p>(3)通过socket服务的send()方法将该包发出。</p><p>(4)将socket关闭。</p><h3 id="2、创建接收端"><a href="#2、创建接收端" class="headerlink" title="2、创建接收端"></a>2、创建接收端</h3><p>(1)建立DatagramSocket对象。要监听一个端口。</p><p>(2)通过socket的receive方法将数据存入数据包中。</p><p>(3)通过数据包dp的方法getData()、getAddress()、getPort()等方法获取包中的指定信息。</p><p>(4)将socket关闭。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)接收端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDPDemo2 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket(8000);        byte[] buff = new byte[100];        DatagramPacket packet = new DatagramPacket(buff, 100);        socket.receive(packet);//接收传来的数据包        System.out.println(new String(buff,0,packet.getLength()));        String string = &quot;Me too!&quot;;        DatagramPacket packet2 = new DatagramPacket(string.getBytes(), string.length(),packet.getAddress(),packet.getPort());        socket.send(packet2);        socket.close();    }}</code></pre><p>(2)发送端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPDemo1 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket();        String string = &quot;I Love You!&quot;;        //将数据进行封装，封装到数据包当中        DatagramPacket packet = new DatagramPacket(string.getBytes(), string.length(),InetAddress.getByName(&quot;localhost&quot;),8000);        socket.send(packet);//发送        byte[] buff = new byte[100];        DatagramPacket packet2 = new DatagramPacket(buff, 100);        socket.receive(packet2);        System.out.println(new String(buff,0,packet2.getLength()));        socket.close();    }}</code></pre><p>(3)为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . UDP*.java//开启接收端java com.iotek.tcpsocket.UDPDemo2//开启发送端，这里另外开启一个窗口java com.iotek.tcpsocket.UDPDemo1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、创建发送端&quot;&gt;&lt;a href=&quot;#1、创建发送端&quot; class=&quot;headerlink&quot; title=&quot;1、创建发送端&quot;&gt;&lt;/a&gt;1、创建发送端&lt;/h3&gt;&lt;p&gt;(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于TCP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于TCP协议的Socket编程/</id>
    <published>2018-08-05T03:38:19.000Z</published>
    <updated>2018-08-05T08:53:09.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Socket概述"><a href="#1、Socket概述" class="headerlink" title="1、Socket概述"></a>1、Socket概述</h3><p>(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。它是连接运行在网络上的两个程序间的双向通讯的端点。</p><p>(2)网络通讯其实指的就是socket间的通讯。通讯的两端都有socket，数据在两个socket之间通过IO来进行传输。</p><p>(3)使用socket进行网络通信的过程</p><pre><code>1)服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求。2)客户程序根据服务器程序所在的主机名和端口号发出连接请求。3)如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。4)客户和服务器通过读、写套接字进行通讯。</code></pre><h3 id="2、基于TCP协议的socket编程"><a href="#2、基于TCP协议的socket编程" class="headerlink" title="2、基于TCP协议的socket编程"></a>2、基于TCP协议的socket编程</h3><p>(1)创建TCP服务端步骤：</p><pre><code>1)创建一个ServerSocket对象2)调用accept()方法接受客户端请求3)从socket中获取IO流4)对IO流进行读写操作，完成与客户端的交互。5)关闭IO流和Socket</code></pre><p>(2)创建TCP客户端步骤：</p><pre><code>1)创建一个Socket对象2)从Socket中获取IO流3)对IO流进行读写操作，完成与服务端的交互4)关闭IO流和Socket</code></pre><p>注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。</p><p>(3)举例说明</p><p>1)服务器端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class TCPServer {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(8888);//创建一个ServerSocket对象        Socket socket = serverSocket.accept();//调用accept()方法来接受客户端的请求        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has connected!&quot;);        //获取socket对象的输入输出流        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        String line = null;        while((line = bReader.readLine())!=null){//读取客户端传过来的数据            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(line);            /*bWriter.write(line.toUpperCase());//把转换成大写的字符串传给客户端            bWriter.newLine();//换行，这样客户端才能知道输入什么时候结束的            bWriter.flush();*/            pWriter.println(line.toUpperCase());        }        //bWriter.close();        pWriter.close();        bReader.close();        socket.close();        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has disconnected!&quot;);    }}</code></pre><p>2)客户端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class TCPClient {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        BufferedReader bw = new BufferedReader(new InputStreamReader(socket.getInputStream()));        while(true){            String line = bReader.readLine();//获取键盘所输入的字符串            /*bWriter.write(line);            bWriter.newLine();//换行，这样服务端才能识别一行的结束            bWriter.flush();*/            pWriter.println(line);            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(bw.readLine());//获取服务端传来的大写字符串        }        bReader.close();        bw.close();        //bWriter.close();        pWriter.close();        socket.close();    }}</code></pre><p>为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . *.java//开启服务器java com.iotek.tcpsocket.TCPServer//开启客户端，这里另外开启一个窗口java com.iotek.tcpsocket.TCPClient</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Socket概述&quot;&gt;&lt;a href=&quot;#1、Socket概述&quot; class=&quot;headerlink&quot; title=&quot;1、Socket概述&quot;&gt;&lt;/a&gt;1、Socket概述&lt;/h3&gt;&lt;p&gt;(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中网络编程基础知识和通讯要素</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中网络编程基础知识和通讯要素/</id>
    <published>2018-08-05T02:25:36.000Z</published>
    <updated>2018-08-05T03:41:58.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、网络基础知识"><a href="#1、网络基础知识" class="headerlink" title="1、网络基础知识"></a>1、网络基础知识</h3><p>(1)计算机网络</p><p>计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能性强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p><p>(2)网络体系结构</p><p>网络体系结构定义计算机设备和其他设备如何连接在一起以形成一个允许用户共享信息和资源的通信系统。国际标准化组织ISO于1978年提出“开放系统互连参考模型”，即著名的OSI(Open System Interconnection)模型。OSI模型保证了各类设备生产厂家的产品兼容性。该模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>(3)TCP/IP协议</p><p>TCP/IP协议是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络接口层、网络层、传输层和应用层。</p><h3 id="2、网络通信要素"><a href="#2、网络通信要素" class="headerlink" title="2、网络通信要素"></a>2、网络通信要素</h3><p>(1)网络编程的目的</p><p>网络编程的目的就是指直接或者间接地通过网络协议与其他计算机进行通讯。网络编程中有两个主要问题，一个是如何准确的定位网络上一台或者多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。</p><p>(2)IP地址</p><p>网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。对应的类-InetAddress。</p><p>(3)端口号</p><p>端口号用来表示该计算机上的应用程序，代表此应用程序逻辑地址。端口号使用一个16位的数字来表示，它的范围是0~65535,1024以下的端口号保留给预定义的服务。例如：http使用80端口。</p><p>(4)协议</p><p>为计算机网络中进行数据交互而建立的规则、标准或约定的集合。</p><pre><code>TCP是一种面向连接的保证可靠传输的协议。UDP是一种无连接的且不可靠的传输协议。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、网络基础知识&quot;&gt;&lt;a href=&quot;#1、网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、网络基础知识&quot;&gt;&lt;/a&gt;1、网络基础知识&lt;/h3&gt;&lt;p&gt;(1)计算机网络&lt;/p&gt;
&lt;p&gt;计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的RandomAccessFile</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84RandomAccessFile/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的RandomAccessFile/</id>
    <published>2018-08-04T08:47:03.000Z</published>
    <updated>2018-08-04T08:47:37.658Z</updated>
    
    <content type="html"><![CDATA[<p>1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。</p><p>2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，随着对字节的写入而前移此文件指针。</p><p>3、写入该隐含数组末尾之后的输出操作导致该数组扩展。该文件指针可以通过getFilePointer方法读取，通过seek方法设置该文件指针的位置。</p><p>4、RandomAccessFile举例</p><pre><code>package com.iotek.otherio;import java.io.IOException;import java.io.RandomAccessFile;import java.util.Scanner;public class RandomAccessFileDemo {    public static void main(String[] args) throws IOException {        Person[] persons = {new Person(&quot;chenhao&quot;,90),                new Person(&quot;justin&quot;,30),new Person(&quot;bush&quot;,80),                new Person(&quot;lisi&quot;,20)};        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;f:\\test\\3.txt&quot;, &quot;rw&quot;);        /*for(int i=0;i&lt;persons.length;i++){//写入数据到RandomAccessFile这个对象中            randomAccessFile.writeChars(persons[i].getName());            randomAccessFile.writeInt(persons[i].getAge());        }*/        //读取指定位置上的Person对象        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;读取第几个Person对象数据&quot;);        int num = scanner.nextInt();        //使用seek方法来操作存取位置        randomAccessFile.seek((num-1)*Person.size());        Person person = new Person();        person.setName(readName(randomAccessFile));        person.setAge(randomAccessFile.readInt());        System.out.println(&quot;姓名:&quot;+person.getName());        System.out.println(&quot;年龄:&quot;+person.getAge());        randomAccessFile.close();    }    private static String readName(RandomAccessFile randomAccessFile) throws IOException{        char[] name = new char[15];        for(int i=0;i&lt;name.length;i++){            name[i] = randomAccessFile.readChar();         }        return new String(name).replace(&apos;\u0000&apos;, &apos; &apos;);    }}class Person{    private String name;    private int age;    public Person(){    }    public Person(String name, int age) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //每个对象所占的字节数    public static int size(){        return 34;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。&lt;/p&gt;
&lt;p&gt;2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中其他的IO流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84IO%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中其他的IO流/</id>
    <published>2018-08-04T07:45:54.000Z</published>
    <updated>2018-08-04T07:46:30.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、ObjectInputStream和ObjectOutputStream"><a href="#1、ObjectInputStream和ObjectOutputStream" class="headerlink" title="1、ObjectInputStream和ObjectOutputStream"></a>1、ObjectInputStream和ObjectOutputStream</h3><p>ObjectInputStream和ObjectOutputStream分别与FileInputStream和FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。我们把对象以某种特定的编码格式写入称之为“序列化”。把写入的编码格式内容还原成对象称之为“反序列化”。被序列化的对象必须实现Serializable接口。</p><pre><code>package com.iotek.otherio;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectInputOutputDemo {    public static void main(String[] args) throws IOException {        /*Student student = new Student(&quot;zhangsan&quot;, 30);        FileOutputStream fos = new FileOutputStream(&quot;f:\\test\\1.txt&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);        objectOutputStream.writeObject(student);//把对象序列化到指定的文件输出流中        objectOutputStream.close();//释放资源*/            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;f:\\test\\1.txt&quot;));        try {            Student student = (Student)objectInputStream.readObject();            System.out.println(student);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class Student implements Serializable{//需要实现Serializable接口    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="2、InputStreamReader和OutputStreamWriter"><a href="#2、InputStreamReader和OutputStreamWriter" class="headerlink" title="2、InputStreamReader和OutputStreamWriter"></a>2、InputStreamReader和OutputStreamWriter</h3><p>转换流是指将字节流与字符流之间进行转换。转换流的出现方便了对文件的读写，它在字符流与字节流之间架起了一座桥梁，使原本毫无关联的两种操作能够进行转化，提高了程序的灵活性。字节流中的数据都是字符时，转化成字符流操作更高效。如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式的参数，而FileReader与FileWriter是默认编码的文本文件。</p><pre><code>package com.iotek.otherio;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputStreamWriterReaderDemo {    public static void main(String[] args) throws IOException {        /*OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;f:\\test\\2.txt&quot;), &quot;utf-8&quot;);        BufferedWriter bw = new BufferedWriter(osw);        bw.write(&quot;您好&quot;);        bw.close();*/        /*BufferedReader br = new BufferedReader(new FileReader(&quot;f:\\test\\2.txt&quot;));        String line = null;        while((line = br.readLine())!=null){            System.out.println(line);        }        br.close();*/        BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;f:\\test\\2.txt&quot;),&quot;utf-8&quot;));        String line = null;        while((line = bReader.readLine())!=null){            System.out.println(line);        }        bReader.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、ObjectInputStream和ObjectOutputStream&quot;&gt;&lt;a href=&quot;#1、ObjectInputStream和ObjectOutputStream&quot; class=&quot;headerlink&quot; title=&quot;1、ObjectInputStr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的字符流/</id>
    <published>2018-08-04T06:03:29.000Z</published>
    <updated>2018-08-04T06:32:10.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Reader和Writer抽象类"><a href="#1、Reader和Writer抽象类" class="headerlink" title="1、Reader和Writer抽象类"></a>1、Reader和Writer抽象类</h3><p>字节流提供处理任何类型输入输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。字符流层次结构的顶层是Reader和Writer抽象类，它们的顶层仍然是字节流。Reader是定义Java的流式字符输入模式的抽象类。Reader抽象类中的方法和InputStream类似。Writer是定义Java的流式字符输出模式的抽象类。该类的方法都返回void值并在出错条件下抛IOException异常。Writer抽象类中的方法和OutputStream类似。</p><h3 id="2、FileReader和FileWriter"><a href="#2、FileReader和FileWriter" class="headerlink" title="2、FileReader和FileWriter"></a>2、FileReader和FileWriter</h3><p>FileReader类表示可以读取文件内容的Reader类，构造方法有：</p><pre><code>FileReader(String filePath)FileReader(File fileObj)</code></pre><p>FileWriter表示可以写文件的Writer类，构造方法有：</p><pre><code>FileWriter(String filePath)FileWriter(String filePath,boolean append)FileWriter(File fileObj)</code></pre><h3 id="3、FileReader和FileWriter举例"><a href="#3、FileReader和FileWriter举例" class="headerlink" title="3、FileReader和FileWriter举例"></a>3、FileReader和FileWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        char[] buffer = new char[100];        FileWriter fWriter = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        int len = 0;//实际读到的字符个数        while((len = fr.read(buffer))!=-1){            fWriter.write(buffer,0,len);        }        fr.close();        fWriter.close();    }}</code></pre><h3 id="4、BufferedReader和BufferedWriter"><a href="#4、BufferedReader和BufferedWriter" class="headerlink" title="4、BufferedReader和BufferedWriter"></a>4、BufferedReader和BufferedWriter</h3><p>BufferedReader通过缓冲区提高输入性能。BufferedWriter则通过缓冲区提高输出性能。类似于BufferedInputStream和BufferedOutputStream。分别都具有两个构造方法：</p><pre><code>BufferedReader(Reader inputStream)BufferedReader(Reader inputStream,int bufSize)BufferedWriter(Writer ouputStream)BufferedWriter(Writer outputStream,int bufSize)</code></pre><h3 id="5、BufferedReader和BufferedWriter举例"><a href="#5、BufferedReader和BufferedWriter举例" class="headerlink" title="5、BufferedReader和BufferedWriter举例"></a>5、BufferedReader和BufferedWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class BufferedReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        FileWriter fw = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        BufferedReader bReader = new BufferedReader(fr);        BufferedWriter bWriter = new BufferedWriter(fw);        String line = null;        while((line=bReader.readLine())!=null){            System.out.println(line);            bWriter.write(line);//写入一行            bWriter.newLine();//换行            //bWriter.flush();//不使用close()方法时需要使用此方法        }        bReader.close();        bWriter.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;a href=&quot;#1、Reader和Writer抽象类&quot; class=&quot;headerlink&quot; title=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;/a&gt;1、Reader和Writer抽象类&lt;/h3&gt;&lt;p&gt;字节流提供处
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用字节流复制一个文件夹</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中使用字节流复制一个文件夹/</id>
    <published>2018-08-04T01:21:32.000Z</published>
    <updated>2018-08-04T01:22:53.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>使用字节流复制一个文件夹中的所有内容到指定的文件夹中。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>使用递归算法，使用字节缓冲区来提高程序效率。</p><h3 id="3、案例实现："><a href="#3、案例实现：" class="headerlink" title="3、案例实现："></a>3、案例实现：</h3><pre><code>package com.iotek.file;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyFileDemo {    public static void main(String[] args) throws IOException {        CopyUtil.copyDir(new File(&quot;f:\\haha&quot;), new File(&quot;f:\\ee&quot;));    }}class CopyUtil{    public static void copyDir(File src,File dst) throws IOException{        dst.mkdirs();//相比于mkdir()会创建路径中本不存在的文件夹        if(src!=null){            File[] files = src.listFiles();//遍历原文件夹中的文件或目录            if(files!=null){                for(File f:files){                    if(f.isFile()){//复制文件                        FileInputStream fis = new FileInputStream(f);                        FileOutputStream fos = new FileOutputStream(dst.getAbsolutePath() + &quot;\\&quot; + f.getName());                        byte[] buffer = new byte[1024*1024];                        int len = 0;//保存读到的字节个数                        while((len = fis.read(buffer))!=-1){                            fos.write(buffer,0,len);                        }                        fis.close();                        fos.close();                    }else {                        copyDir(f, new File(dst.getAbsolutePath()+&quot;\\&quot;+dst.getName()));                    }                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;使用字节流复制一个文件夹中的所有内容到指定的文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;2、案例设计&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git入门(二)</title>
    <link href="http://www.echodemo.cc/2018/08/02/Git%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/08/02/Git入门(二)/</id>
    <published>2018-08-02T02:38:07.000Z</published>
    <updated>2018-08-02T02:39:34.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、比较分支"><a href="#1、比较分支" class="headerlink" title="1、比较分支"></a>1、比较分支</h3><pre><code>//查看test分支和master之间的差别$ git diff master test//查看当前的工作目录与另外一个分支的差别，查看与test分支的区别$ git diff test//你也以加上路径限定符，来只比较某一个文件或目录$ git diff test file1//--stat 参数可以统计一下有哪些文件被改动，有多少行被改动$ git diff test --stat</code></pre><h3 id="2、分布式的工作流程"><a href="#2、分布式的工作流程" class="headerlink" title="2、分布式的工作流程"></a>2、分布式的工作流程</h3><p>(1)分布式的工作流程</p><p>你目前的项目在gitproject目录下，这是我们的git仓库(repository)，假设另一个用户也想与你协作开发。他的工作目录也在这台机器上。首先，我们假设另一个用户也用相同的用户登录，只是工作在不同的目录下开发代码，实际工作中不太可能发生，大部分情况都是多个用户，这个假设只是为了让实验简化。</p><pre><code>//克隆git仓库，建了一个新的叫&quot;myrepo&quot;的目录，这个目录里包含了一份gitproject仓库的克隆$ git clone gitproject myrepo//查看$ ls -l myrepo</code></pre><p>在 myrepo 做了一些修改并且提交：</p><pre><code>$ cd myrepo//添加新的文件newfile$ echo &quot;newcontent&quot; &gt; newfile//提交修改$ git add newfile$ git commit -m &quot;add newfile&quot;</code></pre><p>myrepo修改完成后，可以在仓库gitproject中把myrepo的修改给拉(pull)下来，合并这份修改到gitproject的git仓库。git pull命令执行两个操作: 它从远程分支(remote branch)抓取修改git fetch的内容，然后把它合并git merge进当前的分支。如果gitproject在myrepo修改文件内容的同时也做了修改的话，可能需要手工去修复冲突。</p><pre><code>$ cd gitproject$ git pull myrepo master$ ls   </code></pre><p>gitproject里可以用git fetch 来执行git pull前半部分的工作，但是这条命令并不会把抓下来的修改合并到当前分支里：</p><pre><code>$ git fetch myrepo</code></pre><p>获取后，我们可以通过git log查看远程分支做的所有修改，由于我们已经合并了所有修改，所以不会有任何输出：</p><pre><code>$ git log -p master..myrepo/master</code></pre><p>当检查完修改后，gitproject可以把修改合并到它的主分支中：</p><pre><code>$ git merge myrepo/master</code></pre><p>如果我们在myrepo目录下执行git pull。myrepo会从克隆的位置拉取代码并更新本地仓库，就是把gitproject上的修改同步到本地:</p><pre><code>//进入到gitproject$ cd gitproject//添加一行内容到newfile$ echo &quot;gitproject: new line&quot; &gt;&gt; newfile//提交修改$ git commit -a -m &apos;add newline to newfile&apos;//进入myrepo目录$ cd myrepo//同步gitproject的所有修改$ git pull</code></pre><p>因为myrepo是从gitproject仓库克隆的，那么他就不需要指定gitproject仓库的地址。因为Git把gitproject仓库的地址存储到myrepo的配置文件中，这个地址就是在git pull时默认使用的远程仓库:</p><pre><code>$ git config --get remote.origin.url</code></pre><p>(2)公共git仓库</p><p>开发过程中，通常大家都会使用一个公共的仓库，并clone到自己的开发环境中，完成一个阶段的代码后可以告诉目标仓库的维护者来pull自己的代码。如果你和维护者都在同一台机器上有帐号，那么你们可以互相从对方的仓库目录里直接拉所作的修改，git命令里的仓库地址也可以是本地的某个目录名：</p><pre><code>$ git clone /path/to/repository$ git pull /path/to/other/repository//也可以是一个ssh地址：$ git clone ssh://yourhost/~you/repository</code></pre><p>(3)将修改推到一个公共仓库</p><p>通过http或是git协议，其它维护者可以通过远程访问的方式抓取(fetch)你最近的修改，但是他们 没有写权限。如何将本地私有仓库的最近修改主动上传到公共仓库中呢？最简单的办法就是用git push命令，推送本地的修改到远程Git仓库，执行下面的命令:</p><pre><code>$ git push ssh://yourserver.com/~you/proj.git master:master或者:$ git push ssh://yourserver.com/~you/proj.git master</code></pre><p>如果推送(push)结果不是快速向前fast forward，可能会报像错。常是因为没有使用git pull获取远端仓库的最新更新，在本地修改的同时，远端仓库已经变化了（其他协作者提交了代码），此时应该先使用git pull合并最新的修改后再执行git push：</p><pre><code>$ git pull$ git push ssh://yourserver.com/~you/proj.git master</code></pre><h3 id="3、git标签"><a href="#3、git标签" class="headerlink" title="3、git标签"></a>3、git标签</h3><p>(1)轻量级标签</p><p>我们可以用 git tag不带任何参数创建一个标签(tag)指定某个提交(commit):</p><pre><code>//进入到gitproject目录$ cd gitproject//查看git提交记录$ git log//选择其中一个记录标志位stable-1的标签，注意需要将后面的8c315325替换成仓库下的真实提交内，commit的名称很长，通常我们只需要写前面8位即可$ git tag stable-1 8c315325//查看当前所有tag$ git tag</code></pre><p>这样，我们可以用stable-1作为提交8c315325的代称。前面这样创建的是一个“轻量级标签”。如果你想为一个tag添加注释，或是为它添加一个签名, 那么我们就需要创建一个 “标签对象”。git tag中使用-a， -s 或是 -u三个参数中任意一个，都会创建一个标签对象，并且需要一个标签消息(tag message)来为tag添加注释。 如果没有-m 或是 -F这些参数，命令执行时会启动一个编辑器来让用户输入标签消息。当这样的一条命令执行后，一个新的对象被添加到Git对象库中，并且标签引用就指向了一个标签对象，而不是指向一个提交，这就是与轻量级标签的区别。</p><p>下面是一个创建标签对象的例子:</p><pre><code>$ git tag -a stable-2 8c315325 -m &quot;stable 2&quot;</code></pre><p>(2)签名的标签</p><p>签名标签可以让提交和标签更加完整可信。如果你配有GPG key，那么你就很容易创建签名的标签。首先你要在你的 .git/config 或 ~/.gitconfig 里配好key。</p><p>下面是示例:</p><pre><code>[user]    signingkey = &lt;gpg-key-id&gt;</code></pre><p>你也可以用命令行来配置:</p><pre><code>$ git config (--global) user.signingkey &lt;gpg-key-id&gt;</code></pre><p>现在你可以在创建标签的时候使用-s 参数来创建“签名的标签”：</p><pre><code>$ git tag -s stable-1 1b2e1d63ff</code></pre><p>如果没有在配置文件中配GPG key,你可以用-u参数直接指定。</p><pre><code>$ git tag -u &lt;gpg-key-id&gt; stable-1 1b2e1d63ff</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、比较分支&quot;&gt;&lt;a href=&quot;#1、比较分支&quot; class=&quot;headerlink&quot; title=&quot;1、比较分支&quot;&gt;&lt;/a&gt;1、比较分支&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//查看test分支和master之间的差别
$ git diff master test

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java中的装饰模式</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的装饰模式/</id>
    <published>2018-08-01T10:51:22.000Z</published>
    <updated>2018-08-01T10:52:29.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、装饰模式的概念"><a href="#1、装饰模式的概念" class="headerlink" title="1、装饰模式的概念"></a>1、装饰模式的概念</h3><p>装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。</p><h3 id="2、装饰模式中的角色"><a href="#2、装饰模式中的角色" class="headerlink" title="2、装饰模式中的角色"></a>2、装饰模式中的角色</h3><p>(1)抽象构建(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。如：InputStream。</p><p>(2)具体构件(Concrete Component)角色：定义一个将要接收附加责任的类。如：FileInputStream。</p><p>(3)装饰(Decorator)角色：持有一个构件对象的实例，并定义一个与抽象构建接口一致的接口。如：FilterInputStream。</p><p>(4)具体装饰(Concrete Decorator)角色：负责给构件对象“贴上”附加的责任。如：BufferedInputStream、DataInputStream。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)抽象构建角色</p><pre><code>package com.iotek.decorator;public interface Component {    void doThingA();}</code></pre><p>(2)具体构件角色</p><pre><code>package com.iotek.decorator;public class ConcreteComponent implements Component {    @Override    public void doThingA() {        System.out.println(&quot;do A thing.&quot;);    }}</code></pre><p>(3)装饰角色</p><pre><code>package com.iotek.decorator;public class Decorator implements Component {    private Component component = null;    public Decorator(Component component) {        this.component = component;    }    @Override    public void doThingA() {        component.doThingA();//调用被装饰对象的方法    }}</code></pre><p>(4)具体装饰角色1</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator1 extends Decorator {    public ConcreteDecorator1(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingB();    }    //扩展的方法    private void doThingB(){        System.out.println(&quot;do B thing.&quot;);    }}</code></pre><p>(5)具体装饰角色2</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator2 extends Decorator {    public ConcreteDecorator2(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingC();    }    //扩展的方法    private void doThingC(){        System.out.println(&quot;do C thing.&quot;);    }}</code></pre><p>(6)测试类</p><pre><code>package com.iotek.decorator;public class Test {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        //concreteComponent.doThingA();        ConcreteDecorator1 cd1 = new ConcreteDecorator1(concreteComponent);        //cd1.doThingA();        ConcreteDecorator2 cd2 = new ConcreteDecorator2(cd1);        cd2.doThingA();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、装饰模式的概念&quot;&gt;&lt;a href=&quot;#1、装饰模式的概念&quot; class=&quot;headerlink&quot; title=&quot;1、装饰模式的概念&quot;&gt;&lt;/a&gt;1、装饰模式的概念&lt;/h3&gt;&lt;p&gt;装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1023 组个最小数</title>
    <link href="http://www.echodemo.cc/2018/08/01/PAT-B1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/08/01/PAT-B1023-组个最小数/</id>
    <published>2018-08-01T09:21:29.000Z</published>
    <updated>2018-08-01T09:27:10.387Z</updated>
    
    <content type="html"><![CDATA[<p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。</p><p>输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。</p><p>输出格式：在一行中输出能够组成的最小的数。</p><pre><code>输入样例：2 2 0 0 0 3 0 0 1 0输出样例：10015558</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a[10];    int t = 0;    for (int i = 0;i &lt; 10;i++) {        cin &gt;&gt; a[i];    }    for (int i = 1;i &lt; 10;i++) {//查找第一个不包括零在内的个数不为零的数并输出一个        if (a[i] != 0) {            cout &lt;&lt; i;            t = i;            break;        }    }    for (int i = 0;i &lt; a[0];i++) {        cout &lt;&lt; 0;    }    for (int i = 0;i &lt; a[t] - 1;i++) {        cout &lt;&lt; t;    }    for (int i = t + 1;i &lt; 10;i++) {        for (int j = 0;j &lt; a[i];j++) {            cout &lt;&lt; i;        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
</feed>
