<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-08-24T06:46:35.641Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《沈从文的前半生》摘录</title>
    <link href="http://www.echodemo.cc/2018/08/24/%E7%A4%BA%E4%BE%8B/"/>
    <id>http://www.echodemo.cc/2018/08/24/示例/</id>
    <published>2018-08-24T07:05:11.000Z</published>
    <updated>2018-08-24T06:46:35.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，"><a href="#今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，" class="headerlink" title="今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，"></a>今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，</h3><h2 id="最值得玩味的，还是一个人坐在洋车上颠颠簸簸，头上淋着雨，心中想着‘诗’。"><a href="#最值得玩味的，还是一个人坐在洋车上颠颠簸簸，头上淋着雨，心中想着‘诗’。" class="headerlink" title="最值得玩味的，还是一个人坐在洋车上颠颠簸簸，头上淋着雨，心中想着‘诗’。"></a>最值得玩味的，还是一个人坐在洋车上颠颠簸簸，头上淋着雨，心中想着‘诗’。</h2><h1 id="你从前做的诗不行了，因为你今天的生活是一首超越一切的好诗。"><a href="#你从前做的诗不行了，因为你今天的生活是一首超越一切的好诗。" class="headerlink" title="你从前做的诗不行了，因为你今天的生活是一首超越一切的好诗。"></a>你从前做的诗不行了，因为你今天的生活是一首超越一切的好诗。</h1><pre><code>我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。我应当为自己庆幸。</code></pre><p>望到北平高空明蓝的天，人只想下跪，<code>你给我的影响恰如这天空，距离得那么远</code>，我日里望着，晚上做梦，总梦到生着翅膀，向上飞举。</p><p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">向上飞去，便看到许多星子，都成为你的眼睛了。</p><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，&quot;&gt;&lt;a href=&quot;#今天真美，因为那么好天气，是我平生少见的，雨后的虹同雨后的雷还不出奇，&quot; class=&quot;headerlink&quot; title=&quot;今天真美，因为那么好天气，是我平生少见的，雨
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的XML配置</title>
    <link href="http://www.echodemo.cc/2018/08/16/MyBatis%E4%B8%AD%E7%9A%84XML%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.echodemo.cc/2018/08/16/MyBatis中的XML配置/</id>
    <published>2018-08-16T07:11:29.000Z</published>
    <updated>2018-08-16T08:05:20.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、properties"><a href="#1、properties" class="headerlink" title="1、properties"></a>1、properties</h3><p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。首先在同级目录下新建一个db.properties文件。</p><pre><code>&lt;!-- db.properties文件 --&gt;driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root&lt;!-- properties配置 --&gt;&lt;properties resource=&quot;db.properties&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;&lt;!-- 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，如下所示： --&gt;&lt;dataSource type=&quot;POOLED&quot;&gt;  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;&lt;!--     1、在properties元素体内指定的属性首先被读取。    2、然后根据properties元素中的resource属性读取类路径下属性文件或根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性。    3、最后读取作为方法参数(parameterType)传递的属性，并覆盖已读取的同名属性。    4、通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。--&gt;</code></pre><h3 id="2、Setting"><a href="#2、Setting" class="headerlink" title="2、Setting"></a>2、Setting</h3><p>它们会修改MyBatis在运行时的行为方式，ibatis的全局配置参数，包括很多的性能参数(最大线程数、最大等待时间等)，通过调用这些性能参数使用ibatis达到高性能的运行。MyBatis运行时调整全局参数，相当于软件运行时的参数。(需要小心配置，配置参数会影响MyBatis的执行)</p><h3 id="3、typeAlias"><a href="#3、typeAlias" class="headerlink" title="3、typeAlias"></a>3、typeAlias</h3><pre><code>&lt;!--    1、类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。     2、自定义别名:alias别名；type类型。如果指定包中所有类都有别名，使用类名作为别名(大小写不敏感)。--&gt;&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;user&quot; type=&quot;com.entity.User&quot;/&gt;    &lt;package name=&quot;com.entity&quot;/&gt;&lt;/typeAliases&gt;</code></pre><h3 id="4、environments"><a href="#4、environments" class="headerlink" title="4、environments"></a>4、environments</h3><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。</p><pre><code>&lt;!-- 可以接受环境配置的两个方法签名 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);&lt;!-- 如果忽略了环境参数，那么默认环境将会被加载 --&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);&lt;environments default=&quot;development&quot;&gt;  &lt;environment id=&quot;development&quot;&gt;    &lt;transactionManager type=&quot;JDBC&quot;&gt;    &lt;/transactionManager&gt;    &lt;dataSource type=&quot;POOLED&quot;&gt;      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;    &lt;/dataSource&gt;  &lt;/environment&gt;&lt;/environments&gt;&lt;!-- 在MyBatis中有两种类型的事务管理器：1、JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。2、MANAGED这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 --&gt;&lt;transactionManager type=&quot;MANAGED&quot;&gt;      &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;&lt;/transactionManager&gt;</code></pre><h3 id="5、mappers"><a href="#5、mappers" class="headerlink" title="5、mappers"></a>5、mappers</h3><p>这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了</p><pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt;  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt;  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt;  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、properties&quot;&gt;&lt;a href=&quot;#1、properties&quot; class=&quot;headerlink&quot; title=&quot;1、properties&quot;&gt;&lt;/a&gt;1、properties&lt;/h3&gt;&lt;p&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Jav
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis第一个入门程序</title>
    <link href="http://www.echodemo.cc/2018/08/15/MyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.echodemo.cc/2018/08/15/MyBatis第一个入门程序/</id>
    <published>2018-08-15T07:37:43.000Z</published>
    <updated>2018-08-16T08:58:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><p>2、写一个mybatis的入门程序</p><p>(1)在Myeclipse上新建一个Java项目。首先导入jar包，在该项目下新建一个lib目录，将下列的jar包导入到lib目录下。</p><p><img src="/images/2018/8/1.jpg" alt="&quot;jar包&quot;"></p><p>(2)在该项目下创建一个与src同级的source folder，取名为config。在这其中存放xml配置文件。</p><p>1)sqlMapConfig.xml(名字是自行定义的):其中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。如下所示：这里要注意DOCTYPE首部最好是在mybatis文档当中复制粘贴，不要自己手打。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- 全局配置文件 --&gt;&lt;configuration&gt;    &lt;!-- 环境变量 --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 事务管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 数据源 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;!-- 以下的数据库以及密码需要配置自己的 --&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射定义信息) --&gt;        &lt;mapper resource=&quot;Usermapper.xml&quot; /&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>2)Usermapper.xml(和上面的配置文件中的mappers当中的mapper是一一对应的):这个配置文件主要用于进行SQL的配置。同时记得在数据库当中创建users表，且添加数据。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper.xml(配置SQL) --&gt;&lt;!-- namespace命名空间，为了对SQL语句进行隔离，方便管理 mapper开发dao方式，有特殊的作用。 --&gt;&lt;mapper namespace=&quot;mappertest&quot;&gt;    &lt;!--     mapper.xml文件配置的SQL语句，执行每一个SQL，都将封装为mapperStatement对象。    mapper.xml以statement为单位管理SQL语句 。    --&gt;    &lt;!-- ID唯一标识Statement --&gt;    &lt;!-- parameterType：输入参数类型，通过#{}，#{}中名称任意 --&gt;    &lt;!-- resultType：输出结果的类型，返回单条或者多条记录，指明类型 --&gt;    &lt;!-- #{}表示占位符，如果参数给出String，自动添加&apos;&apos;；${value}表示SQL语句拼接，不会自动添加&apos;&apos;。 --&gt;    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where id=#{id}    &lt;/select&gt;    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username=#{username}    &lt;/select&gt;    &lt;select id=&quot;findUserByName1&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt;        select * from users where username like &apos;%${value}%&apos;    &lt;/select&gt;    &lt;!-- 添加用户,传参时将大括号中填写的是属性名 --&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        &lt;!--         order设置是取SQL语句执行之前还是之后的值 。        resultType：返回类型。        keyProperty：将主键设置到属性。        last_insert_id()：获得刚插入的记录自动编号的值。        --&gt;        &lt;selectKey order=&quot;AFTER&quot; resultType=&quot;int&quot; keyProperty=&quot;id&quot;&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into users(username,age) values(#{username},#{age})    &lt;/insert&gt;    &lt;!-- 删除用户 --&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;        delete from users where id=#{id}    &lt;/delete&gt;    &lt;!-- 修改用户 ，用户的ID一定需要有值--&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.entity.User&quot;&gt;        update users set username=#{username},age=#{age} where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>(3)创建一个com.entity包，在此包下新建User.java文件。</p><pre><code>package com.entity;public class User {    private int id;    private String username;    private int age;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public User(){        super();    }    public User(String username, int age) {        super();        this.username = username;        this.age = age;    }    public User(int id, String username, int age) {        super();        this.id = id;        this.username = username;        this.age = age;    }    @Override    public String toString() {        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><p>(4)最后创建一个com.test包，创建一个APPTest.java文件，用于junit测试(记得导入junit的jar包)。</p><pre><code>package com.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.entity.User;public class AppTest {    SqlSessionFactory sqlSessionFactory = null;    @Before    public void Init() throws IOException{        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    }    @Test    public void testSelectUser() {//查找数据        SqlSession sqlSession = sqlSessionFactory.openSession();        //第一个参数是Statement的id,第二个参数是SQL语句中所需要的值。        /*User user = (User)sqlSession.selectOne(&quot;findUserById&quot;, 2);        System.out.println(user.toString());*/        //List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName&quot;, &quot;EchoDemo&quot;);        List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName1&quot;, &quot;Echo&quot;);        for(User user:list){            System.out.println(user.toString());        }        sqlSession.close();    }    @Test    public void testInsertUser(){//插入数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(&quot;落叶物语&quot;,24);        sqlSession.insert(&quot;addUser&quot;, user);        sqlSession.commit();//提交        sqlSession.close();        System.out.println(&quot;当前插入用户的ID:&quot; + user.getId());    }    @Test    public void testDeleteUser(){//删除数据        SqlSession sqlSession = sqlSessionFactory.openSession();        sqlSession.delete(&quot;deleteUser&quot;,2);        sqlSession.commit();        sqlSession.close();    }    @Test    public void testUpdateUser(){//更新数据        SqlSession sqlSession = sqlSessionFactory.openSession();        User user = new User(3,&quot;紫苏半夏&quot;,22);        sqlSession.update(&quot;updateUser&quot;, user);        sqlSession.commit();        sqlSession.close();    }}</code></pre><p>1)每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。</p><p>2)SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在以保证所有的XML解析资源开放给更重要的事情。</p><p>3)SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p>4)每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Pl
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.echodemo.cc/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML</title>
    <link href="http://www.echodemo.cc/2018/08/07/Java%E4%B8%AD%E7%9A%84XML/"/>
    <id>http://www.echodemo.cc/2018/08/07/Java中的XML/</id>
    <published>2018-08-07T08:50:21.000Z</published>
    <updated>2018-08-07T08:51:40.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、XML定义"><a href="#1、XML定义" class="headerlink" title="1、XML定义"></a>1、XML定义</h3><p>(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输，类似HTML，不同的是它的设计宗旨是传输数据，而非显示数据。</p><p>(2)XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。XML标签没有被预定义，开发者根据需要自行定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。</p><h3 id="2、XML文档结构"><a href="#2、XML文档结构" class="headerlink" title="2、XML文档结构"></a>2、XML文档结构</h3><p>(1)XML声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p>(2)XML根元素定义：XML文档的树形结构要求必须有一个根元素。根元素的起始标记要放在所有其他元素起始标记之前，根元素的结束标记放在其他元素的结束标记之后。</p><p>(3)XML元素：元素的基本结构由开始标记，数据内容，结束标记组成。</p><h3 id="3、XML语法规则"><a href="#3、XML语法规则" class="headerlink" title="3、XML语法规则"></a>3、XML语法规则</h3><pre><code>(1)所有XML元素都须有关闭标签。(2)XML标签对大小写敏感。(3)XML必须正确地嵌套。(4)XML文档必须有根元素。(5)XML的属性以名值对方式组成，值须加引号。(6)XML可编写注释。(7)在XML中，空格会被保留，文档中的空格不会被删节。</code></pre><h3 id="4、举例说明"><a href="#4、举例说明" class="headerlink" title="4、举例说明"></a>4、举例说明</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;    &lt;book bookno=&quot;001&quot;&gt;        &lt;title&gt;Java语言编程&lt;/title&gt;        &lt;author&gt;张三&lt;/author&gt;        &lt;price&gt;80&lt;/price&gt;    &lt;/book&gt;    .    .    .&lt;/bookstore&gt;</code></pre><h3 id="5、XML-SAX解析器"><a href="#5、XML-SAX解析器" class="headerlink" title="5、XML SAX解析器"></a>5、XML SAX解析器</h3><p>(1)SAX(Simple API For XML)是一个公共的基于事件的XML文档解析标准，能够通过一个简单的、快速的方法来对XML文档进行处理，和DOM相比它所占用的系统资源更少。</p><p>(2)SAX既是一个接口，也是一个软件包。作为接口，SAX是事件驱动型XML解析的一个标准接口，对文档进行顺序扫描，当扫描到文档(document)开始、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</p><h3 id="6、SAX解析器API"><a href="#6、SAX解析器API" class="headerlink" title="6、SAX解析器API"></a>6、SAX解析器API</h3><p>(1)事件类型，大多数的SAX会产生以下类型的事件：</p><pre><code>1)在文档的开始时和结束时触发文档处理事件。2)在文档内每一XML元素接受解析的前后触发元素事件。3)任何的元数据通常由单独的事件处理。</code></pre><p>(2)举例说明</p><pre><code>&lt;doc&gt;    &lt;para&gt;Hello,iotek!&lt;/para&gt;&lt;doc&gt;其解析过程为：1)start document;2)start element:doc;3)start element.para;4)characters:Hello,iotek!;5)end element:para;6)end element:doc;7)end document;</code></pre><p>(3)解析步骤</p><pre><code>1)创建事件处理程序(即编写ContentHandler的实现类，一般继承自DefaultHandler类，采用adapter模式)2)创建SAX解析器3)将事件处理程序分配到解析器。4)对文档进行解析，将每个事件发送至事件处理程序。</code></pre><p>(4)常用接口：ContentHandler接口</p><p>1)ContentHandler是Java类包中一个特殊的SAX接口。该接口封装了一些对事件处理的方法，当XML解析器开始解析XML输入文档时，他会遇到某些特殊的事件，比如文档的开头和结束、元素开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法(回调方法)来响应该事件。</p><p>2)ContentHandler接口常用方法：</p><pre><code>void startDocument();//文档解析开始的处理。void endDocument();//文档解析结束的处理。void startElement(String uri,String localName,String qName,Attributes atts);//ElementNode开始的处理。void endElement(String uri,String localName,String qName);//ElementNode结束的处理。void character(char[] ch,int start,int length);//具体在某一节点中的处理。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、XML定义&quot;&gt;&lt;a href=&quot;#1、XML定义&quot; class=&quot;headerlink&quot; title=&quot;1、XML定义&quot;&gt;&lt;/a&gt;1、XML定义&lt;/h3&gt;&lt;p&gt;(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中反射与Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%8EAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中反射与Annotation/</id>
    <published>2018-08-06T11:41:30.000Z</published>
    <updated>2018-08-06T11:42:10.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、MetaAnnotation概念"><a href="#1、MetaAnnotation概念" class="headerlink" title="1、MetaAnnotation概念"></a>1、MetaAnnotation概念</h3><p>(1)MetaAnnotation也称为元Annotation，也是一种Annotation，可以对其他的Annotation进行注释。</p><p>(2)Java5.0提供了一些标准的MetaAnnotation：</p><pre><code>1)@Retention2)@Target3)@Documented4)@Inherited</code></pre><p>(3)@Retention:控制被Retention注释的Annotation信息的保留时间长短。</p><pre><code>@Retention(SOURCE/CLASS/RUNTIME)public/default @interface Annotation名称{...}a、SOURCE:Annotation信息在编译阶段被丢弃，仅保留在java源文件中。b、CLASS(默认):Annotation信息在编译阶段被保留，保留到class文件中，但是运行阶段不存在。c、RUNTIME:Annotation信息一直保存到运行阶段，直到退出虚拟机才被丢弃。以上三个值是java.lang.annotation.RetentionPolicy这个类所提供的枚举值。</code></pre><p>(4)@Target:表示一个Annotation的使用范围。</p><pre><code>@Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD,...})public/defalut @interface Annotation名字{...}a、TYPE:只能在类或接口或枚举上使用。b、METHOD:在方法中使用。c、FIELD:在成员变量使用。d、PARAMETER:在参数上使用。e、CONSTRUCTOR:在构造中使用。f、LOCAL_VARIABLE:在局部变量上使用。g、ANNOTATION_TYPE:只能在Annotation中使用。h、PACKAGE:只能在包中使用。</code></pre><p>(5)@Documented:想要在使用者制作JavaDoc文件的同时，也一并将Annotation的讯息加入至API文件中。</p><pre><code>@Documentedpublic/default @interface Annotation名称{...}</code></pre><p>(4)@Inherited:表示一个Annotation是否允许被其子类继承下来。</p><pre><code>@Inheritedpublic/default @inherited Annotation名称{...}</code></pre><h3 id="2、反射与Annotation"><a href="#2、反射与Annotation" class="headerlink" title="2、反射与Annotation"></a>2、反射与Annotation</h3><p>(1)一个Annotation真正起作用，必须结合反射机制，在java.lang.reflect反射包中提供AccessibleObject类来对Annotation进行操作，最常用的方法如下：</p><pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);//判断是否使用时指定的Annotation。public Annotation[] getAnnotation();//得到全部的Annotation。注：无反射，不注解。</code></pre><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Method;public class ReflectAnnotationDemo {    public static void main(String[] args) throws Exception {        Class&lt;?&gt; classType = Class.forName(&quot;com.iotek.annotation.AnnotationTest&quot;);        boolean flag = classType.isAnnotationPresent(Description.class);        if(flag){            Description description = classType.getAnnotation(Description.class);            System.out.println(&quot;AnnotationTest&apos;s description--&gt;&quot; + description.value());            Method[] methods = classType.getDeclaredMethods();            for(Method method:methods){                if(method.isAnnotationPresent(Author.class)){                    Author author = method.getAnnotation(Author.class);                    System.out.println(&quot;AnnotationTest&apos;s author--&gt;&quot; + author.name() + &quot; from &quot;+author.group());                }            }        }    }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documented@interface Author{    String name();    String group();}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@interface Description{    String value();}@Description(&quot;这是一个用于测试的类&quot;)class AnnotationTest{    @Author(name=&quot;EchoDemo&quot;,group=&quot;com.iotek&quot;)    public void test(){        System.out.println(&quot;test over!&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、MetaAnnotation概念&quot;&gt;&lt;a href=&quot;#1、MetaAnnotation概念&quot; class=&quot;headerlink&quot; title=&quot;1、MetaAnnotation概念&quot;&gt;&lt;/a&gt;1、MetaAnnotation概念&lt;/h3&gt;&lt;p&gt;(1)Met
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中Annotation</title>
    <link href="http://www.echodemo.cc/2018/08/06/Java%E4%B8%ADAnnotation/"/>
    <id>http://www.echodemo.cc/2018/08/06/Java中Annotation/</id>
    <published>2018-08-06T10:25:49.000Z</published>
    <updated>2018-08-06T10:26:23.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Annotation简介"><a href="#1、Annotation简介" class="headerlink" title="1、Annotation简介"></a>1、Annotation简介</h3><p>(1)Annotation是Java5开始引入的新特性。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素(类、方法、成员变量等)进行关联。更通俗的意思就是为程序的元素(类、方法、成员变量)加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>(2)Annotation的原理</p><p>1)Annotation其实是一种接口。通过Java反射机制中的相关API来访问annotation信息。相关类(框架或工具的类)根据这些信息来决定如何使用该程序元素或者改变他们的行为。Annotation是不会影响程序代码的执行的，无论Annotation怎么变化，代码都始终如一地执行。</p><p>2)Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。Annotation的工具统称APT(Annotation Processing Tool)。</p><h3 id="2、常见的标准Annotation"><a href="#2、常见的标准Annotation" class="headerlink" title="2、常见的标准Annotation"></a>2、常见的标准Annotation</h3><p>(1)@Override:@Override就是用来指定方法重写的，他可以强调一个子类必须要覆盖父类的方法。</p><p>(2)@Deprecated:@deprecated用于表示某个程序元素(类、方法等)已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。</p><p>(3)@SuppressWarning：@SuppressWarning指示被Annotation标识的程序元素(以及在该程序元素中的所有子元素)取消显示指定的编译器警告。</p><p>(4)举例说明</p><p>1)@Override:可以防止方法名写错。</p><pre><code>package com.iotek.annotation;public class OVerrideDemo {    public static void main(String[] args) {        Apple apple = new Apple();        apple.info();    }}class Fruit{    public void info(){        System.out.println(&quot;描述水果的信息！&quot;);    }}class Apple extends Fruit{    @Override    public void info() {        System.out.println(&quot;我是苹果！&quot;);    }}</code></pre><p>2)@Deprecated:提示程序员不推荐使用</p><pre><code>package com.iotek.annotation;public class DeprecatedDemo {    public static void main(String[] args) {        Person person = new Person();        person.showInfo();    }}class Person{    @Deprecated    public void showInfo(){        System.out.println(&quot;hello person!&quot;);    }}</code></pre><p>3)@Suppresswarning:去除警告信息</p><pre><code>package com.iotek.annotation;public class SuppresswarningDemo {    public static void main(String[] args) {    }}class Container&lt;T&gt;{    private Object[] obj = null;    public Container(){        obj = new Object[10];    }    @SuppressWarnings(&quot;unchecked&quot;)    public T[] toArray(){        return (T[])obj;    }}</code></pre><h3 id="3、自定义Annotation"><a href="#3、自定义Annotation" class="headerlink" title="3、自定义Annotation"></a>3、自定义Annotation</h3><p>(1)语法</p><pre><code>访问修饰符 @interface Annotation名称{    返回类型 method() [默认值];}</code></pre><p>1)Annotation类型的方法必须声明为无参数、无异常抛出的。这些方法定义了Annotation的成员：方法名成为了成员名，而方法返回值成为了成员的类型。方法的返回类型必须要为基本数据类型、String类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一维数组。</p><p>2)方法的后面可以使用default和一个默认数值来声明成员的默认值来声明成员的默认值，null不能作为成员的默认值。在定义Annotation型态时，不能继承其他的Annotation型态或是接口。</p><p>(2)举例说明</p><pre><code>package com.iotek.annotation;//可以修饰类@MyAnnotation1public class MyAnnotation {    //可以修饰方法    @MyAnnotation1    @MyAnnotation3    public static void main(String[] args) {        //可以修饰成员变量，可以有多个注解        @MyAnnotation1        @MyAnnotation2(name=&quot;zhangsan&quot;)        @MyAnnotation3(&quot;haha&quot;)        @MyAnnotation4(sex=&quot;男&quot;,age=10)        @MyAnnotation5({&quot;haah&quot;,&quot;hehe&quot;,&quot;ee&quot;})        @MyAnnotation6(color=Color.RED)        int number = 10;    }}@interface MyAnnotation1{}@interface MyAnnotation2{    String name();}@interface MyAnnotation3{//value和默认值    String value() default &quot;lisi&quot;;//只有为value时才可以省略&quot;value=&quot;，有默认值时可以不给值。}@interface MyAnnotation4{//两个元素    String sex();    int age();}@interface MyAnnotation5{//数组    String[] value();}enum Color{    RED,BLUE,YELLOW;}@interface MyAnnotation6{//枚举类型    Color color();}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Annotation简介&quot;&gt;&lt;a href=&quot;#1、Annotation简介&quot; class=&quot;headerlink&quot; title=&quot;1、Annotation简介&quot;&gt;&lt;/a&gt;1、Annotation简介&lt;/h3&gt;&lt;p&gt;(1)Annotation是Java5开始引
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中URL类的使用</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%ADURL%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中URL类的使用/</id>
    <published>2018-08-05T08:43:08.000Z</published>
    <updated>2018-08-05T08:48:25.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、URL概念"><a href="#1、URL概念" class="headerlink" title="1、URL概念"></a>1、URL概念</h3><p>URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。它由五个部分组成：</p><pre><code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#&lt;引用&gt;</code></pre><h3 id="2、URL编程"><a href="#2、URL编程" class="headerlink" title="2、URL编程"></a>2、URL编程</h3><p>(1)为了表示URL，java.net包中实现了类URL。我们可以通过下面的构造方法来初始化一个URL对象：</p><pre><code>URL(String url);//URL代表了一个绝对地址，URL对象直接指向这个资源。URL(URL baseURL,String relativeURL);//其中baseURL代表绝对地址，realtiveURL代表相对地址。URL(String protocol,String host,String file);//protocol代表通信协议，host代表主机名，file代表文件名。URL(String protocol,String host,int port,String file);</code></pre><p>(2)获取URL对象的属性：</p><pre><code>getFile();//获得URL指定资源的完整文件名。getHost();//返回主机名。getPath();//返回指定资源的文件目录和文件名。getPort();//返回端口号。getProtocol();//返回表示URL中协议的字符串对象。getRef();//返回URL的HTML文档标记，即#号标记。getUserInfo();//返回用户信息。</code></pre><p>(3)URL有两种方法可以用来访问Internet上的资源：</p><p>1)使用URL的openConnection()方法创建一个URLConnection类对象。再通过URLConnection对象获取相应的输入流和输出流。</p><p>2)利用URL类的openStream()方法。openStream()方法与指定的URL建立连接并返回InputStream类的对象。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><pre><code>package com.iotek.url;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class URLDemo {    public static void main(String[] args) throws IOException {        DownloadUtil.download(&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot;, &quot;baidu.jpg&quot;, &quot;f:\\test&quot;);        System.out.println(&quot;下载结束！&quot;);    }}class DownloadUtil{    public static void download(String urlString,String fileName,String savePath) throws IOException{        URL url = new URL(urlString);        /*URLConnection conn = url.openConnection();        InputStream inputStream = conn.getInputStream();*/        InputStream inputStream = url.openStream();        byte[] buff = new byte[1024*1024];        int len = 0;        File file = new File(savePath);        if(!file.exists()){            file.mkdirs();        }        OutputStream outputStream = new FileOutputStream(file.getAbsolutePath()+&quot;\\&quot;+fileName);        while((len = inputStream.read(buff))!=-1){            outputStream.write(buff, 0, len);        }        inputStream.close();        outputStream.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、URL概念&quot;&gt;&lt;a href=&quot;#1、URL概念&quot; class=&quot;headerlink&quot; title=&quot;1、URL概念&quot;&gt;&lt;/a&gt;1、URL概念&lt;/h3&gt;&lt;p&gt;URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于UDP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于UDP协议的Socket编程/</id>
    <published>2018-08-05T07:25:21.000Z</published>
    <updated>2018-08-05T08:47:04.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、创建发送端"><a href="#1、创建发送端" class="headerlink" title="1、创建发送端"></a>1、创建发送端</h3><p>(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可以手动指定。</p><p>(2)将数据进行packet包的封装，必须要指定目的地地址和端口。</p><p>(3)通过socket服务的send()方法将该包发出。</p><p>(4)将socket关闭。</p><h3 id="2、创建接收端"><a href="#2、创建接收端" class="headerlink" title="2、创建接收端"></a>2、创建接收端</h3><p>(1)建立DatagramSocket对象。要监听一个端口。</p><p>(2)通过socket的receive方法将数据存入数据包中。</p><p>(3)通过数据包dp的方法getData()、getAddress()、getPort()等方法获取包中的指定信息。</p><p>(4)将socket关闭。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)接收端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDPDemo2 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket(8000);        byte[] buff = new byte[100];        DatagramPacket packet = new DatagramPacket(buff, 100);        socket.receive(packet);//接收传来的数据包        System.out.println(new String(buff,0,packet.getLength()));        String string = &quot;Me too!&quot;;        DatagramPacket packet2 = new DatagramPacket(string.getBytes(), string.length(),packet.getAddress(),packet.getPort());        socket.send(packet2);        socket.close();    }}</code></pre><p>(2)发送端：</p><pre><code>package com.iotek.tcpsocket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPDemo1 {    public static void main(String[] args) throws IOException {        DatagramSocket socket = new DatagramSocket();        String string = &quot;I Love You!&quot;;        //将数据进行封装，封装到数据包当中        DatagramPacket packet = new DatagramPacket(string.getBytes(), string.length(),InetAddress.getByName(&quot;localhost&quot;),8000);        socket.send(packet);//发送        byte[] buff = new byte[100];        DatagramPacket packet2 = new DatagramPacket(buff, 100);        socket.receive(packet2);        System.out.println(new String(buff,0,packet2.getLength()));        socket.close();    }}</code></pre><p>(3)为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . UDP*.java//开启接收端java com.iotek.tcpsocket.UDPDemo2//开启发送端，这里另外开启一个窗口java com.iotek.tcpsocket.UDPDemo1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、创建发送端&quot;&gt;&lt;a href=&quot;#1、创建发送端&quot; class=&quot;headerlink&quot; title=&quot;1、创建发送端&quot;&gt;&lt;/a&gt;1、创建发送端&lt;/h3&gt;&lt;p&gt;(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中基于TCP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于TCP协议的Socket编程/</id>
    <published>2018-08-05T03:38:19.000Z</published>
    <updated>2018-08-05T08:53:09.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Socket概述"><a href="#1、Socket概述" class="headerlink" title="1、Socket概述"></a>1、Socket概述</h3><p>(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。它是连接运行在网络上的两个程序间的双向通讯的端点。</p><p>(2)网络通讯其实指的就是socket间的通讯。通讯的两端都有socket，数据在两个socket之间通过IO来进行传输。</p><p>(3)使用socket进行网络通信的过程</p><pre><code>1)服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求。2)客户程序根据服务器程序所在的主机名和端口号发出连接请求。3)如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。4)客户和服务器通过读、写套接字进行通讯。</code></pre><h3 id="2、基于TCP协议的socket编程"><a href="#2、基于TCP协议的socket编程" class="headerlink" title="2、基于TCP协议的socket编程"></a>2、基于TCP协议的socket编程</h3><p>(1)创建TCP服务端步骤：</p><pre><code>1)创建一个ServerSocket对象2)调用accept()方法接受客户端请求3)从socket中获取IO流4)对IO流进行读写操作，完成与客户端的交互。5)关闭IO流和Socket</code></pre><p>(2)创建TCP客户端步骤：</p><pre><code>1)创建一个Socket对象2)从Socket中获取IO流3)对IO流进行读写操作，完成与服务端的交互4)关闭IO流和Socket</code></pre><p>注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。</p><p>(3)举例说明</p><p>1)服务器端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class TCPServer {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(8888);//创建一个ServerSocket对象        Socket socket = serverSocket.accept();//调用accept()方法来接受客户端的请求        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has connected!&quot;);        //获取socket对象的输入输出流        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        String line = null;        while((line = bReader.readLine())!=null){//读取客户端传过来的数据            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(line);            /*bWriter.write(line.toUpperCase());//把转换成大写的字符串传给客户端            bWriter.newLine();//换行，这样客户端才能知道输入什么时候结束的            bWriter.flush();*/            pWriter.println(line.toUpperCase());        }        //bWriter.close();        pWriter.close();        bReader.close();        socket.close();        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has disconnected!&quot;);    }}</code></pre><p>2)客户端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class TCPClient {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        BufferedReader bw = new BufferedReader(new InputStreamReader(socket.getInputStream()));        while(true){            String line = bReader.readLine();//获取键盘所输入的字符串            /*bWriter.write(line);            bWriter.newLine();//换行，这样服务端才能识别一行的结束            bWriter.flush();*/            pWriter.println(line);            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(bw.readLine());//获取服务端传来的大写字符串        }        bReader.close();        bw.close();        //bWriter.close();        pWriter.close();        socket.close();    }}</code></pre><p>为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . *.java//开启服务器java com.iotek.tcpsocket.TCPServer//开启客户端，这里另外开启一个窗口java com.iotek.tcpsocket.TCPClient</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Socket概述&quot;&gt;&lt;a href=&quot;#1、Socket概述&quot; class=&quot;headerlink&quot; title=&quot;1、Socket概述&quot;&gt;&lt;/a&gt;1、Socket概述&lt;/h3&gt;&lt;p&gt;(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中网络编程基础知识和通讯要素</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中网络编程基础知识和通讯要素/</id>
    <published>2018-08-05T02:25:36.000Z</published>
    <updated>2018-08-05T03:41:58.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、网络基础知识"><a href="#1、网络基础知识" class="headerlink" title="1、网络基础知识"></a>1、网络基础知识</h3><p>(1)计算机网络</p><p>计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能性强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p><p>(2)网络体系结构</p><p>网络体系结构定义计算机设备和其他设备如何连接在一起以形成一个允许用户共享信息和资源的通信系统。国际标准化组织ISO于1978年提出“开放系统互连参考模型”，即著名的OSI(Open System Interconnection)模型。OSI模型保证了各类设备生产厂家的产品兼容性。该模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>(3)TCP/IP协议</p><p>TCP/IP协议是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络接口层、网络层、传输层和应用层。</p><h3 id="2、网络通信要素"><a href="#2、网络通信要素" class="headerlink" title="2、网络通信要素"></a>2、网络通信要素</h3><p>(1)网络编程的目的</p><p>网络编程的目的就是指直接或者间接地通过网络协议与其他计算机进行通讯。网络编程中有两个主要问题，一个是如何准确的定位网络上一台或者多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。</p><p>(2)IP地址</p><p>网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。对应的类-InetAddress。</p><p>(3)端口号</p><p>端口号用来表示该计算机上的应用程序，代表此应用程序逻辑地址。端口号使用一个16位的数字来表示，它的范围是0~65535,1024以下的端口号保留给预定义的服务。例如：http使用80端口。</p><p>(4)协议</p><p>为计算机网络中进行数据交互而建立的规则、标准或约定的集合。</p><pre><code>TCP是一种面向连接的保证可靠传输的协议。UDP是一种无连接的且不可靠的传输协议。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、网络基础知识&quot;&gt;&lt;a href=&quot;#1、网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、网络基础知识&quot;&gt;&lt;/a&gt;1、网络基础知识&lt;/h3&gt;&lt;p&gt;(1)计算机网络&lt;/p&gt;
&lt;p&gt;计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的RandomAccessFile</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84RandomAccessFile/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的RandomAccessFile/</id>
    <published>2018-08-04T08:47:03.000Z</published>
    <updated>2018-08-04T08:47:37.658Z</updated>
    
    <content type="html"><![CDATA[<p>1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。</p><p>2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，随着对字节的写入而前移此文件指针。</p><p>3、写入该隐含数组末尾之后的输出操作导致该数组扩展。该文件指针可以通过getFilePointer方法读取，通过seek方法设置该文件指针的位置。</p><p>4、RandomAccessFile举例</p><pre><code>package com.iotek.otherio;import java.io.IOException;import java.io.RandomAccessFile;import java.util.Scanner;public class RandomAccessFileDemo {    public static void main(String[] args) throws IOException {        Person[] persons = {new Person(&quot;chenhao&quot;,90),                new Person(&quot;justin&quot;,30),new Person(&quot;bush&quot;,80),                new Person(&quot;lisi&quot;,20)};        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;f:\\test\\3.txt&quot;, &quot;rw&quot;);        /*for(int i=0;i&lt;persons.length;i++){//写入数据到RandomAccessFile这个对象中            randomAccessFile.writeChars(persons[i].getName());            randomAccessFile.writeInt(persons[i].getAge());        }*/        //读取指定位置上的Person对象        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;读取第几个Person对象数据&quot;);        int num = scanner.nextInt();        //使用seek方法来操作存取位置        randomAccessFile.seek((num-1)*Person.size());        Person person = new Person();        person.setName(readName(randomAccessFile));        person.setAge(randomAccessFile.readInt());        System.out.println(&quot;姓名:&quot;+person.getName());        System.out.println(&quot;年龄:&quot;+person.getAge());        randomAccessFile.close();    }    private static String readName(RandomAccessFile randomAccessFile) throws IOException{        char[] name = new char[15];        for(int i=0;i&lt;name.length;i++){            name[i] = randomAccessFile.readChar();         }        return new String(name).replace(&apos;\u0000&apos;, &apos; &apos;);    }}class Person{    private String name;    private int age;    public Person(){    }    public Person(String name, int age) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //每个对象所占的字节数    public static int size(){        return 34;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。&lt;/p&gt;
&lt;p&gt;2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中其他的IO流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84IO%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中其他的IO流/</id>
    <published>2018-08-04T07:45:54.000Z</published>
    <updated>2018-08-04T07:46:30.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、ObjectInputStream和ObjectOutputStream"><a href="#1、ObjectInputStream和ObjectOutputStream" class="headerlink" title="1、ObjectInputStream和ObjectOutputStream"></a>1、ObjectInputStream和ObjectOutputStream</h3><p>ObjectInputStream和ObjectOutputStream分别与FileInputStream和FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。我们把对象以某种特定的编码格式写入称之为“序列化”。把写入的编码格式内容还原成对象称之为“反序列化”。被序列化的对象必须实现Serializable接口。</p><pre><code>package com.iotek.otherio;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectInputOutputDemo {    public static void main(String[] args) throws IOException {        /*Student student = new Student(&quot;zhangsan&quot;, 30);        FileOutputStream fos = new FileOutputStream(&quot;f:\\test\\1.txt&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);        objectOutputStream.writeObject(student);//把对象序列化到指定的文件输出流中        objectOutputStream.close();//释放资源*/            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;f:\\test\\1.txt&quot;));        try {            Student student = (Student)objectInputStream.readObject();            System.out.println(student);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class Student implements Serializable{//需要实现Serializable接口    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="2、InputStreamReader和OutputStreamWriter"><a href="#2、InputStreamReader和OutputStreamWriter" class="headerlink" title="2、InputStreamReader和OutputStreamWriter"></a>2、InputStreamReader和OutputStreamWriter</h3><p>转换流是指将字节流与字符流之间进行转换。转换流的出现方便了对文件的读写，它在字符流与字节流之间架起了一座桥梁，使原本毫无关联的两种操作能够进行转化，提高了程序的灵活性。字节流中的数据都是字符时，转化成字符流操作更高效。如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式的参数，而FileReader与FileWriter是默认编码的文本文件。</p><pre><code>package com.iotek.otherio;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputStreamWriterReaderDemo {    public static void main(String[] args) throws IOException {        /*OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;f:\\test\\2.txt&quot;), &quot;utf-8&quot;);        BufferedWriter bw = new BufferedWriter(osw);        bw.write(&quot;您好&quot;);        bw.close();*/        /*BufferedReader br = new BufferedReader(new FileReader(&quot;f:\\test\\2.txt&quot;));        String line = null;        while((line = br.readLine())!=null){            System.out.println(line);        }        br.close();*/        BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;f:\\test\\2.txt&quot;),&quot;utf-8&quot;));        String line = null;        while((line = bReader.readLine())!=null){            System.out.println(line);        }        bReader.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、ObjectInputStream和ObjectOutputStream&quot;&gt;&lt;a href=&quot;#1、ObjectInputStream和ObjectOutputStream&quot; class=&quot;headerlink&quot; title=&quot;1、ObjectInputStr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的字符流/</id>
    <published>2018-08-04T06:03:29.000Z</published>
    <updated>2018-08-04T06:32:10.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Reader和Writer抽象类"><a href="#1、Reader和Writer抽象类" class="headerlink" title="1、Reader和Writer抽象类"></a>1、Reader和Writer抽象类</h3><p>字节流提供处理任何类型输入输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。字符流层次结构的顶层是Reader和Writer抽象类，它们的顶层仍然是字节流。Reader是定义Java的流式字符输入模式的抽象类。Reader抽象类中的方法和InputStream类似。Writer是定义Java的流式字符输出模式的抽象类。该类的方法都返回void值并在出错条件下抛IOException异常。Writer抽象类中的方法和OutputStream类似。</p><h3 id="2、FileReader和FileWriter"><a href="#2、FileReader和FileWriter" class="headerlink" title="2、FileReader和FileWriter"></a>2、FileReader和FileWriter</h3><p>FileReader类表示可以读取文件内容的Reader类，构造方法有：</p><pre><code>FileReader(String filePath)FileReader(File fileObj)</code></pre><p>FileWriter表示可以写文件的Writer类，构造方法有：</p><pre><code>FileWriter(String filePath)FileWriter(String filePath,boolean append)FileWriter(File fileObj)</code></pre><h3 id="3、FileReader和FileWriter举例"><a href="#3、FileReader和FileWriter举例" class="headerlink" title="3、FileReader和FileWriter举例"></a>3、FileReader和FileWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        char[] buffer = new char[100];        FileWriter fWriter = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        int len = 0;//实际读到的字符个数        while((len = fr.read(buffer))!=-1){            fWriter.write(buffer,0,len);        }        fr.close();        fWriter.close();    }}</code></pre><h3 id="4、BufferedReader和BufferedWriter"><a href="#4、BufferedReader和BufferedWriter" class="headerlink" title="4、BufferedReader和BufferedWriter"></a>4、BufferedReader和BufferedWriter</h3><p>BufferedReader通过缓冲区提高输入性能。BufferedWriter则通过缓冲区提高输出性能。类似于BufferedInputStream和BufferedOutputStream。分别都具有两个构造方法：</p><pre><code>BufferedReader(Reader inputStream)BufferedReader(Reader inputStream,int bufSize)BufferedWriter(Writer ouputStream)BufferedWriter(Writer outputStream,int bufSize)</code></pre><h3 id="5、BufferedReader和BufferedWriter举例"><a href="#5、BufferedReader和BufferedWriter举例" class="headerlink" title="5、BufferedReader和BufferedWriter举例"></a>5、BufferedReader和BufferedWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class BufferedReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        FileWriter fw = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        BufferedReader bReader = new BufferedReader(fr);        BufferedWriter bWriter = new BufferedWriter(fw);        String line = null;        while((line=bReader.readLine())!=null){            System.out.println(line);            bWriter.write(line);//写入一行            bWriter.newLine();//换行            //bWriter.flush();//不使用close()方法时需要使用此方法        }        bReader.close();        bWriter.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;a href=&quot;#1、Reader和Writer抽象类&quot; class=&quot;headerlink&quot; title=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;/a&gt;1、Reader和Writer抽象类&lt;/h3&gt;&lt;p&gt;字节流提供处
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用字节流复制一个文件夹</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中使用字节流复制一个文件夹/</id>
    <published>2018-08-04T01:21:32.000Z</published>
    <updated>2018-08-04T01:22:53.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>使用字节流复制一个文件夹中的所有内容到指定的文件夹中。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>使用递归算法，使用字节缓冲区来提高程序效率。</p><h3 id="3、案例实现："><a href="#3、案例实现：" class="headerlink" title="3、案例实现："></a>3、案例实现：</h3><pre><code>package com.iotek.file;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyFileDemo {    public static void main(String[] args) throws IOException {        CopyUtil.copyDir(new File(&quot;f:\\haha&quot;), new File(&quot;f:\\ee&quot;));    }}class CopyUtil{    public static void copyDir(File src,File dst) throws IOException{        dst.mkdirs();//相比于mkdir()会创建路径中本不存在的文件夹        if(src!=null){            File[] files = src.listFiles();//遍历原文件夹中的文件或目录            if(files!=null){                for(File f:files){                    if(f.isFile()){//复制文件                        FileInputStream fis = new FileInputStream(f);                        FileOutputStream fos = new FileOutputStream(dst.getAbsolutePath() + &quot;\\&quot; + f.getName());                        byte[] buffer = new byte[1024*1024];                        int len = 0;//保存读到的字节个数                        while((len = fis.read(buffer))!=-1){                            fos.write(buffer,0,len);                        }                        fis.close();                        fos.close();                    }else {                        copyDir(f, new File(dst.getAbsolutePath()+&quot;\\&quot;+dst.getName()));                    }                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;使用字节流复制一个文件夹中的所有内容到指定的文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;2、案例设计&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git入门(二)</title>
    <link href="http://www.echodemo.cc/2018/08/02/Git%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/08/02/Git入门(二)/</id>
    <published>2018-08-02T02:38:07.000Z</published>
    <updated>2018-08-02T02:39:34.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、比较分支"><a href="#1、比较分支" class="headerlink" title="1、比较分支"></a>1、比较分支</h3><pre><code>//查看test分支和master之间的差别$ git diff master test//查看当前的工作目录与另外一个分支的差别，查看与test分支的区别$ git diff test//你也以加上路径限定符，来只比较某一个文件或目录$ git diff test file1//--stat 参数可以统计一下有哪些文件被改动，有多少行被改动$ git diff test --stat</code></pre><h3 id="2、分布式的工作流程"><a href="#2、分布式的工作流程" class="headerlink" title="2、分布式的工作流程"></a>2、分布式的工作流程</h3><p>(1)分布式的工作流程</p><p>你目前的项目在gitproject目录下，这是我们的git仓库(repository)，假设另一个用户也想与你协作开发。他的工作目录也在这台机器上。首先，我们假设另一个用户也用相同的用户登录，只是工作在不同的目录下开发代码，实际工作中不太可能发生，大部分情况都是多个用户，这个假设只是为了让实验简化。</p><pre><code>//克隆git仓库，建了一个新的叫&quot;myrepo&quot;的目录，这个目录里包含了一份gitproject仓库的克隆$ git clone gitproject myrepo//查看$ ls -l myrepo</code></pre><p>在 myrepo 做了一些修改并且提交：</p><pre><code>$ cd myrepo//添加新的文件newfile$ echo &quot;newcontent&quot; &gt; newfile//提交修改$ git add newfile$ git commit -m &quot;add newfile&quot;</code></pre><p>myrepo修改完成后，可以在仓库gitproject中把myrepo的修改给拉(pull)下来，合并这份修改到gitproject的git仓库。git pull命令执行两个操作: 它从远程分支(remote branch)抓取修改git fetch的内容，然后把它合并git merge进当前的分支。如果gitproject在myrepo修改文件内容的同时也做了修改的话，可能需要手工去修复冲突。</p><pre><code>$ cd gitproject$ git pull myrepo master$ ls   </code></pre><p>gitproject里可以用git fetch 来执行git pull前半部分的工作，但是这条命令并不会把抓下来的修改合并到当前分支里：</p><pre><code>$ git fetch myrepo</code></pre><p>获取后，我们可以通过git log查看远程分支做的所有修改，由于我们已经合并了所有修改，所以不会有任何输出：</p><pre><code>$ git log -p master..myrepo/master</code></pre><p>当检查完修改后，gitproject可以把修改合并到它的主分支中：</p><pre><code>$ git merge myrepo/master</code></pre><p>如果我们在myrepo目录下执行git pull。myrepo会从克隆的位置拉取代码并更新本地仓库，就是把gitproject上的修改同步到本地:</p><pre><code>//进入到gitproject$ cd gitproject//添加一行内容到newfile$ echo &quot;gitproject: new line&quot; &gt;&gt; newfile//提交修改$ git commit -a -m &apos;add newline to newfile&apos;//进入myrepo目录$ cd myrepo//同步gitproject的所有修改$ git pull</code></pre><p>因为myrepo是从gitproject仓库克隆的，那么他就不需要指定gitproject仓库的地址。因为Git把gitproject仓库的地址存储到myrepo的配置文件中，这个地址就是在git pull时默认使用的远程仓库:</p><pre><code>$ git config --get remote.origin.url</code></pre><p>(2)公共git仓库</p><p>开发过程中，通常大家都会使用一个公共的仓库，并clone到自己的开发环境中，完成一个阶段的代码后可以告诉目标仓库的维护者来pull自己的代码。如果你和维护者都在同一台机器上有帐号，那么你们可以互相从对方的仓库目录里直接拉所作的修改，git命令里的仓库地址也可以是本地的某个目录名：</p><pre><code>$ git clone /path/to/repository$ git pull /path/to/other/repository//也可以是一个ssh地址：$ git clone ssh://yourhost/~you/repository</code></pre><p>(3)将修改推到一个公共仓库</p><p>通过http或是git协议，其它维护者可以通过远程访问的方式抓取(fetch)你最近的修改，但是他们 没有写权限。如何将本地私有仓库的最近修改主动上传到公共仓库中呢？最简单的办法就是用git push命令，推送本地的修改到远程Git仓库，执行下面的命令:</p><pre><code>$ git push ssh://yourserver.com/~you/proj.git master:master或者:$ git push ssh://yourserver.com/~you/proj.git master</code></pre><p>如果推送(push)结果不是快速向前fast forward，可能会报像错。常是因为没有使用git pull获取远端仓库的最新更新，在本地修改的同时，远端仓库已经变化了（其他协作者提交了代码），此时应该先使用git pull合并最新的修改后再执行git push：</p><pre><code>$ git pull$ git push ssh://yourserver.com/~you/proj.git master</code></pre><h3 id="3、git标签"><a href="#3、git标签" class="headerlink" title="3、git标签"></a>3、git标签</h3><p>(1)轻量级标签</p><p>我们可以用 git tag不带任何参数创建一个标签(tag)指定某个提交(commit):</p><pre><code>//进入到gitproject目录$ cd gitproject//查看git提交记录$ git log//选择其中一个记录标志位stable-1的标签，注意需要将后面的8c315325替换成仓库下的真实提交内，commit的名称很长，通常我们只需要写前面8位即可$ git tag stable-1 8c315325//查看当前所有tag$ git tag</code></pre><p>这样，我们可以用stable-1作为提交8c315325的代称。前面这样创建的是一个“轻量级标签”。如果你想为一个tag添加注释，或是为它添加一个签名, 那么我们就需要创建一个 “标签对象”。git tag中使用-a， -s 或是 -u三个参数中任意一个，都会创建一个标签对象，并且需要一个标签消息(tag message)来为tag添加注释。 如果没有-m 或是 -F这些参数，命令执行时会启动一个编辑器来让用户输入标签消息。当这样的一条命令执行后，一个新的对象被添加到Git对象库中，并且标签引用就指向了一个标签对象，而不是指向一个提交，这就是与轻量级标签的区别。</p><p>下面是一个创建标签对象的例子:</p><pre><code>$ git tag -a stable-2 8c315325 -m &quot;stable 2&quot;</code></pre><p>(2)签名的标签</p><p>签名标签可以让提交和标签更加完整可信。如果你配有GPG key，那么你就很容易创建签名的标签。首先你要在你的 .git/config 或 ~/.gitconfig 里配好key。</p><p>下面是示例:</p><pre><code>[user]    signingkey = &lt;gpg-key-id&gt;</code></pre><p>你也可以用命令行来配置:</p><pre><code>$ git config (--global) user.signingkey &lt;gpg-key-id&gt;</code></pre><p>现在你可以在创建标签的时候使用-s 参数来创建“签名的标签”：</p><pre><code>$ git tag -s stable-1 1b2e1d63ff</code></pre><p>如果没有在配置文件中配GPG key,你可以用-u参数直接指定。</p><pre><code>$ git tag -u &lt;gpg-key-id&gt; stable-1 1b2e1d63ff</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、比较分支&quot;&gt;&lt;a href=&quot;#1、比较分支&quot; class=&quot;headerlink&quot; title=&quot;1、比较分支&quot;&gt;&lt;/a&gt;1、比较分支&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//查看test分支和master之间的差别
$ git diff master test

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java中的装饰模式</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的装饰模式/</id>
    <published>2018-08-01T10:51:22.000Z</published>
    <updated>2018-08-01T10:52:29.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、装饰模式的概念"><a href="#1、装饰模式的概念" class="headerlink" title="1、装饰模式的概念"></a>1、装饰模式的概念</h3><p>装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。</p><h3 id="2、装饰模式中的角色"><a href="#2、装饰模式中的角色" class="headerlink" title="2、装饰模式中的角色"></a>2、装饰模式中的角色</h3><p>(1)抽象构建(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。如：InputStream。</p><p>(2)具体构件(Concrete Component)角色：定义一个将要接收附加责任的类。如：FileInputStream。</p><p>(3)装饰(Decorator)角色：持有一个构件对象的实例，并定义一个与抽象构建接口一致的接口。如：FilterInputStream。</p><p>(4)具体装饰(Concrete Decorator)角色：负责给构件对象“贴上”附加的责任。如：BufferedInputStream、DataInputStream。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)抽象构建角色</p><pre><code>package com.iotek.decorator;public interface Component {    void doThingA();}</code></pre><p>(2)具体构件角色</p><pre><code>package com.iotek.decorator;public class ConcreteComponent implements Component {    @Override    public void doThingA() {        System.out.println(&quot;do A thing.&quot;);    }}</code></pre><p>(3)装饰角色</p><pre><code>package com.iotek.decorator;public class Decorator implements Component {    private Component component = null;    public Decorator(Component component) {        this.component = component;    }    @Override    public void doThingA() {        component.doThingA();//调用被装饰对象的方法    }}</code></pre><p>(4)具体装饰角色1</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator1 extends Decorator {    public ConcreteDecorator1(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingB();    }    //扩展的方法    private void doThingB(){        System.out.println(&quot;do B thing.&quot;);    }}</code></pre><p>(5)具体装饰角色2</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator2 extends Decorator {    public ConcreteDecorator2(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingC();    }    //扩展的方法    private void doThingC(){        System.out.println(&quot;do C thing.&quot;);    }}</code></pre><p>(6)测试类</p><pre><code>package com.iotek.decorator;public class Test {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        //concreteComponent.doThingA();        ConcreteDecorator1 cd1 = new ConcreteDecorator1(concreteComponent);        //cd1.doThingA();        ConcreteDecorator2 cd2 = new ConcreteDecorator2(cd1);        cd2.doThingA();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、装饰模式的概念&quot;&gt;&lt;a href=&quot;#1、装饰模式的概念&quot; class=&quot;headerlink&quot; title=&quot;1、装饰模式的概念&quot;&gt;&lt;/a&gt;1、装饰模式的概念&lt;/h3&gt;&lt;p&gt;装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1023 组个最小数</title>
    <link href="http://www.echodemo.cc/2018/08/01/PAT-B1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/08/01/PAT-B1023-组个最小数/</id>
    <published>2018-08-01T09:21:29.000Z</published>
    <updated>2018-08-01T09:27:10.387Z</updated>
    
    <content type="html"><![CDATA[<p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。</p><p>输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。</p><p>输出格式：在一行中输出能够组成的最小的数。</p><pre><code>输入样例：2 2 0 0 0 3 0 0 1 0输出样例：10015558</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a[10];    int t = 0;    for (int i = 0;i &lt; 10;i++) {        cin &gt;&gt; a[i];    }    for (int i = 1;i &lt; 10;i++) {//查找第一个不包括零在内的个数不为零的数并输出一个        if (a[i] != 0) {            cout &lt;&lt; i;            t = i;            break;        }    }    for (int i = 0;i &lt; a[0];i++) {        cout &lt;&lt; 0;    }    for (int i = 0;i &lt; a[t] - 1;i++) {        cout &lt;&lt; t;    }    for (int i = t + 1;i &lt; 10;i++) {        for (int j = 0;j &lt; a[i];j++) {            cout &lt;&lt; i;        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的过滤流</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的过滤流/</id>
    <published>2018-08-01T00:18:39.000Z</published>
    <updated>2018-08-01T10:07:01.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、过滤流介绍"><a href="#1、过滤流介绍" class="headerlink" title="1、过滤流介绍"></a>1、过滤流介绍</h3><p>(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装。这些流一般由普通类的方法(即过滤流的一个父类)访问。</p><p>(2)过滤字节流FilterInputStream和FilterOutputStream，它们不是抽象类，它们提供的方法和InputStream和OutputStream类的方法相同。构造方法有：</p><pre><code>FilterOutputStream(OutputStream os);FilterInputstream(InputStream is);</code></pre><p>常用的过滤流有BufferedInputStream和BufferedOutputStream(带缓冲区)，需要使用已经存在的节点流(直接操作设备的流)来构造，FileInputStream就是节点流，而BufferedInputStream包装了FileInputStream。提供带缓冲的读写，提高了读写的效率。DataInputStream和DataOutputStream(对基本数据类型进行读写操作)。数据输入输出流允许应用程序读写基本Java数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取。读写顺序要保持一致。</p><h3 id="2、过滤流举例说明"><a href="#2、过滤流举例说明" class="headerlink" title="2、过滤流举例说明"></a>2、过滤流举例说明</h3><p>(1)BufferedInputStream和BufferedOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class BufferedInputOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        BufferedInputStream bis = new BufferedInputStream(fileInputStream);        BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream);        long time1 = System.currentTimeMillis();        int data = 0;        while((data = bis.read())!=-1){//从缓冲区里面读，而不是直接从输入流里面读。            bos.write(data);//先写到缓冲区，当缓冲区满的时候再一次性写到输出流里面去。        }        bis.close();        bos.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><p>(2)DataInputStream和DataOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DataInputOutputStream {    public static void main(String[] args) throws IOException {        /*String name = &quot;zhangsan&quot;;        int age = 10;        boolean flag = true;        char set = &apos;男&apos;;        double money = 100.56;        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;f:\\test\\b.txt&quot;));        dos.writeUTF(name);        dos.writeInt(age);        dos.writeBoolean(flag);        dos.writeChar(set);        dos.writeDouble(money);        dos.close();*/        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;f:\\test\\b.txt&quot;));        //读的顺序必须和写的顺序一致        System.out.println(dis.readUTF());        System.out.println(dis.readInt());        System.out.println(dis.readBoolean());        System.out.println(dis.readChar());        System.out.println(dis.readDouble());        dis.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、过滤流介绍&quot;&gt;&lt;a href=&quot;#1、过滤流介绍&quot; class=&quot;headerlink&quot; title=&quot;1、过滤流介绍&quot;&gt;&lt;/a&gt;1、过滤流介绍&lt;/h3&gt;&lt;p&gt;(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的输入输出流</title>
    <link href="http://www.echodemo.cc/2018/07/31/Java%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/07/31/Java中的输入输出流/</id>
    <published>2018-07-31T12:14:08.000Z</published>
    <updated>2018-07-31T12:15:51.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、流的概念和分类"><a href="#1、流的概念和分类" class="headerlink" title="1、流的概念和分类"></a>1、流的概念和分类</h3><p>(1)流的概念</p><p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件、内存或是网络连接。同理，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据就好像在这其中“流动”一样。</p><p>(2)流的分类</p><p>a、流按其流向分为“输入流”和“输出流”。</p><p>b、流按数据传输单位分为“字节流”和“字符流”。“字节流”用来读写8位二进制的字节，“字符流”用来读写16位二进制字符。</p><p>c、流按功能分为“节点流”和“过滤流”。“节点流”用于直接操作目标设备的流，例如：磁盘或一块内存区域。“过滤流”是对一个已存在的流的链接和封装，通过对数据进行处理，为程序提供功能强大、灵活的读写功能。</p><h3 id="2、InputStream和Outputstream抽象类"><a href="#2、InputStream和Outputstream抽象类" class="headerlink" title="2、InputStream和Outputstream抽象类"></a>2、InputStream和Outputstream抽象类</h3><p>字节流类用于向字节流读写8位二进制的字节。一般的，字节流类主要用于读写诸如图像或声音等的二进制数据。字节流类以InputStream和OutputStream为顶层类。他们都是抽象类。InputStream中定义的方法有：</p><pre><code>public abstract int read();//从输入流中读取数据的下一个字节public int read(byte[] b);//从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中public int read(byte[] b ,int off ,int len);//将输入流中最多len个数据字节读入byte数组public long skip(long n);//跳过或者丢弃此输入流中数据的n个字节public int available();//返回从该输入流中可以读取的字节数的估计值，而不会被下一次调用此输入流的方法阻塞public void close();//关闭输入流并释放与该流关联的所有系统资源</code></pre><p>OutputStream抽象类所有方法返回void值，在出错情况下抛IOException异常。需要定义OutputStream子类的应用,OutputStream必须至少提供一个写入一个字节输出的方法。OutputStream中定义的方法：</p><pre><code>public abstract void write(int b);//将指定的字节写入此输出流。 public void write(byte[] b);//将b.length个字节从指定的byte数组写入此输出流public void write(byte[] ,int off ,int len);//从指定的字节数组写入len个字节，从偏移off开始输出到此输出流。public void flush();//刷新此输出流并强制任何缓冲的输出字节被写出。public void close();//关闭输出流并释放与该流关联的所有系统资源</code></pre><h3 id="3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类"><a href="#3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类" class="headerlink" title="3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)"></a>3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)</h3><p>(1)每个抽象类都有多个具体的子类，这些子类对不同的外设进行处理，例如磁盘文件，网络连接，甚至是内存缓冲区。FileInputStream类表示能从文件读取字节的InputStream类。其常用的构造方法有：FileInputStream(String filepath);FileInputStream(File fileObj);FileOutputStream类表示能向文件写入字节的OutputStream类。其常用的构造方法有：FileOutputStream(String filepath);FileOutputStream(File fileObj);FileOutputStream(String filePath,boolean append);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileInputStreamOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileCopyUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileCopyUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        long time1 = System.currentTimeMillis();        /*int data = -1;        while((data = fileInputStream.read())!=-1){            fileOutputStream.write(data);        }*/        byte[] buf = new byte[1024*1024];//创建一个1M大小的缓冲区，用来存放输入流中的字节数据        int len = 0;//用来保存实际读到的字节数        while((len = fileInputStream.read(buf))!=-1){            fileOutputStream.write(buf, 0, len);//使用缓冲区对文件的进行读写操作会大大提高读写的速度        }        fileOutputStream.close();        fileInputStream.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><h3 id="4、ByteArrayInputStream和ByteArrayOutputStream"><a href="#4、ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="4、ByteArrayInputStream和ByteArrayOutputStream"></a>4、ByteArrayInputStream和ByteArrayOutputStream</h3><p>(1)ByteArrayInputStream是把字节数组当成源的输入流，其内部包含一个内部缓冲区，且调用close()方法关闭ByteArrayInputStream无效。它有两个构造方法，每个都需要一个字节数组提供数据源：ByteArrayInputStream(byte array[]);ByteArrayInputStream(byte array[],int start,int numBytes);ByteArrayOutputStream是把字节数组当作目标的输出流，它也有两个构造方法：ByteArrayInputStream();ByteArrayOutputStream(int numBytes);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class ByteArrayInputOutputStream {    public static void main(String[] args) throws IOException {        /*String string = &quot;Hello,shanghai!&quot;;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(string.getBytes());        int data = -1;        while((data=byteArrayInputStream.read())!=-1){            System.out.print((char)data);        }        byteArrayInputStream.close();//这里的关闭时无效的，因为没有调用操作系统底层的函数。*/        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        byteArrayOutputStream.write(97);        byteArrayOutputStream.write(65);        byteArrayOutputStream.write(&quot;hello,world!&quot;.getBytes());        byte[] buff = byteArrayOutputStream.toByteArray();        for(byte b:buff){            System.out.print((char)b);        }        FileOutputStream fileOutputStream = new FileOutputStream(&quot;f:\\test\\a.txt&quot;,true);//true表示可以追加        byteArrayOutputStream.writeTo(fileOutputStream);//把ByteArrayOutputStream内部缓冲区中的数据写到对应的文件输出流中        byteArrayOutputStream.close();//这里的关闭同上    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、流的概念和分类&quot;&gt;&lt;a href=&quot;#1、流的概念和分类&quot; class=&quot;headerlink&quot; title=&quot;1、流的概念和分类&quot;&gt;&lt;/a&gt;1、流的概念和分类&lt;/h3&gt;&lt;p&gt;(1)流的概念&lt;/p&gt;
&lt;p&gt;流是一个很形象的概念，当程序需要读取数据的时候，就会开
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vim入门</title>
    <link href="http://www.echodemo.cc/2018/07/31/Vim%E5%85%A5%E9%97%A8/"/>
    <id>http://www.echodemo.cc/2018/07/31/Vim入门/</id>
    <published>2018-07-31T08:39:27.000Z</published>
    <updated>2018-07-31T08:46:40.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Vim的模式介绍"><a href="#1、Vim的模式介绍" class="headerlink" title="1、Vim的模式介绍"></a>1、Vim的模式介绍</h3><p>(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p><p>(2)插入模式(Insert mode):在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</p><p>(3)可视模式(Visual mode):这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p><p>(4)选择模式(Select mode):这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p><p>(5)命令行模式(Command line mode):在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p><p>(6)Ex模式(Ex mode):这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。这其中我们常用到就是普通模式、插入模式和命令行模式。</p><p>vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[(这在vim课程环境中不管用)即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</p><h3 id="2、Vim常用命令"><a href="#2、Vim常用命令" class="headerlink" title="2、Vim常用命令"></a>2、Vim常用命令</h3><p>(1)移动</p><pre><code>1)h 左移一个字符；2)l 右移一个字符；3)j 下移一行；4)k 上移一行；5)w 移动到下一个单词；6)b 移动到上一个单词；</code></pre><p>(2)插入</p><pre><code>1)i 在当前光标处进行编辑；2)I 在当前行首插入；3)a 在光标后插入；4)A 在当前行末插入；5)o 在下面新建一行插入；6)O 在上面新建一行插入；</code></pre><p>(3)保存</p><pre><code>1):wq 保存并退出；2):w 保存修改；3):q 退出；4):saveas newfilename 另存为；5):q! 强制退出，不保存；6):wq! 强制保存并退出；</code></pre><p>(4)删除</p><pre><code>1)x 删除游标所在的字符2)X 删除游标所在前一个字符3)dd 删除整行4)dw 删除一个单词（不适用中文）5)d$或D 删除至行尾6)d^ 删除至行首7)dG 删除到文档结尾处8)d1G 删至文档首部</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Vim的模式介绍&quot;&gt;&lt;a href=&quot;#1、Vim的模式介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Vim的模式介绍&quot;&gt;&lt;/a&gt;1、Vim的模式介绍&lt;/h3&gt;&lt;p&gt;(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
  </entry>
  
</feed>
