<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-06T01:08:20.259Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>诗词入门(二)</title>
    <link href="http://www.echodemo.cc/2018/04/05/%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/04/05/诗词入门(二)/</id>
    <published>2018-04-05T11:35:50.000Z</published>
    <updated>2018-04-06T01:08:20.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、拗救"><a href="#1、拗救" class="headerlink" title="1、拗救"></a>1、拗救</h2><p>(1)拗：不符合诗律的一般规律(出律了)</p><p>(2)救：在拗的前提下调节平仄使音感和谐。</p><h2 id="2、拗救的常见形式"><a href="#2、拗救的常见形式" class="headerlink" title="2、拗救的常见形式"></a>2、拗救的常见形式</h2><p>以下皆以五言作为例句进行说明，那么也就是说七言的后五字同样适用于这些情况。</p><p>(1)本句自救(准律句)：平平平仄仄=》平平仄平仄</p><p>例：</p><pre><code>凉风起天末，君子意如何。平平仄平仄，平仄仄平平。</code></pre><p>根据诗律的原则，这里的“凉风起天末”句明显出律了。那么是“风”字出律还是“天”字出律呢？我们可以通过“君子意如何”句的平仄来判断。在这一联当中，对句的二四字的平仄为仄、平，那么就可以推出出句的二四字的平仄就为平、仄。也就是说是“天”字出律了(当仄为平时)，那么为什么明明“天”字出律了还会认为是对的呢？这种情况就是属于拗救中的本句自救。我们先来看一下出句的正确的平仄：“平平平仄仄”。这里有这样的规定：如果在诗的创作过程中碰到了“平平平仄仄”这种情况，可以使用另外一种格式，即：把五言的第三四字的平仄位置互换(七言当中第五六字的平仄位置互换)，此时规定五言的第一字必须用平声(七言的第三字必须用平声)，不再是可平可仄的，也就变成了“平平仄平仄”。我们可以发现，这种形式只能出现在出句当中(因为对句必须是押韵的，而近体诗当中是不能压仄声韵的)，同时又由于诗律中的相对和相粘原则，出句之中也只有两句才能出现这种情况。</p><p>若首字为仄，则是特例，初学者不建议使用。如：昔闻洞庭水(仄平仄平仄)。虽然说首字为仄的情况也是存在的，但毕竟与首字为平相比还是及其少见的。老杜虽是及其注重格律之人，但他活在格律成形的那个年代，那个时候的格律还是处于可以推敲的阶段，当然也就不能说他是错的。(这里只是希望初学者不要钻牛角尖，只要记住这种拗救的形式就行)</p><p>又例：</p><pre><code>遥怜小儿女，未解忆长安。平平仄平仄，仄仄仄平平。何时倚虚晃，双照泪痕干。平平仄平仄，平仄仄平平。西望瑶池降王母(平仄平平仄平仄)</code></pre><p>(2)对句相救：出句第四字当平为仄时，对句第三字只能是平声。</p><p>例：</p><pre><code>向晚意不适，驱车登古原。仄仄仄仄仄，平平平仄平。*在诗词当中，“不”字几乎可以说是只能为仄声。但也不是绝对的，当“不”字通“否”字时且作为韵脚时，它是平声的。如果它位于句中就一定是仄声。</code></pre><p>同样，这里根据对句的平仄可以判断出，是出句当中的第四字“不”字出律了(当平为仄时)。此时，可以通过对句的第三字(此时必为平声)来救，也就是例句中的“登”字。按照“一三五不论”的原则，“登”字本是可平可仄的，但是在这种情况之下就只能为平声了。因为是出句由对句来救，所以这种情况只能发生在出句当中。</p><p>又例：</p><pre><code>野火烧不尽，春风吹又生。仄仄平仄仄，平平平仄平。*吹字是可平可仄的，作名词的时候为仄声(歌吹是扬州)，作动词的时候为平声。</code></pre><h2 id="3、“一三五不论”需要排除的三种情况"><a href="#3、“一三五不论”需要排除的三种情况" class="headerlink" title="3、“一三五不论”需要排除的三种情况"></a>3、“一三五不论”需要排除的三种情况</h2><pre><code>(1)三平尾：在已经确定倒数第一和倒数第二字为平声的情况之下，如果仍然令倒数第三字为平声的话，就会变成“平平平”。三平尾是写诗的大忌。(2)三仄尾：在已经确定倒数第一和倒数第二字为仄声的情况之下，如果仍然令倒数第三字为仄声的话，就会变成“仄仄仄”。三仄尾也是写诗的大忌。(3)孤平：就是“仄平仄仄平”。孤平同样是写诗的大忌。这里可以将第三字改为平声来补偿，以免犯孤平。</code></pre><h2 id="4、根据平仄判断律句，若非律句再判断是否可救的步骤"><a href="#4、根据平仄判断律句，若非律句再判断是否可救的步骤" class="headerlink" title="4、根据平仄判断律句，若非律句再判断是否可救的步骤"></a>4、根据平仄判断律句，若非律句再判断是否可救的步骤</h2><pre><code>(1)先判断二四六字是否是平仄交替的。如果是则说明暂时是一个律句，进行第二步；否则说明此句不是一个标准的律句，进行第三步。(2)是否出现了三平尾、三仄尾或者是孤平。如果出现了其中一种，则必定是错误的。若没有，则说明是可以用的。(3)判断是否符合拗救的两种基本形式。如果符合其中之一说明是可以用的；如果都不符合则说明是错误的。</code></pre><h2 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h2><p>如果是本句自救(准律句)，打半钩；如果是对句自救，则标记出其对句该如何。如果最终不符合格律则打叉，符合则打钩。若有学有余力，为正确的律句查找相应的诗句。</p><p><img src="/images/2018/4/1.jpg" alt="&quot;作业&quot;"></p><p><img src="/images/2018/4/2.jpg" alt="&quot;作业&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、拗救&quot;&gt;&lt;a href=&quot;#1、拗救&quot; class=&quot;headerlink&quot; title=&quot;1、拗救&quot;&gt;&lt;/a&gt;1、拗救&lt;/h2&gt;&lt;p&gt;(1)拗：不符合诗律的一般规律(出律了)&lt;/p&gt;
&lt;p&gt;(2)救：在拗的前提下调节平仄使音感和谐。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/05/MySQL%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/05/MySQL中的问题整理/</id>
    <published>2018-04-05T01:45:49.000Z</published>
    <updated>2018-04-05T02:33:56.808Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、mysql共享锁和排他锁</code></pre><p>(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排它锁。</p><p>(2)共享锁也叫读锁，简称S锁，原理：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改。</p><p>(3)排他锁也叫写锁，简称x锁，原理：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁(排他锁或者共享锁)，即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改。但是获取排他锁的事务是可以对数据进行读取和修改。</p><p>(4)设置共享锁：SELECT … LOCK IN SHARE MODE;设置排他锁：SELECT … FOR UPDATE;</p><p>(5)对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。 对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。</p><pre><code>2、MySQL几种备份方式</code></pre><p>(1)逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。</p><p>优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。</p><p>缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。</p><p>(2)物理备份：直接拷贝mysql的数据目录。直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。</p><p>缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。</p><p>(3)双机热备份。mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备)。</p><p>优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。</p><pre><code>3、数据库范式：一张数据表的表结构所符合的某种设计标准的级别</code></pre><p>(1)第一范式(1NF)</p><p>在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。<br>所谓第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>(2)第二范式(2NF)</p><p>第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是消除了非主属性对于码的部分函数依赖。</p><p>(3)第三范式(3NF)</p><p>满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是消除了非主属性对于码的传递函数依赖。</p><pre><code>4、SQL语句优化</code></pre><p>(1)应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>(2)应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</code></pre><p>(3)很多时候用 exists 代替 in 是一个好的选择。</p><p>(4)用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过。</p><pre><code>5、存储过程与触发器的区别</code></pre><p>(1)触发器与存储过程非常相似，它是一种特殊类型的存储过程。触发器也是SQL语句集，他们都像是数据库中运行的方法。两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发(激活)执行。</p><p>(2)触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p><p>(3)触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p><pre><code>6、union 与union all的区别</code></pre><p>union 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all 则会显示重复结果,只是简单的两个结果合并并返回.所以效率比union高,在保证没有重复数据的情况下用union all。</p><pre><code>7、MyISAM和InnoDB区别</code></pre><p>(1)InnoDB支持外键，而MyISAM不支持。</p><p>(2)InnoDB不支持全文索引，而MyISAM支持。</p><p>(3)InnoDB支持行级锁，而MyISAM支持表级锁。</p><p>(4)MyISAM不提供事务支持。InnoDB提供事务支持。</p><p>(5)MyISAM保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p>(6)MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p>(7)MyISAM可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p>(8)如果执行大量的SELECT，MyISAM是更好的选择。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p>(9)每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><pre><code>8、MySQL的三级模式</code></pre><p>(1)模式(逻辑模式)：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><p>(2)外模式(用户模式)：是数据库用户的数据视图，是局部数据的逻辑结构和特征的描述。</p><p>(3)内模式(存储模式)：一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p><pre><code>9、mysql中视图和表的区别以及联系</code></pre><p>区别：</p><p>(1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。</p><p>(2)视图没有实际的物理记录，而表有。</p><p>(3)视图是窗口，表是内容。</p><p>(4)视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。</p><p>(5)表可以及时对它进行修改；而视图只能用创建语句来修改。</p><p>(6)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。</p><p>(7)从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。</p><p>(8)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</p><p>(9)视图的建立和删除只影响视图本身，不影响对应的表。</p><p>联系：</p><p>(1)视图是在表之上建立的虚表，它的结构(所定义的列)和内容(所有记录)都来自表，视图依据表存在而存在。一个视图可以对应多个表。视图是表的抽象和在逻辑意义上建立的新关系。</p><p>(2)删除视图中的数据,数据库中表的数据会一起被删除。</p><pre><code>10、存储过程(procedure)和函数(function)区别</code></pre><p>(1)本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。</p><p>(2)函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。</p><p>(3)函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、mysql共享锁和排他锁
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="http://www.echodemo.cc/2018/04/04/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.echodemo.cc/2018/04/04/MySQL事务/</id>
    <published>2018-04-04T15:46:14.000Z</published>
    <updated>2018-04-05T02:34:05.226Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><pre><code>(1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。(2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。(3)事务用来管理 insert,update,delete 语句</code></pre><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><p>(1)原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>(2)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>(3)隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><pre><code>a、未提交读（RU）：最弱的隔离级别，事务中的修改即使没有提交，对其他事务也都是可见的。（即脏读）b、不可重复读（RC）：大多数数据库系统的默认隔离级别。解决了脏读的问题，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。一个事务两次执行同样的查询，可能会得到不一样的结果。c、可重复读（RR）：mysql默认隔离级别。解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。该级无法解决幻读的问题，幻读是当某个事务在读取某个范围内的记录时，一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。innodb和xtradb存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。d、可串行化：该级是最高的级别，通过强制事务串行执行，避免了幻读的问题，该级会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题，</code></pre><p>(4)持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务必使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><p>事务控制语句：</p><pre><code>(1)BEGIN或START TRANSACTION；显式地开启一个事务；(2)COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；(3)ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；(4)SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；(5)RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(6)ROLLBACK TO identifier；把事务回滚到标记点；(7)SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</code></pre><p>MYSQL 事务处理主要有两种方法：</p><pre><code>1、用 BEGIN, ROLLBACK, COMMIT来实现(1)BEGIN 开始一个事务(2)ROLLBACK 事务回滚(3)COMMIT 事务确认2、直接用 SET 来改变 MySQL 的自动提交模式:(1)SET AUTOCOMMIT=0 禁止自动提交(2)SET AUTOCOMMIT=1 开启自动提交</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)在 MySQL 中只有使用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.echodemo.cc/2018/04/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.echodemo.cc/2018/04/04/红黑树/</id>
    <published>2018-04-04T01:50:20.000Z</published>
    <updated>2018-04-05T00:01:48.845Z</updated>
    
    <content type="html"><![CDATA[<p>1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次递减时，它会不断地插在节点的左子树)。此时的二叉查找树的查找性能几乎变成了线性。那么如何解决二叉查找树多次插入新节点而导致的不平衡呢？红黑树也就应运而生了。</p><pre><code>二叉查找树的性质：a、左子树上所有结点的值均小于或等于它的根结点的值。b、右子树上所有结点的值均大于或等于它的根结点的值。c、左、右子树也分别为二叉排序树。</code></pre><p>2、红黑树(Red Black Tree)是一种平衡的二叉查找树(但不是一个完美的平衡二叉树)。它的应用有很多，Java中的TreeSet和TreeMap数据结构，Java8中的HashMap也用到了红黑树；在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。</p><font color="#8A2BE2">(1)性质</font><pre><code>a、节点是红色或黑色。b、根节点是黑色。c、每个叶子节点都是黑色的空节点（NIL节点）。d、每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)e、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</code></pre><p>以上这些限制强化了红黑树的关键属性：从根节点到最远叶节点的路径不超过从根到最近叶节点的路径的两倍(最短的路径是:全部都是黑色节点，最长的路径是:在红色和黑色节点之间交替)。这也是红黑树和二叉查找树之间最大的不同。</p><font color="#8A2BE2">(2)左旋转和右旋转</font><p>a、左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子树取代，而父节点自己成为自己右子树(现在已经是父节点了)的左子树。现在已经是父节点的的左子树成为曾经的父节点的右子树。</p><p>b、右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子树取代，而父节点自己成为自己左子树(现在已经是父节点了)的右子树。现在已经是父节点的的右子树成为曾经的父节点的左子树。</p><font color="#8A2BE2">(3)插入节点</font><p>a、当前节点位于树的根部。为了满足（根节点是黑色），将其颜色变成黑色。由于这会向每条路径都添加一个黑色节点，所以（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）不会被违反。</p><p>b、当前节点的父节点是黑色的。所以（每个红色节点的两个子节点都是黑色）不会失效。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）没有受到威胁，因为当前节点有两个黑色节点，但由于当前节点是红色，所以到达其每个叶子节点路径上的黑色节点的数量与它所替换的叶子节点路径上的黑色节点的数量是相同的。</p><p>c、如果父节点和父节点的兄弟节点都是红色的，那么可以将他们的颜色都变成黑色，并且将祖父母节点的颜色变成红色以维持（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）。由于通过父节点和父节点的兄弟节点的任何路径必须经过祖父母节点，所以这些路径上的黑色节点的数目并没有改变。然而，祖父母节点现在可能违反了（根节点是黑色），如果它是根或（每个红色节点的两个子节点都是黑色），如果它具有红色的父母节点。为了解决这个问题，树上的红黑修复程序在祖父母节点上重新运行。</p><p>d、父节点是红色的，但是父节点的兄弟节点是黑色的。最终目标是将当前节点旋转到祖父母节点的位置，但如果当前节点位于祖父母节点下子树的“内部” （即，如果当前节点是祖父母节点的右子节点的左子节点或者是祖父母节点的左子节点的右子节点）。在这种情况下，可以在父节点上执行左旋转以切换当前节点及其父节点的位置。由于父节点和当前的插入节点都是红色的，所以旋转这两个节点不会使（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）受到旋转的影响。这一步完成后（每个红色节点的两个子节点都是黑色）仍然被违反。此时，当前节点现在肯定位于祖父母节点的子树的外部（左子节点或右子节点）。在这种情况下，执行祖父母节点上的右旋转;其中前父母节点现在是当前节点和前祖父母节点的父母节点。此时前父母节点和前祖父母节点的颜色互换，结果树满足（每个红色节点的两个子节点都是黑色）。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）也依然不满足，再将前祖父母节点和其右子节点的颜色互换即可。</p><p>*具体的红黑树中插入和删除出现的有关旋转和变色的情况，请自行跳转至维基百科查看：<a href="https://en.m.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">维基百科红黑树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>柴</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%9F%B4/"/>
    <id>http://www.echodemo.cc/2018/03/31/柴/</id>
    <published>2018-03-31T08:03:52.000Z</published>
    <updated>2018-03-31T08:06:39.689Z</updated>
    
    <content type="html"><![CDATA[<p>你本是泥土里的种子</p><p>春雨下来，便破土而出，发芽又抽绿</p><p>阳光透过乔木和灌木的叶子漏下来</p><p>照耀着你微弱的身体</p><p><br><br>后来呀，雨露下来，寒风穿过</p><p>土壤也时而干燥</p><p>根在土里生长</p><p>叶在空气里徜徉</p><p>向着更广阔的空间里延伸</p><p>春夏秋冬地过去，轮回。</p><p><br><br>那一日，我手持柴刀独自上山</p><p>无意间来到你的身旁</p><p>此时的你已巍然成木</p><p>在多少次的手起刀落后</p><p>在洁白的木屑四散飞溅后</p><p>你轰然倒下</p><p>倒在你无比熟悉的地点</p><p>我残忍地脱去你的外衣，卸下你的臂膀</p><p>甚至头颅。</p><p><br><br>你已经死了</p><p>你的尸体跟随我下了山</p><p>你永远地离开了生生世世守护的这方土地</p><p>被我丢弃在陌生的沙土之上</p><p>无情的斧子借着外力将你的尸体大卸八块</p><p>陈列在清灰色瓦片盖的土坯房子里</p><p>静静等候与烈火的相遇</p><p>化为炊烟又化为尘土</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你本是泥土里的种子&lt;/p&gt;
&lt;p&gt;春雨下来，便破土而出，发芽又抽绿&lt;/p&gt;
&lt;p&gt;阳光透过乔木和灌木的叶子漏下来&lt;/p&gt;
&lt;p&gt;照耀着你微弱的身体&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;后来呀，雨露下来，寒风穿过&lt;/p&gt;
&lt;p&gt;土壤也时而干燥&lt;/p&gt;
&lt;p&gt;根在土里生长&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>文字</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%96%87%E5%AD%97/"/>
    <id>http://www.echodemo.cc/2018/03/31/文字/</id>
    <published>2018-03-31T07:29:11.000Z</published>
    <updated>2018-03-31T07:34:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全文”的扩展链接，你会知道自己在某天的某个时间段做了什么。可能是有关学习的知识点，可能是有关生活的感悟或自己的思考，又或者仅仅是记录了一件事情的发生。所有这些，过后回望的确会有及其深刻的意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(三)</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/31/《眠空》摘句(三)/</id>
    <published>2018-03-31T07:13:57.000Z</published>
    <updated>2018-03-31T07:14:55.216Z</updated>
    
    <content type="html"><![CDATA[<p>1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。</p><p>2、经过提纯的内心空间，不是不懂，不知，而是不问，不计较，不介意，不追究。愿意把别人想得好一些，不把人想得复杂，考虑到对方的立场。可说，可不说时，不如选择不说。</p><p>4、不存在无可救药的人、感情、生活。一切终究有变化。如果你认为它无可救药，不过是沉溺。我们可以选择完全的放下，或者完全的承担。唯独不能伪装成一个懒怠的理所当然的姿势。你尽可拖延和故作不知，企图获得其他妥协。命运静静等待一侧，旁观你辗转煎熬，最终会逼迫你把脚步移向注定的一格。实践一旦进行，错误和方式就会自动调整和归位。出发时首要的。</p><p>5、跪拜只是一个仪式，为了让心恭敬谦卑平和柔顺，在毫无杂念从事这一重复举动时训练和观照自己。调伏这颗充满傲慢我执的刚硬的心。这是一个修行的任务。</p><p>6、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。&lt;/p&gt;
&lt;p&gt;2、经过提纯的内心空间，不是不懂，不
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的抽象类和接口</title>
    <link href="http://www.echodemo.cc/2018/03/31/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.echodemo.cc/2018/03/31/Java中的抽象类和接口/</id>
    <published>2018-03-31T07:01:20.000Z</published>
    <updated>2018-03-31T07:02:41.750Z</updated>
    
    <content type="html"><![CDATA[<p>1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是GeometricObject类型的数组，然后创建一个GeometricObject的实例，并将它的引用赋值给数组是可以的。虽然不能使用new操作符创建它的实例，但仍然可以定义它的构造方法，抽象类的构造方法定义为protected，因为它只被子类使用。抽象方法只有定义而没有实现。它的实现由子类提供。</p><p>2、抽象方法不能包含在非抽象类中，也就是说一个包含抽象方法的类必须声明为抽象类。但是，可以定义一个不包含抽象方法的抽象类(同样不能使用new操作符创建它的实例)，这种类是用来定义新子类的基类的。如果抽象父类的子类不能实现所有的抽象方法，那么这个子类也必须定义为抽象的。另外，抽象方法是非静态的。</p><p>3、即使子类的父类是具体的，这个子类也可以是抽象的。比如：object类是具体的，但继承于它的类却可以是抽象的。子类可以覆盖父类的方法并将它定义为abstract(这是很少见的)，但是它在当父类的方法实现在子类中变得不合法时是很有用的。在这种情况下，子类必须为abstract。</p><p>4、接口是一种与类相似的结构，只包含常量和抽象方法。它和抽象类相似，不能使用new操作创建接口的实例。由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以java允许忽略这些修饰符。</p><p>5、Java只允许为类的扩展做单一继承，但是允许使用接口做多重继承。用关键字extends，接口可以继承其他接口，但是不可扩展类。一个类可以扩展它的父类同时实现多个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是Ge
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>画地为牢</title>
    <link href="http://www.echodemo.cc/2018/03/28/%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2/"/>
    <id>http://www.echodemo.cc/2018/03/28/画地为牢/</id>
    <published>2018-03-28T12:25:39.000Z</published>
    <updated>2018-03-28T12:28:30.244Z</updated>
    
    <content type="html"><![CDATA[<p>人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一双发现美的眼睛，同时也需要有伸向外界的触角和勇气。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Strcpy函数的实现</title>
    <link href="http://www.echodemo.cc/2018/03/28/Strcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.echodemo.cc/2018/03/28/Strcpy函数的实现/</id>
    <published>2018-03-28T10:54:17.000Z</published>
    <updated>2018-03-28T10:57:39.608Z</updated>
    
    <content type="html"><![CDATA[<p>(1)strcpy函数的代码实现</p><pre><code>char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。    assert(dst != NULL &amp;&amp; src != NULL);//检查指针的有效性，如果它的条件返回错误，则终止程序执行。    char *ret = dst;    while ((*dst++=*src++)!=&apos;\0&apos;);    return ret;}</code></pre><p>(2)为什么要返回char *?</p><pre><code>返回dst的原始值使函数能够支持链式表达式。链式表达式的形式如：int l=strlen(strcpy(strA,strB));又如：char * strA=strcpy(new char[10],strB);返回strSrc的原始值是错误的。其一，源字符串肯定是已知的，返回它没有意义。其二，不能支持形如第二例的表达式。其三，把const char *作为char *返回，类型不符，编译报错。</code></pre><p>(3)考虑dst和src内存重叠的情况</p><p>所谓重叠，就是src未处理的部分已经被dst给覆盖了，只有一种情况：src&lt;=dst&lt;=src+strlen(src)。C函数memcpy自带内存重叠检测功能，下面给出memcpy的实现my_memcpy。</p><pre><code>char *strcpy(char *dst,const char *src){    assert(dst != NULL &amp;&amp; src != NULL);    char *ret = dst;    my_memcpy(dst, src, strlen(src)+1);    return ret;}</code></pre><p>my_memcpy的实现：</p><pre><code>char *my_memcpy(char *dst, const char* src, int cnt){    assert(dst != NULL &amp;&amp; src != NULL);    char *ret = dst;     if(dst &gt;= src &amp;&amp; dst &lt;= src+cnt-1){//内存重叠，从高地址开始复制        dst = dst+cnt-1;        src = src+cnt-1;        while (cnt--)            *dst-- = *src--;    }else{//正常情况，从低地址开始复制        while (cnt--)            *dst++ = *src++;    }    return ret;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(1)strcpy函数的代码实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。
    assert(dst != NULL &amp;amp;&amp;amp; src 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>三月二十七号</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E4%B8%89%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8F%B7/"/>
    <id>http://www.echodemo.cc/2018/03/27/三月二十七号/</id>
    <published>2018-03-27T11:51:27.000Z</published>
    <updated>2018-03-27T11:54:38.037Z</updated>
    
    <content type="html"><![CDATA[<p>奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量的传递与引导，人与自然需要一定的联结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(二)</title>
    <link href="http://www.echodemo.cc/2018/03/27/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/27/《眠空》摘句(二)/</id>
    <published>2018-03-27T11:29:09.000Z</published>
    <updated>2018-03-27T11:30:11.879Z</updated>
    
    <content type="html"><![CDATA[<p>1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。仿佛一种强悍的无法屈服的意愿。</p><p>2、我们最终所得到的训练无非是，面对无所知、无常、虚妄，时时抚平心绪，保持警惕、平静、坚强、有方向地活下去。并且静观这个世间所有破落的碎片擦身而过。</p><p>3、人的生活需要公园。它为日常生活提供一处停顿。停顿意味暂时没有心念，没有目标，略作小憩，与己共存。</p><p>4、如果要做到不伤害他人，前提是不要对他人抱有期待。同时也不让他人抱有对你的期待。做到后一条更为困难。这意味着在某些时刻，你必须显示你自己真实的立场，而没有一丝自私的隐藏或者造作。</p><p>5、有时，我们爱人，是取悦自己渴望被爱的欲求；对他人的提供，是试图填补内在匮乏的需求；憎恶或攻击他人，是被对方提醒了不愿意被揭示的遮蔽的暗处；愤恨或者狂躁，联结着内心长期积累的软弱和无力。。。自我战争不过是冲突于牢笼之中。</p><p>6、时间很重要，物证很重要。它们会使某些曾经被蒙蔽或忽略的情感，在很久之后被澄清和浮出。我也会手写书信给生命中真正重要的人。只为了让他或她，在以后某天终会明白我的心。</p><p>7、摘完杏，和农夫闲聊。他说果实在树上，阳光的温度或突降的暴雨都会给予它影响。每一天它的内在都在发生变化，都在面临无常。所以，及时地摘下并享用它即是最好的方式。</p><p>8、人由自我限制而生发的对他人的狭窄念头，毫发无损于对方，只使自己捉襟见肘。若能置身事外，才不会画地为牢。</p><p>9、当下享受是最好的态度。接受无常，接纳完整的存在，而不试图重新塑造，也不扭曲自己和他人。关系第一原则，应是允许他人以独立和自愿的方式存在。期望是自以为是的权力。</p><p>10、在一本书里，读者感受到作者的精神方式、观念、特质，觉得与之契合，有共鸣，遂在心里把他当作一个知己。他们之间的关系，有时会比生活中实际相处的人抵达更为深邃的心灵限度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(三)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(三)/</id>
    <published>2018-03-26T10:10:23.000Z</published>
    <updated>2018-03-31T07:00:52.662Z</updated>
    
    <content type="html"><![CDATA[<p>1、define与const的区别</p><p>(1)define在预处理阶段进行替换;const在编译时确定其值。</p><p>(2)用define可以定义一些简单的函数，const是不可以定义函数的。</p><p>(3)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的。</p><p>(4)define无类型，不进行类型安全检查，可能会产生意想不到的错误;const有数据类型,编译时会进行类型检查。</p><p>(5)define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大;const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。</p><p>(6)宏定义的作用范围仅限于当前文件;而const对象在默认状态下，只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字(在声明和定义时都要加。</p><p>2、构造函数不能为虚函数，而析构函数可以且常常是虚函数</p><p>(1)如果构造函数是虚函数，那么就需要通过vtable来调用，但此时面对一块raw memeory是找不到vtable的，vtable是在构造函数中才初始化的，而不是在其之前。因此构造函数不能为虚函数。</p><p>(2)析构函数可以是虚函数,此时vtable已经初始化了,况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p><p>3、虚函数和纯虚函数的作用与区别</p><p>(1)虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不重写基类中的此函数。</p><p>(2)纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数。它不能直接实例化，需要派生类来实现函数定义。</p><p>4、面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。他们之间的共同点是抽象和创建可重用代码，但它们的理念决然不同。泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板，模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型，它们都是STL通用方法的重要组成部分。</p><p>5、头文件中的#ifndef/#define/#endif的作用</p><p>其作用是防止该头文件被重复引用。”被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include “c.h”而此时b.cpp文件导入了#include”a.h”和#include”c.h”此时就会造成c.h重复引用。有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些。但是对于大工程而言编译效率低下就会是一件很痛苦的事情了。</p><p>6、动态内存分配的初始化问题</p><p>1)malloc函数：void *malloc(unsigned int size)</p><p>在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。</p><p>2)calloc函数： void *calloc(unsigned int num, unsigned int size)</p><p>按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。</p><p>3)realloc函数：void <em>realloc(void </em>ptr, unsigned int size)</p><p>动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。申请的内存空间不会进行初始化。</p><p>4)new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。</p><p>7、指针和const</p><pre><code>int * const x = &amp;y;       //指针所指向的内存不可变，内存中的值可以改变。const int *x = &amp;y;        //指针所指向的内存可变，但内存中的值不能通过指针改变。int const *x = &amp;y;        //指针所指向的内存可变，但内存中的值不能通过指针改变。const int const *x = &amp;y;  //指针所指向的内存不可变，内存中的值也不能通过指针改变。const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。当const在*的左边，则表示指针所指向的空间的内容不能通过改变*p的值来修改，或者说指针所指向空间的值不能被修改。当const在*的右边，则表示指针的地址不能被修改，或者说指针的指向不能被修改。</code></pre><p>8、无论是整型数组还是字符数组，数组名作为右值的时候都代表数组首元素的首地址。数组发生降级(数组名退化为数组首元素的地址)的情况：数组传参、数组名参与运算。数组名不会发生降级的情况：sizeof(数组名)、取地址数组名(取到的是整个数组的地址而不是首元素的地址)。</p><p>9、重载、覆盖和隐藏</p><pre><code>(1)成员函数被重载的特征：a、相同的范围(在同一个类中)；b、函数名字相同；c、参数不同；d、virtual关键字可有可无。(2)覆盖是指派生类函数覆盖基类函数，只作用于派生类函数，特征是：a、不同的范围(分别位于派生类与基类)；b、函数名字相同；c、参数相同；d、基类函数必须有virtual关键字。实际上虚函数的作用，就是实现覆盖。(3)“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：a、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)。b、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)。</code></pre><p>10、类模板与模板类的概念</p><p>(1)类模板:一个类模板(也称为类属类或类生成类)允许用户为类定义一种模式，使得类中的某些数据成员、默认成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。</p><p>(2)模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。<br>类模板的重点是模板，表示的是一个模板，专门用于产生类的模子。模板类的重点是类，表示的是由一个模板生成而来的类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、define与const的区别&lt;/p&gt;
&lt;p&gt;(1)define在预处理阶段进行替换;const在编译时确定其值。&lt;/p&gt;
&lt;p&gt;(2)用define可以定义一些简单的函数，const是不可以定义函数的。&lt;/p&gt;
&lt;p&gt;(3)用define定义的常量是不可以用指针变量去
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(二)</title>
    <link href="http://www.echodemo.cc/2018/03/26/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/03/26/C++中的问题整理(二)/</id>
    <published>2018-03-26T07:12:01.000Z</published>
    <updated>2018-03-31T07:07:25.739Z</updated>
    
    <content type="html"><![CDATA[<p>1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。</p><p>2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。</p><p>3、构造函数初始化时必须采用初始化列表的一共有三种情况</p><pre><code>(1)需要初始化的数据成员是对象(继承时调用基类构造函数)(2)需要初始化const修饰的类成员(3)需要初始化引用成员数据*由于static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的。static const成员也不在初始化列表中。*static属于类，它在未实例化的时候就已经存在了，而构造函数的初始化列表，只有在实例化的时候才执行。*static成员不属于对象。我们在调用构造函数自然是创建对象，一个跟对象没直接关系的成员没有必要初始化。</code></pre><p>4、实参可以是任何类型（可以是常量，变量或表达式），但是形参却不能是表达式。C语言中最简单的数据类型包括整型、实型(实型又称浮点数或者实数)、字符型。在C语言中，没有专门的逻辑型数据类型，而是用0和1来表示逻辑值。</p><p>5、类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐。基类中存在虚函数时，派生类会继承基类的虚函数(虚函数也是类的成员函数)，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。(指向虚函数的指针为4个字节)</p><p>6、fork()与clone的区别</p><p>函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；clone()函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可以通过参数设定选择的，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。</p><p>7、关于浅复制和深复制</p><p>所谓浅复制，就是在构造函数当中直接为复制的对象的数据成员赋值。在很多情况下，这是可以的。创建新的对象，要为对象的数据成员分配存储空间，直接赋值就将值保存在相应的空间中。但是如果在构造函数当中出现了指针类型的数据成员时，也按照上面那样直接赋值而未经过地址的分配就会在调试的时候出错，这种指针被称为“野指针”。解决这样的问题的方法，就是在构造函数中，为指针类型的成员，分配专门的空间。以这条规则构建的复制，称作为深复制。</p><p>8、C语言中的未定义行为(Undefined Behavior)</p><p>未定义行为是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。</p><p>9、C++面向对象的三个基本特征(封装、继承和多态)</p><p>(1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行。封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p><p>(2)继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>(3)多态：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上。同时又有这些多态的形式，参数多态：指参数方面，包含函数模板与类模板；包含多态：含有virtual关键字；重载多态：函数名相同，但函数参数的个数或类型不同构成多态；强制多态：通过强制类型转换形成；重载多态和强制多态是指特定多态。参数多态和包含多态是指通用多态。</p><p>*封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现接口重用！</p><p>10、虚函数如何实现的</p><pre><code>(1)虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针。(2)在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。(3)实际上在编译的时候，编译器会自动加上虚表。(4)虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函数重新定义。(5)虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。(6)必须通过基类类型的引用或指针进行函数调用才会发生多态。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。&lt;/p&gt;
&lt;p&gt;2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Windows中个人常用快捷键</title>
    <link href="http://www.echodemo.cc/2018/03/26/Windows%E4%B8%AD%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://www.echodemo.cc/2018/03/26/Windows中个人常用快捷键/</id>
    <published>2018-03-26T03:10:27.000Z</published>
    <updated>2018-03-26T03:13:02.922Z</updated>
    
    <content type="html"><![CDATA[<p>1、Ctrl类</p><pre><code>(1)撤消操作：Ctrl+Z(2)复制选定文本：Ctrl+C(3)粘贴选定文本：Ctrl+V(4)剪切选定文本：Ctrl+X(5)打开新窗口：Ctrl+N(6)关闭当前所在窗口：Ctrl+W(7)恢复关闭的窗口：ctrl+shift+T(8)新建文件夹：Ctrl+Shift+N(9)选择文档或窗口中的所有项目：Ctrl+A(10)在本应用下的窗口之间进行切换：Ctrl+Tab</code></pre><p>2、Windows类</p><pre><code>(1)电脑锁屏：Windows+L(2)显示和隐藏桌面：Windows+D(3)打开任务视图：Windows+Tab(4)打开“运行”对话框：Windows+R(5)打开文件资源管理器：Windows+E(6)添加虚拟桌面：Windows+Ctrl+D(7)关闭你正在使用的虚拟桌面：Windows+Ctrl+F4(8)在你于右侧创建的虚拟桌面之间切换：Windows+Ctrl+向右键(9)在你于左侧创建的虚拟桌面之间切换：Windows+Ctrl+向左键    </code></pre><p>3、其他</p><pre><code>(1)刷新当前窗口：F5(2)在所有打开的应用之间进行切换：Alt+Tab</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Ctrl类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)撤消操作：Ctrl+Z

(2)复制选定文本：Ctrl+C

(3)粘贴选定文本：Ctrl+V

(4)剪切选定文本：Ctrl+X


(5)打开新窗口：Ctrl+N

(6)关闭当前所在窗口：Ctrl+W

(7)恢复关
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Windows" scheme="http://www.echodemo.cc/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>指针和引用的区别</title>
    <link href="http://www.echodemo.cc/2018/03/25/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.echodemo.cc/2018/03/25/指针和引用的区别/</id>
    <published>2018-03-25T11:23:26.000Z</published>
    <updated>2018-03-26T07:22:21.218Z</updated>
    
    <content type="html"><![CDATA[<p>(1)可以有const指针，但是没有const引用。</p><p>(2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;&a;是不合法的)。</p><p>(3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。</p><p>(4)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。</p><p>(5)指针可以是空值，可以在任何时候被初始化。而引用不可以为空且在被创建的时候，必须初始化。此处引用类似于const的指针。</p><p>(6)指针和引用的自增(++)运算意义不一样。指针自增是所指的数据类型变量的下一个数据类型的地址。而引用是引用所指向的变量的值加1。</p><p>(7)”sizeof(引用)”得到的是所指向的变量(对象)的大小(即引用的sizeof为所引用的对象在内存中分配空间的大小(单位字节))，而”sizeof(指针)”得到的是指针本身的大小。在C++当中，存放一个地址和一个int类型的大小相同：4字节。即sizeof(指针)=4。</p><p>(8)指针是一个变量，只不过这个变量存储的是一个地址，是指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。引用变量的主要作用是用作函数的形参，通过将引用变量用作形参，函数将使用原始数据，而不是其副本。</p><p>注意：要把引用的&amp;和取地址运算符&amp;区分开来，引用并不是取地址的意思，引用符号是类型标识的一部分。由于引用是产生变量的别名，故常量不可使用引用。指针变量其实是unsigned类型的整数，这也解释了为什么在C++当中指针类型的变量的sizeof就是4个字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(1)可以有const指针，但是没有const引用。&lt;/p&gt;
&lt;p&gt;(2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;amp;&amp;a;是不合法的)。&lt;/p&gt;
&lt;p&gt;(3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(一)</title>
    <link href="http://www.echodemo.cc/2018/03/25/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/03/25/C++中的问题整理(一)/</id>
    <published>2018-03-25T11:19:51.000Z</published>
    <updated>2018-03-26T01:12:10.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别"><a href="#1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别" class="headerlink" title="1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?"></a>1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?</h3><p>答：对于#include&lt;filename.h&gt;,编译器从标准库路径开始搜索filename.h,而对于#include “filename.h”,编译器从用户的工作路径开始搜索filename.h。</p><h3 id="2、在C-程序中调用被C编译器编译后的函数-为什么要加extern“C”"><a href="#2、在C-程序中调用被C编译器编译后的函数-为什么要加extern“C”" class="headerlink" title="2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?"></a>2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?</h3><p>答：C++语言支持函数重载,C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为:void foo(int x, int y);该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int 之类的名字。C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。</p><h3 id="3、一个类有基类、内部有一个其他类的成员对象-构造函数的执行顺序是怎样的"><a href="#3、一个类有基类、内部有一个其他类的成员对象-构造函数的执行顺序是怎样的" class="headerlink" title="3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?"></a>3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?</h3><p>答：先执行基类的(如果基类当中有虚基类,要先执行虚基类的,其他基类则按照声明派生类时的顺序依次执行),再执行成员对象的,最后执行自己的。</p><h3 id="4、New-delete与malloc-free的区别是什么？"><a href="#4、New-delete与malloc-free的区别是什么？" class="headerlink" title="4、New/delete与malloc/free的区别是什么？"></a>4、New/delete与malloc/free的区别是什么？</h3><p>(1)new/delete是C++的操作符，而malloc/free是C中的函数。</p><p>(2)new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。</p><p>(3)new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。</p><p>(4)new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。</p><h3 id="5、Struct和class的区别是什么？"><a href="#5、Struct和class的区别是什么？" class="headerlink" title="5、Struct和class的区别是什么？"></a>5、Struct和class的区别是什么？</h3><pre><code>答：struct中成员变量和成员函数默认访问权限是public,class是private。</code></pre><h3 id="6、多态有哪些分类？"><a href="#6、多态有哪些分类？" class="headerlink" title="6、多态有哪些分类？"></a>6、多态有哪些分类？</h3><p>答：多态可以分为编译时多态和运行时多态。编译时多态可以通过函数的重载来实现，具体表现在根据参数的个数和类型的不同选择合适的同名函数。运行时多态通过虚函数实现，就是运行时根据对象类型自动选择正确的调用函数(也叫动态绑定)。模板属于编译时多态性，因为编译时自动根据模板生成模板函数。虚函数的动态绑定仅在基类指针或引用绑定派生类对象时发生。如果函数的形参不是指针或者引用，则调用哪个类的函数就已经确定。</p><h3 id="7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？"><a href="#7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？" class="headerlink" title="7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？"></a>7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？</h3><pre><code>(1)默认情况下，编译器的对齐系数为8(2)内存对齐：就是每个成员的起始位置必须是对齐系数与成员自身大小二者中较小者的整数倍。(3)内存补齐：取结构体或类的成员中最大的那个值，与对齐系统相比，取二者中的较小者。然后保证整个对象结尾地址的下一个地址是较小者的整数倍。(4)结构体对齐除了第1点之外还要求结构体数组也必须是对齐的，也就是说每个相邻的结构体内部都是对齐的。可以看一下这篇文章:http://www.cppblog.com/cc/archive/2006/08/01/10765.html</code></pre><h3 id="8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。"><a href="#8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。" class="headerlink" title="8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。"></a>8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。</h3><h3 id="9、const-有什么用途？"><a href="#9、const-有什么用途？" class="headerlink" title="9、const 有什么用途？"></a>9、const 有什么用途？</h3><p>(1)可以定义const常量。</p><p>(2)const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。被const修饰的函数定义体的函数能被const或者非const对象调用，但是const对象只能调用被const修饰过定义体的函数。</p><h3 id="10、什么是内联函数？"><a href="#10、什么是内联函数？" class="headerlink" title="10、什么是内联函数？"></a>10、什么是内联函数？</h3><p>(1)编译器使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存。例如：如果程序在10个不同的地方调用了同一个内联函数，则该程序将包含该代码的10个副本。</p><p>(2)在函数声明之前加上关键字inline或者在函数定义之前加上inline。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别&quot;&gt;&lt;a href=&quot;#1、-include-lt-filename-h-gt-和-include“filename-h”有什么区别&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>诗词入门(一)</title>
    <link href="http://www.echodemo.cc/2018/03/24/%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/03/24/诗词入门(一)/</id>
    <published>2018-03-24T15:52:33.000Z</published>
    <updated>2018-03-29T07:24:51.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、格律"><a href="#1、格律" class="headerlink" title="1、格律"></a>1、格律</h2><p>(1)平仄:单个汉字发音的音调</p><p>a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平。四声当中平声属于平仄当中的平声,而另外三声上、去、入则属于平仄中的仄声。</p><p><img src="/images/2018/3/1.jpg" alt="&quot;平仄&quot;"></p><p>b、古代汉语的四声和今天普通话的声调种类不完全相同。上图中的黑色线条对古代汉语四声和现代汉语四声的连接是比较容易区分的：平声分为阴平和阳平，其中阴平对应现代汉语中的第一声，而阳平则对应现代汉语中的第二声；属于仄声的上声对应现代汉语中的第三声；属于仄声的去声则对应现代汉语中的第四声。</p><p>c、上图中用灰色线条连接起来的有关属于仄声的入声的演化是学习近体诗中平仄最让人费解的了。虽然现代江浙、福建、广东、广西、湖南和江西等处都还保存着入声，北方也有不少地方保存着入声这一个调类。但在普通话当中，入声字已经不复存在了。而是分别演化派进了现代汉语中的一、二、三、四声中去(也就是派进了古代汉语中的平、上、去三声当中，也称之为‘入派三声’)。当然对于演化成现代汉语中的三、四声的字我们无需担心(因为三、四声所对应的上声和去声本就是属于古代汉语中的仄声)，所以令我们困惑的就只是演化成现代汉语中一、二声的入声字(即入声演化为平声的情况)。而这一困惑是需要依靠查字典或者韵书才能消除的(当然如果你非常幸运地发现自己的方言就能辨别入声字，那你就一个人自己偷着乐吧)。这里素师推荐使用龙榆生的《唐宋词格律》。</p><p>d、这里引用大家耳熟能详的柳宗元的《江雪》作为例子来说明入派三声</p><pre><code>《江雪》柳宗元千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。这里的绝(jue)、雪(xue)、灭(mie)都是入声字，分别演化派入于平、上、去三声当中。</code></pre><p>e、古仄今平、古平今仄和可平可仄。</p><pre><code>古仄今平：就是上面提到过的入声派入平声。例：黑、白、竹、屋、绝、笛。。。古平今仄：俱(ju第一声)、论(lun第二声)语可平可仄：看;听;骑(qi)马(平)、一骑(ji)红尘妃子笑(仄)*素师说，在读近体诗的时候要么用方言，要么用普通话。不要四不像。</code></pre><p>(2)韵律:诗从平水韵，词从词林正韵。不可用中华新韵(完全丢弃了入声的概念)，中原音韵。</p><h2 id="2、体式"><a href="#2、体式" class="headerlink" title="2、体式"></a>2、体式</h2><p>(1)诗体</p><p><img src="/images/2018/3/2.jpg" alt="&quot;诗体&quot;"></p><p>一般而言，我们当下所说的古诗指的是诗体当中的古体诗。古体诗不受平仄的束缚，但是受韵的束缚(这是在沈佺期和宋之问等人在以沈约、谢眺等为代表的永明体基础上，从原来的讲求四声发展到只辨平仄，从消极的“回忌声病”发展到悟出积极的平仄规律，又由原来只讲求一句一联的音节、协调发展到全篇平仄的粘对，以及中间二联必须上下句属对，从而形成完整的律诗。规范了格律之后脱离出来的体裁)。</p><p>那诗体中的近体诗(也叫今体诗)就是我们当下学习的诗体。它不但受平仄的束缚，而且受到押韵的束缚。其中由八句组成的称之为律诗，四句组成的称之为绝句。在律诗当中又有五律(每句五个字)和七律(每句七个字)之分，相应的绝句也有五绝和七绝之分。</p><p>(2)词体</p><p><img src="/images/2018/3/3.jpg" alt="&quot;词体&quot;"></p><h2 id="3、诗律-以杜甫的登高为例"><a href="#3、诗律-以杜甫的登高为例" class="headerlink" title="3、诗律(以杜甫的登高为例)"></a>3、诗律(以杜甫的登高为例)</h2><p><img src="/images/2018/3/4.jpg" alt="&quot;登高&quot;"></p><p>上图中的竖线表示仄声，横线表示平声，三角形表示押韵。在一首诗当中有四联，分别为首联(第一、二句)、颔联(第三、四句)、颈联(第五、六句)和尾联(第七、八句)。一联的前一句称之为出句，后一句称之为对句。</p><pre><code>(1)一三五不论，二四六分明。第一、三、五字不考虑平仄，第二、四、六字平仄分明。(2)一句之内平仄相间，一联之间平仄相对(不符合即为：失对)，两联之间平仄相粘(上一联对句和下一联出句的平仄一致。不符合即为：失粘)(3)首句可入韵可不入韵(4)不入韵的句末必为仄*三平尾和三仄尾是大忌(此时的五须论，五律和七律皆如此)*平起还是仄起看的是首联出句的第二个字。</code></pre><h2 id="4、作业"><a href="#4、作业" class="headerlink" title="4、作业"></a>4、作业</h2><pre><code>(1)在唐诗三百首当中找出一首诗：平起首句不入韵的七言律诗，抄写一遍标注平仄、押韵。(2)预习拗救</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、格律&quot;&gt;&lt;a href=&quot;#1、格律&quot; class=&quot;headerlink&quot; title=&quot;1、格律&quot;&gt;&lt;/a&gt;1、格律&lt;/h2&gt;&lt;p&gt;(1)平仄:单个汉字发音的音调&lt;/p&gt;
&lt;p&gt;a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>论文参考文献标准格式要求</title>
    <link href="http://www.echodemo.cc/2018/03/24/%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82/"/>
    <id>http://www.echodemo.cc/2018/03/24/论文参考文献标准格式要求/</id>
    <published>2018-03-24T07:50:23.000Z</published>
    <updated>2018-03-25T05:14:53.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、参考文献的分类"><a href="#1、参考文献的分类" class="headerlink" title="1、参考文献的分类"></a>1、参考文献的分类</h2><p>按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类:</p><pre><code>(1)引文文献是著者在撰写或编辑论著的过程中,为正文中的直接引语(如数据、公式、理论、观点、图表等)或间接引语而提供的有关文献信息资源。(2)阅读型文献是著者在撰写或编辑论著的过程中,曾经阅读过的文献信息资源。(3)推荐型文献通常是专家或教师为特定读者、特定目的而提供的、可供读者查阅的文献信息资源。</code></pre><h2 id="2、文献类型和标识代码"><a href="#2、文献类型和标识代码" class="headerlink" title="2、文献类型和标识代码"></a>2、文献类型和标识代码</h2><p>参考文献目前共有16个文献类型和标识代码:普通图书M,会议录C,汇编G,报纸N,期刊J,学位论文D,报告R,标准S,专利P,数据库DB,计算机程序CP,电子公告EB,档案A,舆图CM,数据集DS,其他Z.凡无法归属于前15个类型的文献,均可以用Z来标志。</p><h2 id="3、参考文献格式要求"><a href="#3、参考文献格式要求" class="headerlink" title="3、参考文献格式要求"></a>3、参考文献格式要求</h2><p>1、参考文献按正文部分标注的序号依次列出,并在序号中加[]。</p><p>2、对于常见的各类参考文献标注方法如下:</p><pre><code>(1)著作:作者姓名,题名[M].出版地:出版者,出版年.(2)期刊论文:作者姓名.题名[J].期刊名称,年,卷(期):页码.(3)会议论文集:作者姓名.题名[C]//论文集名称,会议地点,会议日期.(4)学位论文:作者姓名.题名[D].出版地:出版者,出版年.(5)专利文献:专利申请者或所有者姓名.专利题名:专利国别,专利号[P].公告日期或公开日期.获取路径.(6)电子文献:作者姓名.题名[文献类型标志(含文献载体标志)见其它].出版地:出版者,出版年(更新或修改日期),获取路径.(7)报告:作者姓名. 题名[R].出版地:出版者,出版年.(8)标准:标准号.题名[S].出版地:出版者,出版年.</code></pre><p>3、同一著作中作者姓名不超过3名时,全部照录,超过3名时,只著录前3名作者,其后加“, 等”。</p><p>4、其他:数据库(DB),计算机程序(GP),光盘(CD),联机网络(OL)。</p><h2 id="4、参考文献著录格式"><a href="#4、参考文献著录格式" class="headerlink" title="4、参考文献著录格式"></a>4、参考文献著录格式</h2><p>参考文献按在正文中出现的先后次序列表于文后;表上以“参考文献:” (左顶格) 或“[参考文献]”(居中)作为标识;参考文献的序号左顶格,并用数字加方括号表示,如[1], [2],…,以与正文中的指示序号格式一致. 参照ISO690及ISO 6 9 0-2,每一参考文献条目的最后均以结束. 各类参考文献条目的编排格式及示例如下:</p><p>a.专著、论文集、学位论文、报告</p><pre><code>[序号]主要责任者. 文献题名[文献类型标识].出版地:出版者,出版年.[1]刘国钧,陈绍业,王凤者. 图书馆目录[M].北京:高等教育出版社,1957.[2]辛希孟. 信息技术与信息服务国际研讨会论文集:A集[C].北京:中国社会科学出版社,1994.[3]张筑生. 微分半动力系统的不变集[D].北京:北京大学数学系数学研究所,1983.[4]冯西桥. 核反应堆压力管道与压力容器的LBB分析[R].北京:清华大学核能技术设计研究院,1997.[5]尼葛洛庞帝. 数字化生存[M].胡泳,范海燕,译. 海口:海南出版社,19%.</code></pre><p>b.期刊文章</p><pre><code>[序号]主要责任者. 文献题名[J].刊名,年,卷 (期) :起止页码.[5]何龄修. 读顾城《南明史》[J].中国史研究,1998, (3) :167-173.[6]金显贺,王昌长,王忠东,等·一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版) , 1993, 33 (4) :62-67.</code></pre><p>c.论文集中的析出文献</p><pre><code>[序号]析出文献主要责任者. 析出文献题名[A].原文献主要责任者 (任选}.原文献题名[C].出版地:出版者,出版年. 析出文献起止页码.[7]钟文发·非线性规划在可燃毒物配置中的应用[A].赵玮. 运筹学的理论与应用-中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996.468-471.</code></pre><p>d.报纸文章</p><pre><code>[序号]主要责任者. 文献题名[N].报纸名,出版日期 (版次) .[8]谢希德. 创造学习的新思路[N].人民日报,1998-12-25 (10) .</code></pre><p>e.国际、国家标准</p><pre><code>[序号]标准编号,标准名称[S].[9]GB/T 16159-1996, 汉语拼音正词法基本规则[S].</code></pre><p>f.专利</p><pre><code>[序号]专利所有者,专利题名[P].专利国别:专利号,出版日期.[10]姜锡洲. 一种温热外敷药制备方案[P].中国专利:881056073, 1989-07-26.</code></pre><p>g.电子文献</p><pre><code>[序号]主要责任者. 电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址,发表或更新日期/引用曰期 (任选) .[11]学术堂. 论文参考文献标准格式要求[EB/OL].http://www.lunwenstudy.com/cankaowenxian/130239.html.2018-03-14.[12]万锦堃. 中国大学学报论文文摘 (1983-1993) .英文版[D B/C D].北京:中国大百科全书出版社,19%.</code></pre><p>h.各种未定义类型的文献</p><pre><code>[序号]主要责任者. 文献题名[Z].出版地:出版者,出版年.</code></pre><h2 id="5、文内参考文献标注格式"><a href="#5、文内参考文献标注格式" class="headerlink" title="5、文内参考文献标注格式"></a>5、文内参考文献标注格式</h2><p>文内所列参考文献应限于作者直接阅读过的、最主要的、且为发表在正式出版物上的文章.私人通信和未发表 (含待发表) 的著作及论文,一般不宜作为参考文献. 参考文献还应注重权威性和时效性.文内标注参考文献时应按文献出现的先后顺序用阿拉伯数字连续编码,并将序号置于方括号中.可根据具体情况分别按下述3种格式之一标注.</p><pre><code>(1) 文中已标明原始文献作者姓名时,序号标注于作者姓名右上角.　　　　例如：Vairaktaris等[7]研究表明,MMP-9-1562C/T基因多态性与口腔癌关系密切.　　(2) 正文未标明作者或非原始文献作者时,序号标注于引用内容的句末.　　　　例如：……在中枢神经系统中具有保护神经的作用,减少缺氧、缺血对动物脑神经元的损害[1].　　(3) 正文直接述及文献序号时则将之作为语句的组成部分时不用角码标注.　　　　例如：肱动脉超声检查的方法见文献[2].　　</code></pre><p>　　<br>文中多次引用同一参考文献,只在第一次出现时编排序号 (在参考文献表中也只出现一次) , 其他处使用同一序号；如果多次引用的是同一参考文献的不同页的内容,则应参考文献表中按引用顺序一一列出页码.若某一问题使用了多篇文献说明,这时将各文献的序号在一个方括号内全部列出,中间加逗号,若遇连续序号,则在起止序号中间加“-”表示.如：……组织型RAS激活也成为心肌肥厚、心肌纤维化、心腔扩大、心力衰竭的主要因素[1,3,9-10].　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、参考文献的分类&quot;&gt;&lt;a href=&quot;#1、参考文献的分类&quot; class=&quot;headerlink&quot; title=&quot;1、参考文献的分类&quot;&gt;&lt;/a&gt;1、参考文献的分类&lt;/h2&gt;&lt;p&gt;按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类:&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="参考文献" scheme="http://www.echodemo.cc/tags/%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE/"/>
    
  </entry>
  
  <entry>
    <title>C++中的成员变量、全局变量和局部变量</title>
    <link href="http://www.echodemo.cc/2018/03/22/C++%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <id>http://www.echodemo.cc/2018/03/22/C++中的成员变量和全局变量和局部变量/</id>
    <published>2018-03-22T11:56:53.000Z</published>
    <updated>2018-03-29T01:58:38.134Z</updated>
    
    <content type="html"><![CDATA[<p>1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。</p><pre><code>注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。存储:堆(当前对象对应的堆的存储空间中)存储在堆中的数据,不会被自动释放,只能程序员手动释放。</code></pre><p>2、全局变量:写在函数和大括号外部的变量,称之为全局变量。</p><pre><code>作用域:从定义的那一行开始,一直到文件末尾。全局变量可以先定义再初始化,也可以定义的同时初始化。存储:静态区。程序一启动就会分配存储空间,直到程序结束才会释放。</code></pre><p>3、局部变量:写在函数或者代码块中的变量,称之为局部变量。</p><pre><code>作用域:从定义的那一行开始,一直到遇到大括号或者return。局部变量可以先定义再初始化,也可以定义的同时初始化。存储:栈。存储在栈中的数据有一个特点,系统会自动给我们释放。</code></pre><p>*全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</p><p>*非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。另外，静态全局变量只初使化一次，防止在其他文件单元中被引用。</p><p>*局部变量和静态局部变量的区别在于它们的存储方式不同，前者存储在栈当中，而后者存储在静态区当中。</p><p>*静态函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。类中的非静态函数默认是有this指针的，表明为该类的对象所有，静态函数不属于任何类的对象，没有this指针，由类直接调用。也就是说全局函数，静态函数都不能使用this。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。

存储:堆(当前对象对应的堆的存储空间中)存储在堆
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
</feed>
