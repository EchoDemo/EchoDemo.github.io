<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-05-06T02:52:38.715Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>立夏</title>
    <link href="http://www.echodemo.cc/2018/05/05/%E7%AB%8B%E5%A4%8F/"/>
    <id>http://www.echodemo.cc/2018/05/05/立夏/</id>
    <published>2018-05-05T02:40:20.000Z</published>
    <updated>2018-05-06T02:52:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚结束了于自己而言的一段旅程。立夏时节，早起，奔赴图书馆。昨夜有雨，地面湿漉，焕发着生机与活力的植被上布满了晶莹的水珠。门还未开，来到湖边的石椅上独坐，背单词。空气清新，雾气弥漫，晨光柔和，适合摄影的光线和境地。清脆的鸟鸣不断，偶尔会有鱼儿跃出水面，打破水面的平静，想起杜甫的那句“细雨鱼儿出，微风燕子斜”。上午在图书馆自习，写毕业的论文。倦了就去长廊里休憩，在长廊里听程璧的《你们》，吹凉爽的风，看楼下的景。今日的风稍大很特别，吹得整个人都倍感放松和惬意，这或许是春夏之交的礼赠。楼下已经有人开始拍摄毕业照，穿着一致的服装，为大学四年的相遇和时光留下最后一点珍贵的记忆。长廊的另一头望见的是晨梦亭、荷塘、郁郁葱葱的树木之中的小道还有很难觉察到的的小溪。想必此时的荷叶已经开始酝酿它的繁华时期了，山坡上的那棵桑树还有桑葚挂在枝头吗？这一载睡莲的长势会不会向迅猛方向发展从而占领更多的领地？想着在离去之前是一定要再去见它们一面的，与它们作别也与自己作别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;刚刚结束了于自己而言的一段旅程。立夏时节，早起，奔赴图书馆。昨夜有雨，地面湿漉，焕发着生机与活力的植被上布满了晶莹的水珠。门还未开，来到湖边的石椅上独坐，背单词。空气清新，雾气弥漫，晨光柔和
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1022 D进制的A+B</title>
    <link href="http://www.echodemo.cc/2018/05/01/PAT-B1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A+B/"/>
    <id>http://www.echodemo.cc/2018/05/01/PAT-B1022-D进制的A+B/</id>
    <published>2018-05-01T09:02:03.000Z</published>
    <updated>2018-05-01T09:03:51.378Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。</p><p>输入格式：输入在一行中依次给出3个整数A、B和D。</p><p>输出格式：输出A+B的D进制数。</p><pre><code>输入样例：123 456 8输出样例：1103</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入两个非负10进制整数A和B(&amp;lt;=230-1)，输出A+B的D (1 &amp;lt; D &amp;lt;= 10)进制数。&lt;/p&gt;
&lt;p&gt;输入格式：输入在一行中依次给出3个整数A、B和D。&lt;/p&gt;
&lt;p&gt;输出格式：输出A+B的D进制数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入样例：
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1021 个位数统计</title>
    <link href="http://www.echodemo.cc/2018/05/01/PAT-B1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    <id>http://www.echodemo.cc/2018/05/01/PAT-B1021-个位数统计/</id>
    <published>2018-05-01T08:45:19.000Z</published>
    <updated>2018-05-01T09:01:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个k位整数N = dk-1<em>10^k-1 + … + d1</em>10^1 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。</p><p>输入格式：每个输入包含1个测试用例，即一个不超过1000位的正整数N。</p><p>输出格式：对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。</p><pre><code>输入样例：100311输出样例：0:21:33:1</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  string s;  cin &gt;&gt; s;  int a[10] = { 0 };  for (int i = 0;i &lt; s.size();i++) {    int n = s[i] - &apos;0&apos;;    a[n]++;  }  for (int i = 0;i &lt; 10;i++) {    if (a[i] &gt; 0)      cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; a[i] &lt;&lt; endl;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个k位整数N = dk-1&lt;em&gt;10^k-1 + … + d1&lt;/em&gt;10^1 + d0 (0&amp;lt;=di&amp;lt;=9, i=0,…,k-1, dk-1&amp;gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1020 月饼</title>
    <link href="http://www.echodemo.cc/2018/04/30/PAT-B1020-%E6%9C%88%E9%A5%BC/"/>
    <id>http://www.echodemo.cc/2018/04/30/PAT-B1020-月饼/</id>
    <published>2018-04-30T12:31:21.000Z</published>
    <updated>2018-04-30T14:18:47.523Z</updated>
    
    <content type="html"><![CDATA[<p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><p>输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><p>输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。</p><pre><code>输入样例：3 2018 15 1075 72 45输出样例：94.50</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct mooncake {  int store;//库存量  int total;//总售价  double price;//单价};bool cmp(mooncake a, mooncake b) {  return a.price &gt; b.price;}int main() {  int N, D;  cin &gt;&gt; N &gt;&gt; D;  vector&lt;mooncake&gt; m(N);  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; m[i].store;  }  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; m[i].total;    m[i].price = (1.0*m[i].total) / m[i].store;  }  sort(m.begin(), m.end(), cmp);  double sum = 0;  for (int i = 0;i &lt; N;i++) {    if (D &lt; m[i].store) {      sum += ((D*1.0) / m[i].store)*m[i].total;      break;    }    else {      sum += m[i].total;      D -= m[i].store;    }  }  printf(&quot;%.2f&quot;, sum);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;/p&gt;
&lt;p&gt;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1019 数字黑洞</title>
    <link href="http://www.echodemo.cc/2018/04/30/PAT-B1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/"/>
    <id>http://www.echodemo.cc/2018/04/30/PAT-B1019-数字黑洞/</id>
    <published>2018-04-30T10:17:27.000Z</published>
    <updated>2018-04-30T12:28:24.785Z</updated>
    
    <content type="html"><![CDATA[<p>给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。</p><p>例如，我们从6767开始，将得到</p><pre><code>7766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ...</code></pre><p>现给定任意4位正整数，请编写程序演示到达黑洞的过程。</p><p>输入格式：输入给出一个(0, 10000)区间内的正整数N。</p><p>输出格式：如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。</p><pre><code>输入样例1：6767输出样例1：7766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174输入样例2：2222输出样例2：2222 - 2222 = 0000</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int transfer(string s) {  int sum = 0;  for (int i = 0;i &lt; 4;i++) {    sum = sum * 10 + s[i] - &apos;0&apos;;  }  return sum;}bool cmp(char a,char b) {  return a &gt; b;}int main() {  int M;  string N, X, Y;  cin &gt;&gt; M;  N = to_string(M);  N.insert(0, 4 - N.length(), &apos;0&apos;);  while (N != &quot;6174&quot;) {    sort(N.begin(), N.end());//递增排序    X = N;    sort(N.begin(), N.end(), cmp);//递减排序    Y = N;    if (X == Y) {      cout &lt;&lt; N &lt;&lt; &quot; - &quot; &lt;&lt; N &lt;&lt; &quot; = 0000&quot; &lt;&lt; endl;      N = &quot;6174&quot;;    }    else {      N = to_string(transfer(Y) - transfer(X));      N.insert(0, 4 - N.length(), &apos;0&apos;);      cout &lt;&lt; Y &lt;&lt; &quot; - &quot; &lt;&lt; X &lt;&lt; &quot; = &quot; &lt;&lt; N &lt;&lt; endl;    }  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。&lt;/p&gt;
&lt;p&gt;例如，我们从67
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1018 锤子剪刀布</title>
    <link href="http://www.echodemo.cc/2018/04/30/PAT-B1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/"/>
    <id>http://www.echodemo.cc/2018/04/30/PAT-B1018-锤子剪刀布/</id>
    <published>2018-04-30T06:29:35.000Z</published>
    <updated>2018-04-30T10:15:45.169Z</updated>
    
    <content type="html"><![CDATA[<p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p><p><img src="/images/2018/4/3.jpg" alt="&quot;锤子剪刀布&quot;"></p><p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p><p>输入格式：输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p><p>输出格式：输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p><pre><code>输入样例：10C JJ BC BB BB CC CC BJ BB CJ J输出样例：5 3 22 3 5B B</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {  int N, x = 0, y = 0, z = 0, jia[3] = { 0 }, yi[3] = { 0 };  char a, b, c[4] = { &apos;B&apos;,&apos;C&apos;,&apos;J&apos; };  cin &gt;&gt; N;  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; a &gt;&gt; b;    if (a == &apos;B&apos;) {      if (b == &apos;B&apos;) y++;      else if (b == &apos;C&apos;) {        x++;        jia[0]++;      }      else {        z++;        yi[2]++;      }    }    else if (a == &apos;C&apos;) {      if (b == &apos;B&apos;) {        z++;        yi[0]++;      }      else if (b == &apos;C&apos;) y++;      else {        x++;        jia[1]++;      }    }    else {      if (b == &apos;B&apos;) {        x++;        jia[2]++;      }      else if (b == &apos;C&apos;) {        z++;        yi[1]++;      }      else y++;    }  }  cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;  cout &lt;&lt; z &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl;  int max1 = jia[0], max2 = yi[0], m = 0, n = 0;  for (int i = 1;i &lt; 3;i++) {    if (jia[i] &gt; max1) {      max1 = jia[i];      m = i;    }    if (yi[i] &gt; max2) {      max2 = yi[i];      n = i;    }  }  cout &lt;&lt; c[m] &lt;&lt; &quot; &quot; &lt;&lt; c[n];  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/4/3.jpg&quot; alt=&quot;&amp;quot;锤子剪刀布&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/30/操作系统问题整理/</id>
    <published>2018-04-30T05:53:52.000Z</published>
    <updated>2018-04-30T05:56:04.927Z</updated>
    
    <content type="html"><![CDATA[<p>1、进程和线程</p><p>(1)线程是独立调度的基本单位，进程是拥有资源的基本单位。线程不拥有资源(减小了时空开销)。</p><p>(2)一个进程中可以包括多个线程，并且线程共享整个进程的资源(一般都要进行同步和互斥)，一个进程至少包括一个线程。进程内的线程对于其他进程不可见。</p><p>(3)引入进程的目的是为了更好地使用多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程度。引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>(4)进程间的通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以直接读/写进程数据段来进行通信。</p><p>2、线程同步的几种方式</p><p>(1)临界区(CCriticalSection):当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。</p><p>(2)互斥量(CMutex):互斥量与临界区的行为完全相同，但是也有一定的区别：互斥量是内核对象，临界区是用户模式下的同步对象，执行速度快于内核对象。</p><p>(3)事件(CEvent):通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</p><p>(4)信号量(CSemphore):它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目</p><p>3、进程间通信(IPC)</p><p>(1)共享存储：在通信的进程间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程间的通信。(常用到PV操作来进行同步和互斥)</p><p>(3)消息传递：进程通过系统提供的发送消息和接受消息两个原语进行数据交换。(有直接通信方式和间接通信方式)</p><p>(3)管道通信(通常指无名管道)是一种半双工的通信方式。它是指用于连接一个读进程和一个写进程以实现他们之间通信的共享文件。</p><p>4、缓冲区溢出</p><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。会产生以下危害：程序崩溃，导致拒绝额服务；跳转并且执行一段恶意代码。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><p>5、死锁</p><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的四个条件如下(有一个条件不成立，则不会产生死锁)</p><pre><code>(1)互斥条件：一个资源一次只能被一个进程使用。(2)请求与保持条件：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源被其他进程占用。(3)不剥夺条件：进程获得的资源，在未使用完之前，不能被强行剥夺，只能主动释放。(4)循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。</code></pre><p>解决死锁的基本方法:</p><p>(1)预防死锁：资源一次性分配(破坏请求和保持条件)；可剥夺资源，即当某进程新的资源未满足时，释放已占有的资源(破坏不可剥夺条件)；资源有序分配法，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反(破坏环路等待条件)</p><p>(2)避免死锁:系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p><p>(3)检测死锁:这种方法无须事先采取任何限性制措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。</p><p>(4)解除死锁:当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><p>6、进程的几种状态</p><pre><code>(1)就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源。(2)运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数。(3)阻塞状态： 进程等待某种条件，在条件满足之前无法执行。</code></pre><p>7、动态分区算法</p><p>(1)首次适应算法(FF):空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。该算法优先利用内存中低址空间，保留了高址空间，缺点是低址部分不断被划分，留下许多内存碎片。</p><p>(2)循环首次适应算法(NF):NF算法每次从上一次分配的地方继续分配，该算法需要一个起始查询的指针用于指示下一次查询的空间地址。缺点是：缺乏大的空间分区。</p><p>(3)最佳适应算法(BF):空闲分区以容量递增形成分区链，找到第一个能满足要求的空闲分区。缺点是：留下许多内存碎片。</p><p>(4)最坏适应算法(WF):空闲分区以容量递减形成分区链,找到第一个能满足要求的空闲分区。即总是挑选最大的空闲区域分配给作业使用。优点是不至于使空闲区间太小，产生碎片的可能性小，缺点是：缺乏大的空间分区</p><p>8、分页和分段的区别</p><pre><code>(1)都采用离散分配方式，且都是通过地址映射机构来实现地址的转换。(2)分页管理不会产生外部碎片，但产生内部碎片；分段管理不会产生内部碎片。(3)页的大小固定且由系统决定，在采用分页存储管理方式中直接由硬件实现。而段的大小不固定，决定于用户所编写的程序。(4)分页的地址空间是一维的，分段系统中是二维的。</code></pre><p>9、虚拟存储器页面置换算法</p><p>(1)最佳置换算法(Optimal):淘汰的页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p><p>(2)先进先出算法(FIFO):总是最先淘汰最先进去的页面。缺点：通常程序调入内存的先后顺序和程序执行的先后顺序不一致，导致缺页率高。</p><p>(3)最近最久未使用(LEU):选择最近最长时间未访问过的页面予以淘汰。</p><p>(4)时钟置换算法(LFU):在每个页面设置一个移位寄存器记录该页面的访问频率，最近时期最少使用的页面被淘汰。</p><p>10、调度算法</p><p>(1)先来先服务调度算法(FCFS):每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它。</p><p>(2)短作业优先调度算法(SJF):对短作业(运行时间最短)优先调度的算法。</p><p>(3)优先级调度算法:每次从后备作业中选择优先级最高的作业，将其调入内存，分配必要的资源。</p><p>(4)高响应比优先调度算法:在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p><p>(5)时间片轮转调度算法:将系统中所有就绪进程按照先来先服务的原则，但仅能运行一个时间片。</p><p>(6)多级反馈队列调度算法(集合了前几种算法的优点):是时间片轮转调度算法和优先级调度算法的综合和发展。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、进程和线程&lt;/p&gt;
&lt;p&gt;(1)线程是独立调度的基本单位，进程是拥有资源的基本单位。线程不拥有资源(减小了时空开销)。&lt;/p&gt;
&lt;p&gt;(2)一个进程中可以包括多个线程，并且线程共享整个进程的资源(一般都要进行同步和互斥)，一个进程至少包括一个线程。进程内的线程对于其他进
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="操作系统" scheme="http://www.echodemo.cc/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/30/计算机网络问题整理/</id>
    <published>2018-04-30T05:52:09.000Z</published>
    <updated>2018-04-30T05:53:19.877Z</updated>
    
    <content type="html"><![CDATA[<p>1、TCP连接时，为什么要进行三次握手</p><p>client发出的一个连接请求报文段在某个网络节点长时间滞留，以致于延误到连接释放以后才到达server。本来是一个早已失效的报文段，但server误认为是client发出的新的连接请求。于是就向client发送确认报文段，同意建立连接。如果不采取三次握手，那么只要server发出确认，新的连接就建立了。但由于client实际上并没有发出连接请求，因此不予理睬server的确认，也不会向server发送确认。但server却认为连接已经建立，并一直等待client发来数据。造成server资源的浪费。</p><pre><code>A：“喂，你听得到吗？”。B：“我听得到呀，你听得到我吗？”(应答和请求同时发出)。C：我能听得到你，balabala...”。</code></pre><p>2、为什么需要四次挥手</p><p>(1)当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口，就会发FIN给主机B。</p><p>(2)当主机B收到A发送的FIN，表示收到了，就会发送ACK回复A。</p><p>(3)但此时B可能还在发送数据，没有想要关闭数据口，所以B的FIN和回复A的ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。</p><p>(4)A收到B发来的FIN，知道B的数据也发送完了，回复ACK。A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭连接，B也关闭了连接。</p><pre><code>A：“喂，我不说了”。B：“我知道了。等一下，我还没说完。Balabala...”。B：“好了，我说完了，我也不说了”。A：“我知道了”。</code></pre><p>client发出最后的ACK回复可能会丢失。server如果没有收到ACK，将不断重复发送FIN片段。所以client不能立即关闭，他必须确认server收到了该ACK。client会在发出ACK之后进入到TIME_Wait状态。同时设置一个计时器，等待2MSL(MSL指一个片段在网络中最大的存活时间)的时间。如果在该段时间内收到FIN，那么需要重发ACK。如果没有再次收到ACK，client就认为server已经收到ACK，结束TCP连接。</p><p>3、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、TCP连接时，为什么要进行三次握手&lt;/p&gt;
&lt;p&gt;client发出的一个连接请求报文段在某个网络节点长时间滞留，以致于延误到连接释放以后才到达server。本来是一个早已失效的报文段，但server误认为是client发出的新的连接请求。于是就向client发送确认报文
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机网络" scheme="http://www.echodemo.cc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1017 A除以B</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1017-A%E9%99%A4%E4%BB%A5B/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1017-A除以B/</id>
    <published>2018-04-29T08:38:02.000Z</published>
    <updated>2018-04-29T12:06:16.727Z</updated>
    
    <content type="html"><![CDATA[<p>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。</p><p>输入格式：输入在1行中依次给出A和B，中间以1空格分隔。</p><p>输出格式：在1行中依次输出Q和R，中间以1空格分隔。</p><pre><code>输入样例：123456789050987654321 7输出样例：17636684150141093474 3</code></pre><p>题目代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string s;    cin &gt;&gt; s;    int a;    cin &gt;&gt; a;    int len = s.length();    int t = (s[0] - &apos;0&apos;) / a;    if ((t != 0 &amp;&amp; len &gt; 1) || len == 1) {        cout &lt;&lt; t;    }    int temp = (s[0] - &apos;0&apos;) % a;    for (int i = 1; i &lt; len; i++) {        t = (temp * 10 + s[i] - &apos;0&apos;) / a;        cout &lt;&lt; t;        temp = (temp * 10 + s[i] - &apos;0&apos;) % a;    }    cout &lt;&lt; &quot; &quot; &lt;&lt; temp;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。&lt;/p&gt;
&lt;p&gt;输入格式：输入在1行中依次给出A和B，中间以1空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：在1行中依次输出Q和R，中间以1空格分隔。&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1016 部分A+B</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1016-%E9%83%A8%E5%88%86A+B/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1016-部分A+B/</id>
    <published>2018-04-29T07:55:21.000Z</published>
    <updated>2018-04-29T08:38:07.580Z</updated>
    
    <content type="html"><![CDATA[<p>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。</p><p>现给定A、DA、B、DB，请编写程序计算PA + PB。</p><p>输入格式：输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 10^10。</p><p>输出格式：在一行中输出PA + PB的值。</p><pre><code>输入样例1：3862767 6 13530293 3输出样例1：399输入样例2：3862767 1 13530293 8输出样例2：0</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int PAB(string X, int Y) {  int n = 0, sum = 0;  for (int i = 0;i &lt; X.size();i++) {    if (X[i] - &apos;0&apos; == Y) n++;  }  for (int i = 0;i &lt; n;i++) {    sum = sum * 10 + Y;  }  return sum;}int main() {  int DA, DB;  string A, B;  cin &gt;&gt; A &gt;&gt; DA &gt;&gt; B &gt;&gt; DB;  cout &lt;&lt; PAB(A, DA)+ PAB(B, DB);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。&lt;/p&gt;
&lt;p&gt;现给定A、DA、B、DB，请编写程序计算PA + PB。&lt;/p&gt;
&lt;p&gt;输入格式：输入在一
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1015 德才论</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1015-德才论/</id>
    <published>2018-04-29T02:18:19.000Z</published>
    <updated>2018-04-29T07:54:55.520Z</updated>
    
    <content type="html"><![CDATA[<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><p>输入格式：输入第1行给出3个正整数，分别为：N（&lt;=10^5），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p><p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p><p>输出格式：输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><pre><code>输入样例：14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60输出样例：1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90</code></pre><p>题目代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”&lt;/p&gt;
&lt;p&gt;现给出一批考生的德才分数，请根据司马光的理论给出录取排名。&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1014 福尔摩斯的约会</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1014-福尔摩斯的约会/</id>
    <published>2018-04-29T01:23:28.000Z</published>
    <updated>2018-04-29T07:13:49.221Z</updated>
    
    <content type="html"><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：</p><pre><code>“我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。</code></pre><p>大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p><p>输入格式：输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p><p>输出格式：在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，<br>即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，<br>SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p><pre><code>输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm输出样例：THU 14:04</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() {  string day[7] = { &quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot; };  string str1, str2, str3, str4;  cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3 &gt;&gt; str4;  int i = 0, j = 0, k = 0, n = 0;  while (i &lt; str1.size() &amp;&amp; i &lt; str2.size()) {    if ((str1[i] == str2[i]) &amp;&amp; (k == 1) &amp;&amp; ((str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;N&apos;) || (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;)))      break;    if (str1[i] == str2[i] &amp;&amp; str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;G&apos;) {      k++;      if (k == 1)        n = i;    }    i++;  }  cout &lt;&lt; day[str1[n] - &apos;A&apos;] &lt;&lt; &quot; &quot;;  if (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;) {//如果是数字    cout &lt;&lt; &quot;0&quot; &lt;&lt; str1[i] - &apos;0&apos;&lt;&lt;&quot;:&quot;;  }  else {//如果是字母    cout &lt;&lt; (9 + str1[i] - &apos;A&apos; + 1) &lt;&lt; &quot;:&quot;;  }  while (j &lt; str3.size() &amp;&amp; j &lt; str4.size()) {    if ((str3[j] == str4[j]) &amp;&amp; ((str3[j] &gt;= &apos;A&apos;&amp;&amp;str3[j] &lt;= &apos;Z&apos;) || (str3[j] &gt;= &apos;a&apos;&amp;&amp;str3[j] &lt;= &apos;z&apos;)))      break;    j++;  }  if (j &gt;= 0 &amp;&amp; j &lt;= 9)    cout &lt;&lt; &quot;0&quot; &lt;&lt; j;  else    cout &lt;&lt; j;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大侦探福尔摩斯接到一张奇怪的字条：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大侦探很快就明白了，字条上奇怪的乱
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1013 数素数</title>
    <link href="http://www.echodemo.cc/2018/04/29/PAT-B1013-%E6%95%B0%E7%B4%A0%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/04/29/PAT-B1013-数素数/</id>
    <published>2018-04-29T00:51:26.000Z</published>
    <updated>2018-04-29T02:02:36.281Z</updated>
    
    <content type="html"><![CDATA[<p>令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。</p><p>输入格式：输入在一行中给出M和N，其间以空格分隔。</p><p>输出格式：输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。</p><pre><code>输入样例：5 27输出样例：11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;bool prime(int n) {//判定是否为素数  if (n &lt;= 1) return false;  for (int i = 2;i*i &lt;= n;i++) {    if (n%i == 0) return false;  }  return true;}int main() {  int M, N, i = 2, j = 0, k = 0;  cin &gt;&gt; M &gt;&gt; N;  while (k &lt; N) {    if (prime(i)) {      k++;//统计目前是第几个素数      if (k &gt;= M) {        cout &lt;&lt; i;        j++;        if (j % 10 == 0) cout &lt;&lt; endl;        else {          if (k &lt; N) cout &lt;&lt; &quot; &quot;;        }      }      }    i++;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;令Pi表示第i个素数。现任给两个正整数M &amp;lt;= N &amp;lt;= 104，请输出PM到PN的所有素数。&lt;/p&gt;
&lt;p&gt;输入格式：输入在一行中给出M和N，其间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1012 数字分类</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1012-数字分类/</id>
    <published>2018-04-28T07:59:10.000Z</published>
    <updated>2018-04-29T00:47:03.990Z</updated>
    
    <content type="html"><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p><pre><code>A1 = 能被5整除的数字中所有偶数的和；A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；A3 = 被5除后余2的数字的个数；A4 = 被5除后余3的数字的平均数，精确到小数点后1位；A5 = 被5除后余4的数字中最大数字。</code></pre><p>输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p><p>输出格式：对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出“N”。</p><pre><code>输入样例1：13 1 2 3 4 5 6 7 8 9 10 20 16 18输出样例1：30 11 2 9.7 9输入样例2：8 1 2 4 5 6 7 9 16输出样例2：N 11 2 N 9</code></pre><p>题目代码：需要注意的是最好不要让cout和printf在同一个程序当中出现。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;math.h&gt;using namespace std;int main() {  int n;  cin &gt;&gt; n;  vector&lt;int&gt; a(n);  for (int i = 0;i &lt; n;i++) {    cin &gt;&gt; a[i];  }  int A1 = 0, A2 = 0, A3 = 0, A5 = 0, flag2 = 0, j = 0 ;  double A4 = 0.0, flag4 = 0.0;  for (int i = 0;i &lt; n;i++) {    if (a[i] % 5 == 0 &amp;&amp; a[i] % 2 == 0) A1 += a[i];    if (a[i] % 5 == 1) { A2 += (int)(pow(-1, j++)*a[i]); flag2++; }    if (a[i] % 5 == 2) A3++;    if (a[i] % 5 == 3) { A4 += a[i]; flag4++; }    if (a[i] % 5 == 4) if (a[i] &gt; A5) A5 = a[i];  }  if (A1 &gt; 0) printf(&quot;%d &quot;, A1);  else printf(&quot;N &quot;);  if (flag2 &gt; 0) printf(&quot;%d &quot;, A2);  else printf(&quot;N &quot;);  if (A3 &gt; 0) printf(&quot;%d &quot;, A3);  else printf(&quot;N &quot;);  if (A4 &gt; 0) printf(&quot;%.1f &quot;, A4 / flag4);  else printf(&quot;N &quot;);  if (A5 &gt; 0) printf(&quot;%d&quot;, A5);  else printf(&quot;N&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A1 = 能被5整除的数字中所有偶数的和；
A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；
A3 = 被5除后余2的数字的个数；
A4 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1011 A+B和C</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1011-A+B%E5%92%8CC/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1011-A+B和C/</id>
    <published>2018-04-28T07:47:36.000Z</published>
    <updated>2018-04-28T07:58:55.982Z</updated>
    
    <content type="html"><![CDATA[<p>给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。</p><p>输入格式：输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p><p>输出格式：对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p><pre><code>输入样例：41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647输出样例：Case #1: falseCase #2: trueCase #3: trueCase #4: false</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {  int n;  long long A, B, C;  cin &gt;&gt; n;  for (int i = 0;i &lt; n;i++) {    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;    if ((A + B) &gt; C) cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: true&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: false&quot; &lt;&lt; endl;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。&lt;/p&gt;
&lt;p&gt;输入格式：输入第1行给出正整数T(&amp;lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：对每组测试用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1010 一元多项式求导</title>
    <link href="http://www.echodemo.cc/2018/04/28/PAT-B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <id>http://www.echodemo.cc/2018/04/28/PAT-B1010-一元多项式求导/</id>
    <published>2018-04-28T07:20:29.000Z</published>
    <updated>2018-04-28T07:46:15.931Z</updated>
    
    <content type="html"><![CDATA[<p>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）</p><p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p><pre><code>输入样例：3 4 -5 2 6 1 -2 0输出样例：12 3 -10 1 6 0</code></pre><p>题目代码：这里设立一个flag标志位，如果指数为零并且标志位也同时为零，则说明是零多项式。</p><pre><code>#include&lt;iostream&gt;using namespace std;int main() {  int m, n, flag = 0;  while (cin &gt;&gt; m &gt;&gt; n) {    if (!flag &amp;&amp; !n) {      cout &lt;&lt; &quot;0 0&quot;;//零多项式    }    if (n) {      if (flag) cout &lt;&lt; &quot; &quot;;//不是第一组输出时，要在当前这组数据输出前加上空格。      cout &lt;&lt; m*n &lt;&lt; &quot; &quot; &lt;&lt; n - 1;      flag = 1;    }  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）&lt;/p&gt;
&lt;p&gt;输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>致临安</title>
    <link href="http://www.echodemo.cc/2018/04/28/%E8%87%B4%E4%B8%B4%E5%AE%89/"/>
    <id>http://www.echodemo.cc/2018/04/28/致临安/</id>
    <published>2018-04-28T03:03:11.000Z</published>
    <updated>2018-04-28T05:27:08.430Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;――――题记</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起临安，我会想起什么呢？虽然彼此素未谋面。但我在许嵩的《断桥残雪》里；在柳永的《望海潮》中；从“暖风熏得游人醉，直把杭州作汴州”和“小楼一夜听春雨，深巷明朝卖杏花”那里面窥见的临安城是如此地楚楚动人，惹人喜爱。曾经这样想过：选择了一座城是否就选择了一种生活的方式？后来，自己给出的答案是肯定的。因为外界环境从始至终都会或多或少地影响一个人的心情和状态。再者我想：如果可以在自己喜欢的城市里柴米油盐地生活，便是一种极大的愉悦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;喜欢一座城，可以具备一定的缘由，或许也可以不问因果。我对杭州起初的向往就像三毛之于撒哈拉一样，怀着一种非此地不居的想法，犹如冥冥之中的神秘引力，让我们彼此惺惺相（吸）。还记得多年以前《新白娘子传奇》中那断桥上的油纸伞吗？还记得杨万里的那句“接天莲叶无穷碧，映日荷花别样红”吗？这其中哪个是我第一次接触到的有关于杭州的记忆，我又是从什么时候起拥有了对杭州的执念，这些都难以追溯。但我知道是什么促进了，加强了甚至是升华了我对杭州的喜爱。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杭州自秦朝设县治以来已有2200多年的历史，曾是吴越国和南宋的都城，因风景秀丽，素有“人间天堂”的美誉。杭州之名从“秦时明月汉时关”里属会稽郡的钱唐，到东汉属吴郡的钱唐，到三国和两晋时期属吴郡但却归于古扬州的钱唐，再到后来隋朝时期“杭州”二字的首次登台，再到为避唐朝国号之讳将此“唐”改为彼“塘”。就这样等到五代十国时期一过，由于先前运河的修建，水利的兴修。杭州便迎来了在中国历史上的全盛时期，也就是宋王朝。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，正如你所看到的，上面这一大段大多都是百度百科里的东西。我所想抓住的便是其中的一个宋字。从北宋到南宋，用“钱塘自古繁华”一句来讲我想是恰当的。这些从张择端的《清明上河图》中便可见一斑。谈及北宋，作为苏子瞻这位诗词大文豪的铁杆粉丝，我想这里对他的记录是必不可少的。苏子瞻是四川眉州眉山人，凭借其清心洒脱、豪放不羁的文采征服了当时的文坛领袖欧阳修。在欧阳修的赏识之下，作为初唐宰相苏味道之后的苏子瞻，作为后来唐宋八大家苏氏一家独占三个名额的苏子瞻。顿时便名声大噪。无奈当时王安石变法如火如荼，但苏子瞻的很多师友，包括他自己在内也与王安石集团政见不和。于是遭受排挤在所难免。熙宁四年（1071年），苏子瞻上书皇帝谈论新法之弊病。遭王安石集团之不满，于是请求出京任职，被授为杭州通判。此后历经乌台诗案，被贬黄州。后因神宗驾崩，哲宗即位，高太后把持朝政（其对苏子瞻颇为赏识）。因此，从复为朝奉郎知登州（蓬莱），到以礼部郎中被召还朝，到升为起居舍人，到中书舍人，再到升翰林学士、知制诰，知礼部贡举。虽然苏子瞻一路高歌猛进，但当他发现司马光集团与原来的王安石集团不过是一丘之貉时，便再次向朝廷提出谏议，也因此再次遭受排挤。元祐四年也就是公元1089年，苏子瞻再度自求外调，任龙图阁学士、知杭州。苏子瞻这两次为官在杭州一共呆了5年，这五年我想应是他仕途当中最快乐的时光。远离了政治的中心，远离了朝局，没有了勾心斗角、尔虞我诈。有的是关心民瘼，赈济灾民，兴修水利，浚治西湖。因此也深受杭州百姓的爱戴。他也在闲暇之余，纵情山水之间，其足迹遍及西湖山水、园林、寺庙等等。留下了颇多的传说、题名、碑刻和诗词。作为诗人和词人，这无疑是一种莫大的享受。可以说苏子瞻为杭州的历史和文化底蕴增添了浓墨重彩的一笔。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起苏堤当然还有白堤，说起词人当然还有柳永，说起诗人当然还有陆游，除了北宋当然还有南宋。靖康之变后，徽钦二帝被俘，北宋沦亡，为金朝所灭。宋高宗赵构定都临安府。或许曾经的宋高宗也为临安的气质所折服才愿意在此偏安一隅吧。想起800多年前的岳鹏举怀着满腔的热血和报国之志踏上这片美丽而又繁华的土地，是否也会驻足回望，为临安的所有而惊艳。常年征战在外的他；身处军营和刀光剑影里的他；写下气势磅礴，英勇而悲壮的《满江红》的他；到头来却被奸佞所诬陷，高宗所猜忌的他。是否也曾在满月的夜里，想着能够和家人在类似于临安的城里共度余生。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对杭州的眷恋，想来与这些早已故去却一直存在的烟云有着莫大的关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;em
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1009 说反话</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1009-说反话/</id>
    <published>2018-04-26T13:09:20.000Z</published>
    <updated>2018-04-28T07:19:25.482Z</updated>
    
    <content type="html"><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p><p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p><pre><code>输入样例：Hello World Here I Come输出样例：Come I Here World Hello</code></pre><p>题目代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() {    stack&lt;string&gt; s;    string a;    while(cin &gt;&gt; a) s.push(a);    cout &lt;&lt; s.top();    s.pop();    while(!s.empty()) {        cout &lt;&lt; &quot; &quot; &lt;&lt; s.top();        s.pop();    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。&lt;/p&gt;
&lt;p&gt;输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1008 数组元素循环右移问题</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1008-数组元素循环右移问题/</id>
    <published>2018-04-26T12:55:19.000Z</published>
    <updated>2018-04-26T12:57:47.143Z</updated>
    
    <content type="html"><![CDATA[<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数,<br>之间用空格分隔。</p><p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><pre><code>输入样例：6 21 2 3 4 5 6输出样例：5 6 1 2 3 4</code></pre><p>题目代码：本题需要注意的是当移动的次数为0，为N或者大于N的特殊情况。</p><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main() {  int N, M;  cin &gt;&gt; N &gt;&gt; M;  vector&lt;int&gt; a(N);  for (int i = 0;i &lt; N;i++) {    cin &gt;&gt; a[i];  }  if (M != 0 &amp;&amp; M != N) {    if (M &gt; N) M = M%N;    reverse(a.begin(), a.begin() + N - M);//将前面的N-M位进行反转    reverse(a.begin() + N - M, a.end());//将后面的M位进行反转    reverse(a.begin(), a.end());//将整个数组进行反转  }  for (int i = 0;i &lt; N;i++) {    cout &lt;&lt; a[i];    if (i &lt; N - 1) cout &lt;&lt; &quot; &quot;;  }  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个数组A中存有N（N&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&amp;gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1007 素数对猜想</title>
    <link href="http://www.echodemo.cc/2018/04/26/PAT-B1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.echodemo.cc/2018/04/26/PAT-B1007-素数对猜想/</id>
    <published>2018-04-26T12:18:15.000Z</published>
    <updated>2018-04-26T12:18:47.987Z</updated>
    
    <content type="html"><![CDATA[<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。</p><p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p><p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p><pre><code>输入样例：20输出样例：4</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;bool isPrime(int n) {//判定是否为素数  if (n &lt;= 1) return false;  for (int i = 2;i*i &lt;= n;i++) {    if (n % i == 0) return false;  }  return true;}int main() {  int n, num = 0;  cin &gt;&gt; n;  for (int i = 5;i &lt;= n;i++) {    if (isPrime(i - 2) &amp;&amp; isPrime(i))      num++;//如果相差2的两个数均为素数，则num自增1  }  cout &lt;&lt; num;  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&amp;gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&amp;lt; 105)，请计算不超过N的满足猜想的素数对的个数。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
</feed>
