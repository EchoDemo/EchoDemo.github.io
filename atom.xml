<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-08-05T03:39:40.152Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中基于TCP协议的Socket编程</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中基于TCP协议的Socket编程/</id>
    <published>2018-08-05T03:38:19.000Z</published>
    <updated>2018-08-05T03:39:40.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Socket概述"><a href="#1、Socket概述" class="headerlink" title="1、Socket概述"></a>1、Socket概述</h3><p>(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。它是连接运行在网络上的两个程序间的双向通讯的端点。</p><p>(2)网络通讯其实指的就是socket间的通讯。通讯的两端都有socket，数据在两个socket之间通过IO来进行传输。</p><p>(3)使用socket进行网络通信的过程</p><pre><code>1、服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求。2、客户程序根据服务器程序所在的主机名和端口号发出连接请求。3、如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。4、客户和服务器通过读、写套接字进行通讯。</code></pre><h3 id="2、基于TCP协议的socket编程"><a href="#2、基于TCP协议的socket编程" class="headerlink" title="2、基于TCP协议的socket编程"></a>2、基于TCP协议的socket编程</h3><p>(1)创建TCP服务端步骤：</p><pre><code>1)创建一个ServerSocket对象2)调用accept()方法接受客户端请求3)从socket中获取IO流4)对IO流进行读写操作，完成与客户端的交互。5)关闭IO流和Socket</code></pre><p>(2)创建TCP客户端步骤：</p><pre><code>1)创建一个Socket对象2)从Socket中获取IO流3)对IO流进行读写操作，完成与服务端的交互4)关闭IO流和Socket</code></pre><p>注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。</p><p>(3)举例说明</p><p>1)服务器端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class TCPServer {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(8888);//创建一个ServerSocket对象        Socket socket = serverSocket.accept();//调用accept()方法来接受客户端的请求        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has connected!&quot;);        //获取socket对象的输入输出流        BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        String line = null;        while((line = bReader.readLine())!=null){//读取客户端传过来的数据            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(line);            /*bWriter.write(line.toUpperCase());//把转换成大写的字符串传给客户端            bWriter.newLine();//换行，这样客户端才能知道输入什么时候结束的            bWriter.flush();*/            pWriter.println(line.toUpperCase());        }        //bWriter.close();        pWriter.close();        bReader.close();        socket.close();        System.out.println(socket.getInetAddress().getHostAddress() + &quot;has disconnected!&quot;);    }}</code></pre><p>2)客户端</p><pre><code>package com.iotek.tcpsocket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class TCPClient {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));        //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true);        BufferedReader bw = new BufferedReader(new InputStreamReader(socket.getInputStream()));        while(true){            String line = bReader.readLine();//获取键盘所输入的字符串            /*bWriter.write(line);            bWriter.newLine();//换行，这样服务端才能识别一行的结束            bWriter.flush();*/            pWriter.println(line);            if(line.equals(&quot;over&quot;)){                break;            }            System.out.println(bw.readLine());//获取服务端传来的大写字符串        }        bReader.close();        bw.close();        //bWriter.close();        pWriter.close();        socket.close();    }}</code></pre><p>为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。</p><pre><code>//编译javac -d . *.java//开启服务器java com.iotek.tcpsocket.TCPServer//开启客户端，这里另外开启一个窗口java com.iotek.tcpsocket.TCPClient</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Socket概述&quot;&gt;&lt;a href=&quot;#1、Socket概述&quot; class=&quot;headerlink&quot; title=&quot;1、Socket概述&quot;&gt;&lt;/a&gt;1、Socket概述&lt;/h3&gt;&lt;p&gt;(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中网络编程基础知识和通讯要素</title>
    <link href="http://www.echodemo.cc/2018/08/05/Java%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0/"/>
    <id>http://www.echodemo.cc/2018/08/05/Java中网络编程基础知识和通讯要素/</id>
    <published>2018-08-05T02:25:36.000Z</published>
    <updated>2018-08-05T03:41:58.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、网络基础知识"><a href="#1、网络基础知识" class="headerlink" title="1、网络基础知识"></a>1、网络基础知识</h3><p>(1)计算机网络</p><p>计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能性强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。</p><p>(2)网络体系结构</p><p>网络体系结构定义计算机设备和其他设备如何连接在一起以形成一个允许用户共享信息和资源的通信系统。国际标准化组织ISO于1978年提出“开放系统互连参考模型”，即著名的OSI(Open System Interconnection)模型。OSI模型保证了各类设备生产厂家的产品兼容性。该模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>(3)TCP/IP协议</p><p>TCP/IP协议是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络接口层、网络层、传输层和应用层。</p><h3 id="2、网络通信要素"><a href="#2、网络通信要素" class="headerlink" title="2、网络通信要素"></a>2、网络通信要素</h3><p>(1)网络编程的目的</p><p>网络编程的目的就是指直接或者间接地通过网络协议与其他计算机进行通讯。网络编程中有两个主要问题，一个是如何准确的定位网络上一台或者多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。</p><p>(2)IP地址</p><p>网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。对应的类-InetAddress。</p><p>(3)端口号</p><p>端口号用来表示该计算机上的应用程序，代表此应用程序逻辑地址。端口号使用一个16位的数字来表示，它的范围是0~65535,1024以下的端口号保留给预定义的服务。例如：http使用80端口。</p><p>(4)协议</p><p>为计算机网络中进行数据交互而建立的规则、标准或约定的集合。</p><pre><code>TCP是一种面向连接的保证可靠传输的协议。UDP是一种无连接的且不可靠的传输协议。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、网络基础知识&quot;&gt;&lt;a href=&quot;#1、网络基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、网络基础知识&quot;&gt;&lt;/a&gt;1、网络基础知识&lt;/h3&gt;&lt;p&gt;(1)计算机网络&lt;/p&gt;
&lt;p&gt;计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的RandomAccessFile</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84RandomAccessFile/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的RandomAccessFile/</id>
    <published>2018-08-04T08:47:03.000Z</published>
    <updated>2018-08-04T08:47:37.658Z</updated>
    
    <content type="html"><![CDATA[<p>1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。</p><p>2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，随着对字节的写入而前移此文件指针。</p><p>3、写入该隐含数组末尾之后的输出操作导致该数组扩展。该文件指针可以通过getFilePointer方法读取，通过seek方法设置该文件指针的位置。</p><p>4、RandomAccessFile举例</p><pre><code>package com.iotek.otherio;import java.io.IOException;import java.io.RandomAccessFile;import java.util.Scanner;public class RandomAccessFileDemo {    public static void main(String[] args) throws IOException {        Person[] persons = {new Person(&quot;chenhao&quot;,90),                new Person(&quot;justin&quot;,30),new Person(&quot;bush&quot;,80),                new Person(&quot;lisi&quot;,20)};        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;f:\\test\\3.txt&quot;, &quot;rw&quot;);        /*for(int i=0;i&lt;persons.length;i++){//写入数据到RandomAccessFile这个对象中            randomAccessFile.writeChars(persons[i].getName());            randomAccessFile.writeInt(persons[i].getAge());        }*/        //读取指定位置上的Person对象        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;读取第几个Person对象数据&quot;);        int num = scanner.nextInt();        //使用seek方法来操作存取位置        randomAccessFile.seek((num-1)*Person.size());        Person person = new Person();        person.setName(readName(randomAccessFile));        person.setAge(randomAccessFile.readInt());        System.out.println(&quot;姓名:&quot;+person.getName());        System.out.println(&quot;年龄:&quot;+person.getAge());        randomAccessFile.close();    }    private static String readName(RandomAccessFile randomAccessFile) throws IOException{        char[] name = new char[15];        for(int i=0;i&lt;name.length;i++){            name[i] = randomAccessFile.readChar();         }        return new String(name).replace(&apos;\u0000&apos;, &apos; &apos;);    }}class Person{    private String name;    private int age;    public Person(){    }    public Person(String name, int age) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        StringBuilder builder = null;        if(name!=null){            builder = new StringBuilder(name);        }else{            builder = new StringBuilder(15);        }        builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos;        this.name = builder.toString();    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //每个对象所占的字节数    public static int size(){        return 34;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。&lt;/p&gt;
&lt;p&gt;2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中其他的IO流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84IO%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中其他的IO流/</id>
    <published>2018-08-04T07:45:54.000Z</published>
    <updated>2018-08-04T07:46:30.419Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、ObjectInputStream和ObjectOutputStream"><a href="#1、ObjectInputStream和ObjectOutputStream" class="headerlink" title="1、ObjectInputStream和ObjectOutputStream"></a>1、ObjectInputStream和ObjectOutputStream</h3><p>ObjectInputStream和ObjectOutputStream分别与FileInputStream和FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。我们把对象以某种特定的编码格式写入称之为“序列化”。把写入的编码格式内容还原成对象称之为“反序列化”。被序列化的对象必须实现Serializable接口。</p><pre><code>package com.iotek.otherio;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectInputOutputDemo {    public static void main(String[] args) throws IOException {        /*Student student = new Student(&quot;zhangsan&quot;, 30);        FileOutputStream fos = new FileOutputStream(&quot;f:\\test\\1.txt&quot;);        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos);        objectOutputStream.writeObject(student);//把对象序列化到指定的文件输出流中        objectOutputStream.close();//释放资源*/            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;f:\\test\\1.txt&quot;));        try {            Student student = (Student)objectInputStream.readObject();            System.out.println(student);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class Student implements Serializable{//需要实现Serializable接口    private static final long serialVersionUID = 1L;    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="2、InputStreamReader和OutputStreamWriter"><a href="#2、InputStreamReader和OutputStreamWriter" class="headerlink" title="2、InputStreamReader和OutputStreamWriter"></a>2、InputStreamReader和OutputStreamWriter</h3><p>转换流是指将字节流与字符流之间进行转换。转换流的出现方便了对文件的读写，它在字符流与字节流之间架起了一座桥梁，使原本毫无关联的两种操作能够进行转化，提高了程序的灵活性。字节流中的数据都是字符时，转化成字符流操作更高效。如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式的参数，而FileReader与FileWriter是默认编码的文本文件。</p><pre><code>package com.iotek.otherio;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class InputStreamWriterReaderDemo {    public static void main(String[] args) throws IOException {        /*OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;f:\\test\\2.txt&quot;), &quot;utf-8&quot;);        BufferedWriter bw = new BufferedWriter(osw);        bw.write(&quot;您好&quot;);        bw.close();*/        /*BufferedReader br = new BufferedReader(new FileReader(&quot;f:\\test\\2.txt&quot;));        String line = null;        while((line = br.readLine())!=null){            System.out.println(line);        }        br.close();*/        BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;f:\\test\\2.txt&quot;),&quot;utf-8&quot;));        String line = null;        while((line = bReader.readLine())!=null){            System.out.println(line);        }        bReader.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、ObjectInputStream和ObjectOutputStream&quot;&gt;&lt;a href=&quot;#1、ObjectInputStream和ObjectOutputStream&quot; class=&quot;headerlink&quot; title=&quot;1、ObjectInputStr
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的字符流</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中的字符流/</id>
    <published>2018-08-04T06:03:29.000Z</published>
    <updated>2018-08-04T06:32:10.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Reader和Writer抽象类"><a href="#1、Reader和Writer抽象类" class="headerlink" title="1、Reader和Writer抽象类"></a>1、Reader和Writer抽象类</h3><p>字节流提供处理任何类型输入输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。字符流层次结构的顶层是Reader和Writer抽象类，它们的顶层仍然是字节流。Reader是定义Java的流式字符输入模式的抽象类。Reader抽象类中的方法和InputStream类似。Writer是定义Java的流式字符输出模式的抽象类。该类的方法都返回void值并在出错条件下抛IOException异常。Writer抽象类中的方法和OutputStream类似。</p><h3 id="2、FileReader和FileWriter"><a href="#2、FileReader和FileWriter" class="headerlink" title="2、FileReader和FileWriter"></a>2、FileReader和FileWriter</h3><p>FileReader类表示可以读取文件内容的Reader类，构造方法有：</p><pre><code>FileReader(String filePath)FileReader(File fileObj)</code></pre><p>FileWriter表示可以写文件的Writer类，构造方法有：</p><pre><code>FileWriter(String filePath)FileWriter(String filePath,boolean append)FileWriter(File fileObj)</code></pre><h3 id="3、FileReader和FileWriter举例"><a href="#3、FileReader和FileWriter举例" class="headerlink" title="3、FileReader和FileWriter举例"></a>3、FileReader和FileWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        char[] buffer = new char[100];        FileWriter fWriter = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        int len = 0;//实际读到的字符个数        while((len = fr.read(buffer))!=-1){            fWriter.write(buffer,0,len);        }        fr.close();        fWriter.close();    }}</code></pre><h3 id="4、BufferedReader和BufferedWriter"><a href="#4、BufferedReader和BufferedWriter" class="headerlink" title="4、BufferedReader和BufferedWriter"></a>4、BufferedReader和BufferedWriter</h3><p>BufferedReader通过缓冲区提高输入性能。BufferedWriter则通过缓冲区提高输出性能。类似于BufferedInputStream和BufferedOutputStream。分别都具有两个构造方法：</p><pre><code>BufferedReader(Reader inputStream)BufferedReader(Reader inputStream,int bufSize)BufferedWriter(Writer ouputStream)BufferedWriter(Writer outputStream,int bufSize)</code></pre><h3 id="5、BufferedReader和BufferedWriter举例"><a href="#5、BufferedReader和BufferedWriter举例" class="headerlink" title="5、BufferedReader和BufferedWriter举例"></a>5、BufferedReader和BufferedWriter举例</h3><pre><code>package com.iotek.readerwriter;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class BufferedReaderWriterDemo {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;);        FileWriter fw = new FileWriter(&quot;f:\\test\\hh.txt&quot;);        BufferedReader bReader = new BufferedReader(fr);        BufferedWriter bWriter = new BufferedWriter(fw);        String line = null;        while((line=bReader.readLine())!=null){            System.out.println(line);            bWriter.write(line);//写入一行            bWriter.newLine();//换行            //bWriter.flush();//不使用close()方法时需要使用此方法        }        bReader.close();        bWriter.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;a href=&quot;#1、Reader和Writer抽象类&quot; class=&quot;headerlink&quot; title=&quot;1、Reader和Writer抽象类&quot;&gt;&lt;/a&gt;1、Reader和Writer抽象类&lt;/h3&gt;&lt;p&gt;字节流提供处
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用字节流复制一个文件夹</title>
    <link href="http://www.echodemo.cc/2018/08/04/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://www.echodemo.cc/2018/08/04/Java中使用字节流复制一个文件夹/</id>
    <published>2018-08-04T01:21:32.000Z</published>
    <updated>2018-08-04T01:22:53.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>使用字节流复制一个文件夹中的所有内容到指定的文件夹中。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>使用递归算法，使用字节缓冲区来提高程序效率。</p><h3 id="3、案例实现："><a href="#3、案例实现：" class="headerlink" title="3、案例实现："></a>3、案例实现：</h3><pre><code>package com.iotek.file;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyFileDemo {    public static void main(String[] args) throws IOException {        CopyUtil.copyDir(new File(&quot;f:\\haha&quot;), new File(&quot;f:\\ee&quot;));    }}class CopyUtil{    public static void copyDir(File src,File dst) throws IOException{        dst.mkdirs();//相比于mkdir()会创建路径中本不存在的文件夹        if(src!=null){            File[] files = src.listFiles();//遍历原文件夹中的文件或目录            if(files!=null){                for(File f:files){                    if(f.isFile()){//复制文件                        FileInputStream fis = new FileInputStream(f);                        FileOutputStream fos = new FileOutputStream(dst.getAbsolutePath() + &quot;\\&quot; + f.getName());                        byte[] buffer = new byte[1024*1024];                        int len = 0;//保存读到的字节个数                        while((len = fis.read(buffer))!=-1){                            fos.write(buffer,0,len);                        }                        fis.close();                        fos.close();                    }else {                        copyDir(f, new File(dst.getAbsolutePath()+&quot;\\&quot;+dst.getName()));                    }                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;使用字节流复制一个文件夹中的所有内容到指定的文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;2、案例设计&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git入门(二)</title>
    <link href="http://www.echodemo.cc/2018/08/02/Git%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/08/02/Git入门(二)/</id>
    <published>2018-08-02T02:38:07.000Z</published>
    <updated>2018-08-02T02:39:34.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、比较分支"><a href="#1、比较分支" class="headerlink" title="1、比较分支"></a>1、比较分支</h3><pre><code>//查看test分支和master之间的差别$ git diff master test//查看当前的工作目录与另外一个分支的差别，查看与test分支的区别$ git diff test//你也以加上路径限定符，来只比较某一个文件或目录$ git diff test file1//--stat 参数可以统计一下有哪些文件被改动，有多少行被改动$ git diff test --stat</code></pre><h3 id="2、分布式的工作流程"><a href="#2、分布式的工作流程" class="headerlink" title="2、分布式的工作流程"></a>2、分布式的工作流程</h3><p>(1)分布式的工作流程</p><p>你目前的项目在gitproject目录下，这是我们的git仓库(repository)，假设另一个用户也想与你协作开发。他的工作目录也在这台机器上。首先，我们假设另一个用户也用相同的用户登录，只是工作在不同的目录下开发代码，实际工作中不太可能发生，大部分情况都是多个用户，这个假设只是为了让实验简化。</p><pre><code>//克隆git仓库，建了一个新的叫&quot;myrepo&quot;的目录，这个目录里包含了一份gitproject仓库的克隆$ git clone gitproject myrepo//查看$ ls -l myrepo</code></pre><p>在 myrepo 做了一些修改并且提交：</p><pre><code>$ cd myrepo//添加新的文件newfile$ echo &quot;newcontent&quot; &gt; newfile//提交修改$ git add newfile$ git commit -m &quot;add newfile&quot;</code></pre><p>myrepo修改完成后，可以在仓库gitproject中把myrepo的修改给拉(pull)下来，合并这份修改到gitproject的git仓库。git pull命令执行两个操作: 它从远程分支(remote branch)抓取修改git fetch的内容，然后把它合并git merge进当前的分支。如果gitproject在myrepo修改文件内容的同时也做了修改的话，可能需要手工去修复冲突。</p><pre><code>$ cd gitproject$ git pull myrepo master$ ls   </code></pre><p>gitproject里可以用git fetch 来执行git pull前半部分的工作，但是这条命令并不会把抓下来的修改合并到当前分支里：</p><pre><code>$ git fetch myrepo</code></pre><p>获取后，我们可以通过git log查看远程分支做的所有修改，由于我们已经合并了所有修改，所以不会有任何输出：</p><pre><code>$ git log -p master..myrepo/master</code></pre><p>当检查完修改后，gitproject可以把修改合并到它的主分支中：</p><pre><code>$ git merge myrepo/master</code></pre><p>如果我们在myrepo目录下执行git pull。myrepo会从克隆的位置拉取代码并更新本地仓库，就是把gitproject上的修改同步到本地:</p><pre><code>//进入到gitproject$ cd gitproject//添加一行内容到newfile$ echo &quot;gitproject: new line&quot; &gt;&gt; newfile//提交修改$ git commit -a -m &apos;add newline to newfile&apos;//进入myrepo目录$ cd myrepo//同步gitproject的所有修改$ git pull</code></pre><p>因为myrepo是从gitproject仓库克隆的，那么他就不需要指定gitproject仓库的地址。因为Git把gitproject仓库的地址存储到myrepo的配置文件中，这个地址就是在git pull时默认使用的远程仓库:</p><pre><code>$ git config --get remote.origin.url</code></pre><p>(2)公共git仓库</p><p>开发过程中，通常大家都会使用一个公共的仓库，并clone到自己的开发环境中，完成一个阶段的代码后可以告诉目标仓库的维护者来pull自己的代码。如果你和维护者都在同一台机器上有帐号，那么你们可以互相从对方的仓库目录里直接拉所作的修改，git命令里的仓库地址也可以是本地的某个目录名：</p><pre><code>$ git clone /path/to/repository$ git pull /path/to/other/repository//也可以是一个ssh地址：$ git clone ssh://yourhost/~you/repository</code></pre><p>(3)将修改推到一个公共仓库</p><p>通过http或是git协议，其它维护者可以通过远程访问的方式抓取(fetch)你最近的修改，但是他们 没有写权限。如何将本地私有仓库的最近修改主动上传到公共仓库中呢？最简单的办法就是用git push命令，推送本地的修改到远程Git仓库，执行下面的命令:</p><pre><code>$ git push ssh://yourserver.com/~you/proj.git master:master或者:$ git push ssh://yourserver.com/~you/proj.git master</code></pre><p>如果推送(push)结果不是快速向前fast forward，可能会报像错。常是因为没有使用git pull获取远端仓库的最新更新，在本地修改的同时，远端仓库已经变化了（其他协作者提交了代码），此时应该先使用git pull合并最新的修改后再执行git push：</p><pre><code>$ git pull$ git push ssh://yourserver.com/~you/proj.git master</code></pre><h3 id="3、git标签"><a href="#3、git标签" class="headerlink" title="3、git标签"></a>3、git标签</h3><p>(1)轻量级标签</p><p>我们可以用 git tag不带任何参数创建一个标签(tag)指定某个提交(commit):</p><pre><code>//进入到gitproject目录$ cd gitproject//查看git提交记录$ git log//选择其中一个记录标志位stable-1的标签，注意需要将后面的8c315325替换成仓库下的真实提交内，commit的名称很长，通常我们只需要写前面8位即可$ git tag stable-1 8c315325//查看当前所有tag$ git tag</code></pre><p>这样，我们可以用stable-1作为提交8c315325的代称。前面这样创建的是一个“轻量级标签”。如果你想为一个tag添加注释，或是为它添加一个签名, 那么我们就需要创建一个 “标签对象”。git tag中使用-a， -s 或是 -u三个参数中任意一个，都会创建一个标签对象，并且需要一个标签消息(tag message)来为tag添加注释。 如果没有-m 或是 -F这些参数，命令执行时会启动一个编辑器来让用户输入标签消息。当这样的一条命令执行后，一个新的对象被添加到Git对象库中，并且标签引用就指向了一个标签对象，而不是指向一个提交，这就是与轻量级标签的区别。</p><p>下面是一个创建标签对象的例子:</p><pre><code>$ git tag -a stable-2 8c315325 -m &quot;stable 2&quot;</code></pre><p>(2)签名的标签</p><p>签名标签可以让提交和标签更加完整可信。如果你配有GPG key，那么你就很容易创建签名的标签。首先你要在你的 .git/config 或 ~/.gitconfig 里配好key。</p><p>下面是示例:</p><pre><code>[user]    signingkey = &lt;gpg-key-id&gt;</code></pre><p>你也可以用命令行来配置:</p><pre><code>$ git config (--global) user.signingkey &lt;gpg-key-id&gt;</code></pre><p>现在你可以在创建标签的时候使用-s 参数来创建“签名的标签”：</p><pre><code>$ git tag -s stable-1 1b2e1d63ff</code></pre><p>如果没有在配置文件中配GPG key,你可以用-u参数直接指定。</p><pre><code>$ git tag -u &lt;gpg-key-id&gt; stable-1 1b2e1d63ff</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、比较分支&quot;&gt;&lt;a href=&quot;#1、比较分支&quot; class=&quot;headerlink&quot; title=&quot;1、比较分支&quot;&gt;&lt;/a&gt;1、比较分支&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//查看test分支和master之间的差别
$ git diff master test

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.echodemo.cc/tags/git/"/>
    
      <category term="github" scheme="http://www.echodemo.cc/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java中的装饰模式</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的装饰模式/</id>
    <published>2018-08-01T10:51:22.000Z</published>
    <updated>2018-08-01T10:52:29.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、装饰模式的概念"><a href="#1、装饰模式的概念" class="headerlink" title="1、装饰模式的概念"></a>1、装饰模式的概念</h3><p>装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。</p><h3 id="2、装饰模式中的角色"><a href="#2、装饰模式中的角色" class="headerlink" title="2、装饰模式中的角色"></a>2、装饰模式中的角色</h3><p>(1)抽象构建(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。如：InputStream。</p><p>(2)具体构件(Concrete Component)角色：定义一个将要接收附加责任的类。如：FileInputStream。</p><p>(3)装饰(Decorator)角色：持有一个构件对象的实例，并定义一个与抽象构建接口一致的接口。如：FilterInputStream。</p><p>(4)具体装饰(Concrete Decorator)角色：负责给构件对象“贴上”附加的责任。如：BufferedInputStream、DataInputStream。</p><h3 id="3、举例说明"><a href="#3、举例说明" class="headerlink" title="3、举例说明"></a>3、举例说明</h3><p>(1)抽象构建角色</p><pre><code>package com.iotek.decorator;public interface Component {    void doThingA();}</code></pre><p>(2)具体构件角色</p><pre><code>package com.iotek.decorator;public class ConcreteComponent implements Component {    @Override    public void doThingA() {        System.out.println(&quot;do A thing.&quot;);    }}</code></pre><p>(3)装饰角色</p><pre><code>package com.iotek.decorator;public class Decorator implements Component {    private Component component = null;    public Decorator(Component component) {        this.component = component;    }    @Override    public void doThingA() {        component.doThingA();//调用被装饰对象的方法    }}</code></pre><p>(4)具体装饰角色1</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator1 extends Decorator {    public ConcreteDecorator1(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingB();    }    //扩展的方法    private void doThingB(){        System.out.println(&quot;do B thing.&quot;);    }}</code></pre><p>(5)具体装饰角色2</p><pre><code>package com.iotek.decorator;public class ConcreteDecorator2 extends Decorator {    public ConcreteDecorator2(Component component) {        super(component);    }    public void doThingA(){//调用被包装类的方法        super.doThingA();        doThingC();    }    //扩展的方法    private void doThingC(){        System.out.println(&quot;do C thing.&quot;);    }}</code></pre><p>(6)测试类</p><pre><code>package com.iotek.decorator;public class Test {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        //concreteComponent.doThingA();        ConcreteDecorator1 cd1 = new ConcreteDecorator1(concreteComponent);        //cd1.doThingA();        ConcreteDecorator2 cd2 = new ConcreteDecorator2(cd1);        cd2.doThingA();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、装饰模式的概念&quot;&gt;&lt;a href=&quot;#1、装饰模式的概念&quot; class=&quot;headerlink&quot; title=&quot;1、装饰模式的概念&quot;&gt;&lt;/a&gt;1、装饰模式的概念&lt;/h3&gt;&lt;p&gt;装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>PAT B1023 组个最小数</title>
    <link href="http://www.echodemo.cc/2018/08/01/PAT-B1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    <id>http://www.echodemo.cc/2018/08/01/PAT-B1023-组个最小数/</id>
    <published>2018-08-01T09:21:29.000Z</published>
    <updated>2018-08-01T09:27:10.387Z</updated>
    
    <content type="html"><![CDATA[<p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。</p><p>输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。</p><p>输出格式：在一行中输出能够组成的最小的数。</p><pre><code>输入样例：2 2 0 0 0 3 0 0 1 0输出样例：10015558</code></pre><p>题目代码：</p><pre><code>#include&lt;iostream&gt;using namespace std;int main(){    int a[10];    int t = 0;    for (int i = 0;i &lt; 10;i++) {        cin &gt;&gt; a[i];    }    for (int i = 1;i &lt; 10;i++) {//查找第一个不包括零在内的个数不为零的数并输出一个        if (a[i] != 0) {            cout &lt;&lt; i;            t = i;            break;        }    }    for (int i = 0;i &lt; a[0];i++) {        cout &lt;&lt; 0;    }    for (int i = 0;i &lt; a[t] - 1;i++) {        cout &lt;&lt; t;    }    for (int i = t + 1;i &lt; 10;i++) {        for (int j = 0;j &lt; a[i];j++) {            cout &lt;&lt; i;        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT B" scheme="http://www.echodemo.cc/tags/PAT-B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的过滤流</title>
    <link href="http://www.echodemo.cc/2018/08/01/Java%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/08/01/Java中的过滤流/</id>
    <published>2018-08-01T00:18:39.000Z</published>
    <updated>2018-08-01T10:07:01.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、过滤流介绍"><a href="#1、过滤流介绍" class="headerlink" title="1、过滤流介绍"></a>1、过滤流介绍</h3><p>(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装。这些流一般由普通类的方法(即过滤流的一个父类)访问。</p><p>(2)过滤字节流FilterInputStream和FilterOutputStream，它们不是抽象类，它们提供的方法和InputStream和OutputStream类的方法相同。构造方法有：</p><pre><code>FilterOutputStream(OutputStream os);FilterInputstream(InputStream is);</code></pre><p>常用的过滤流有BufferedInputStream和BufferedOutputStream(带缓冲区)，需要使用已经存在的节点流(直接操作设备的流)来构造，FileInputStream就是节点流，而BufferedInputStream包装了FileInputStream。提供带缓冲的读写，提高了读写的效率。DataInputStream和DataOutputStream(对基本数据类型进行读写操作)。数据输入输出流允许应用程序读写基本Java数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取。读写顺序要保持一致。</p><h3 id="2、过滤流举例说明"><a href="#2、过滤流举例说明" class="headerlink" title="2、过滤流举例说明"></a>2、过滤流举例说明</h3><p>(1)BufferedInputStream和BufferedOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class BufferedInputOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        BufferedInputStream bis = new BufferedInputStream(fileInputStream);        BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream);        long time1 = System.currentTimeMillis();        int data = 0;        while((data = bis.read())!=-1){//从缓冲区里面读，而不是直接从输入流里面读。            bos.write(data);//先写到缓冲区，当缓冲区满的时候再一次性写到输出流里面去。        }        bis.close();        bos.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><p>(2)DataInputStream和DataOutputStream</p><pre><code>package com.iotek.inputoutputstream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class DataInputOutputStream {    public static void main(String[] args) throws IOException {        /*String name = &quot;zhangsan&quot;;        int age = 10;        boolean flag = true;        char set = &apos;男&apos;;        double money = 100.56;        DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;f:\\test\\b.txt&quot;));        dos.writeUTF(name);        dos.writeInt(age);        dos.writeBoolean(flag);        dos.writeChar(set);        dos.writeDouble(money);        dos.close();*/        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;f:\\test\\b.txt&quot;));        //读的顺序必须和写的顺序一致        System.out.println(dis.readUTF());        System.out.println(dis.readInt());        System.out.println(dis.readBoolean());        System.out.println(dis.readChar());        System.out.println(dis.readDouble());        dis.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、过滤流介绍&quot;&gt;&lt;a href=&quot;#1、过滤流介绍&quot; class=&quot;headerlink&quot; title=&quot;1、过滤流介绍&quot;&gt;&lt;/a&gt;1、过滤流介绍&lt;/h3&gt;&lt;p&gt;(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的输入输出流</title>
    <link href="http://www.echodemo.cc/2018/07/31/Java%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://www.echodemo.cc/2018/07/31/Java中的输入输出流/</id>
    <published>2018-07-31T12:14:08.000Z</published>
    <updated>2018-07-31T12:15:51.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、流的概念和分类"><a href="#1、流的概念和分类" class="headerlink" title="1、流的概念和分类"></a>1、流的概念和分类</h3><p>(1)流的概念</p><p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件、内存或是网络连接。同理，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据就好像在这其中“流动”一样。</p><p>(2)流的分类</p><p>a、流按其流向分为“输入流”和“输出流”。</p><p>b、流按数据传输单位分为“字节流”和“字符流”。“字节流”用来读写8位二进制的字节，“字符流”用来读写16位二进制字符。</p><p>c、流按功能分为“节点流”和“过滤流”。“节点流”用于直接操作目标设备的流，例如：磁盘或一块内存区域。“过滤流”是对一个已存在的流的链接和封装，通过对数据进行处理，为程序提供功能强大、灵活的读写功能。</p><h3 id="2、InputStream和Outputstream抽象类"><a href="#2、InputStream和Outputstream抽象类" class="headerlink" title="2、InputStream和Outputstream抽象类"></a>2、InputStream和Outputstream抽象类</h3><p>字节流类用于向字节流读写8位二进制的字节。一般的，字节流类主要用于读写诸如图像或声音等的二进制数据。字节流类以InputStream和OutputStream为顶层类。他们都是抽象类。InputStream中定义的方法有：</p><pre><code>public abstract int read();//从输入流中读取数据的下一个字节public int read(byte[] b);//从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中public int read(byte[] b ,int off ,int len);//将输入流中最多len个数据字节读入byte数组public long skip(long n);//跳过或者丢弃此输入流中数据的n个字节public int available();//返回从该输入流中可以读取的字节数的估计值，而不会被下一次调用此输入流的方法阻塞public void close();//关闭输入流并释放与该流关联的所有系统资源</code></pre><p>OutputStream抽象类所有方法返回void值，在出错情况下抛IOException异常。需要定义OutputStream子类的应用,OutputStream必须至少提供一个写入一个字节输出的方法。OutputStream中定义的方法：</p><pre><code>public abstract void write(int b);//将指定的字节写入此输出流。 public void write(byte[] b);//将b.length个字节从指定的byte数组写入此输出流public void write(byte[] ,int off ,int len);//从指定的字节数组写入len个字节，从偏移off开始输出到此输出流。public void flush();//刷新此输出流并强制任何缓冲的输出字节被写出。public void close();//关闭输出流并释放与该流关联的所有系统资源</code></pre><h3 id="3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类"><a href="#3、FileInputStream和FileOutputStream-它们分别是InputStream和OutputStream类的子类" class="headerlink" title="3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)"></a>3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)</h3><p>(1)每个抽象类都有多个具体的子类，这些子类对不同的外设进行处理，例如磁盘文件，网络连接，甚至是内存缓冲区。FileInputStream类表示能从文件读取字节的InputStream类。其常用的构造方法有：FileInputStream(String filepath);FileInputStream(File fileObj);FileOutputStream类表示能向文件写入字节的OutputStream类。其常用的构造方法有：FileOutputStream(String filepath);FileOutputStream(File fileObj);FileOutputStream(String filePath,boolean append);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileInputStreamOutputStreamDemo {    public static void main(String[] args) {        try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。            FileCopyUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;));        } catch (IOException e) {            e.printStackTrace();        }    }}class FileCopyUtil{    public static void copyFile(File src,File dst) throws IOException{            FileInputStream fileInputStream = new FileInputStream(src);        FileOutputStream fileOutputStream = new FileOutputStream(dst);        long time1 = System.currentTimeMillis();        /*int data = -1;        while((data = fileInputStream.read())!=-1){            fileOutputStream.write(data);        }*/        byte[] buf = new byte[1024*1024];//创建一个1M大小的缓冲区，用来存放输入流中的字节数据        int len = 0;//用来保存实际读到的字节数        while((len = fileInputStream.read(buf))!=-1){            fileOutputStream.write(buf, 0, len);//使用缓冲区对文件的进行读写操作会大大提高读写的速度        }        fileOutputStream.close();        fileInputStream.close();        long time2 = System.currentTimeMillis();        System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;);    }}</code></pre><h3 id="4、ByteArrayInputStream和ByteArrayOutputStream"><a href="#4、ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="4、ByteArrayInputStream和ByteArrayOutputStream"></a>4、ByteArrayInputStream和ByteArrayOutputStream</h3><p>(1)ByteArrayInputStream是把字节数组当成源的输入流，其内部包含一个内部缓冲区，且调用close()方法关闭ByteArrayInputStream无效。它有两个构造方法，每个都需要一个字节数组提供数据源：ByteArrayInputStream(byte array[]);ByteArrayInputStream(byte array[],int start,int numBytes);ByteArrayOutputStream是把字节数组当作目标的输出流，它也有两个构造方法：ByteArrayInputStream();ByteArrayOutputStream(int numBytes);</p><p>(2)举例说明</p><pre><code>package com.iotek.inputoutputstream;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.IOException;public class ByteArrayInputOutputStream {    public static void main(String[] args) throws IOException {        /*String string = &quot;Hello,shanghai!&quot;;        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(string.getBytes());        int data = -1;        while((data=byteArrayInputStream.read())!=-1){            System.out.print((char)data);        }        byteArrayInputStream.close();//这里的关闭时无效的，因为没有调用操作系统底层的函数。*/        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        byteArrayOutputStream.write(97);        byteArrayOutputStream.write(65);        byteArrayOutputStream.write(&quot;hello,world!&quot;.getBytes());        byte[] buff = byteArrayOutputStream.toByteArray();        for(byte b:buff){            System.out.print((char)b);        }        FileOutputStream fileOutputStream = new FileOutputStream(&quot;f:\\test\\a.txt&quot;,true);//true表示可以追加        byteArrayOutputStream.writeTo(fileOutputStream);//把ByteArrayOutputStream内部缓冲区中的数据写到对应的文件输出流中        byteArrayOutputStream.close();//这里的关闭同上    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、流的概念和分类&quot;&gt;&lt;a href=&quot;#1、流的概念和分类&quot; class=&quot;headerlink&quot; title=&quot;1、流的概念和分类&quot;&gt;&lt;/a&gt;1、流的概念和分类&lt;/h3&gt;&lt;p&gt;(1)流的概念&lt;/p&gt;
&lt;p&gt;流是一个很形象的概念，当程序需要读取数据的时候，就会开
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vim入门</title>
    <link href="http://www.echodemo.cc/2018/07/31/Vim%E5%85%A5%E9%97%A8/"/>
    <id>http://www.echodemo.cc/2018/07/31/Vim入门/</id>
    <published>2018-07-31T08:39:27.000Z</published>
    <updated>2018-07-31T08:46:40.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Vim的模式介绍"><a href="#1、Vim的模式介绍" class="headerlink" title="1、Vim的模式介绍"></a>1、Vim的模式介绍</h3><p>(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</p><p>(2)插入模式(Insert mode):在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</p><p>(3)可视模式(Visual mode):这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p><p>(4)选择模式(Select mode):这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p><p>(5)命令行模式(Command line mode):在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p><p>(6)Ex模式(Ex mode):这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。这其中我们常用到就是普通模式、插入模式和命令行模式。</p><p>vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[(这在vim课程环境中不管用)即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。</p><h3 id="2、Vim常用命令"><a href="#2、Vim常用命令" class="headerlink" title="2、Vim常用命令"></a>2、Vim常用命令</h3><p>(1)移动</p><pre><code>1)h 左移一个字符；2)l 右移一个字符；3)j 下移一行；4)k 上移一行；5)w 移动到下一个单词；6)b 移动到上一个单词；</code></pre><p>(2)插入</p><pre><code>1)i 在当前光标处进行编辑；2)I 在当前行首插入；3)a 在光标后插入；4)A 在当前行末插入；5)o 在下面新建一行插入；6)O 在上面新建一行插入；</code></pre><p>(3)保存</p><pre><code>1):wq 保存并退出；2):w 保存修改；3):q 退出；4):saveas newfilename 另存为；5):q! 强制退出，不保存；6):wq! 强制保存并退出；</code></pre><p>(4)删除</p><pre><code>1)x 删除游标所在的字符2)X 删除游标所在前一个字符3)dd 删除整行4)dw 删除一个单词（不适用中文）5)d$或D 删除至行尾6)d^ 删除至行首7)dG 删除到文档结尾处8)d1G 删至文档首部</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Vim的模式介绍&quot;&gt;&lt;a href=&quot;#1、Vim的模式介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Vim的模式介绍&quot;&gt;&lt;/a&gt;1、Vim的模式介绍&lt;/h3&gt;&lt;p&gt;(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://www.echodemo.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java中IO框架之File</title>
    <link href="http://www.echodemo.cc/2018/07/30/Java%E4%B8%ADIO%E6%A1%86%E6%9E%B6%E4%B9%8BFile/"/>
    <id>http://www.echodemo.cc/2018/07/30/Java中IO框架之File/</id>
    <published>2018-07-30T12:26:33.000Z</published>
    <updated>2018-07-31T04:38:35.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、I-O框架介绍"><a href="#1、I-O框架介绍" class="headerlink" title="1、I/O框架介绍"></a>1、I/O框架介绍</h3><p>I/O(Input/Output)是计算机输入/输出的接口。Java的核心库java.io提供了全方面的I/O接口，包括：文件系统的操作，文件读写，标准设备输出等等。</p><h3 id="2、File类及使用"><a href="#2、File类及使用" class="headerlink" title="2、File类及使用"></a>2、File类及使用</h3><p>(1)一个File类的对象，表示了磁盘上的文件或者目录。File类提供了与平台无关的方法来对磁盘上的文件或者目录进行操作。File类直接处理文件和文件系统。比如删除文件，获取文件长度大小等信息。File类没有提供方法从文件读取或者向文件存储信息。其构造方法有：File(String directoryPath);File(String directoryPath,String filename);File(File dirObj,String filename);</p><p>(2)File定义了获取File对象标准属性的方法：</p><pre><code>public String getName();获取文件或目录的名字public String getParent();获取父目录的路径字符串public File getParentFile();获取父目录的File对象public String getAbsolutePath();获取文件或目录的绝对路径public boolean exists();判断文件或目录是否存在public String[] list();获得目录里面的文件名和目录名。public boolean isDirectory();判断是否是目录public boolean isFile();判断是否是文件public long length();获取文件的大小public boolean delete();删除目录或者文件夹public boolean mkdir();创建文件夹......</code></pre><h3 id="3、IO方法举例"><a href="#3、IO方法举例" class="headerlink" title="3、IO方法举例"></a>3、IO方法举例</h3><pre><code>package com.iotek.file;import java.io.File;import java.io.FileFilter;import java.io.FilenameFilter;import java.io.IOException;public class FileDemo {    public static void main(String[] args) {        File file = new File(&quot;f:\\hehe&quot;);        System.out.println(file.getAbsolutePath());//获得绝对路径        System.out.println(file.getParent());//获得父目录的路径字符串        System.out.println(file.isDirectory());//判断是否为目录        System.out.println(file.isFile());//判断是否为文件        System.out.println(file.exists());//判断是否存在        System.out.println(file.length());//获取长度        File myFile = new File(&quot;f:\\hehe&quot;);        System.out.println(myFile.mkdir());//新建一个目录        File myFile1 = new File(&quot;f:/hehe/hehe.txt&quot;);        try {            System.out.println(myFile1.createNewFile());//新建一个文件        } catch (IOException e) {            e.printStackTrace();        }        /*String[] filesStrings = file.list();//获取当前目录下的所有文件名和目录名        for(String f:filesStrings){            System.out.println(f);        }*/        /*String[] filesString = myFile.list(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名            }        });        for(String f:filesString){            System.out.println(f);        }*/            /*File[] files = myFile.listFiles();        for(File f:files){            System.out.println(f.getName() + &quot;--&quot; + f.length());//打印文件或目录的名字和大小        }*/        /*File[] filesString = myFile.listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名            }        });        for(File f:filesString){            System.out.println(f.getName() + &quot;--&quot; + f.length());        }*/        File[] files = myFile.listFiles(new FileFilter() {            @Override            public boolean accept(File pathname) {                return pathname.getName().endsWith(&quot;.gif&quot;);            }        });        for(File f:files){            System.out.println(f.getName() + &quot;--&quot; + f.length());        }    }}</code></pre><h3 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h3><p>(1)案例说明：给定一个目录要求按层次显示目录结构信息，文件名后面加上*或者\来表示文件夹。</p><p>(2)案例分析：使用递归算法，使用File类中的ListFile方法来遍历文件夹，使用List集合。</p><p>(3)案例实现</p><pre><code>package com.iotek.file;import java.io.File;import java.util.ArrayList;import java.util.List;public class IteratorDirDemo {    public static void main(String[] args) {        IteratorUtil.IteratorDir(new File(&quot;f:/git&quot;));    }}class IteratorUtil{    private static int level = 0;    public static void IteratorDir(File file){        if(null!=file){            /*             * 找到递归的出口，如果是文件或者是空文件夹就触碰到边界             */            if(file.isFile()||file.listFiles().length==0){                return;            }else{                File[] files = file.listFiles();                 files = sortFiles(files);                for(File f:files){                    StringBuilder sBuilder = new StringBuilder();                    sBuilder.append(getTab(level));                    sBuilder.append(f.getName());                    if(!f.isFile()){                        sBuilder.append(&quot;\\&quot;);                    }                    System.out.println(sBuilder.toString());                    if(f.isDirectory()){//如果是文件夹，进入目录遍历，层级自增1                        level++;                        IteratorDir(f);                        level--;//目录自减1，返回上一级目录                    }                }            }        }    }    private static File[] sortFiles(File[] files) {//对File类型的数组进行先目录后文件的排列        List&lt;File&gt; fList = new ArrayList&lt;File&gt;();        for(File f:files){//先存放文件夹            if(f.isDirectory()){                fList.add(f);            }        }        for(File f:files){//再存放文件            if(f.isFile()){                fList.add(f);            }        }        return fList.toArray(new File[fList.size()]);//把集合中的元素转化成指定大小的和指定类型的数组    }    private static String getTab(int level) {//根据层级数来得到制表符的个数        StringBuilder stringBuilder = new StringBuilder();        for(int i=0;i&lt;level;i++){            stringBuilder.append(&quot;\t&quot;);        }        return stringBuilder.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、I-O框架介绍&quot;&gt;&lt;a href=&quot;#1、I-O框架介绍&quot; class=&quot;headerlink&quot; title=&quot;1、I/O框架介绍&quot;&gt;&lt;/a&gt;1、I/O框架介绍&lt;/h3&gt;&lt;p&gt;I/O(Input/Output)是计算机输入/输出的接口。Java的核心库java
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中线程的单例模式</title>
    <link href="http://www.echodemo.cc/2018/07/30/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.echodemo.cc/2018/07/30/Java中线程的单例模式/</id>
    <published>2018-07-29T23:31:12.000Z</published>
    <updated>2018-07-30T00:24:47.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>单例模式有饿汉式和懒汉式之分，懒汉式即延迟初始化单例。在多线程环境下，简单的懒汉式会有线程安全的困扰。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>使用双重检查加锁机制解决线程安全问题。单例模式还有更好的解决方案，即使用静态类方式。</p><h3 id="3、案例实现"><a href="#3、案例实现" class="headerlink" title="3、案例实现"></a>3、案例实现</h3><pre><code>package com.iotek.synchronize;public class SingleTonDemo {    public static void main(String[] args) {        /*SingleTon.getInstance();        SingleTon.getInstance();//单例模式只产生一个对象*/            SThread sThread = new SThread();        Thread t1 = new Thread(sThread);        t1.start();        Thread t2 = new Thread(sThread);        t2.start();    }}class SThread implements Runnable{    @Override    public void run(){        SingleTon.getInstance();    }}class SingleTon{    private static SingleTon singleTon = null;    private SingleTon(){        System.out.println(&quot;单例模式&quot;);    }    public static SingleTon getInstance(){        if(singleTon == null){            synchronized (SingleTon.class) {                if(singleTon == null){                    //第一个线程进来                    //第二个线程也进来了                    singleTon = new SingleTon();                }            }        }        return singleTon;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;单例模式有饿汉式和懒汉式之分，懒汉式即延迟初始化单例。在多线程环境下，简单的懒汉式会有线程安全的困扰。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程通信</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的线程通信/</id>
    <published>2018-07-28T09:06:29.000Z</published>
    <updated>2018-07-28T09:07:15.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、线程通信相关方法"><a href="#1、线程通信相关方法" class="headerlink" title="1、线程通信相关方法"></a>1、线程通信相关方法</h3><p>Java提供了三个重要的方法巧妙地解决线程间的通信问题。这三个方法分别是：wait()、notify()和notifyAll()。</p><p>(1)调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。</p><p>(2)调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的进程，并使该线程退出等待队列，进入可运行态。</p><p>(3)调用notifyAll()方法可以使所有正在等待队列中共享同一资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><pre><code>package com.iotek.synchronize;import java.util.LinkedList;public class ProductorConsumerDemo {    public static void main(String[] args) {        Basket basket = new Basket();        Productor productor = new Productor(basket);        Consumer consumer = new Consumer(basket);        productor.start();        consumer .start();    }}class Apple{//苹果类    private int id;    public Apple(int id){        this.id = id;    }    @Override    public String toString() {        return &quot;Apple:&quot; + (id+1);    }}class Basket{//篮子类    private LinkedList&lt;Apple&gt; basket = new LinkedList&lt;Apple&gt;();    public synchronized void pushApple(){//放四轮苹果        for(int i=0;i&lt;20;i++){            Apple apple = new Apple(i);            push(apple);        }    }    public synchronized void popApple(){//取四轮苹果        for(int i=0;i&lt;20;i++){            pop();        }    }    private void push(Apple apple){//向篮子放苹果，当存放了五个苹果就等待并通知消费者来取苹果。        if(basket.size()==5){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }//等待并释放当前对象的锁        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }        basket.addFirst(apple);//每隔500毫秒放一个苹果进篮子里面        System.out.println(&quot;存放&quot;+apple.toString());        notify();//通知消费者来消费    }    private void pop(){//向篮子取苹果，当篮子当中苹果数为零的时候，就等待并通知生产者来生产。        if(basket.size()==0){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }//等待并释放当前对象的锁        }        try {            Thread.sleep(500);        } catch (InterruptedException e) {            e.printStackTrace();        }        Apple apple = basket.removeFirst();//每隔500毫秒从篮子里面取一个苹果        System.out.println(&quot;吃掉&quot;+apple.toString());        notify();//通知生产者来生产    }}class Productor extends Thread{//生产者    private Basket basket = null;    public Productor(Basket basket) {        super();        this.basket = basket;    }    @Override    public void run(){        basket.pushApple();    }}class Consumer extends Thread{//消费者    private Basket basket = null;    public Consumer(Basket basket) {        super();        this.basket = basket;    }    @Override    public void run(){        basket.popApple();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、线程通信相关方法&quot;&gt;&lt;a href=&quot;#1、线程通信相关方法&quot; class=&quot;headerlink&quot; title=&quot;1、线程通信相关方法&quot;&gt;&lt;/a&gt;1、线程通信相关方法&lt;/h3&gt;&lt;p&gt;Java提供了三个重要的方法巧妙地解决线程间的通信问题。这三个方法分别是：w
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的多线程编程</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的多线程编程/</id>
    <published>2018-07-28T03:41:33.000Z</published>
    <updated>2018-07-28T08:32:26.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、线程同步"><a href="#1、线程同步" class="headerlink" title="1、线程同步"></a>1、线程同步</h3><p>线程同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。它是保证多线程安全访问竞争资源的一种手段。</p><p>(1)同步和锁：Java中的每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例(this实例)有关的锁；当程序运行到synchronized同步代码块时，自动获得锁定对象的锁。一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放锁。这也意味着任何其他线程都不能进入synchronized方法或者代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或者代码块。</p><p>(2)对于同步，一般而言在Java中需要完成两个操作：把竞争访问的资源表示为private；同步那些访问资源的代码，使用synchronized关键字修饰方法或者代码块。当synchronized方法执行完或者发生异常时会自动释放锁。</p><h3 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h3><p>(1)案例介绍</p><p>某银行账号上有500元存款，一个人拿着存折去取钱，同时另一个人拿着银行卡去ATM机上取钱，各自取钱400元。要求取钱的过程中不能出现资源竞争：比如400元被取出两次、银行卡的账目不能小于0等。</p><p>(2)案例实现</p><pre><code>package com.iotek.synchronize;public class BankDemo {    public static void main(String[] args) {        Bank bank1 = new Bank();        BankThread bankThread = new BankThread(bank1);        bankThread.start();//柜台取钱        BankThread bankThread2 = new BankThread(bank1);        bankThread2.start();//ATM机取钱    }}class Bank{    private int money = 500;    private Object object = new Object();//锁这个对象也可以实现，因为任何对象都只有一个锁。    /*取钱的方法，返回取钱的数目    当一个线程去调用同步方法的时候，这个线程就调用了当前对象的锁。其他线程则等待*/    public int getMoney(int number) throws InterruptedException{        synchronized(this){            if(number &lt; 0)                return -1;            else if(money &lt; 0)                return -2;            else if(number - money &gt;0)                return -3;            else{                Thread.sleep(1000);                money-=number;                System.out.println(&quot;账户余额：&quot; + money);            }            return number;        }    }}class BankThread extends Thread{    private Bank bank = null;    public BankThread(Bank bank){        this.bank = bank;    }    @Override    public void run(){        try {            System.out.println(&quot;取钱：&quot;+bank.getMoney(400));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="3、同步产生死锁"><a href="#3、同步产生死锁" class="headerlink" title="3、同步产生死锁"></a>3、同步产生死锁</h3><p>(1)同步产生死锁的原因：当一个线程已经获取了对象1的锁，同时又想获取对象二的锁。而此时另一个线程当前已经持有了对象二的锁，而又想获取对象一的锁。这中相互等待对方释放锁的过程，会导致“死锁”。</p><p>(2)死锁举例</p><pre><code>package com.iotek.synchronize;public class DieThreadDemo {    public static void main(String[] args) throws InterruptedException {        Example example = new Example();        DieThread thread1 = new DieThread(example);        thread1.start();        DieThread1 thread2 = new DieThread1(example);        thread2.start();    }}class Example{    private Object obj1 = new Object();    private Object obj2 = new Object();    public void method1() throws InterruptedException{//先占用对象1，再请求对象2.        synchronized (obj1) {            Thread.sleep(1000);            synchronized (obj2) {                System.out.println(&quot;method1&quot;);            }        }    }    public void method2() throws InterruptedException{//先占用对象2，再请求对象1.        synchronized (obj2) {            Thread.sleep(1000);            synchronized (obj1) {                System.out.println(&quot;method2&quot;);            }        }    }}class DieThread extends Thread{//死亡进程1    private Example example = null;    public DieThread(Example example) {        super();        this.example = example;    }    @Override    public void run(){        try {            example.method1();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}class DieThread1 extends Thread{//死亡进程2    private Example example = null;    public DieThread1(Example example) {        super();        this.example = example;    }    @Override    public void run(){        try {            example.method2();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、线程同步&quot;&gt;&lt;a href=&quot;#1、线程同步&quot; class=&quot;headerlink&quot; title=&quot;1、线程同步&quot;&gt;&lt;/a&gt;1、线程同步&lt;/h3&gt;&lt;p&gt;线程同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。它是保证多线程安全访问竞争资源的一种手段。&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中线程的生命周期</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中线程的生命周期/</id>
    <published>2018-07-28T01:01:21.000Z</published>
    <updated>2018-07-28T01:02:48.356Z</updated>
    
    <content type="html"><![CDATA[<p>与人的生老病死一样，线程也同样要经历新建、就绪、运行、阻塞和死亡五种不同的状态。这五种状态都可以通过Thread类中的方法进行控制。</p><p>(1)新建状态(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。线程处于创建状态时，可通过Thread类的方法来设置线程各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。</p><p>(2)就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。</p><p>(3)运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占用CPU并转为运行状态。此时，系统真正执行线程的run()方法。可以通过Thread类的isAlive()方法来判断线程是否处于就绪状态：当线程处于就绪/运行状态时，isAlive()方法返回true；否则的话，线程可能处于阻塞状态也可能是处于停止状态。</p><p>(4)阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞状态。包括以下原因：</p><pre><code>a、当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集(Blocked Pool)内，等待超时而自动苏醒。b、当多个线程试图进入某个同步区域(synchronized)时，没能进入该同步区域的线程会被置入锁定集(Lock Pool)，直到获得该同步区域的锁，进入就绪状态。c、当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集(Wait Pool)中，直到执行了该对象的notify()方法，wait()/notify()方法的执行要求线程首先获取到该对象的锁。</code></pre><p>(5)死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。</p><p>(6)终止线程的三种方法</p><pre><code>a、使用退出标志，使线程正常退出，也就是run()方法完成后线程终止，推荐使用。b、使用stop()方法强行终止线程(这个方法不推荐使用，因为stop()和suspend()、resume()一样，也可能发生不可预料的后果)。c、使用interrupt()方法中断线程。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;与人的生老病死一样，线程也同样要经历新建、就绪、运行、阻塞和死亡五种不同的状态。这五种状态都可以通过Thread类中的方法进行控制。&lt;/p&gt;
&lt;p&gt;(1)新建状态(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程模型</title>
    <link href="http://www.echodemo.cc/2018/07/28/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.echodemo.cc/2018/07/28/Java中的线程模型/</id>
    <published>2018-07-27T16:04:49.000Z</published>
    <updated>2018-07-27T16:17:45.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念了解"><a href="#1、概念了解" class="headerlink" title="1、概念了解"></a>1、概念了解</h3><p>(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。</p><p>(2)进程是运行中的程序，是动态的概念。每个进程有独立的资源空间。</p><p>(3)线程是轻量级的进程，是程序执行流的最小单位，是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。</p><p>(4)多线程是在单个程序中可以同时运行多个不同的线程执行不同的任务。一个进程可以包含一个或者多个线程。一个程序实现多个代码同时交替运行就需要产生多个线程。线程本身不拥有系统资源，与同属一个进程的其他线程共享所在进程所拥有的资源。同一进程中的多个线程之间可以并发执行。CPU会随机抽出时间，让我们的程序一会做这件事，一会做另外一件事情。多线程的目的在于，最大限度地利用CPU资源，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。</p><p>(5)Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。Java是纯面向对象语言，Java的线程模型也是面向对象的。</p><p>(6)创建线程的方式有两种：第一，通过继承Thread类创建线程，普通Java类如继承自Thread类，就成为一个线程类，并可通过该类的start方法来启动线程，执行线程代码。Thread子类可直接实例化，但在子类中必须覆盖run方法才能真正运行线程的代码。第二，通过实现Runnable接口创建线程，实现Runnable接口的类必须借助Thread类才能创建线程(本质上还是通过继承Thread来实现)。通过Runnable接口创建线程分为两步：创建实现Runnable接口的类的实例；创建一个Thread类对象，将第一步实例化得到的Runnable对象作为参数传入Thread类的构造方法。最后通过Thread类的start方法启动线程。</p><h3 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h3><p>(1)举例一：通过继承Thread类创建线程</p><pre><code>package com.iotek.threadtest;public class HelloThreadDemo {    public static void main(String[] args) {        HelloThread h1HelloThread = new HelloThread(&quot;A&quot;);        //h1HelloThread.setName(&quot;线程1&quot;);//自定义线程名字        h1HelloThread.start();//启动线程就会调用run方法        HelloThread h2HelloThread = new HelloThread(&quot;B&quot;);        //h1HelloThread.setName(&quot;线程2&quot;);        h2HelloThread.start();    }}class HelloThread extends Thread{    public HelloThread(String name) {        super(name);    }    @Override    public void run(){        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(2)举例二：通过实现Runnable接口创建线程</p><pre><code>package com.iotek.threadtest;public class HelloRunnableDemo {    public static void main(String[] args) {        HelloRunnable helloRunnable = new HelloRunnable();        Thread thread = new Thread(helloRunnable,&quot;A&quot;);        thread.start();        Thread thread2 = new Thread(helloRunnable,&quot;B&quot;);        thread2.start();    }}/** * Runnable接口优于Thread的地方 * 1、避免单继承的局限，一个类可以实现多个接口，但只能继承一个类。 * 2、适合资源的共享。 * @author 紫苏半夏 * */class HelloRunnable implements Runnable{    @Override    public void run() {        for(int i = 0 ;i &lt; 5 ;i++){            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);        }    }}</code></pre><p>(3)举例三：Runnable接口适合资源的共享</p><pre><code>package com.iotek.threadtest;public class SharedDataThreadDemo {    public static void main(String[] args) {        /*TicketThread ticketThread1 = new TicketThread(&quot;一号窗口&quot;);        ticketThread1.start();        TicketThread ticketThread2 = new TicketThread(&quot;二号窗口&quot;);        ticketThread2.start();*/        TicketRunnable ticketRunnable = new TicketRunnable();        Thread thread = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread.start();        Thread thread1 = new Thread(ticketRunnable, &quot;一号窗口&quot;);        thread1.start();    }}/*class TicketThread extends Thread{    private int ticket = 5;    public TicketThread(String name){        super(name);    }    @Override    public void run(){        while (true) {            System.out.println(this.getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}*/class TicketRunnable implements Runnable{    private int ticket = 5;    @Override    public void run(){        while (true) {            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (ticket--));            if(ticket &lt; 1){                break;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、概念了解&quot;&gt;&lt;a href=&quot;#1、概念了解&quot; class=&quot;headerlink&quot; title=&quot;1、概念了解&quot;&gt;&lt;/a&gt;1、概念了解&lt;/h3&gt;&lt;p&gt;(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。&lt;/p&gt;
&lt;p&gt;(2)进程是运行中的程序，是动态的概
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(二)</title>
    <link href="http://www.echodemo.cc/2018/07/26/Java%E5%8F%8D%E5%B0%84API(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/07/26/Java反射API(二)/</id>
    <published>2018-07-26T09:59:35.000Z</published>
    <updated>2018-07-27T00:26:16.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student对象。通过反射复制此Student对象。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>通过反射机制来获取类的属性和方法。通过反射来生成对象，并通过反射来调用其set方法来对属性进行赋值以达到复制对象的目的。最后对复制成功的对象信息进行打印。</p><h3 id="3、方案实施"><a href="#3、方案实施" class="headerlink" title="3、方案实施"></a>3、方案实施</h3><pre><code>(1)创建Student类。(2)创建一个Student对象。(3)获取Student对象所属类型的Class对象。(4)通过调用class.newInstance方法来构建一个目标对象。(5)获取class对象中的get和set方法。(6)调用源对象的get方法获取属性值。(7)调用目标对象的set方法来设置属性值。(8)打印目标对象的数据。</code></pre><h3 id="4、案例实现"><a href="#4、案例实现" class="headerlink" title="4、案例实现"></a>4、案例实现</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import javax.activation.FileDataSource;import org.omg.CORBA.portable.ValueBase;public class ReflectionExampleDemo {    public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        Student student = new Student(1, &quot;EchoDemo&quot;, 22);        Student student2 = (Student) ObjectCopyUtil.copyObj(student);        System.out.println(&quot;复制对象成功&quot;);        System.out.println(student2.toString());    }}/** * 这是一个拷贝对象的工具类，内部提供了一个拷贝对象的方法，接收源对象。 * @author 紫苏半夏 * */class ObjectCopyUtil{    public static Object copyObj(Object obj) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{        //获取student对象所对应类型的Class对象(也就是Student类所对应的对象)        Class&lt;?&gt; classType = obj.getClass();        //通过class对象的newInstance方法来构建一个目标对象        Object objCopy = classType.newInstance();        //获取Class对象的get和set方法        for(Field field : classType.getDeclaredFields()){            /*//得到属性所对应的get和set方法            String getMethodName = &quot;get&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            String setMethodName = &quot;set&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1);            //调用源对象的get方法获取属性值            Method getMethod = classType.getDeclaredMethod(getMethodName, new Class[]{});            Object value = getMethod.invoke(obj, new Object[]{});            //调用源对象的set方法给属性赋值            Method setMethod = classType.getDeclaredMethod(setMethodName, new Class[]{field.getType()});            setMethod.invoke(obj, new Object[]{value});*/            //直接获取源对象的值            field.setAccessible(true);            Object value = field.get(obj);            field.set(objCopy, value);        }        return objCopy;    }}//声明一个学生类class Student{    private int id;    private String name;    private int age;    public Student(){    }    public Student(int id, String name, int age) {        super();        this.id = id;        this.name = name;        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射API(一)</title>
    <link href="http://www.echodemo.cc/2018/07/24/Java%E5%8F%8D%E5%B0%84API(%E4%B8%80)/"/>
    <id>http://www.echodemo.cc/2018/07/24/Java反射API(一)/</id>
    <published>2018-07-24T10:18:29.000Z</published>
    <updated>2018-07-26T10:04:53.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Java-lang-reflect库"><a href="#1、Java-lang-reflect库" class="headerlink" title="1、Java.lang.reflect库"></a>1、Java.lang.reflect库</h3><p>Class类和java.lang.reflect类库一起对反射的概念进行支持。在java.lang包下：Class<t>:表示一个正在运行的Java应用程序中的类和接口，是Reflection的起源。在java.lang.reflect包下：Field类：代表类的成员变量(也称之为类的属性)；Method类：代表类的方法；Constructor类：代表类的构造方法；Array类：提供动态创建数组，以及访问数组的元素的静态方法。</t></p><h3 id="2、通过反射实例化对象"><a href="#2、通过反射实例化对象" class="headerlink" title="2、通过反射实例化对象"></a>2、通过反射实例化对象</h3><p>(1)平常情况我们通过new Object来生成一个类的实例，但有时候我们没法直接new，只能通过反射动态生成。</p><p>(2)实例化无参构造函数的对象，两种方式：</p><pre><code>Class.newInstace();Class.getConstructor(new Class[]{}).newInstance(new Object[]{});</code></pre><p>(3)实例化带参构造函数的对象</p><pre><code>Class.getConstructor(Class&lt;?&gt;...parameterTypes).newInstance(Object...initargs);</code></pre><h3 id="3、通过反射获取并调用方法"><a href="#3、通过反射获取并调用方法" class="headerlink" title="3、通过反射获取并调用方法"></a>3、通过反射获取并调用方法</h3><p>(1)获得当前类以及超类的public Method</p><pre><code>Method[] arrMethods=classType.getMethods();</code></pre><p>(2)获得当前类申明的所有Method</p><pre><code>Method[] arrMethods=classTyep.getDeclaredMethods();</code></pre><p>(3)获得当前类以及超类指定的public Method</p><pre><code>Method method=classType.getMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(4)获得当前类申明的指定的Method</p><pre><code>Method method=classType.getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes);</code></pre><p>(5)通过反射动态运行指定Method</p><pre><code>Object  obj=method.invoke(Object obj,Object...args);</code></pre><h3 id="4、通过反射获取并调用属性"><a href="#4、通过反射获取并调用属性" class="headerlink" title="4、通过反射获取并调用属性"></a>4、通过反射获取并调用属性</h3><p>(1)获得当前类以及超类的public Field</p><pre><code>Field[] arrFields=classType.getFields();</code></pre><p>(2)获得当前类申明的所有Field</p><pre><code>Field[] arrFields=classFields=classType.getDeclaredFields();</code></pre><p>(3)获得当前类以及超类指定的public Field</p><pre><code>Field field=classType.getField(String name);</code></pre><p>(4)获得当前类申明的指定的Field</p><pre><code>Field field=classType.getDeclaredField(String name);</code></pre><p>(5)通过反射动态设定Field的值</p><pre><code>field.set(Object obj,Object value);</code></pre><p>(6)通过反射动态获取Field的值</p><pre><code>Object obj=field.get(Object obj);</code></pre><h3 id="5、举例"><a href="#5、举例" class="headerlink" title="5、举例"></a>5、举例</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectionAPIDemo {    public static void main(String[] args) throws Exception{        /**         * 只要用到反射，先获得Class对象。没有方法能够获得当前类的超类的private方法和属性，         * 你必须通过getSuperclass()找到超类以后再去尝试获得。通常情况下，即使是当前类，         * private属性或者方法也是不能访问的，你需要设置压制权限setAccessible(true)来         * 取得private的访问权。但这样的话，就破坏了面向对象的规则，所以除非万不得已，尽量少用。         */        //获取Emploee这个类所关联的class对象        Class&lt;?&gt; classType=Class.forName(&quot;com.iotek.reflect.Emploee&quot;);        //通过反射机制来构造一个Emploee的实例对象(默认调用无参的构造方法)        Emploee emploee=(Emploee)classType.newInstance();        //调用指定的构造方法来实例化对象        Constructor&lt;?&gt; constructor=classType.getConstructor(new Class[]{});        Emploee emploee2=(Emploee)constructor.newInstance(new Object[]{});        System.out.println(emploee);        System.out.println(emploee2);        //调用指定的构造方法来实例化对象(调用带参数的构造方法)        Constructor&lt;?&gt; constructor1=classType.getConstructor(new Class[]{String.class,int.class});        Emploee emploee3=(Emploee)constructor1.newInstance(new Object[]{&quot;zhangsan&quot;,30});        System.out.println(emploee3);        //获取class对象指定的方法，包括私有的        Method method=classType.getDeclaredMethod(&quot;toString&quot;, new Class[]{});        System.out.println(method.getName());        //方法的调用        String desc=(String) method.invoke(emploee, new Object[]{});        System.out.println(desc);        //获取class对象指定的所有方法，包括私有的(私有的是默认不能被访问的)        Method[] methods = classType.getDeclaredMethods();        for(Method method2 : methods){            method2.setAccessible(true);//私有的可以访问了            System.out.println(method2.getName()+&quot;--&gt;&quot;+method2.getModifiers());        }        //获取Class对象所指定的属性，包括私有的(私有的默认是不能被访问的)        Field field = classType.getDeclaredField(&quot;nameString&quot;);        field.setAccessible(true);//可访问了        field.set(emploee, &quot;李四&quot;);        System.out.println(field.get(emploee));    }}class Emploee{    private String nameString;    private int age;    public Emploee(){        System.out.println(&quot;无参构造法方法&quot;);    }    public Emploee(String nameString, int age) {        super();        this.nameString = nameString;        this.age = age;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Emploee [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;]&quot;;    }}</code></pre><h3 id="6、使用反射机制来创建一维数组和二维数组"><a href="#6、使用反射机制来创建一维数组和二维数组" class="headerlink" title="6、使用反射机制来创建一维数组和二维数组"></a>6、使用反射机制来创建一维数组和二维数组</h3><pre><code>package com.iotek.reflect;import java.lang.reflect.Array;public class ReflectionArrayDemo {    public static void main(String[] args) throws ClassNotFoundException {        //创建一个一维数组(String)        Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;);        Object obj = Array.newInstance(classType,5);        Array.set(obj, 3, &quot;abc&quot;);        System.out.println(Array.get(obj, 3));        //创建二维数组(3行3列)        int[] dimens={3,3};        Object obj1 = Array.newInstance(int.class, dimens);        Object obj2 = Array.get(obj1, 2);//获取第三行(它是一个一维数组)        Array.setInt(obj2, 2, 5);//给指定位置赋值        int[][] obj3 = (int[][])obj1;        System.out.println(obj3[2][2]);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Java-lang-reflect库&quot;&gt;&lt;a href=&quot;#1、Java-lang-reflect库&quot; class=&quot;headerlink&quot; title=&quot;1、Java.lang.reflect库&quot;&gt;&lt;/a&gt;1、Java.lang.reflect库&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
</feed>
