<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-04-20T04:43:12.000Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://www.echodemo.cc/2018/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.echodemo.cc/2018/04/20/动态规划/</id>
    <published>2018-04-20T04:38:20.000Z</published>
    <updated>2018-04-20T04:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：</p><pre><code>int F(int n){    if(n==0||n==1) return 1;    else return F(n-1)+F(n-2);}</code></pre><p>然而上述代码会涉及很多的重复计算，由于没有对中间计算的结果进行保存，实际复杂度会高达O(2^n)。这里通过开一个数组来对已计算出来的数据进行保存。</p><pre><code>int dp[max];int F(int n){    if(n==0||n==1) return 1;    if(dp[n]!=-1) return dp[n];    else{        dp[n]=F(n-1)+F(n-2);        return dp[n];    }}</code></pre><p>这样可以将复杂度从O(2^n)降到O(n)。如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有重叠子问题。因此，一个问题必须拥有重叠子问题，才能使用动态规划进行求解。</p><p>2、动态规划的递推写法：其使用的计算方式是自底向上，即从边界开始，不断向上解决问题，直到解决了目标问题为止；而递归写法是自顶向下，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止。以经典的数塔问题为例</p><p>首先开一个二维数组array[i][j]对每层的数据进行存放，由于除第一层之外，每一层都至少会有一条重合的路径。不妨零dp[i][j]表示从第i行第j个数字出发到达最底层的所有路径中能得到的最大和。也就会有dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j]。这里把dp[i][j]称为问题的状态，把这个式子称为状态转移方程。数塔的边界是dp[n][j]==array[n][j]，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn=1000;int array[maxn][maxn],dp[maxn][maxn];int main(){    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++){        for(int j=1;j&lt;=i;j++){            cin&gt;&gt;array[i][j];//初始化数塔        }    }    for(int i=1;i&lt;=n;i++){//边界        dp[n][i]=array[n][i];    }    for(int i=n-1;i&gt;=1;i--){        for(int j=1;j&lt;=i;j++){            dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j];//状态转移方程        }    }    cout&lt;&lt;dp[1][1];    return 0}</code></pre><p>如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么就称这个问题拥有最优子结构。因此，一个问题必须拥有最优子结构，才能使用动态规划进行求解。</p><p>3、两组概念的区分</p><p>(1)分治和动态规划</p><p>分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题。</p><p>(2)贪心和动态规划</p><p>贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程对数塔问题而言，贪心法从最上层开始，每次选择左下和右上两个数字中较大的一个，一直到最底层得到最后的结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶下下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，他总是会考虑所有的子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士割腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int F(int n){
    if(n==0||n==1) return 1;
    else return
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1002 A+B for Polynomials</title>
    <link href="http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/"/>
    <id>http://www.echodemo.cc/2018/04/13/PAT-A1002-A+B-for-Polynomials/</id>
    <published>2018-04-13T13:49:02.000Z</published>
    <updated>2018-04-13T13:57:54.726Z</updated>
    
    <content type="html"><![CDATA[<p>This time, you are supposed to find A+B where A and B are two polynomials.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p><p>Output Specification:</p><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><pre><code>Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5Sample Output3 2 1.5 1 2.9 0 3.2</code></pre><p>此题在一开始写的时候没有注意到当输出系数不为零的个数为0时的情况，故导致格式错误。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main() {    double a[1001] = { 0.0 }, b[1001] = { 0.0 }, c[1001] = { 0.0 };    int m, n;    cin &gt;&gt; m;    for (int i = 0;i &lt; m;i++) {//初始化第一个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; a[j];        c[j] += a[j];    }    cin &gt;&gt; n;    for (int i = 0;i &lt; n;i++) {//初始化第二个多项式        int j;        cin &gt;&gt; j;        cin &gt;&gt; b[j];        c[j] += b[j];    }    int num = 0;    for (int i = 0;i &lt; 1001;i++) {//计算系数非零的个数        if (c[i] != 0) num++;    }    cout &lt;&lt; num;    if (num != 0) cout &lt;&lt; &quot; &quot;;//这里需要注意    for (int i = 1000;i &gt;= 0;i--) {        if (c[i] == 0) continue;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;        printf(&quot;%.1f&quot;, c[i]);        num--;        if (num != 0) cout &lt;&lt; &quot; &quot;;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;/p&gt;
&lt;p&gt;Each input file contains on
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1001 A+B Format</title>
    <link href="http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/"/>
    <id>http://www.echodemo.cc/2018/04/12/PAT-A1001-A+B-Format/</id>
    <published>2018-04-12T09:09:21.000Z</published>
    <updated>2018-04-12T09:51:44.778Z</updated>
    
    <content type="html"><![CDATA[<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><p>Input Specification:</p><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p><p>Output Specification:</p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><pre><code>Sample Input-1000000 9Sample Output-999,991</code></pre><p>此题使用如下代码在PAT测试时出现一个段错误。如有大佬光临寒舍，还望多多指教。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;using namespace std;int main() {    int a, b,sum=0;    cin &gt;&gt; a &gt;&gt; b;    sum = a + b;    if (sum &lt; 0) cout &lt;&lt; &quot;-&quot;;//和为负数，就先把负号输出    sum = (sum &lt; 0) ? -sum : sum;//求绝对值    stack&lt;char&gt; s;    int num = 0;    while (sum) {        s.push((sum % 10)+&apos;0&apos;);//从最低位开始入栈        num++;//统计sum中各个位入栈的个数        if (num % 3 == 0) s.push(&apos;,&apos;);//每当sum的位入栈三次，就把‘，’入栈        sum /= 10;    }    if (s.top() == &apos;,&apos;) s.pop();//如果全栈最顶为‘，’，则直接出栈    while (!s.empty()) {        cout &lt;&lt; s.top();//输出栈顶元素        s.pop();//栈顶元素出栈    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless ther
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>梦境</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A2%A6%E5%A2%83/"/>
    <id>http://www.echodemo.cc/2018/04/08/梦境/</id>
    <published>2018-04-08T04:45:29.000Z</published>
    <updated>2018-04-08T04:47:49.996Z</updated>
    
    <content type="html"><![CDATA[<p>夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一种方式，人在极度的恐惧当中，往往会表现出最本真的自己，没有压抑也没有伪装。人需要有所畏惧，有所敬畏，生于忧患，死于安乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1053 Path of Equal Weight</title>
    <link href="http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/"/>
    <id>http://www.echodemo.cc/2018/04/08/PAT-A1053-Path-of-Equal-Weight/</id>
    <published>2018-04-08T02:12:36.000Z</published>
    <updated>2018-04-08T02:29:46.326Z</updated>
    
    <content type="html"><![CDATA[<p>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p><p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1.</p><p>Input Specification:</p><p>Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt;= 100, the number of nodes in a tree, M (&lt; N), the number of non-leaf nodes, and 0 &lt; S &lt; 230, the given weight number. The next line contains N positive numbers where Wi (&lt;1000) corresponds to the tree node Ti. Then M lines follow,each in the format:</p><pre><code>ID K ID[1] ID[2] ... ID[K]</code></pre><p>where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</p><p>Output Specification:</p><p>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p><p>Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &lt;= k &lt; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 &gt; Bk+1.</p><pre><code>Sample Input:20 9 2410 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 200 4 01 02 03 0402 1 0504 2 06 0703 3 11 12 1306 1 0907 2 08 1016 1 1513 3 14 16 1717 2 18 19Sample Output:10 5 2 710 4 1010 3 3 6 210 3 3 6 2</code></pre><p>题目大意：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be t
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>树的静态写法和遍历</title>
    <link href="http://www.echodemo.cc/2018/04/08/%E6%A0%91%E7%9A%84%E9%9D%99%E6%80%81%E5%86%99%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86/"/>
    <id>http://www.echodemo.cc/2018/04/08/树的静态写法和遍历/</id>
    <published>2018-04-08T02:01:52.000Z</published>
    <updated>2018-04-08T02:04:13.825Z</updated>
    
    <content type="html"><![CDATA[<p>1、存储结构</p><p>由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态分配。</p><pre><code>struct node{    typename data;//数据域    vector&lt;typename&gt; child;//指针域，存放所有子节点的下标}Node[maxn];//节点数组，maxn为节点的上限个数</code></pre><p>2、新建一个节点</p><pre><code>int index=0;int newNode(int x){    Node[index].data=x;//数据域为x    Node[index].child.clear();//清空子节点    return index++;//返回节点下标，并令index自增}</code></pre><p>3、先根遍历</p><pre><code>void preOrder(int root){    cout&lt;&lt;Node[root].data&lt;&lt;&quot; &quot;;//访问当前节点    for(int i=0;i&lt;Node[root].child.size();i++){        preOrder(Node[root].child[i]);//递归访问节点root的所有子节点    }}</code></pre><p>4、层序遍历</p><pre><code>void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre><p>如果需要计算每个节点的层次，存储结构和层序遍历如下：</p><pre><code>struct node{    int layer;    typename data;    vector&lt;typename&gt; child;}void LayerOrder(int root){    queue&lt;int&gt; q;    q.push(root);//根节点入队    Node[root].layer=1;    while(!q.empty()){        int now=q.front();//取队首元素        q.pop();//队首元素出队        cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域        for(int i=0;i&lt;Node[now].child.size();i++){            Node[Node[now].child[i]].layer=Node[now].layer+1;//子节点的层数加1            q.push(Node[now].child[i]);//将当前节点的所有子节点入队        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、存储结构&lt;/p&gt;
&lt;p&gt;由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>平水韵(入声)</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E5%B9%B3%E6%B0%B4%E9%9F%B5(%E5%85%A5%E5%A3%B0)/"/>
    <id>http://www.echodemo.cc/2018/04/07/平水韵(入声)/</id>
    <published>2018-04-07T13:41:30.000Z</published>
    <updated>2018-04-07T13:52:25.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、一屋"><a href="#1、一屋" class="headerlink" title="1、一屋"></a>1、一屋</h2><p>竹 屋 谷 目 木 熟 菊 腹 哭 服 肉 独 福 速 逐 禄 鹿 麓 肃 轴 牧 宿[住宿] 卜 陆 六 族 筑 毂 祝 沐 斛 馥 穀 犊 掬 缩 築 牍 叔 读[读书] 粥 簇 蹙 复[往来也，返也] 育 秃 覆 碌 復 伏 穆 渎 戮 淑 蓄 縠 矗 扑 幅 镞 菽 漉 竺 燠 蓿 蔌 撲 瀑 曲[酒曲] 簌 椟 睦 鵩 鞠 鹜 觫 蹴 簏 蝠 黩 郁 霂 塾 澳 谡 夙 辘 餗 麴 恧 仆[群飞貌] 畜 榖 衄 洑 濮 蔔 槭 樕 毓 辐 朴 複 孰 匊 倏 浊 舳 醭 讟 樸 輻 鬻 僇 煜 角 蝮 稑 暴[日乾也] 箙 昱 彧 槲 曝 啄 鞫 朒 盝 韣 匐 睩 琭 龊 蓼 蹜 滀 毣 忸 鵴 瀫 俶 踧 袱 鹔 柷 澓 髑 輹 柚 搐 摝 瘯 慉 殰 鏕 碡 副[剖也，判也，裂也] 囿 菔 茯 薁 剭 螰 苜 踀 喌 嘼 蔟 虙 趚 骕 蹗 鱐 楅 贕 鵚 簶 閦 噈 缪[与穆同] 稢 虪 穋 觳 朷 告 葍 腛 勠 鋉 瑴 縬 濲 摍 藗 焀 蓛 熇 遬 汋[激水声也] 蹼 唷 唂 橚 趢 儥 蜟 拲 娽 坶 蔛 涑 樚 鶝 踾 跾 豖 匑 翏 錥 圥 鴔 趗 栜 棴 鮛 楘 蚞 襡 艒 纀 蕧 栿 獛 熝 嬻 躹 鵱 蔍 茿 剹 諔 踿 喐 韇 蓫 沑 鱁 蟏 梀 惐 梮 皾 莥 逳 箼 荲 騼 宓 騳 驧 潚 畐 斀 稪 萺 莤 玊 哊 鉐 鵦 癁 鉃 粶 丵 焂 埱 坴 襆 敊 涋 粷 喅 蓻 鱳 瓄珿  軮 鳆 踓 剢 犕 鑟 蔋 椈 嗀 聏 琡 鞪 鏉 蘛 鼀 疛 巈 淕 絥 鄜 齱 璛 淯 璹 樢 婅 蒮 斣 穙 鍙 趜 雮 偪 阿[阿谁] 疁 骲 篴 媨 罜 殐 掓 稶 嚛 磩 槒 膔 栯 礇 炑 鄐 鳪 轐 殧 塶 螜 閰 媉 棛 篫 諨 摵 椱 砡 樎 鎐 誎 垘 苖 婌 泦 椂 鐭 攴 堉 嗖 鯥 觷 觻</p><pre><code>其它僻字：</code></pre><p>䘵 䩮 䮷 䱙 䎘 䍡 䉛 䃤 䛢 㳤 㰗 㜚 䞱 䃙 㕰 㰲 㓘 䑿 㚆 䫝 㽤 㥔 䙒 㶖 䜡 㲫 㩋 㧅 䟿 䥮 䘻 㓐 䢱 䟟 䋭 䢗 㑉 䗇 䴪 䇚 䃞 㪩 䑁 䔎 㦇 䊾 䄾 䘐 䋹 㜙 㮋 䏋 㗤 㤢 䗛 㥌 䶊 䪁 㠅 㣎 㜅 㬼 䐨 㼾 䧤 䎌 䡜 䕮 䈸 䜯 䫳 㾄 䃚 㘲 䏱 㝛 䨱 䵈 㾥 㻃 㒔 䪕 䟮 䌒 䎼 㖨 㴼 䮱 䳱 㡔 㵀 䨹 㞺 䞽 㑐 㛬 䙯 㪶 㯟 䤋 㙏 䗱 䚼 䎑 㯈 㜈 䛙 䜼 䱡 䐿 㑛 㯷 䐁 䀰 㣃 㷤 㺉 䀲 㹼 㪖 䖡 㽇 㾇 㞘 㬘 䇍 㦽 𨌥 𪇰 𥪋 𪘏 𩶫 𠱙 𩋟 𣖫 𡡐 𧼭 𣨍 𩑒 𥲒 𥉑 𥳇 𡰿 𪃃 𣤶 𦪇 𤞞</p><h2 id="2、二沃"><a href="#2、二沃" class="headerlink" title="2、二沃"></a>2、二沃</h2><p>绿 玉 俗 烛 足 续 粟 束 促 辱 局 鹄 躅 欲 录 蜀 触 毒 浴 狱 旭 瞩 箓 属 酷 渌 醁 笃 沃 曲 赎 褥 斸 勖 督 嘱 溽 梏 缛 鹆 纛 菉 騄 蠋 蓐 瘃 峪 趣 牿 顼 仆 鄏 幞 裻 告 挶 鳿 喾 襮 歜 輂 斶 锔 鋈 逯 藚 媷 臅 虑 憟 匤 熇 臛 旮[同旭] 蛐 欘 趢 犦 哫 灟 拲 娽 傉 彳 鸀 駶 軉 筁 蝳 蠾 趗 髷 镤 薥 鋊 脨 砡 檋 琟 輍 頶 俈 捁 泶 斀 珛 钃 搙 潥 隺 絭 悎 觷 螸 傶 襡 钰 洬 嚛 錊 噣 孎 錖 誎 嗕 斣 襆 疁 梮 捒 蔋 鶮</p><pre><code>其它僻字：</code></pre><p>䠱 䪅 㯮 㒒 䒼 䟉 㮂 䥔 䌚 㙇 䞖 䶜 䎤 䌵 䜹 㻿 䞝 䧊 䕽 䙱 䐂 䳔 䡞 䚄 䑑 䅶 䋰 䚛 䛤 㫽 䱚 䴰 㩴 䴆 㿥 㔄 䧼 䅇 㦺 䈞 𤌍 𧰵 𧛔 𩌮 𤞞</p><h2 id="3、三觉"><a href="#3、三觉" class="headerlink" title="3、三觉"></a>3、三觉</h2><p>学 岳 朔 幄 渥 角 濯 邈 握 璞 剥 觉[知觉] 琢 确 卓 壳 雹 擢 鷟 槊 斲 荦 捉 驳 浊 喔 啄 榷 桷 数 [频数] 朴 駮 灂 诼 乐[音乐] 龊 樸 埆 搉 啅 镯 较 倬 珏 戳 鸑 涿 翯 鸴 跑 桌 踔 娖 鸐 硞 峃 椓 擉 药 浞 謈 悫 搦 碻[同确] 鋜 豰 懪 穱 欶 爆 瞀 瓝 偓 瑴 韄 嚗 傕 箾 穛 噣 眊 觳 搠 斠 斮 龌 掿 捔 趵 礐 蒴 烞 晫 洬 嗍 鵫 墣 蠗 窇 鞄 籗 瓁 悎 瞐 鞪 皃 汋 隺 鎙 劰 燢 豿 娕 礭 仢 欘 韷 泶 飑 矠 骲 楃 斀 丵 瞨 墧 鳆 硺 觷 腛 燩 棹[树 枝 直 上 貌] 钋 鑡 簎 菿 龏 敩 攴 顜 齺 篧 捳 髉 琸 珿 犦 籱 搻 壆 鳪 媉 齱 殐</p><pre><code>其它僻字：</code></pre><p>㧻 㲉 㩧 䃗 䓎 㙾 㰌 㓸 䂍 㮶 㼎 䈏 䑈 䁷 㰒 䃕 䪨 㔬 䮸 㱿 䦠 㙸 㺪 㹒 㿺 㺟 㪬 䇶 㱋 㹊 䨌 㴶 䡈 㦝 䥤 䮓 㵡 䥃 䠎 𥢔 𢁁 𩣡 𪑱 𦢊 𥭖 𢷏 𩺽 𥭓 𧲐 𧞐 𤓊 𧣚</p><h2 id="4、四质"><a href="#4、四质" class="headerlink" title="4、四质"></a>4、四质</h2><p>日 笔 室 一 失 密 术 实 術 疾 逸 律 毕 匹 膝 出 帙 漆 栗 溢 诘 七 橘 必 述 秩 吉 蜜 恤 瑟 乙 质 栉 秫 虱 蟀 荜 悉 慄 黜 弼 叱 潏 嵂 嫉 汩 朮 谧 戌 昵 窒 篥 镒 率 侄 怵 锧 骘 壹 卒[终也] 筚 绌 节 佚 苾 鹬 轶 跸 驲 茁 抶 桎 唧 姪 崒 獝 繂 沭 疋 韠 遹 繘 泆 罼 鳦 袐 铚 衵 蟋 凓 飋 聿 飶 霱 咥 蒺 袟 蔤 沏 泌 鴥 蛭 佾 訹 珌 妷 挃 鞸 礩 厔 耴 尼[近也，止也] 茟 肸 熚 觱 堲 翐 紩 桼 傈 瀄 踤 窋 姞 駜 溧 晊 帅 捽 矞 佶 拮 鷅 銊 馝 璱 饆 佖 荗 膟 鴄 眣 瓆 鬻 摔 圪 咭 沕 疙 宓 蛣 滭 枇[枇杷] 鉥 郅 鹎 銡 楖 怸 螲 怭 铋 滗 趌 黢 鱊 痆 窸 齣 滵 柣 庢 呹 箻 鷝 秷 峚 狤 珬 欪 祑 胵 螏 逫 蠠 秖 抳 塛 榓 跮 恎 絉 鮅 欰 炢 咰 趉 袕 揤 浂 擳 銉 肷 柫 衹 眰 比[比次也] 鏎 腟 僁 焌 搮 恄 箤 燏 鴓 笜 怷 麜 臷 鲒 豑 犵 臸 秪[与秖通，适也] 蝍 詄 瑮 郆 縪 妼 琗 寽 祇[适也，仅仅也] 嬄 宲 鶐 炪 鴶 邲 祗[与祇通，适也] 胇 欥 洷 柒 暨 彃 淧 樒 膣 魓 槉 鞊 櫍 驈 蹫 欯 釰 芛</p><pre><code>其它僻字：</code></pre><p>䫻 䁥 㗚 䘌 䭿 䬆 䟆 䎉 㘉 㾁 䮡 㔕 㯃 䢖 䫕 㵥 䮇 㪤 㺩 㻎 䒤 䏘 䑇 㓖 䶡 䵒 䢞 㗧 䬹 㻫 䬛 䳳 㟳 䔁 䩛 䢦 㚕 㣟 䬄 䣛 㴵 㮿 㜱 㜼 䱃 㑁 㤕 䢤 㞊 㫘 㣰 䄶 㻶 䔞 㳑 䌏 䡃 㧒 㢶 䤎 㳚 㰵 㗭 㘍 㳼 㮚 䱣 䟈 䏄 䆝 䘤 㔑 㢸 䜉 䳀 䰬 㺷 䋖 䜠 㳴 䖩 㻭 䵑 䢕 㗌 䟣 䤉 㖅 㑵 㲺 㤜 𥠈 𪗨 𥣮 𡢑 𧾣 𧫤 𧗿 𦝭 𦳯 𧽻 𢘍 𧾢 𩋡 𪗻</p><h2 id="5、五物"><a href="#5、五物" class="headerlink" title="5、五物"></a>5、五物</h2><p>物 佛 屈 拂 绂 乞 黻 綍 勿 绋 祓 诎 郁 讫 屹 茀 韨 倔 黦 咈 弗 歘 怫 髴 芴 欻 仡 蔚 刜 沕 崛 不[与弗同] 吃[言蹇难也] 掘 熨 岪 汔 迄 坲 镼 釳 厥[突厥] 魆 肸 艴[色怒也] 尉 岉 沷 菀 昒 忔 鶌 粅 灪 帗 炥 誳 鮄 芞 柭 爩 紑 嶏 蛂 昲 冹 莔 烼 袦 虳 柫 弡 翇 趉 伆 鉘 乀 砩 阢 笰 甶 芾 惌</p><pre><code>其它僻字：</code></pre><p>㗵 䘿 㭾 䏌 䎢 㷉 䵥 䭮 㐹 䖇 䁌 㻕 䒗 䰴 䛥 㪄 䞞 䠇 䞷 㠨 𠜾 𨧱 𧿳</p><h2 id="6、六月"><a href="#6、六月" class="headerlink" title="6、六月"></a>6、六月</h2><p>月 发 發 骨 阙 没 髮 窟 忽 兀 伐 谒 袜 樾 钺 笏 粤 蕨 突 襪 渤 惚 歇 勃 殁 罚 筏 越 窣 曰 阀 蹶 柮 讷 卒[士卒] 屼 劂 橛 猝 獗 羯 杌 矻 矹 竭 卼 滑[乱也] 鹘 軏 腯 搰 咄 淈 垡 硉 蠍 崒 纥 揭 碣 汨 馞 撅 峍 蟨 核 掘 哕 刖 愲 狘 扢 凸 暍 孛 浡 嗢 堀 鷢 揬 悖 讦 捽 曶 榾 泏 扤 鳜 蚏 抇 阏 龁 抐 瞂 胐 麧 玥 蜶 匫 钀 莈 不 厥 崛 脖 唿 昒 饽 鹁 棁 囫 镢 犵 钠 腽 淴 怢 馉 艴 猲 蓇 桲 葧 椊 葖 稡 阢 昢 瘚 侓 馧[馧馞] 饳 蚎 荸 鈯 嶡 絗 縎 鼵 鶟 杚 枂 颰 冹 榲 趃 亅 埣 坺 顝 熓 怴 朏 籺 摕 侼 欮 堨 迌 趉 寣 揾 瞃 囝 憠 宊 殨 笜 舭 郣 捸 璏 抈 殟 橃 沷 熭 碿 藅 鋍 尳 湥 岄 垏 鍎 歾 琷 鍻 啒 瘟[心闷貌] 糏 哱 犻 貀 鼿 榲 挬</p><pre><code>其它僻字：</code></pre><p>㪍 䬂 䓤 䎳 㷎 㶿 䞘 䨚 䑔 䬍 䥟 䓛 㖀 㫚 䴯 䚝 㪐 䦍 䟠 㻠 䎀 䖓 䘚 䣹 㳷 㩿 㐳 䩐 㧾 㟑 䪬 㵐 㒴 䡇 䝆 䑢 㨡 䀜 䯇 䟜 㬞 䇅 䂗 䁫 㘺 㴾 䯿 䋐 䙠 䭯 㔜 㵠 䍪 䠈 㲞 㞽 㧮 㾶 㛘 㽾 䮩 䪲 㕹 㛲 𣔻 𩨳 𧉦 𩑡 𢷒 𢪏 𧽸 𩗓 𥝖 𪁽 𪘧</p><h2 id="7、七曷"><a href="#7、七曷" class="headerlink" title="7、七曷"></a>7、七曷</h2><p>阔 末 活 脱 渴 豁 钵 夺 闼 葛 割 沫 聒 抹 遏 拨 泼 达 括 秣 剌 跋 辣 魃 怛 萨 蝎 斡 轕 栝 撮 筈 挞 茇 躠 撒 捋 喝 頞 臈 鹖 敚 褐 鞨 掇 拶 鱍 粝 囋 喇 獭 钹 适[疾也] 鞑 靺 澾 髺 裰 妺 拔 阏 噶 剟 跶 曷 軷 毼 摋 袯 越 咄 蘖 哒 獦 呾 泧 嶱 酦 犮 胺 炟 胈 焥 荙 繓 鸹 捾 暍 鏺 丐 挖 轹 碣 捺 咱 叭 侻 饐 齾 妲 嶭 笪 齃 猲 瘌 鵽 蛞 蝲 敠 靼 嵑 濊 帓 枺 粖 姡 頢 攥 囐 揦 蟽 茉 鼥 癹 礤 萿 毲 秳 癶 莌 妭 頱 濣 趏 蛶 睕 柭 嬒 餲 炥 魩 秡 狚 冭 灒 懖 羍 磆 刽 洝 昩 橃 堨 坺 奯 鬝 匃 驋 攃 汰 痥 燤 螛 咹 幯 湏 颰 仴 鲅 蔎 眓 襊 橽 歇 馛 葀 佸 昲 噧 揧 鮵 啈 蹳 捝 炦 攋 抈 骱 皌 鶷 枂 砞 瓎 脟 懀 眜</p><pre><code>其它僻字：</code></pre><p>䌨 㔇 䯋 䡾 䴲 䅥 䍨 䟯 㦫 䄑 㳨 䁊 㸊 䒷 㓉 㵶 㿣 㞈 㕲 䫘 䏞 䟦 䶛 㻝 䟛 䢌 䄆 㵧 㣵 䦢 䯏 䵣 㧊 㒓 䣶 㶬 䯦 㮫 䣪 䱫 䦚 䈓 䕣 䃮 㿹 㣞 䖧 䳁 㵣 㺚 䱅 䯺 䳚 㞉 㖕 㭮 䣮 㩵 䬴 𡾲 𥻦 𣁳 𤁢 𤷈 𤫵 𦮀 𥽘 𨣱 𧘟 𩩲 𤸎 𠯑 𥄕 𥄗 𦤦 𩒲 𩢛 𠱥 𧙕 𤀤 𤃴 𣎵 𤿫 𪘼</p><h2 id="8、八黠"><a href="#8、八黠" class="headerlink" title="8、八黠"></a>8、八黠</h2><p>札 刹 八 察 辖 黠 轧 戛 杀 煞 刮 猾 哳 扎 恝 揠 瞎 秸 滑 圠 楬 拔 蚻 肭 擦 嘎 茁 嗗 窡 刷 齾 铡 妠 豽 扴 鬝 扒[刨，挖] 铩 稭 榝 螖 搳 颉 劼 娺 圿 秳 痆 帓 汃 鹘 帕 獭 捺 咶 刖 紥 鸹 錣 磍 鴶 擖 砎 捌 朳 哵 鶷 傄 礣 劜 窫 詙 鲒 聐 磆 柭 菝 詚 蠿 猰 颳 耫 捾 糪 忦 硈 揳 玐 骱 眣 摖 鱊 咭 閁 捖 帴 睰 釛 嗐 縖 袺 檫 趏 仈 歇 螛 袹 鵽 叭 釟 貀</p><pre><code>其它僻字：</code></pre><p>䀣 㗫 㓤 䕓 䝟 䦪 㮖 㔍 䴳 㓞 䫄 䀨 㨸 䃰 䶪 䱻 䯉 㑻 䓭 䥷 㭭 䦖 䵵 㪴 㕯 㳐 䚴 䂒 㺴 䆯 㔠 䤢 䰲 𡇼 𪙻 𤫶 𪆰 𪈟 𪇷 𦤙 𠝚 𥴭 𩮁</p><h2 id="9、九屑"><a href="#9、九屑" class="headerlink" title="9、九屑"></a>9、九屑</h2><p>雪 别 绝 灭 血 结 拙 热 穴 洁 铁 裂 列 烈 缺 辙 诀 杰 舌 悦 节 彻 说 设 屑 决 哲 冽 劣 咽[呜咽] 阅 切 澈 折 缬 阕 辍 孽 鳖 玦 瞥 窃 啜 鴂 爇 埒 绁 齧 垤 截 撷 挈 跌 耋 泄 掣 嵲 泬 谲 歇 撤 吷 糵 孑 涅 迭 餮 撇 亵 薛 蔑 洌 鐍 竭 抉 蕝 瓞 桀 惙 噎 拽 浙 卨 楔 臬 契 歠 闑 闭 絜 缀 蠛 僣 臲 褉 页 觖 襭 霓 篾 碣 绖 揭 捏 蹩 衊 凸 蘖 巀 昳 岊 媟 呐 驖 莂 隉 轶 緤 晢 颉 哔 楶 朅 蛚 禼 茁 趐 刷 掇 苶 嶭 焫 茢 捩 锲 揲 蜇 摰 咥 讦 蜺 渫 瘪 碟 拮 醊 棁 搣 疖 蠥 蠘 丿 锊 蛭 桔 鷩 橇 迾 趹 蛣 槷 偈 辥 悊 颲 幭 挒 嫳 棳 篞 馝 絬 准[颊权也] 覈 佚 批 褐 谳 姪 踅 憋 龁 帨 剟 咧 紒 屮 唰 瀎 詄 趔 硩 潎 蟞 奊 跮 蠽 咇 僪 蠮 蚗 爡 刔 襒 畷 蒛 蛥 嵥 糏 蔎 懱 芵 鐅 瞲 蛈 僁 醛 掜 蝢 逫 鱴 櫗 囐 藒 孓 赽 趃 袺 啘 蛂 鲒 胅 鈌 鴷 脟 敜 駃 蠿 齛 罬 烲 砓 栨 彆 蠞 夨 呭 滊 臷 幯 鱊 猰 揳 螲 聺 勶 镻 棙 潱 爄 摕 狤 迼 聅 鄨 笍 湀 洯 眓 攦 劽 坲 乴 鮤 朳 莭 恎 叕 靼 滐 粖 姴 趌 蛶 魝 痥 袕 郣 覕 炦 洇 捌 緳 瞮 尐 榝 稧 柭 妜 蛞 擳 栵 諁 籺 蛪 歽 矞[同谲] 詍 睙 搩 靾 炔 眣 蜹 疶 敠 哾 桖 怢 戜 疀 麧 鑖 眜 苵 嵽 巁 眰 揊 炪 哷 坹 櫍 瘛 鴓 虌 徶 疦 馛 砄 毻 燤 櫭 菍 暼 娎 剈 翓</p><pre><code>其它僻字：</code></pre><p>㧙 㙞 䨮 䁾 䥫 䆷 㿱 䫾 㗧 䕵 䖦 䚢 䞵 㴮 㛃 㬯 㔢 㴪 䇷 㩪 㴽 䌩 㝂 㲳 䫎 䘊 㘿 㓭 䅀 䭇 㯙 㳿 䋉 䂼 䒸 㮮 䌘 䂐 䳤 㭞 㓗 䙽 䩤 䦑 䪼 䆕 䊦 䱑 㸞 㩢 䦬 䊝 㖶 㢼 㸹 㤠 䯵 㐖 㨝 㬚 㭩 䮕 㭈 䩧 㖏 㔃 㔡 䍳 䫼 㦢 䆢 㘶 䟹 䛎 㹟 䠥 䋢 䤿 䏟 䭱 䝌 䟙 㔎 䘷 䒆 䘁 䓆 䨆 䏳 䟾 䞰 㼤 䀗 㣯 䩏 㒝 䏐 㕞 㸅 㓶 䈼 㞕 䥕 䏲 䲙 䐼 㽟 𡿖 𧤾 𢴲 𣧵 𠱕 𡿪 𧎩 𧧸 𩖶 𢗗 𢯳 𢲼 𥉓 𠻜 𥈾 𩠻 𨵪 𤊾 𩢾 𨆳 𥄎 𪏺</p><h2 id="10、十药"><a href="#10、十药" class="headerlink" title="10、十药"></a>10、十药</h2><p>落 薄 鹤 阁 壑 寞 郭 托 酌 漠 泊 略 脚 雀 却 廓 昨 託 跃 洛 弱 缚 恶 鹊 作 萼 乐[哀乐] 约 诺 索 爵 削 钥 橐 络 着 博 错 箔 铄 著[同着] 藿 谑 箨 虐 柝 幕 灼 铎 嚼 礴 霍 怍 鹗 药 愕 瘼 烁 凿 屩 若 酢 籥 锷 讬[同托] 搏 酪 勺 崿 粕 噱 攫 杓 斫 度[谋也] 鳄 蠖 雘 彴 各 掠 莫 貉 涸 镬 谔 绰 疟 鄂 穫 瀹 垩 恪 珞 拓 笮 魄 摸 骆 膊 椁 爚 膜[肉膜] 箬 矱 扩 噩 萚 雒 玃 烙 缴 搁 堮 镈 蠚 泺 获 妁 遌 鞟 焯[明亮] 腭 龠 彍 泽[星名] 爝 格[树枝也] 獲 蒻 亳 钁 艧 饦 礿 礡 矍 醵 咢 襮 躩 蹻 跞 臛 镆 郝 硌 皭 霩 臄 篗 皵 臒 鑮 熇[与謞同] 踱 芍 岝 矐 郤 皬 轹 柞 嗃 煿 蒪 蒦 糳 悫 斮 汋 攉 靃 謞 欂 漷 戄 瞙 飵 鄀 汑 鄚 蝁 猎 躇[超也] 昔 琧 燋 暯 婥 厝 咯 逴 喏 胳 迮 鷇 貜 颚 犦 隺 鐯 瀖 碏 袼 嚯 鮥 猼 喥 彠 辵 婼 硸 袥 烵 凙 矆 楉 馲 鄗 峈 縸 沰 剒 胉 嚩 磭 馎 貈 嗼 杔 崞 毭 剫 笿 矌 犳 曤 鞒 踖 焲 櫎 蘁 偔 娋 莡 稓 慔 謶 蛒 仢 藃 莋 櫮 鎍 岞 秨 逽 魠 敫 覨 劐 斱 擆 狛 搻 鶸 彏 圴 嚛 鈼 撗 谻 櫡 湂 扚 葃 鑩 棤 檴 噋 矡 鱳 籱 溹 嫋[长貌] 擽 庹 庴 縒 矺 癋 妰 詻 嬳 龥 跅 仛 纅 铬 蹃 趞 蠼 鶮 鹱 茖 繑 禚 铂 墌 癨 塻 蠌 牔 鬕 婩 砟 檡 挄 鰝 苲 佫 侂 籗 渃 蘥 鸙 溺</p><pre><code>其它僻字：</code></pre><p>䋏 㟧 㠋 㹱 䨥 㜰 䱜 䭦 䮤 㓢 㸕 㒂 䧄 䖃 㦜 㦡 㿑 㦍 䨰 䎰 㬦 㚟 㤞 䎊 䖼 㕡 䌇 㸲 㪾 㗥 㨯 䶳 䪙 㮙 㨼 䨣 䈷 㴖 䅴 㘀 䣤 䖛 㩱 䝫 䂄 䚥 㷾 㲋 䁨 䯨 䫷 䧐 䟑 䶈 䶅 䠯 㖸 㬍 㓵 䁻 㤩 䥬 䛚 䀩 䥣 䗚 䌎 䐘 㰛 䣞 㕁 䅵 䲵 䮬 䬪 㤰 䍸 㱳 㗉 䙏 䐞 䰊 㗁 䇥 䇎 䅂 䤕 㷬 䂮 㑼 䧿 䈅 䖋 㖾 䖈 䋤 䐾 䞢 䢲 㗘 䉟 䄸 䨋 𦞦 𧎾 𧕋 𧍷 𧊜 𠶸 𥴮 𤻲 𢜭 𢱢 𪙍 𩌏 𨷲 𥽿 𠠎 𤄶 𤡯 𩍿 𧤽 𩟓 𧘑</p><h2 id="11、十一陌"><a href="#11、十一陌" class="headerlink" title="11、十一陌"></a>11、十一陌</h2><p>客 白 石 迹 碧 夕 宅 尺 席 隔 策 惜 役 屐 陌 璧 益 伯 赤 癖 柏 窄 百 驿 剧 脉 辟 戟 翮 隙 迫 掷 液 僻 责 麦 昔 释 舄 积 额 厄 泽 册 帛 坼 易[变易] 逆 赫 革 籍 脊 择 拍 谪 帻 碛 掖 拆 魄 瘠 格 斥 腋 奕 擘 怿 绎 获 画[卦画也] 獲 索 磔 译 适 珀 射 舶 藉 汐 弈 檗 蹠 膈 硕 绤 鶒 蹐 啧 轭 貊 只 帼 炙 扼 赜 馘 螫 箦 骼 蜴 斁 穸 阨 唶 帟 摘 疫 划[划破] 埸 踯 襫 虢 蝈 峄 哑[笑声] 摭 核 刺[穿也，伤也] 奭 嚇 襞 腊 祏 覈[同核] 擿 咋 薜 摵 迮 栅 躄 亦 湱 擗 虩 霢 借 踖 磶 搦 蓦 穫 醳 鲫 嗌 槅 騞 嚄 剨 婳 峉 筴 鬲 阸 媳 掴 鹡 喀 塉 耤 齸 莫[静也] 齰 嗝 砉 蚱 潟 觡 圛 粣 鼫 翟 愬 鸊 啯 齚 撠 貘 睗 洦 呃[鸡声。] 霸[古与魄同] 謮 晹 縌  詻 橶 敀 滆 郤 霹 睪 胔 啪 哧 柞[除木] 硅 嘀 虴 徦 蛨 佰 礉 檡 塥 缂 礋 漍 乇 覤 鸅 墌 簂 皟 蕮 蚅 茖 腘 郄 舴 蹃 曎 襗 鐴 鉐 榒 帞 銆 雿 箣 鯣 躤 襀 垎 嗼 鲌 嵴 捇 擌 諽 庴 獈 砈 趞 膉 潪 枙 鳠 扸 鳽 杔 瞔 炈 疒 覞 歵 鈠 厏 頙 銏 犱 焃 檘 澅 燚 苩 岶 茦 蚸 拺 嚿 袹 臵 樍 讗 簎 諎 谻 呄 鰿 焟 楁 嬕 跅 丮 釽 铬 躆 蚇 眲 馲 坄 籷 狛 厝 慖 啋 脨 廦 焲 焬 熤 絔 啙 墿 糪 痬 棤 溹 矠 蠌 烢 凙 褯 聑 矺 鏼 棭 謋 獥 貖 洓 葃 泎 窢 莋 劐 掝 憡 聻 厇 礊 韄 嫧 燡 罊 雃 虉 挀 豛 胉 啇 蛒 瞁 煂 搩 瘷 揢 蒚 鶪 屰 焷 耫 碦 覛 豟 閴</p><pre><code>其它僻字：</code></pre><p>㶁 㗲 㫺 㡿 䘸 䇲 䵂 㧖 㽚 㛭 㦴 䐙 䶦 㥽 䄷 䘔 䃒 㮦 䩹 䳭 䕉 㼟 䐱 㟙 䳆 㩍 䂹 䊞 䘑 㮝 䱮 䛿 㜋 䜺 㑊 㹮 䟄 䬉 䮮 䂸 䐸 䳮 䁺 㡯 㝜 䨛 㘌 㣂 㖪 䮰 㩇 䡛 䧍 䌟 䕪 䭆 㘁 㦎 㠛 㿟 䙐 䈿 䖌 㗆 䰜 䪂 䚂 㭙 䤨 㿭 䲽 䞠 㶠 䣢 䨫 䖨 㣱 䁤 䦝 㴁 䭞 䊂 㳻 㵹 䦴 㼣 㒀 㾊 㦦 䞟 㴒 䂝 䞦 䪝 𠙆 𦒧 𡩡 𤗮 𤖼 𢅰 𤁰 𢓜 𩹺 𡄴 𦵪 𥬰 𡍩 𢮎 𢷾 𢼛 𢯹 𦌠 𢫦 𥆛 𪐏</p><h2 id="12、十二锡"><a href="#12、十二锡" class="headerlink" title="12、十二锡"></a>12、十二锡</h2><p>壁 寂 笛 敌 滴 历 觅 激 戚 檄 绩 击 锡 的 雳 沥 砾 涤 觌 鹢 枥 镝 析 惕 狄 淅 荻 皪 羃 溺 栎 甓 晰 幂 籴 劈 阒 逖 剔 吃 迪 靮 嫡 皙 菂 觋 呖 趯 甋 瓅 霓 鵙 艗 幕 踢 篴 惄 适 轹 阋 汨[汨罗] 焱 郦 鴃 蹢 籊 殈 赥 鼊 摘 蜥 疬 樀 澼 轣 裼 鼜 鬲 倜 礰 緆 秝 翟 鼏 覭 簚 糸 吊 狊 坜 蚸 繴 薂 濗 砳 焃 霹 墒 砉 攦 踧 墼 悐 鶪 幦 虉 磿 幎 嚁 瓋 毄 焬 鐴 菥 譤 苈 塓 湨 鹝 啇 玓 馰 熐 釽 漃 憵 鱳 纅 扸 樍 撽 儮 苖 爏 讈 扚 欫 椺 墑 漞 趘 冖 仢 儥 銢 頔 轚 燩 覛 硩 礕 靋 觻 磩 镉 肑 綼 糑 惁 敫 蒚 犑 獥 婥 蓨 蓧 瞁 歒 廦 鸄 虳 郹 鼳 鄓 蔋 擽 盢 梑</p><pre><code>其它僻字：</code></pre><p>䍥 䍽 㰅 㭊 䓇 䢮 䥶 䤙 㿨 㣙 䟐 䤨 䢰 䚫 㤸 㢩 䴞 䨤 䵠 㻺 䗩 䣓 䮥 㲻 䂆 䖑 䔉 㦘 㹍 㒪 䳬 䁶 㔏 䮭 㬏 䞶 䚐 㛫 䰛 䑀 㱤 䈪 㱹 䌐 㽁 䨀 㱸 㺡 䚍 䟏 㷴 䯜 𪒄 𦸗 𣒃 𡫁 𣤢 𥍧 𥍠 𥍟 𠴫 𣤩 𥛚 𤄎 𦵦</p><h2 id="13、十三职"><a href="#13、十三职" class="headerlink" title="13、十三职"></a>13、十三职</h2><p>色 得 息 国 力 极 翼 侧 直 黑 忆 墨 域 识[知识] 测 棘 职 臆 贼 刻 食 逼 北 恻 默 德 饰 勒 惑 稷 特 则 即 拭 织 蚀 仄 匿 陟 穑 亿 塞[闭塞] 式 植 抑 殖 敕 亟 克 弋 熄 肋 昃 忒 慝 蜮 轼 饬 啬 踣 阈 泐 殛 嘿 洫 翊 薏 赩 湜 纆 僰 屴 杙 愊 寔 崱 裓 墄 匐 罭 愎 嶷 偪 螣[螟螣] 剋 埴 尅 棫 襋 衋 劾 唧 轖 淢 湢 遫 扐 蠈 緎 淂 蟘 幅 或 恧 荝 栻 鷘 鲗 翌 畟 副 仂 餩 醷 侐 釴 鲫 腷 繶 竻 膱 芅 癔 瀷 蒠 淔 稄 戫 蟔 稙 樴 堲 蝍 菔 犆 趩 堛 掝 蕀 蛡 忑 嫟 恜 瘜 黓 楅 冒 蘵 惐 腘 赲 嘚 稫 脦 煏 玏 戠 溭 穓 鉓 遈 棏 蔷 烒 鶝 艒 鲾 禃 潩 捗 畐 霬 噫 皕 嫼 皀 嬂 謋 琙 捑 骮 揤 蚮 爅 熤 踾 浳 螚 蟙 鳨 釛 澺 垘 鄎 氻 潶 艻 閄 朸 臸 忇 諽 檍 焏 悈 窢 茍 烅 嚜 鉽 侙 殕 懎 慗 揊 熼 鳓 阞 懝 繬</p><pre><code>其它僻字：</code></pre><p>㳁 㥾 㚤 㘈 䰥 䁿 䈟 㔴 䵗 䘃 㤫 㮩 㥂 㱇 䄩 䐚 䙷 䯆 䁼 䅞 䧗 㕵 䘅 㯤 䵱 㞃 䬎 㝶 䱛 䭒 㢞 㭲 㷵 㻷 䗷 䞳 㱄 䐈 䖁 㘠 㹄 䩯 䘝 㧹 㥁 䴬 㷶 㽣 㔹 㴧 䦗 㚜 䣧 䎪 䮙 㫯 㥛 㯰 㥀 㥶 䮠 䦼 㮨 㵓 䁇 㞋 䉢 䆐 䤭 𪀦 𧏾 𤜜 𡍫 𥇛 𪂉 𤗚 𩋉 𪑝 𥇙</p><h2 id="14、十四缉"><a href="#14、十四缉" class="headerlink" title="14、十四缉"></a>14、十四缉</h2><p>急 立 入 湿 集 泣 及 邑 十 涩 拾 蛰 习 笠 粒 汲 给 吸 袭 揖 什 级 执 隰 挹 絷 汁 戢 葺 岌 浥 缉 辑 悒 翕 熠 笈 伋 楫 噏 濈 歙 裛 潗 唈 蕺 槢 廿 潝 霫 芨 霵 钑 褶 啃 漐 苙 鳛 湆 礏 飁 雭 圾 煜 闟 砬 歰 熻 鵖 湁 俋 咠 卙 慹 鷑 譅 雴 骉 彶 箿 礘 叺 瓡 岦 鴔 鏶 偮 翜 釞 淁 趇 騽 喅 鴗 蓻 謺 嶯 漝 皀 嬆 湒 譶 馵 鉝 孴 卌 諿</p><pre><code>其它僻字：</code></pre><p>䏉 㴕 㦻 㤂 㙷 㪧 䦹 㠍 䁯 㬛 㵫 䔼 㴔 䶘 䶋 㗊 䩰 䮶 䏠 㲸 㽺 䓃 㣬 䒁 䭂 䉗 㡮 㧀 㱞 㙫 㘊 㿇 䏩 㬤 㗱 䐕 㒊 䇼 䅤 㒆 䲯 䔱 㕸 䙄 㞚 㩉 㞏 㗩 䁒 𧤏 𩆭 𧚨 𩾳</p><h2 id="15、十五合"><a href="#15、十五合" class="headerlink" title="15、十五合"></a>15、十五合</h2><p>合 榻 塔 答 杂 阖 衲 匝 纳 飒 榼 閤 踏 沓 蛤 鸽 盍 遝 荅 塌 蹋 盒 搭 鞳 拉 腊 蜡 帀 蒳 靸 漯 嗑 趿 嗒 噆 鎝 咂 阘 遢 剳 卡 溘 誻 匌 嚃 拓 馺 罨 镴 搕 唈 韐 岋 濌 褟 涾 耠 軜 盖 卅 磕[石声] 哈 瘩 碜 褡 嘁 鲽 瞌 钑 欱 狧 耷 錔 鮯 鞜 鳎 匎 溻 颌 歞 砵 菈 鰪 砐 匒 傝 崉 雥 囃 詥 溚 篕 魶 峇 鉔 峆 鑉 譶 痷 魳 罯 磼 畗 魼 圾 鞥 矺 抸 廅 毾 礘 佮 砝 魥 熆 笚 鎉 翋 龖 儑 姶 磖 拹 笝 殧 柆 铪 硆 厒 榙 枼 韴 遪</p><pre><code>其它僻字：</code></pre><p>䬃 䕹 㔩 䑽 㷈 㗳 䗶 䑥 䂰 䗘 䍇 㛥 䐦 㹺 㧁 㯓 䵬 㕇 䈳 䌈 䐛 䂿 䪏 䧻 㿯 䵽 㕉 䫦 䈫 䈋 䑜 䃳 䶁 䍝 䪞 㕎 㨥 䶀 䙣 䳴 㭼 㠷 㧺 㥺 䢔 䪺 㛕 㾑 䜚 㿴 㽂 䨿 䑪 㝓 㯚 䪚 䞙 㚫 䓠 㰰 䆟 㡴 𩣯 𪘁 𩋊 𨅔 𥁋 𣣹 𦑶 𤎞 𨜴 𤸱 𩎕 𢕬 𧪞 𢶍 𨃚 𡄋</p><h2 id="16、十六叶"><a href="#16、十六叶" class="headerlink" title="16、十六叶"></a>16、十六叶</h2><p>叶 葉 接 蝶 叠 捷 涉 帖 箧 惬 颊 堞 妾 铗 侠 睫 鬣 牒 靥 浃 屧 蹑 荚 协 摄 贴 慑 燮 挟 楫 馌 烨 摺 镊 躞 谍 晔 猎 蹀 捻 辄 跕 嗫 氎 躐 詟 艓 擪 屟 褶 褋 惵 梜 怗 聂 箑 裛 衱 喋 呫 韘 苶 楪 折 炸 笈 籋 襵 歙 鞢 鍱 魇 霎 厌 婕 偞 菨 崨 倢 椄 讘 欇 筴 邋 鲽 熀 蛱 擸 颞 儠 擛 踥 牃 踕 謵 緁 僷 滠 犣 聗 鎑 錜 銸 徢 惗 穕 帹 蠂 痷 鱲 脻 迠 萐 敜 慹 綊 謺 鮿 鯜 埝 挕 踂 瞱 淁 瞸 獦 鑈 聑 褺 鏶 昅 揞 巤 煠 疌 踗 劦 誱 寁 唊 蓻 枼 殜 霅[霅霅，震电貌] 帇 蓵 渫</p><pre><code>其它僻字：</code></pre><p>㲲 㫸 䩞 䈉 䐑 䌖 㱌 䢡 䳖 㪑 䁋 䜆 䝃 䵿 㩎 䇣 䜲 䝱 䐲 㸎 䧪 㡇 㬪 㢵 䤮 䪓 㤴 㥈 䴑 㥦 䪉 㴇 䭟 㢎 㩸 㯿 䯀 㤐 㰼 㭯 㳧 㙷 㚔 䛟 䝓 䈎 䜓 䌰 㑙 㾜 㚲 㼪 㩶 㼲 䌌 㤲 㰔 㒤 䠟 䁽 㨩 㷸 㛍 㽊 䝕 䴴 䥡 䌜 𣶏 𦣀 𢬴 𦔮 𤍞 𪑧 𦀖 𤑻 𣀳 𨓊 𪔪 𩣘 𤗽 𦔼</p><h2 id="17、十七洽"><a href="#17、十七洽" class="headerlink" title="17、十七洽"></a>17、十七洽</h2><p>业 法 甲 劫 峡 怯 洽 匣 压 狎 乏 鸭 插 狭 锸 嶪 夹 闸 押 袷 柙 帢 唼 歃 掐 劄 呷 恰 裌 翣 胛 硖 邺 霎 陜 霅 箑 嗋 祫 眨 跲 啑 郏 恊 鵊 扱 凹 胁 鞈 搯 熁 玾 喋 愶 筴 岬 胠 葜 烚 渫 擖 姂 庘 哈 钾 萐 嚈 魻 圔 喢 蜐 饸 譗 姶 湆 魥 鉣 驜 呿 翜 韐 疀 笚 埉 厒 笝 煠 殗 搚 痷 铪 唊 欱[与歃同。尝也] 翈 昅 磼 曱 珨 鸈 魼 歰 嶯 澲 砝 疺 圶 抾 帹 炠 筪 拹 殜 餣 舺 殎 垥 偛</p><pre><code>其它僻字：</code></pre><p>䶎 㡊 㰱 䬊 䆘 㭘 㵊 㕅 㛼 㳌 䖎 㡋 䎎 䛅 䨐 䧨 䕛 䤶 䛽 㘝 㹤 䂲 䮢 㗼 㽠 䞩 㾀 㙝 㴙 㮑 䱒 䀴 㓣 䮜 䖖 䀷 䀫 䩡 䘥 䲜 㘡 㾎 䁆 䁍 㑢 㿓 㸣 㵤 䶝 㭱 㷅 𢘉 𣣲 𩌍 𢂷 𤴼 𠗨</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、一屋&quot;&gt;&lt;a href=&quot;#1、一屋&quot; class=&quot;headerlink&quot; title=&quot;1、一屋&quot;&gt;&lt;/a&gt;1、一屋&lt;/h2&gt;&lt;p&gt;竹 屋 谷 目 木 熟 菊 腹 哭 服 肉 独 福 速 逐 禄 鹿 麓 肃 轴 牧 宿[住宿] 卜 陆 六 族 筑 毂 祝 
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>PAT A1020 Tree Traversals</title>
    <link href="http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/"/>
    <id>http://www.echodemo.cc/2018/04/07/PAT-A1020-Tree-Traversals/</id>
    <published>2018-04-07T08:14:39.000Z</published>
    <updated>2018-04-07T09:00:09.858Z</updated>
    
    <content type="html"><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p><p>Input Specification:</p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p><p>Output Specification:</p><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p><pre><code>Sample Input:72 3 1 5 7 6 41 2 3 4 5 6 7Sample Output:4 1 6 3 5 7 2</code></pre><p>题目大意：给出二叉树的后序和中序序列，输出这棵二叉树的层序序列。(所有的二叉树节点的数据都是互不相等的正整数)</p><p>分析：根据二叉树的后序和中序序列可以重建二叉树，再对重建好的二叉树进行层序遍历。</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;queue&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}int n;int j=0;void layerorder(node* root) {    queue&lt;node*&gt; q;//存储节点地址的队列    q.push(root);//根节点入队    while (!q.empty()) {        node* now = q.front();        q.pop();//将队首元素出队        cout &lt;&lt; now-&gt;data;//访问队首元素        j++;        if(j&lt;n) cout&lt;&lt;&quot; &quot;;        if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);//如果左子树不空，将左子树入队        if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);//如果右子树不空，将左子树入队    }}int main() {    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    layerorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存空间    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are s
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="PAT A" scheme="http://www.echodemo.cc/tags/PAT-A/"/>
    
  </entry>
  
  <entry>
    <title>由中序和后序序列输出先序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由中序和后序序列输出先序序列/</id>
    <published>2018-04-07T07:55:20.000Z</published>
    <updated>2018-04-07T08:40:36.703Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树    if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = post[postR];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == post[postR]) {//在中序序列中找到根节点            break;        }    }    int num = k - inL;//左子树的节点个数    //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1]    root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR]    root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void preorder(node* root) {//先序遍历二叉树    if (root == NULL) {        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *in = new int[n];//new一个变长的int型数组    int *post = new int[n];    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    for (int i = 0;i &lt; n;i++) {//输入后序序列        cin &gt;&gt; post[i];    }    int inL = 0,postL = 0, inR = n - 1, postR = n - 1;    preorder(create(in, post, inL, inR, postL, postR));    delete[] post;//释放内存    delete[] in;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>由先序和中序序列输出后序序列</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://www.echodemo.cc/2018/04/07/由先序和中序序列输出后序序列/</id>
    <published>2018-04-07T06:58:11.000Z</published>
    <updated>2018-04-07T08:39:59.971Z</updated>
    
    <content type="html"><![CDATA[<p>先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：</p><pre><code>#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;struct node {//二叉树的存储结构    int data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};node* create(int pre[],int in[],int preL, int preR, int inL, int inR) {//根据先序序列和中序序列重建二叉树    if (preL&gt;preR) return NULL;//如果先序序列长度小于等于0，直接返回空    node* root = new node;//新建一个节点，用来存放当前二叉树的根节点    root-&gt;data = pre[preL];//新建节点的数据域为根节点的值    int k;    for (k = inL;k &lt;= inR;k++) {        if (in[k] == pre[preL]) {//在中序序列中找到根节点            break;        }    }    int numLeft = k - inL;//左子树的节点个数    //左子树的先序序列区间为[preL+1,preL+numLeft],中序序列区间为[inL,k-1]    root-&gt;lchild = create(pre,in,preL + 1, preL + numLeft, inL, k - 1);//返回左子树的根节点地址，赋值给root的左指针    //右子树的先序序列区间为[preL+numLeft+1,preR],中序序列区间为[k+1,inR]    root-&gt;rchild = create(pre,in,preL + numLeft + 1, preR, k + 1, inR);//返回右子树的根节点地址，赋值给root的右指针    return root;//返回根节点地址}void postorder(node* root) {//后序遍历二叉树    if (root == NULL) {        return;//递归边界    }    postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}int main() {    int n;    cin &gt;&gt; n;//输入二叉树的节点个数    int *pre = new int[n];//new一个变长的int型数组    int *in = new int[n];    for (int i = 0;i &lt; n;i++) {//输入先序序列        cin &gt;&gt; pre[i];    }    for (int i = 0;i &lt; n;i++) {//输入中序序列        cin &gt;&gt; in[i];    }    int preL = 0,inL = 0, preR = n - 1, inR = n - 1;    postorder(create(pre,in,preL, preR, inL, inR));    delete[] in;//释放内存    delete[] pre;    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;st
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="算法" scheme="http://www.echodemo.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的基本操作</title>
    <link href="http://www.echodemo.cc/2018/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.echodemo.cc/2018/04/07/二叉树的基本操作/</id>
    <published>2018-04-07T04:01:09.000Z</published>
    <updated>2018-04-07T08:39:29.646Z</updated>
    
    <content type="html"><![CDATA[<p>1、二叉树的存储结构</p><pre><code>struct node {    typename data;//数据域    node* lchild;//指向左子树根节点的指针    node* rchild;//指向右子树根节点的指针};</code></pre><p>2、新建一个二叉树节点</p><pre><code>node* newNode(int n) {    node* Node = new node;//申请一个node型变量的地址空间    Node-&gt;data = n;//节点权值为n    Node-&gt;lchild = Node-&gt;rchild = NULL;//初始状态下左右孩子为空    return Node;//返回新建节点的地址}</code></pre><p>3、查找二叉树中节点数据域为x的节点，并将他们的数据域修改为newdata</p><pre><code>void search(node* root, int x, int newdata) {    if (root == NULL) {        return;//空树，死胡同(递归边界)    }    if (root-&gt;data == x) {        root-&gt;data = newdata;    }    search(root-&gt;lchild, x, newdata);//往左子树搜索x    search(root-&gt;rchild, x, newdata);//往右子树搜索x}</code></pre><p>4、二叉树节点的插入(二叉树节点的插入位置就是数据域在二叉树中查找失败的位置)</p><pre><code>void insert(node* &amp;root, int x) {    if (root == NULL) {        root = newNode(x);//空树，说明查找失败，也即插入的位置(递归边界)        return;    }    if (由二叉树的性质，x应该插在左子树) {        insert(root-&gt;lchild, x);//往左子树搜索(递归式)    }    else {        insert(root-&gt;rchild, x);//往右子树搜索(递归式)    }}</code></pre><p>这里的根节点指针root需要使用引用&amp;，这样才能直接修改原变量的值。与search函数不同的是，search函数中修改的是指针root指向的内容，而不是root本身，而对指针指向的节点内容的修改是不需要加引用的。一般来说，如果函数中需要新建节点，即对二叉树的结构做出修改，就需要加引用；如果只是修改当前已有节点的内容，或仅仅是遍历树，就不需要加引用。</p><p>5、二叉树的创建(其实就是二叉树节点的插入过程)</p><pre><code>node* create(int data[], int n) {    node* root = NULL;//新建空根节点    for (int i = 0;i &lt; n;i++) {        insert(root, data[i]);    }    return root;//返回根节点}</code></pre><p>6、二叉树的先序遍历(递归)</p><pre><code>void preorder(node* root){    if(root==NULL){        return;//递归边界    }    cout&lt;&lt;root-&gt;data;//访问根节点    preorder(root-&gt;lchild);//访问左子树    preorder(root-&gt;rchild);//访问右子树}</code></pre><p>7、二叉树的中序遍历(递归)</p><pre><code>void inorder(node* root){    if(root==NULL){        return;//递归边界    }        inorder(root-&gt;lchild);//访问左子树    cout&lt;&lt;root-&gt;data;//访问根节点    inorder(root-&gt;rchild);//访问右子树}</code></pre><p>8、二叉树的后序遍历(递归)</p><pre><code>void postorder(node* root){    if(root==NULL){        return;//递归边界    }        postorder(root-&gt;lchild);//访问左子树    postorder(root-&gt;rchild);//访问右子树    cout&lt;&lt;root-&gt;data;//访问根节点}</code></pre><p>9、二叉树的层序遍历</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL) q.push(now-&gt;lchild);//左子树非空        if(now-&gt;rchild!=NULL) q.push(now-&gt;rchild);//右子树非空    }}</code></pre><p>如果需要计算每个节点所处的层次，二叉树节点的定义如下：</p><pre><code>struct node{    typename data;//数据域    int layer;//层次    node* lchild;//左指针域    node* rchild;//右指针域}</code></pre><p>此时的层序遍历为：</p><pre><code>void LayerOrder(node* root){    queue&lt;node*&gt; q;//队列当中存储的是地址    root-&gt;layer=1;//根节点的层数为1    q.push(root);//将根节点地址入队    while(!q.empty()){        node* now=q.front();//取出队首元素        q.pop();        cout&lt;&lt;now-&gt;data;//访问队首元素        if(now-&gt;lchild!=NULL){//左子树非空            now-&gt;lchild-&gt;layer=now-&gt;layer+1;//左孩子的层数为当前层数加1            q.push(now-&gt;lchild);        }        if(now-&gt;rchild!=NULL){//右子树非空            now-&gt;rchild-&gt;layer=now-&gt;layer+1;//右孩子的层数为当前层数加1            q.push(now-&gt;rchild);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、二叉树的存储结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct node {
    typename data;//数据域
    node* lchild;//指向左子树根节点的指针
    node* rchild;//指向右子树根节点的指针
};
&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++中的问题整理(四)</title>
    <link href="http://www.echodemo.cc/2018/04/07/C++%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E5%9B%9B)/"/>
    <id>http://www.echodemo.cc/2018/04/07/C++中的问题整理(四)/</id>
    <published>2018-04-07T00:45:34.000Z</published>
    <updated>2018-04-07T01:03:04.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、C-中的BSS、数据段、代码段、堆、栈"><a href="#1、C-中的BSS、数据段、代码段、堆、栈" class="headerlink" title="1、C++中的BSS、数据段、代码段、堆、栈"></a>1、C++中的BSS、数据段、代码段、堆、栈</h2><p>(1)BSS(Block Started by Symbol)通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p><p>(2)数据段：数据段(data segment)通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</p><p>(3)代码段：代码段(code segment/text segment)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>(4)堆(heap)：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)</p><p>(5)栈(stack)：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><h2 id="2、C-中的左值和右值"><a href="#2、C-中的左值和右值" class="headerlink" title="2、C++中的左值和右值"></a>2、C++中的左值和右值</h2><p>在C中，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。通常等号左边表示引用，实质上就是内存地址。等号右边表示数据，从内存取的数据，直接给的数据，或者计算出来的数据。内存地址本身也是数据，也可以放到内存中。相当于C++中说的指针。因为等号左边表示地址，变量映射成地址值，也就等号左边不能是常数。</p><h2 id="3、volatile关键字"><a href="#3、volatile关键字" class="headerlink" title="3、volatile关键字"></a>3、volatile关键字</h2><p>如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。当然了，volatile还能让你在编译时期捕捉到非线程安全的代码。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。以下是使用场景：</p><pre><code>(1)中断服务程序中修改的供其它程序检测的变量需要加volatile。(2)多任务环境下各任务间共享的标志应该加volatile。(3)存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。*可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。*除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。*volatile像const一样会从类传递到它的成员。</code></pre><h2 id="4、枚举类型"><a href="#4、枚举类型" class="headerlink" title="4、枚举类型"></a>4、枚举类型</h2><pre><code>(1)定义：enum Suit { Diamonds, Hearts, Clubs, Spades };或enum Suit { Diamonds, Hearts, Clubs, Spades }a,b,c;(2)对于枚举类型来说，只定义了赋值运算符，没有为枚举定义算术运算。(3)能够将枚举量赋给非枚举变量，因为枚举量是符号常量，赋值编译器会自动把枚举量转换为int类型。(4)在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，也就是说可以通过强制转换将其他类型值赋给枚举变量。(5)可以显式的设置枚举量的值(指定的值必须是整数)，也可以只显式的定义一部分枚举量的值。(6)未被初始化的枚举量的值默认比其前面的枚举量的值大1。当然，枚举量的值可以相同。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、C-中的BSS、数据段、代码段、堆、栈&quot;&gt;&lt;a href=&quot;#1、C-中的BSS、数据段、代码段、堆、栈&quot; class=&quot;headerlink&quot; title=&quot;1、C++中的BSS、数据段、代码段、堆、栈&quot;&gt;&lt;/a&gt;1、C++中的BSS、数据段、代码段、堆、栈
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>诗词入门(二)</title>
    <link href="http://www.echodemo.cc/2018/04/05/%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://www.echodemo.cc/2018/04/05/诗词入门(二)/</id>
    <published>2018-04-05T11:35:50.000Z</published>
    <updated>2018-04-07T12:17:30.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、拗救"><a href="#1、拗救" class="headerlink" title="1、拗救"></a>1、拗救</h2><p>(1)拗：不符合诗律的一般规律(出律了)</p><p>(2)救：在拗的前提下调节平仄使音感和谐。</p><h2 id="2、拗救的常见形式"><a href="#2、拗救的常见形式" class="headerlink" title="2、拗救的常见形式"></a>2、拗救的常见形式</h2><p>以下皆以五言作为例句进行说明，那么也就是说七言的后五字同样适用于这些情况。</p><p>(1)本句自救(准律句)：平平平仄仄=》平平仄平仄</p><p>例：</p><pre><code>凉风起天末，君子意如何。平平仄平仄，平仄仄平平。</code></pre><p>根据诗律的原则，这里的“凉风起天末”句明显出律了。那么是“风”字出律还是“天”字出律呢？我们可以通过“君子意如何”句的平仄来判断。在这一联当中，对句的二四字的平仄为仄、平，那么就可以推出出句的二四字的平仄就为平、仄。也就是说是“天”字出律了(当仄为平时)，那么为什么明明“天”字出律了还会认为是对的呢？这种情况就是属于拗救中的本句自救。我们先来看一下出句的正确的平仄：“平平平仄仄”。这里有这样的规定：如果在诗的创作过程中碰到了“平平平仄仄”这种情况，可以使用另外一种格式，即：把五言的第三四字的平仄位置互换(七言当中第五六字的平仄位置互换)，此时规定五言的第一字必须用平声(七言的第三字必须用平声)，不再是可平可仄的，也就变成了“平平仄平仄”。我们可以发现，这种形式只能出现在出句当中(因为对句必须是押韵的，而近体诗当中是不能压仄声韵的)，同时又由于诗律中的相对和相粘原则，出句之中也只有两句才能出现这种情况。</p><p>若首字为仄，则是特例，初学者不建议使用。如：昔闻洞庭水(仄平仄平仄)。虽然说首字为仄的情况也是存在的，但毕竟与首字为平相比还是及其少见的。老杜虽是及其注重格律之人，但他活在格律成形的那个年代，那个时候的格律还是处于可以推敲的阶段，当然也就不能说他是错的。(这里只是希望初学者不要钻牛角尖，只要记住这种拗救的形式就行)</p><p>又例：</p><pre><code>遥怜小儿女，未解忆长安。平平仄平仄，仄仄仄平平。何时倚虚晃，双照泪痕干。平平仄平仄，平仄仄平平。西望瑶池降王母(平仄平平仄平仄)</code></pre><p>(2)对句相救：出句第四字当平为仄时，对句第三字只能是平声。(但一定要保证出句是以仄声结尾)</p><p>例：</p><pre><code>向晚意不适，驱车登古原。仄仄仄仄仄，平平平仄平。*在诗词当中，“不”字几乎可以说是只能为仄声。但也不是绝对的，当“不”字通“否”字时且作为韵脚时，它是平声的。如果它位于句中就一定是仄声。</code></pre><p>同样，这里根据对句的平仄可以判断出，是出句当中的第四字“不”字出律了(当平为仄时)。此时，可以通过对句的第三字(此时必为平声)来救，也就是例句中的“登”字。按照“一三五不论”的原则，“登”字本是可平可仄的，但是在这种情况之下就只能为平声了。因为是出句由对句来救，所以这种情况只能发生在出句当中。</p><p>又例：</p><pre><code>野火烧不尽，春风吹又生。仄仄平仄仄，平平平仄平。*吹字是可平可仄的，作名词的时候为仄声(歌吹是扬州)，作动词的时候为平声。</code></pre><h2 id="3、“一三五不论”需要排除的三种情况"><a href="#3、“一三五不论”需要排除的三种情况" class="headerlink" title="3、“一三五不论”需要排除的三种情况"></a>3、“一三五不论”需要排除的三种情况</h2><pre><code>(1)三平尾：在已经确定倒数第一和倒数第二字为平声的情况之下，如果仍然令倒数第三字为平声的话，就会变成“平平平”。三平尾是写诗的大忌。(2)三仄尾：在已经确定倒数第一和倒数第二字为仄声的情况之下，如果仍然令倒数第三字为仄声的话，就会变成“仄仄仄”。三仄尾也是写诗的大忌。(3)孤平：就是“仄平仄仄平”。孤平同样是写诗的大忌。这里可以将第三字改为平声来补偿，以免犯孤平。</code></pre><h2 id="4、根据平仄判断律句，若非律句再判断是否可救的步骤"><a href="#4、根据平仄判断律句，若非律句再判断是否可救的步骤" class="headerlink" title="4、根据平仄判断律句，若非律句再判断是否可救的步骤"></a>4、根据平仄判断律句，若非律句再判断是否可救的步骤</h2><pre><code>(1)先判断二四六字是否是平仄交替的。如果是则说明暂时是一个律句，进行第二步；否则说明此句不是一个标准的律句，进行第三步。(2)是否出现了三平尾、三仄尾或者是孤平。如果出现了其中一种，则必定是错误的。若没有，则说明是可以用的。(3)判断是否符合拗救的两种基本形式。如果符合其中之一说明是可以用的；如果都不符合则说明是错误的。</code></pre><h2 id="5、作业"><a href="#5、作业" class="headerlink" title="5、作业"></a>5、作业</h2><p>如果是本句自救(准律句)，打半钩；如果是对句自救，则标记出其对句该如何。如果最终不符合格律则打叉，符合则打钩。若有学有余力，为正确的律句查找相应的诗句。</p><p><img src="/images/2018/4/1.jpg" alt="&quot;作业&quot;"></p><p><img src="/images/2018/4/2.jpg" alt="&quot;作业&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、拗救&quot;&gt;&lt;a href=&quot;#1、拗救&quot; class=&quot;headerlink&quot; title=&quot;1、拗救&quot;&gt;&lt;/a&gt;1、拗救&lt;/h2&gt;&lt;p&gt;(1)拗：不符合诗律的一般规律(出律了)&lt;/p&gt;
&lt;p&gt;(2)救：在拗的前提下调节平仄使音感和谐。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的问题整理</title>
    <link href="http://www.echodemo.cc/2018/04/05/MySQL%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/04/05/MySQL中的问题整理/</id>
    <published>2018-04-05T01:45:49.000Z</published>
    <updated>2018-04-05T02:33:56.808Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、mysql共享锁和排他锁</code></pre><p>(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排它锁。</p><p>(2)共享锁也叫读锁，简称S锁，原理：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改。</p><p>(3)排他锁也叫写锁，简称x锁，原理：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁(排他锁或者共享锁)，即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改。但是获取排他锁的事务是可以对数据进行读取和修改。</p><p>(4)设置共享锁：SELECT … LOCK IN SHARE MODE;设置排他锁：SELECT … FOR UPDATE;</p><p>(5)对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。 对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。</p><pre><code>2、MySQL几种备份方式</code></pre><p>(1)逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。</p><p>优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。</p><p>缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。</p><p>(2)物理备份：直接拷贝mysql的数据目录。直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。</p><p>缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。</p><p>(3)双机热备份。mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备)。</p><p>优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。</p><pre><code>3、数据库范式：一张数据表的表结构所符合的某种设计标准的级别</code></pre><p>(1)第一范式(1NF)</p><p>在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。<br>所谓第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><p>(2)第二范式(2NF)</p><p>第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。<br>第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是消除了非主属性对于码的部分函数依赖。</p><p>(3)第三范式(3NF)</p><p>满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是消除了非主属性对于码的传递函数依赖。</p><pre><code>4、SQL语句优化</code></pre><p>(1)应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>(2)应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</code></pre><p>(3)很多时候用 exists 代替 in 是一个好的选择。</p><p>(4)用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过。</p><pre><code>5、存储过程与触发器的区别</code></pre><p>(1)触发器与存储过程非常相似，它是一种特殊类型的存储过程。触发器也是SQL语句集，他们都像是数据库中运行的方法。两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发(激活)执行。</p><p>(2)触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p><p>(3)触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p><pre><code>6、union 与union all的区别</code></pre><p>union 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all 则会显示重复结果,只是简单的两个结果合并并返回.所以效率比union高,在保证没有重复数据的情况下用union all。</p><pre><code>7、MyISAM和InnoDB区别</code></pre><p>(1)InnoDB支持外键，而MyISAM不支持。</p><p>(2)InnoDB不支持全文索引，而MyISAM支持。</p><p>(3)InnoDB支持行级锁，而MyISAM支持表级锁。</p><p>(4)MyISAM不提供事务支持。InnoDB提供事务支持。</p><p>(5)MyISAM保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p>(6)MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p>(7)MyISAM可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p>(8)如果执行大量的SELECT，MyISAM是更好的选择。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p>(9)每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><pre><code>8、MySQL的三级模式</code></pre><p>(1)模式(逻辑模式)：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><p>(2)外模式(用户模式)：是数据库用户的数据视图，是局部数据的逻辑结构和特征的描述。</p><p>(3)内模式(存储模式)：一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p><pre><code>9、mysql中视图和表的区别以及联系</code></pre><p>区别：</p><p>(1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。</p><p>(2)视图没有实际的物理记录，而表有。</p><p>(3)视图是窗口，表是内容。</p><p>(4)视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。</p><p>(5)表可以及时对它进行修改；而视图只能用创建语句来修改。</p><p>(6)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。</p><p>(7)从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。</p><p>(8)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</p><p>(9)视图的建立和删除只影响视图本身，不影响对应的表。</p><p>联系：</p><p>(1)视图是在表之上建立的虚表，它的结构(所定义的列)和内容(所有记录)都来自表，视图依据表存在而存在。一个视图可以对应多个表。视图是表的抽象和在逻辑意义上建立的新关系。</p><p>(2)删除视图中的数据,数据库中表的数据会一起被删除。</p><pre><code>10、存储过程(procedure)和函数(function)区别</code></pre><p>(1)本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。</p><p>(2)函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。</p><p>(3)函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、mysql共享锁和排他锁
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="http://www.echodemo.cc/2018/04/04/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.echodemo.cc/2018/04/04/MySQL事务/</id>
    <published>2018-04-04T15:46:14.000Z</published>
    <updated>2018-04-05T02:34:05.226Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><pre><code>(1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。(2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。(3)事务用来管理 insert,update,delete 语句</code></pre><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><p>(1)原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>(2)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>(3)隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><pre><code>a、未提交读（RU）：最弱的隔离级别，事务中的修改即使没有提交，对其他事务也都是可见的。（即脏读）b、不可重复读（RC）：大多数数据库系统的默认隔离级别。解决了脏读的问题，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。一个事务两次执行同样的查询，可能会得到不一样的结果。c、可重复读（RR）：mysql默认隔离级别。解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。该级无法解决幻读的问题，幻读是当某个事务在读取某个范围内的记录时，一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。innodb和xtradb存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。d、可串行化：该级是最高的级别，通过强制事务串行执行，避免了幻读的问题，该级会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题，</code></pre><p>(4)持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务必使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><p>事务控制语句：</p><pre><code>(1)BEGIN或START TRANSACTION；显式地开启一个事务；(2)COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；(3)ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；(4)SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；(5)RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；(6)ROLLBACK TO identifier；把事务回滚到标记点；(7)SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</code></pre><p>MYSQL 事务处理主要有两种方法：</p><pre><code>1、用 BEGIN, ROLLBACK, COMMIT来实现(1)BEGIN 开始一个事务(2)ROLLBACK 事务回滚(3)COMMIT 事务确认2、直接用 SET 来改变 MySQL 的自动提交模式:(1)SET AUTOCOMMIT=0 禁止自动提交(2)SET AUTOCOMMIT=1 开启自动提交</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)在 MySQL 中只有使用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MYSQL" scheme="http://www.echodemo.cc/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://www.echodemo.cc/2018/04/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://www.echodemo.cc/2018/04/04/红黑树/</id>
    <published>2018-04-04T01:50:20.000Z</published>
    <updated>2018-04-05T00:01:48.845Z</updated>
    
    <content type="html"><![CDATA[<p>1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次递减时，它会不断地插在节点的左子树)。此时的二叉查找树的查找性能几乎变成了线性。那么如何解决二叉查找树多次插入新节点而导致的不平衡呢？红黑树也就应运而生了。</p><pre><code>二叉查找树的性质：a、左子树上所有结点的值均小于或等于它的根结点的值。b、右子树上所有结点的值均大于或等于它的根结点的值。c、左、右子树也分别为二叉排序树。</code></pre><p>2、红黑树(Red Black Tree)是一种平衡的二叉查找树(但不是一个完美的平衡二叉树)。它的应用有很多，Java中的TreeSet和TreeMap数据结构，Java8中的HashMap也用到了红黑树；在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。</p><font color="#8A2BE2">(1)性质</font><pre><code>a、节点是红色或黑色。b、根节点是黑色。c、每个叶子节点都是黑色的空节点（NIL节点）。d、每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)e、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</code></pre><p>以上这些限制强化了红黑树的关键属性：从根节点到最远叶节点的路径不超过从根到最近叶节点的路径的两倍(最短的路径是:全部都是黑色节点，最长的路径是:在红色和黑色节点之间交替)。这也是红黑树和二叉查找树之间最大的不同。</p><font color="#8A2BE2">(2)左旋转和右旋转</font><p>a、左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子树取代，而父节点自己成为自己右子树(现在已经是父节点了)的左子树。现在已经是父节点的的左子树成为曾经的父节点的右子树。</p><p>b、右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子树取代，而父节点自己成为自己左子树(现在已经是父节点了)的右子树。现在已经是父节点的的右子树成为曾经的父节点的左子树。</p><font color="#8A2BE2">(3)插入节点</font><p>a、当前节点位于树的根部。为了满足（根节点是黑色），将其颜色变成黑色。由于这会向每条路径都添加一个黑色节点，所以（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）不会被违反。</p><p>b、当前节点的父节点是黑色的。所以（每个红色节点的两个子节点都是黑色）不会失效。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）没有受到威胁，因为当前节点有两个黑色节点，但由于当前节点是红色，所以到达其每个叶子节点路径上的黑色节点的数量与它所替换的叶子节点路径上的黑色节点的数量是相同的。</p><p>c、如果父节点和父节点的兄弟节点都是红色的，那么可以将他们的颜色都变成黑色，并且将祖父母节点的颜色变成红色以维持（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）。由于通过父节点和父节点的兄弟节点的任何路径必须经过祖父母节点，所以这些路径上的黑色节点的数目并没有改变。然而，祖父母节点现在可能违反了（根节点是黑色），如果它是根或（每个红色节点的两个子节点都是黑色），如果它具有红色的父母节点。为了解决这个问题，树上的红黑修复程序在祖父母节点上重新运行。</p><p>d、父节点是红色的，但是父节点的兄弟节点是黑色的。最终目标是将当前节点旋转到祖父母节点的位置，但如果当前节点位于祖父母节点下子树的“内部” （即，如果当前节点是祖父母节点的右子节点的左子节点或者是祖父母节点的左子节点的右子节点）。在这种情况下，可以在父节点上执行左旋转以切换当前节点及其父节点的位置。由于父节点和当前的插入节点都是红色的，所以旋转这两个节点不会使（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）受到旋转的影响。这一步完成后（每个红色节点的两个子节点都是黑色）仍然被违反。此时，当前节点现在肯定位于祖父母节点的子树的外部（左子节点或右子节点）。在这种情况下，执行祖父母节点上的右旋转;其中前父母节点现在是当前节点和前祖父母节点的父母节点。此时前父母节点和前祖父母节点的颜色互换，结果树满足（每个红色节点的两个子节点都是黑色）。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）也依然不满足，再将前祖父母节点和其右子节点的颜色互换即可。</p><p>*具体的红黑树中插入和删除出现的有关旋转和变色的情况，请自行跳转至维基百科查看：<a href="https://en.m.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">维基百科红黑树</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://www.echodemo.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>柴</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%9F%B4/"/>
    <id>http://www.echodemo.cc/2018/03/31/柴/</id>
    <published>2018-03-31T08:03:52.000Z</published>
    <updated>2018-03-31T08:06:39.689Z</updated>
    
    <content type="html"><![CDATA[<p>你本是泥土里的种子</p><p>春雨下来，便破土而出，发芽又抽绿</p><p>阳光透过乔木和灌木的叶子漏下来</p><p>照耀着你微弱的身体</p><p><br><br>后来呀，雨露下来，寒风穿过</p><p>土壤也时而干燥</p><p>根在土里生长</p><p>叶在空气里徜徉</p><p>向着更广阔的空间里延伸</p><p>春夏秋冬地过去，轮回。</p><p><br><br>那一日，我手持柴刀独自上山</p><p>无意间来到你的身旁</p><p>此时的你已巍然成木</p><p>在多少次的手起刀落后</p><p>在洁白的木屑四散飞溅后</p><p>你轰然倒下</p><p>倒在你无比熟悉的地点</p><p>我残忍地脱去你的外衣，卸下你的臂膀</p><p>甚至头颅。</p><p><br><br>你已经死了</p><p>你的尸体跟随我下了山</p><p>你永远地离开了生生世世守护的这方土地</p><p>被我丢弃在陌生的沙土之上</p><p>无情的斧子借着外力将你的尸体大卸八块</p><p>陈列在清灰色瓦片盖的土坯房子里</p><p>静静等候与烈火的相遇</p><p>化为炊烟又化为尘土</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你本是泥土里的种子&lt;/p&gt;
&lt;p&gt;春雨下来，便破土而出，发芽又抽绿&lt;/p&gt;
&lt;p&gt;阳光透过乔木和灌木的叶子漏下来&lt;/p&gt;
&lt;p&gt;照耀着你微弱的身体&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;后来呀，雨露下来，寒风穿过&lt;/p&gt;
&lt;p&gt;土壤也时而干燥&lt;/p&gt;
&lt;p&gt;根在土里生长&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://www.echodemo.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗词" scheme="http://www.echodemo.cc/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>文字</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E6%96%87%E5%AD%97/"/>
    <id>http://www.echodemo.cc/2018/03/31/文字/</id>
    <published>2018-03-31T07:29:11.000Z</published>
    <updated>2018-03-31T07:34:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全文”的扩展链接，你会知道自己在某天的某个时间段做了什么。可能是有关学习的知识点，可能是有关生活的感悟或自己的思考，又或者仅仅是记录了一件事情的发生。所有这些，过后回望的确会有及其深刻的意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《眠空》摘句(三)</title>
    <link href="http://www.echodemo.cc/2018/03/31/%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%89)/"/>
    <id>http://www.echodemo.cc/2018/03/31/《眠空》摘句(三)/</id>
    <published>2018-03-31T07:13:57.000Z</published>
    <updated>2018-04-08T09:58:54.823Z</updated>
    
    <content type="html"><![CDATA[<p>1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。</p><p>2、经过提纯的内心空间，不是不懂，不知，而是不问，不计较，不介意，不追究。愿意把别人想得好一些，不把人想得复杂，考虑到对方的立场。可说，可不说时，不如选择不说。</p><p>4、不存在无可救药的人、感情、生活。一切终究有变化。如果你认为它无可救药，不过是沉溺。我们可以选择完全的放下，或者完全的承担。唯独不能伪装成一个懒怠的理所当然的姿势。你尽可拖延和故作不知，企图获得其他妥协。命运静静等待一侧，旁观你辗转煎熬，最终会逼迫你把脚步移向注定的一格。实践一旦进行，错误和方式就会自动调整和归位。出发时首要的。</p><p>5、跪拜只是一个仪式，为了让心恭敬谦卑平和柔顺，在毫无杂念从事这一重复举动时训练和观照自己。调伏这颗充满傲慢我执的刚硬的心。这是一个修行的任务。</p><p>6、不应在原地等待，要一边前行一边等待。</p><p>7、看完一本书，即使觉得好，日后也常常想不起其中句子，也不会使用或摆弄。也许阅读它，如同喝下的一杯清水，不过是维持日常的生存。</p><p>8、如果曾经为别人做过什么，不要事后提醒对方记得你的付出。如果别人曾经出于信任对你分享过他的软弱，不要事后以此攻击对方以证明自身强大。这均是高贵举动。</p><p>9、时间最终会带来解脱，重要或者不重要的事物，在最后纷纷露出它们的本来面目。</p><p>10、我的心是一座浸泡在海水中的宫殿。多年之后，你会记得它，也许忘却它。最终，你会怀念它。这种悲哀与击伤。这种怜悯与温柔。这空无而充盈的力量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。&lt;/p&gt;
&lt;p&gt;2、经过提纯的内心空间，不是不懂，不
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的抽象类和接口</title>
    <link href="http://www.echodemo.cc/2018/03/31/Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.echodemo.cc/2018/03/31/Java中的抽象类和接口/</id>
    <published>2018-03-31T07:01:20.000Z</published>
    <updated>2018-03-31T07:02:41.750Z</updated>
    
    <content type="html"><![CDATA[<p>1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是GeometricObject类型的数组，然后创建一个GeometricObject的实例，并将它的引用赋值给数组是可以的。虽然不能使用new操作符创建它的实例，但仍然可以定义它的构造方法，抽象类的构造方法定义为protected，因为它只被子类使用。抽象方法只有定义而没有实现。它的实现由子类提供。</p><p>2、抽象方法不能包含在非抽象类中，也就是说一个包含抽象方法的类必须声明为抽象类。但是，可以定义一个不包含抽象方法的抽象类(同样不能使用new操作符创建它的实例)，这种类是用来定义新子类的基类的。如果抽象父类的子类不能实现所有的抽象方法，那么这个子类也必须定义为抽象的。另外，抽象方法是非静态的。</p><p>3、即使子类的父类是具体的，这个子类也可以是抽象的。比如：object类是具体的，但继承于它的类却可以是抽象的。子类可以覆盖父类的方法并将它定义为abstract(这是很少见的)，但是它在当父类的方法实现在子类中变得不合法时是很有用的。在这种情况下，子类必须为abstract。</p><p>4、接口是一种与类相似的结构，只包含常量和抽象方法。它和抽象类相似，不能使用new操作创建接口的实例。由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以java允许忽略这些修饰符。</p><p>5、Java只允许为类的扩展做单一继承，但是允许使用接口做多重继承。用关键字extends，接口可以继承其他接口，但是不可扩展类。一个类可以扩展它的父类同时实现多个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是Ge
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
</feed>
