<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EchoDemo&#39;s Blogs</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.echodemo.cc/"/>
  <updated>2018-07-22T15:05:46.887Z</updated>
  <id>http://www.echodemo.cc/</id>
  
  <author>
    <name>EchoDemo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的AWT事件处理</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT事件处理/</id>
    <published>2018-07-22T14:57:37.000Z</published>
    <updated>2018-07-22T15:05:46.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、AWT事件处理基本概念"><a href="#1、AWT事件处理基本概念" class="headerlink" title="1、AWT事件处理基本概念"></a>1、AWT事件处理基本概念</h3><p>AWT事件的处理过程中，主要涉及三类对象。</p><p>(1)Event(事件)：用户对组件的一个操作，称之为一个事件，以类的形式出现，例如，键盘操作对应的事件类是KeyEvent。其实例在该事件发生时由系统自动产生。每一种事件都对应专门的监听者。</p><p>(2)Event Source(事件源)：事件发生的场所，通常就是各个组件，例如按钮Button。事件源自己不处理事件，而是把在其自身所有可能发生的事件委托给事件监听器来处理。</p><p>(3)Event Monitor(事件监听器)：接收事件对象并对其进行处理的类的对象，通常其中某个成员方法对事件进行相应的处理。</p><h3 id="2、事件"><a href="#2、事件" class="headerlink" title="2、事件"></a>2、事件</h3><p>AWT的相关事件继承于java.awt.AWTEvent类，这些事件分为两大类：低级事件和高级事件。</p><p>(1)低级事件是指基于<strong>组件和容器</strong>的事件，当一个组件发生事件，如鼠标进入、点击、拖放或组件的窗口开关等时，触发了组件事件。如：组件事件、容器事件、窗口事件、焦点事件、键盘事件、鼠标事件。</p><p>(2)高级事件是基于<strong>语义</strong>的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类。比如，按下按钮和在TextField中按Enter键会触发ActionEvent事件，滑动滚动条会触发AdjustmentEvent事件，选中项目列表的某一条会触发ItemEvent事件。</p><h3 id="3、事件监听器"><a href="#3、事件监听器" class="headerlink" title="3、事件监听器"></a>3、事件监听器</h3><p>事件监听器通常是一个类，该类必须实现与该事件类型相对应的接口。对应的接口被称之为事件监听器接口。事件监听器接口类的名称与事件类的名称相对应，例如：MouseEvent事件类的监听器接口名为MouseListener。</p><h3 id="4、事件适配器类"><a href="#4、事件适配器类" class="headerlink" title="4、事件适配器类"></a>4、事件适配器类</h3><p>Java语言为一些事件监听提供了适配器(Adapter)。我们可以通过继承事件对应的Adapter类，重写所需要的方法，无关的方法则不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序代码。java.awt.event包中定义的事件适配器类包括以下7个：MouseAdapter(鼠标适配器)、MouseMotionAdapter(鼠标运动适配器)、KeyAdapter(键盘适配器)、WindowAdapter(窗口适配器)、ComponentAdapter(组件适配器)、ComtainerAdapter(容器适配器)、FocusAdapter(焦点适配器)。</p><h3 id="5、示例"><a href="#5、示例" class="headerlink" title="5、示例"></a>5、示例</h3><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionAdapter;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class ListenerDemo {    public static void main(String[] args) {        MyFrame7 frame7=new MyFrame7(&quot;Listener&quot;);    }}class MyFrame7 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame7(String title){        super(title);        init();        registerListener();    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }    private void registerListener(){        /*         * 产生一个事件监听器对象，给四个按钮注册同一个事件监听器。         */        BtnListener btnListener=new BtnListener();        btn_1.addActionListener(btnListener);        btn_2.addActionListener(btnListener);        btn_3.addActionListener(btnListener);        btn_4.addActionListener(btnListener);        lb_1.addMouseMotionListener(new MouseMotionAdapter() {            @Override            public void mouseMoved(MouseEvent e) {                lb_1.setText(e.getX()+&quot;:&quot;+e.getY());            }        });        lb_2.addMouseListener(new MouseAdapter() {            @Override            public void mouseExited(MouseEvent e) {                System.out.println(&quot;鼠标移出&quot;);            }            @Override            public void mouseEntered(MouseEvent e) {                System.out.println(&quot;鼠标移入&quot;);            }        });        tf_contentField.addKeyListener(new KeyAdapter() {            @Override            public void keyPressed(KeyEvent e) {                System.out.println(e.getKeyChar());            }        });        this.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                System.exit(0);            }        });    }    class BtnListener implements ActionListener{        @Override        public void actionPerformed(ActionEvent e) {            /*System.out.println(e.getActionCommand());            System.out.println(e.getSource());*/            Object object=e.getSource();//获得当前点击的事件源            if(object==btn_1){                cardLayout.first(card_panel);//获得第一张            }else if(object==btn_2){                cardLayout.previous(card_panel);//获得前一张            }else if(object==btn_3){                cardLayout.next(card_panel);//获得下一张            }else{                cardLayout.last(card_panel);//获得最后一张            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;a href=&quot;#1、AWT事件处理基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、AWT事件处理基本概念&quot;&gt;&lt;/a&gt;1、AWT事件处理基本概念&lt;/h3&gt;&lt;p&gt;AWT事件的处理过程中，主要涉及三类对象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的布局管理器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的布局管理器/</id>
    <published>2018-07-22T05:30:27.000Z</published>
    <updated>2018-07-22T06:26:27.868Z</updated>
    
    <content type="html"><![CDATA[<p>1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、<br>GridBagLayout网格包布局管理器。</p><p>2、容器中组件的布局通常由布局管理器控制。每个Container(比如一个Panel或一个Frame)都有一个与它相关的缺省布局管理器，Panel容器默认是FlowLayout，Frame容器默认是BorderLayout，我们可以通过调用setLayout()来改变布局管理器。</p><p>3、我们可以通过设置空布局管理器，来控制组件的大小和位置。可以调用setLayout(null)。在设置空布局管理器之后，必须对所有的组件调用setLocation()，setSize()或者setBounds()，将它们定位在容器中。</p><p>4、FlowLayout布局管理器：流程布局通常用于布置面板中的按钮。 它可以水平排列按钮，直到不再有按钮在同一行上。 线对齐由align属性确定。 可能的值是：LEFT、RIGHT、CENTER、LEADING、TRAILING。</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class FlowLayoutDemo {    public static void main(String[] args) {        MyFrame3 frame3=new MyFrame3(&quot;FlowLayout&quot;);        frame3.init();    }}class MyFrame3 extends Frame{    public MyFrame3(String title){        super(title);    }    public void init(){        //FlowLayout layout=new FlowLayout();//构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。         //FlowLayout layout=new FlowLayout(FlowLayout.LEFT);//构造一个新的 FlowLayout左对齐和默认的5单位水平和垂直间隙。         FlowLayout layout=new FlowLayout(FlowLayout.RIGHT,50,50);//构造一个新的 FlowLayout右对齐和默认的5单位水平和垂直间隙均为50。         this.setLayout(layout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));//添加按钮        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.add(new Button(&quot;btn8&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>5、BorderLayout布局管理器：边界布局设置了一个容器，安排和调整其组件，以适应五个区域：北，南，东，西和中心。 每个区域可以含有不超过一个部件，并且通过相应的常数确定： NORTH ， SOUTH ， EAST ， WEST和CENTER 。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;public class BorderLayoutDemo {    public static void main(String[] args) {        MyFrame4 frame4=new MyFrame4(&quot;BorderLayout&quot;);        frame4.init();    }}class MyFrame4 extends Frame{    public MyFrame4(String title){        super(title);    }    public void init(){        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;),BorderLayout.EAST);//添加按钮在东边        this.add(new Button(&quot;btn2&quot;),BorderLayout.WEST);        this.add(new Button(&quot;btn3&quot;),BorderLayout.NORTH);        this.add(new Button(&quot;btn4&quot;),BorderLayout.SOUTH);        this.add(new Button(&quot;btn5&quot;),BorderLayout.CENTER);        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>6、GridLayout布局管理器：它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。当行数和列数都被设置为非零值时，无论是通过构造函数还是setRows和setColumns方法，都会忽略指定的列数。而是从指定的行数和布局中的组件总数确定列的数量。因此，例如，如果已经指定了三行和两列，并且将九个组件添加到布局，则它们将显示为三列三列。仅当行数设置为零时，才指定列数影响布局。 </p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.GridLayout;public class GridLayoutDemo {    public static void main(String[] args) {        MyFrame5 frame5=new MyFrame5(&quot;GridLayout&quot;);        frame5.init();    }}class MyFrame5 extends Frame{    public MyFrame5(String title){        super(title);    }    public void init(){        //GridLayout gridLayout=new GridLayout();//在单个行中创建一个每个组件的默认值为一列的网格布局。         //GridLayout gridLayout=new GridLayout(3,2);//创建具有指定行数和列数的网格布局。        GridLayout gridLayout=new GridLayout(3,2,10,10);//创建具有指定行数和列数的网格布局，且指定水平和垂直间隔。        this.setLayout(gridLayout);        this.setBackground(Color.cyan);        this.add(new Button(&quot;btn1&quot;));        this.add(new Button(&quot;btn2&quot;));        this.add(new Button(&quot;btn3&quot;));        this.add(new Button(&quot;btn4&quot;));        this.add(new Button(&quot;btn5&quot;));        this.add(new Button(&quot;btn6&quot;));        this.add(new Button(&quot;btn7&quot;));        this.setSize(300, 200);        this.setVisible(true);    }}</code></pre><p>7、 CardLayout布局管理器：它将容器中的每个组件视为一张卡。 一次只能看到一张卡片，容器就是一堆卡片。添加到CardLayout对象的第一个组件是首次显示容器时的可见组件。卡片的顺序由容器自己的组件对象的内部顺序决定。CardLayout定义了一组允许应用程序顺序翻转这些卡片或显示指定卡片的方法。 addLayoutComponent(java.awt.Component, java.lang.Object)方法可用于将字符串标识符与给定卡相关联，以便快速随机访问。 </p><pre><code>package com.iotek.awt;import java.awt.BorderLayout;import java.awt.Button;import java.awt.CardLayout;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.Panel;import java.awt.TextField;public class CardLayoutDemo {    public static void main(String[] args) {        MyFrame6 frame6=new MyFrame6(&quot;CardLayout&quot;);        frame6.init();    }}class MyFrame6 extends Frame{    private Panel card_panel=null;    private Panel ctrol_panel=null;    private CardLayout cardLayout=null;    private FlowLayout flowLayout=null;    private Label lb_1,lb_2,lb_3,lb_4;    private TextField tf_contentField;    private Button btn_1,btn_2,btn_3,btn_4;    public MyFrame6(String title){        super(title);    }    /*     * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。     * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。     */    public void init(){        //创建两个面板容器        card_panel=new Panel();        ctrol_panel=new Panel();        //创建两个布局管理器        cardLayout=new CardLayout();        flowLayout=new FlowLayout();        //给面板容器设定指定的布局管理器        card_panel.setLayout(cardLayout);        ctrol_panel.setLayout(flowLayout);        //声明创建四个标签控件和一个文本框控件。        lb_1=new Label(&quot;First Page&quot;,Label.CENTER);        lb_2=new Label(&quot;Second Page&quot;,Label.CENTER);        tf_contentField=new TextField();//编辑文本框        lb_3=new Label(&quot;Third Page&quot;,Label.CENTER);        lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER);        //构建四个按钮对象        btn_1=new Button(&quot;First&quot;);        btn_2=new Button(&quot;Second&quot;);        btn_3=new Button(&quot;Third&quot;);        btn_4=new Button(&quot;Forth&quot;);        //把按钮添加到控制面板        ctrol_panel.add(btn_1);        ctrol_panel.add(btn_2);        ctrol_panel.add(btn_3);        ctrol_panel.add(btn_4);        //把四个标签控件和一个文本框控件添加到card_panel容器中。        card_panel.add(lb_1);        card_panel.add(lb_2);        card_panel.add(tf_contentField);        card_panel.add(lb_3);        card_panel.add(lb_4);        this.add(card_panel,BorderLayout.CENTER);        this.add(ctrol_panel,BorderLayout.SOUTH);        this.setSize(400, 300);        this.setVisible(true);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、&lt;br&gt;G
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的AWT框架和容器</title>
    <link href="http://www.echodemo.cc/2018/07/22/Java%E4%B8%AD%E7%9A%84AWT%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.echodemo.cc/2018/07/22/Java中的AWT框架和容器/</id>
    <published>2018-07-22T03:47:02.000Z</published>
    <updated>2018-07-23T00:27:14.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、GUI概述"><a href="#1、GUI概述" class="headerlink" title="1、GUI概述"></a>1、GUI概述</h3><p>(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通过GUI能方便友好地进行交互。在Java语言中，JFC(Java Foundation Classed)是开发GUI的API集，它主要包括以下几个部分：</p><pre><code>a、AWT(抽象窗口工具包)：Java开发用户界面最初的工具包，是建立JFC的主要基础。b、Swing组件：建立在AWT之上，新的，功能更强大的图形组件包。c、JAVA2D：实现高质量的二维图形。......</code></pre><h3 id="2、AWT框架"><a href="#2、AWT框架" class="headerlink" title="2、AWT框架"></a>2、AWT框架</h3><p>(1)在java.awt包中包含了一个完整的类集以支持GUI程序的设计。awt所提供的控件一般称之为重量级控件，因为awt主要依靠本地方法(操作系统所提供的图形库)来实现其功能，基于此Java为了实现一次编译到处运行的概念，awt就不得不通过牺牲功能来实现(取各个操作系统的交集)。其中的类及相互关系可以用下图来描述。</p><p><img src="/images/2018/7/2.jpg" alt="&quot;类的相互关系&quot;"></p><p>(2)Component类是最核心的类，它是构成Java图形用户界面的基础，大部分组件都是有该类派生出来的。Component类主要由基本组件和容器(Container)组件组成。容器组件组要分为Window容器和Panel容器。</p><p>(3)Frame容器</p><p>a、Window是能独立存在的容器，它有一个子类Frame，它是一个带有标题和缩放角的窗口。</p><p>b、Frame有一个构造方法Frame(String title)。</p><p>c、你可以通过add()方法，在Frame容器中加入其它的组件。</p><p>d、Frame容器有默认的布局管理器。</p><p>e、Frame被创建后，是不可见的。</p><p>f、示例</p><pre><code>package com.iotek.awt;import java.awt.Color;import java.awt.Frame;public class FrameDemo1 {    public static void main(String[] args) {        MyFrame1 myFrame1=new MyFrame1(&quot;标题&quot;);        myFrame1.init();    }}class MyFrame1 extends Frame{    public MyFrame1(String title){        super(title);    }    public void init(){        //this.setSize(300,300);//设置窗体的宽和高        this.setBounds(100, 100, 300, 300);//移动并调整此组件的大小。         this.setBackground(Color.GREEN);//给窗体设置背景颜色        this.setVisible(true);//设置窗体可见    }}</code></pre><p>(4)Panel容器</p><p>a、Panel只能存在于其它的容器(Window或者其子类)中才能显示出来。</p><p>b、通过Panel的默认构造方法Panel()可以创建一个Panel。</p><p>c、示例</p><pre><code>package com.iotek.awt;import java.awt.Button;import java.awt.Color;import java.awt.Frame;import java.awt.Panel;public class FrameDemo2 {    public static void main(String[] args) {        MyFrame2 myFrame2=new MyFrame2(&quot;我的窗体&quot;);        myFrame2.init();    }}class MyFrame2 extends Frame{    public MyFrame2(String title){        super(title);    }    public void init(){        this.setSize(300, 300);        this.setBackground(Color.GREEN);        this.setLayout(null);//去掉窗体的默认布局管理器        Panel panel=new Panel();        panel.setLayout(null);//去掉panel容器的默认布局管理器        panel.setBackground(Color.blue);        panel.setBounds(0, 0, 200, 200);//移动并调整此组件的大小。         Button btn1=new Button(&quot;clickMe&quot;);        btn1.setBounds(0, 0, 100, 100);        btn1.setBackground(Color.red);        panel.add(btn1);//添加按钮到面板中        this.add(panel);//把panel加到窗体中        this.setVisible(true);//让窗体显示    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、GUI概述&quot;&gt;&lt;a href=&quot;#1、GUI概述&quot; class=&quot;headerlink&quot; title=&quot;1、GUI概述&quot;&gt;&lt;/a&gt;1、GUI概述&lt;/h3&gt;&lt;p&gt;(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Collections</title>
    <link href="http://www.echodemo.cc/2018/07/21/Java%E4%B8%AD%E7%9A%84Collections/"/>
    <id>http://www.echodemo.cc/2018/07/21/Java中的Collections/</id>
    <published>2018-07-21T11:33:19.000Z</published>
    <updated>2018-07-21T11:34:33.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Collections类及常用API"><a href="#1、Collections类及常用API" class="headerlink" title="1、Collections类及常用API"></a>1、Collections类及常用API</h3><p>(1)Collections类集工具类，定义了若干用于类集和映射(Map)的算法，这些算法被定义为静态方法。</p><p>(2)常用方法：public static void sort(List<t> list);public static int binarySearch(List<t> list,T key);public static void reverse(List&lt;?&gt; list);public static void shuffle(List&lt;?&gt; list);public static vodi swap(List&lt;?&gt; list,int i,int j);public static <t> void fill(List&lt;? super T&gt; list,T obj);</t></t></t></p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CollectionsDemo1 {    public static void main(String[] args) {        List&lt;String&gt; nList=new ArrayList&lt;String&gt;();        nList.add(&quot;chenhao&quot;);        nList.add(&quot;zhangsan&quot;);        nList.add(&quot;lisi&quot;);        nList.add(&quot;wangwu&quot;);        nList.add(&quot;rose&quot;);        nList.add(&quot;mary&quot;);        System.out.println(&quot;操作前&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;交换顺序后&quot;);        Collections.swap(nList, 1, 2);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;自然排序后&quot;);        Collections.sort(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;打乱顺序后&quot;);        Collections.shuffle(nList);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }        System.out.println();        System.out.println(&quot;填充后&quot;);        Collections.fill(nList, &quot;chenhao&quot;);        for(String s:nList){            System.out.print(s+&quot; &quot;);        }    }}</code></pre><h3 id="2、对ArrayList容器中的内容进行排序"><a href="#2、对ArrayList容器中的内容进行排序" class="headerlink" title="2、对ArrayList容器中的内容进行排序"></a>2、对ArrayList容器中的内容进行排序</h3><p>(1)案例介绍</p><p>ArrayList中存储了多个person对象，(此对象包含，名字，年龄，ID)要求按年龄从小到大排序，年龄相等的话再按名字的大小来排序输出。</p><p>(2)案例设计</p><p>使用ArrayList来存储Person对象，使用Collections类所提供的静态sort方法来按要求对ArrayList进行排序，最终输出排好序的结果信息。(这里需要重写Comparator方法。)</p><p>(3)代码实现</p><pre><code>package com.iotech.set;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class CollectionsDemo2 {    public static void main(String[] args) {        ArrayList&lt;Person&gt; nList=new ArrayList&lt;Person&gt;();        nList.add(new Person(&quot;zhangsan&quot;, 17, 0));        nList.add(new Person(&quot;lisi&quot;, 18, 1));        nList.add(new Person(&quot;xiaohong&quot;, 19, 2));        nList.add(new Person(&quot;chenhao&quot;, 20, 3));        nList.add(new Person(&quot;mary&quot;, 17, 4));        Collections.sort(nList,new Comparator&lt;Person&gt;(){//匿名内部类            @Override            public int compare(Person o1, Person o2) {                int x=o1.getAge()-o2.getAge();                if(x&gt;0) return 1;                else if(x&lt;0) return -1;                else{                    return o1.getNameString().compareTo(o2.getNameString());                }            }        });        for(Person person:nList){            System.out.println(person.toString());        }    }}class Person{     private String nameString;     private int age;     private int id;    public Person(String nameString, int age, int id) {        super();        this.nameString = nameString;        this.age = age;        this.id = id;    }    public String getNameString() {        return nameString;    }    public void setNameString(String nameString) {        this.nameString = nameString;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    @Override    public String toString() {        return &quot;Person [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &quot;]&quot;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Collections类及常用API&quot;&gt;&lt;a href=&quot;#1、Collections类及常用API&quot; class=&quot;headerlink&quot; title=&quot;1、Collections类及常用API&quot;&gt;&lt;/a&gt;1、Collections类及常用API&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Set</title>
    <link href="http://www.echodemo.cc/2018/07/20/Java%E4%B8%AD%E7%9A%84Set/"/>
    <id>http://www.echodemo.cc/2018/07/20/Java中的Set/</id>
    <published>2018-07-20T15:50:08.000Z</published>
    <updated>2018-07-20T15:51:07.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Set容器的特点"><a href="#1、Set容器的特点" class="headerlink" title="1、Set容器的特点"></a>1、Set容器的特点</h3><p>Set容器是一个不包含重复元素的Collection，并且最多包含一个null元素，它和List容器相反，Set容器不能保证其元素的顺序。最常用的两个Set接口的实现类是HashSet和TreeSet。</p><h3 id="2、HashSet及常用API"><a href="#2、HashSet及常用API" class="headerlink" title="2、HashSet及常用API"></a>2、HashSet及常用API</h3><p>(1)HashSet扩展AbstractSet并实现Set接口，HashSet使用散列表(又称之为哈希表)进行存储。<strong>(HashSet底层实际上维护了一个HashMap，只是我们操作的是HashMap的key，而HashMap底层维护了哈希表)</strong></p><p>(2)构造方法：HashSet();HashSet(Collection c);HashSet(int capacity);HashSet(int capacity,float fillRatio)。</p><p>(3)HashSet没有定义任何超过它的父类和接口提供的其他方法，散列集合没有确保其元素的顺序，因为散列处理通常不参与排序。</p><p>(4)举例</p><pre><code>package com.iotech.set;import java.util.HashSet;public class HashSetDemo1 {    public static void main(String[] args) {        /*HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;();        hashSet.add(&quot;zhangsan&quot;);        hashSet.add(&quot;lisi&quot;);        hashSet.add(&quot;jay&quot;);        hashSet.add(&quot;jack&quot;);        System.out.println(hashSet.add(&quot;jay&quot;));        System.out.println(hashSet);*/        HashSet&lt;Student&gt; hashSet=new HashSet&lt;Student&gt;();         System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.add(new Student(&quot;李四&quot;, 30)));        System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20)));        System.out.println(hashSet.size());    }}class Student{    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="3、TreeSet及常用API"><a href="#3、TreeSet及常用API" class="headerlink" title="3、TreeSet及常用API"></a>3、TreeSet及常用API</h3><p>(1)TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储，访问和检索很快。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择。<strong>(事实上，TreeSet的底层就是TreeMap实现的，只是我们操作的是TreeMap的Key)</strong></p><p>(2)构造方法：TreeSet();TreeSet(Collection c);TreeSet(Comparator comp);TreeSet(SortedSet ss)。</p><p>(3)举例</p><pre><code>package com.iotech.set;import java.util.Iterator;import java.util.TreeSet;public class TreeSetDemo1 {    public static void main(String[] args) {        TreeSet&lt;Person&gt; treeSet=new TreeSet&lt;Person&gt;();        treeSet.add(new Person(&quot;chenhao&quot;, 30));        treeSet.add(new Person(&quot;lisi&quot;, 20));        treeSet.add(new Person(&quot;wangwu&quot;, 10));        treeSet.add(new Person(&quot;rose&quot;, 40));        Iterator&lt;Person&gt; iterator=treeSet.iterator();        while(iterator.hasNext()){            Person person=iterator.next();            System.out.println(person.getName()+&quot;--&gt;&quot;+person.getAge());        }    }}class Person implements Comparable&lt;Person&gt;{    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int compareTo(Person o) {        int x=this.age-o.age;        if(x&gt;0) return 1;        else if(x&lt;0) return -1;        return 0;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Set容器的特点&quot;&gt;&lt;a href=&quot;#1、Set容器的特点&quot; class=&quot;headerlink&quot; title=&quot;1、Set容器的特点&quot;&gt;&lt;/a&gt;1、Set容器的特点&lt;/h3&gt;&lt;p&gt;Set容器是一个不包含重复元素的Collection，并且最多包含一个nul
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Map</title>
    <link href="http://www.echodemo.cc/2018/07/20/Java%E4%B8%AD%E7%9A%84Map/"/>
    <id>http://www.echodemo.cc/2018/07/20/Java中的Map/</id>
    <published>2018-07-20T13:17:34.000Z</published>
    <updated>2018-07-20T13:18:23.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Map接口详解"><a href="#1、Map接口详解" class="headerlink" title="1、Map接口详解"></a>1、Map接口详解</h3><p>(1)映射(map)是一个存储键/值对的对象。给定一个键，可以查询到它的值，键和值都是对象。</p><p>(2)键必须是唯一的，值可以重复。</p><p>(3)有些映射可以接收null键和null值，而有的不能。</p><p>(4)Map接口定义的方法：int size();boolean isEmpty();boolean containsKey(Object key);boolean containsValue(Object value);V get(Object key);V put(K key,V value);V remove(Object key);Collection<v> values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();返回包含的映射关系的Set视图，Map接口定义的entrySet()方法返回包含映射项Entry的集合(Set)，集合中元素是Map.Entry类型。</v></p><p>(5)Map.Entry接口代表映射项(键-值对)类型，是Map的嵌套类型(是Map的内部类)。</p><p>(6)Map.Entry接口定义的方法：K getKey();V getValue();V setValue(V value)。</p><h3 id="2、HashMap及常用API"><a href="#2、HashMap及常用API" class="headerlink" title="2、HashMap及常用API"></a>2、HashMap及常用API</h3><p>(1)HashMap类是基于哈希表的map接口的实现，并允许使用null键和null值。</p><p>(2)构造方法：HashMap();HashMap(Map m);HashMap(int capacity);HashMap(int capacity,float fillRatio)。</p><p>(3)HashMap实现并扩展AbstractMap，本身并没有增加任何新的方法。</p><p>(4)散列映射不保证它的元素的顺序，元素加入散列映射的顺序并不一定是它们被迭代读出的顺序。</p><p>(5)HashMap常用方法举例</p><pre><code>package com.iotech.map;import java.util.Collection;import java.util.HashMap;import java.util.Map.Entry;import java.util.Set;public class HashMapDemo1 {    public static void main(String[] args) {        HashMap&lt;String,String&gt; hashmap=new HashMap&lt;String, String&gt;();        hashmap.put(&quot;jay&quot;, &quot;张三&quot;);        hashmap.put(&quot;jay&quot;, &quot;李四&quot;);        hashmap.put(&quot;rose&quot;, &quot;玫瑰&quot;);        hashmap.put(&quot;Mary&quot;, &quot;小红&quot;);        System.out.println(hashmap);        //获取map中的所有键        /*Set&lt;String&gt; keysSet=hashmap.keySet();         for(String name:keysSet){            System.out.println(name);        }*/        //获取map中的所有值        Collection&lt;String&gt; values=hashmap.values();        for(String value:values){            System.out.println(value);        }        //得到key的同时得到key所对应的值        Set&lt;String&gt; keysSet=hashmap.keySet();         for(String name:keysSet){            System.out.println(name+&quot;--&gt;&quot;+hashmap.get(name));        }        System.out.println(hashmap.size());        System.out.println(hashmap.isEmpty());        //当我们调用put(key,value)方法的时候，首先会把key和value封装到Entry这个静态内部类对象中。        //把Entry对象再添加到数组中，所以我们想获取map中的所有键值对，我们只要获取数组中的所有Entry对象，        //接下来调用Entry对象中的getkey()和getvalue()方法就能获取键值对。        Set&lt;Entry&lt;String,String&gt;&gt; entrySet=hashmap.entrySet();        for(Entry&lt;String, String&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }        /*         * hashmap调用默认构造方法会产生一个底层长度为16的Entry数组          * int hash=hash(key.hashCode());         * 首先调用key的hashCode方法来得到一个整数(哈希码)，把哈希码作为参数传到hash函数中来进行运算(散列运算)         * 得到一个整型(散列值)。hashCode()方法能够提高哈希表的性能。         * int i=indexFor(hash,table.length);         * 把散列值和数组的长度来进行运算，最终得到entry对象存放到数组的位置(下标)。         *          * hashmap内部的结构是一个数组链表结构。因为不同的key有可能算出来是相同的散列值，根据散列值计算出存放数组         * 的下标会冲突。         */    }}</code></pre><h3 id="3、哈希码的产生和使用"><a href="#3、哈希码的产生和使用" class="headerlink" title="3、哈希码的产生和使用"></a>3、哈希码的产生和使用</h3><p>(1)hashCode的常规协定：在Java应用程序执行期间，在对同一对象多次调用hashCode方法时，必须一致地返回相同的整数，前提是将对象进行equals比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p><p>(2)如果根据equals(Object)方法，两个对象是相等的那么这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。(这里的equals方法是指Object类中没有被子类重写过的equals方法)。</p><p>(3)如果根据equals(java.lang.Object)方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p><p>(4)举例</p><pre><code>package com.iotech.map;import java.util.HashMap;import java.util.Map;public class HashCodeDemo2 {    public static void main(String[] args) {        Map&lt;Student, String&gt; map=new HashMap&lt;Student, String&gt;();        map.put(new Student(&quot;jay&quot;, 20), &quot;张三&quot;);        map.put(new Student(&quot;lisi&quot;, 30), &quot;李四&quot;);        map.put(new Student(&quot;rose&quot;, 20), &quot;玫瑰&quot;);        map.put(new Student(&quot;lisi&quot;, 30), &quot;陈豪&quot;);        /*要满足student键值相等，首先需要hashCode相等，另外还需要key的equals方法相等。所以需要重写        hashCode()和equals()方法。*/        System.out.println(map);        System.out.println(map.size());    }}class Student{    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="4、TreeMap及常用API"><a href="#4、TreeMap及常用API" class="headerlink" title="4、TreeMap及常用API"></a>4、TreeMap及常用API</h3><p>(1)TreeMap类通过使用红黑树实现Map接口。</p><p>(2)TreeMap提供按排序顺序存储键/值对的有效手段，同时允许快速检索。</p><p>(3)TreeMap不像散列映射，树映射保证它的元素按关键字升序排序。</p><p>(4)TreeMap的构造方法：TreeMap();TreeMap(Comparator comp);TreeMap(Map m);TreeMap(SortedMap sm)。</p><p>(5)TreeMap实现SortedMap并且扩展AbstractMap，它本身没有定义其他的方法。</p><p>(6)举例一</p><pre><code>package com.iotech.map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;public class TreeMapDemo1 {    public static void main(String[] args) {        TreeMap&lt;String,String&gt; treeMap=new TreeMap&lt;String, String&gt;();        treeMap.put(&quot;jack&quot;, &quot;zhangsan&quot;);        treeMap.put(&quot;mary&quot;, &quot;xiaohong&quot;);        treeMap.put(&quot;rose&quot;, &quot;xiaozhang&quot;);        treeMap.put(&quot;free&quot;, &quot;xiaoming&quot;);        treeMap.put(&quot;rose&quot;, &quot;chenhao&quot;);        //TreeMap是按照键来进行排序的，而String实现了comparable接口，所以是没有问题的。        System.out.println(treeMap);        Set&lt;Entry&lt;String, String&gt;&gt; entrySet=treeMap.entrySet();        for(Entry&lt;String, String&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }    }}</code></pre><p>(7)举例二</p><pre><code>package com.iotech.map;import java.util.Comparator;import java.util.TreeMap;public class TreeMapDemo2 {    public static void main(String[] args) {        TreeMap&lt;Person,String&gt; treeMap=new TreeMap&lt;Person,String&gt;(new Comparator&lt;Person&gt;() {            @Override            public int compare(Person o1, Person o2) {                int x=o1.getAge()-o2.getAge();                if(x&gt;0) return 1;                else if(x&lt;0) return -1;                return 0;            }        });        treeMap.put(new Person(&quot;zhangsan&quot;, 30), &quot;张三&quot;);        treeMap.put(new Person(&quot;lisi&quot;, 31), &quot;李四&quot;);        treeMap.put(new Person(&quot;rose&quot;, 32), &quot;玫瑰&quot;);        treeMap.put(new Person(&quot;zhangsan&quot;, 33), &quot;张三&quot;);        //这里的Person作为TreeMap中的键，也是需要进行排序的，所以Person类也需要继承Comparable接口，        //因此也需要重写CompareTo()方法。        System.out.println(treeMap);    }}class Person/* implements Comparable&lt;Person&gt;*/{    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    /*@Override    public int compareTo(Person o) {        int x=this.age-o.getAge();        if(x&gt;0){            return 1;        }else if(x&lt;0){            return -1;        }        return 0;    }*/}</code></pre><h3 id="5、Comparator和Comparable接口"><a href="#5、Comparator和Comparable接口" class="headerlink" title="5、Comparator和Comparable接口"></a>5、Comparator和Comparable接口</h3><p>TreeMap的key存储引用数据类型，需要满足一定条件，要么引用类型实现Comparable接口，要么为该TreeMap容器提供实现Comparator接口的比较器对象。对应上面例二的两种实现方式。</p><h3 id="6、案例讲解"><a href="#6、案例讲解" class="headerlink" title="6、案例讲解"></a>6、案例讲解</h3><p>(1)给定一个字符数组，数组中内容有重复，现要求打印输出各个字符串出现的次数。</p><p>(2)使用HashMap来设计，HashMap的key可以用来保存字符串，value用来保存字符串所对应的次数，从HashMap中获取不存在的key所对应的值为null。</p><p>(3)代码实现</p><pre><code>package com.iotech.map;import java.util.HashMap;import java.util.Map.Entry;import java.util.Set;public class HashMapTest {    public static void main(String[] args) {        String[] string={&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;,&quot;jack&quot;,&quot;zhangsan&quot;,&quot;zhangsan&quot;,&quot;wangwu&quot;};        HashMap&lt;String,Integer&gt; hashMap=new HashMap&lt;String,Integer&gt;();        for(int i=0;i&lt;string.length;i++){            if(null==hashMap.get(string[i])){                hashMap.put(string[i], 1);            }else{                hashMap.put(string[i], hashMap.get(string[i])+1);            }        }        Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet=hashMap.entrySet();        for(Entry&lt;String,Integer&gt; entry:entrySet){            System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Map接口详解&quot;&gt;&lt;a href=&quot;#1、Map接口详解&quot; class=&quot;headerlink&quot; title=&quot;1、Map接口详解&quot;&gt;&lt;/a&gt;1、Map接口详解&lt;/h3&gt;&lt;p&gt;(1)映射(map)是一个存储键/值对的对象。给定一个键，可以查询到它的值，键和值都
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的迭代模式举例</title>
    <link href="http://www.echodemo.cc/2018/07/19/Java%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B/"/>
    <id>http://www.echodemo.cc/2018/07/19/Java中的迭代模式举例/</id>
    <published>2018-07-19T12:47:20.000Z</published>
    <updated>2018-07-19T12:49:53.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例介绍"><a href="#1、案例介绍" class="headerlink" title="1、案例介绍"></a>1、案例介绍</h3><p>提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。自定义容器和迭代器。</p><h3 id="2、案例设计"><a href="#2、案例设计" class="headerlink" title="2、案例设计"></a>2、案例设计</h3><p>迭代器角色(Iterator)、具体迭代器角色(Concrete Iterator)、容器角色(Container)、具体容器角色(Concrete Container)。</p><p>定义具体的迭代器角色(我们可以取名为MyIterator)用来实现迭代器角色接口(如Iterator接口，在使用当中，其主要包含hasNext()方法和next()方法)。对于容器角色和具体的容器角色，可以比较直观地把List看作是容器角色，而把ArrayList看作是具体容器角色。</p><h3 id="3、具体实现"><a href="#3、具体实现" class="headerlink" title="3、具体实现"></a>3、具体实现</h3><p>(1)迭代器角色</p><pre><code>package com.iotech.myiterator;public interface Iterator&lt;T&gt; {    public boolean hasNext();//判断是否有下一个元素    public T next();//获取下一个元素的内容}</code></pre><p>(2)容器角色</p><pre><code>package com.iotech.myiterator;public interface List&lt;T&gt; {    public void add(T obj);//给具体的容器添加元素    public T get(int index);//获取指定位置上的元素    public int size();//获得容器中的元素个数    public Iterator&lt;T&gt; iterator();//得到具体的迭代器对象}</code></pre><p>(3)具体的迭代器角色</p><pre><code>package com.iotech.myiterator;public class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; {    private List list=null;    private int index=0;//访问到容器中元素的当前下标    //创建一个迭代器对象的时候接收要被迭代的具体的容器对象    public MyIterator(List&lt;T&gt; list){        this.list=list;    }    //判断是否有下一个元素    @Override    public boolean hasNext() {        return index&lt;list.size();    }    //取出下一个元素    @SuppressWarnings(&quot;unchecked&quot;)    @Override    public T next() {        return (T) list.get(index++);    }}</code></pre><p>(4)具体的容器角色</p><pre><code>package com.iotech.myiterator;public class ArrayList&lt;T&gt; implements List&lt;T&gt; {    private Object[] obj=null;//声明一个Object类型的数组(泛型是不能声明泛型数组的)    private int index;//数组的下标    private int size;//记录数组中元素的个数    public ArrayList(){        obj=new Object[10];        index=0;        size=0;    }    @Override    public void add(T obj) {        this.obj[index++]=obj;//把数据存放到数组中        size++;//元素个数加1    }    @SuppressWarnings(&quot;unchecked&quot;)    @Override    public T get(int index) {        return (T) this.obj[index];    }    @Override    public int size() {        return size;    }    @Override    public Iterator&lt;T&gt; iterator() {        return new MyIterator&lt;T&gt;(this);    }}</code></pre><p>(5)测试类</p><pre><code>package com.iotech.myiterator;public class Test {    public static void main(String[] args) {        List&lt;String&gt; nameList=new ArrayList&lt;String&gt;();        nameList.add(&quot;zhangsan&quot;);        nameList.add(&quot;lisi&quot;);        nameList.add(&quot;wangwu&quot;);        nameList.add(&quot;chenhao&quot;);        Iterator&lt;String&gt; iterator=nameList.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、案例介绍&quot;&gt;&lt;a href=&quot;#1、案例介绍&quot; class=&quot;headerlink&quot; title=&quot;1、案例介绍&quot;&gt;&lt;/a&gt;1、案例介绍&lt;/h3&gt;&lt;p&gt;提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。自定义容器和迭代器。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的List</title>
    <link href="http://www.echodemo.cc/2018/07/18/Java%E4%B8%AD%E7%9A%84List/"/>
    <id>http://www.echodemo.cc/2018/07/18/Java中的List/</id>
    <published>2018-07-18T13:32:57.000Z</published>
    <updated>2018-07-18T16:02:40.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、List容器特点"><a href="#1、List容器特点" class="headerlink" title="1、List容器特点"></a>1、List容器特点</h3><p>List容器是有序的collection(也称之为序列)，此接口的用户可以对List容器中每个元素的插入位置进行精准地控制。用户可以根据元素的整数索引(在列表中的位置)访问元素，并搜索列表中的元素。List容器允许插入重复的值，包括null。</p><h3 id="2、ArrayList-动态数组-及常用API"><a href="#2、ArrayList-动态数组-及常用API" class="headerlink" title="2、ArrayList(动态数组)及常用API"></a>2、ArrayList(动态数组)及常用API</h3><p>(1)ArrayList类扩展了AbstractList并实现了List接口。</p><p>(2)支持可随需增长的动态数组。(以1.5倍的倍率进行扩容)</p><p>(3)ArrayList构造方法。ArrayList();ArrayList(Collection c);ArrayList(int capacity);</p><p>(4)除继承的方法之外，ArrayList常用方法。E get(int index)方法：返回此列表中指定位置上的元素；int intdexOf(Object o)：返回此列表中首次出现的指定元素的索引，或如果此列表不含该元素，则返回-1。</p><p>(5)ArrayList的常用方法举例</p><pre><code>import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ArrayListDemo1 {    public static void main(String[] args) {        /*         * 当我们调用无参构造方法来构造一个ArrayList对象的时候，它会在内部分配一个初始大小为10的一个Object类型数组。         *          * 当添加的数据容量超过数组大小的时候，会产生一个新的数组，新的数组的大小是原来数组大小的1.5倍。接着把原数组         * 中的数据拷贝到新的数组中。         */        List&lt;String&gt; nList=new ArrayList&lt;String&gt;();        nList.add(&quot;chenhao&quot;);//添加元素        nList.add(&quot;lisi&quot;);        nList.add(&quot;lisi&quot;);        nList.add(&quot;wangwu&quot;);        nList.add(1, &quot;jay&quot;);//在指定的位置添加元素        nList.add(&quot;jack&quot;);        nList.set(0, &quot;chengang&quot;);//修改指定位置的元素值        System.out.println(&quot;使用迭代器对象来进行统一的遍历&quot;);        Iterator&lt;String&gt; iterator=nList.iterator();         while (iterator.hasNext()) {            String name = iterator.next();            System.out.println(name);        }        System.out.println(&quot;使用增强for循环进行遍历&quot;);        for(String name:nList){            System.out.println(name);        }        System.out.println(&quot;********************************&quot;);        System.out.println(nList.indexOf(&quot;lisi&quot;));//查找指定元素的位置        System.out.println(nList.remove(&quot;lisi&quot;));//删除元素        System.out.println(nList.remove(0));//删除某个位置的元素        System.out.println(nList.size());//动态数组的大小        System.out.println(nList.contains(&quot;chenhao&quot;));//是否包含某个元素        System.out.println(nList.get(1));//获取指定位置的元素值        System.out.println(nList.isEmpty());//判断动态数组是否为空        nList.clear();//清空动态数组        System.out.println(nList.isEmpty());        System.out.println(&quot;********************************&quot;);    }}</code></pre><p>(6)ArrayList方法的重载举例</p><pre><code>import java.util.ArrayList;import java.util.List;public class ArrayListDemo2 {    public static void main(String[] args) {        List&lt;Student&gt; stuList=new ArrayList&lt;Student&gt;();//以学生类对象作为泛型的具体化        Student stu1=new Student(&quot;zhangsan&quot;, 10);        Student stu2=new Student(&quot;lisi&quot;, 20);        Student stu3=new Student(&quot;jack&quot;, 30);        Student stu4=new Student(&quot;mandy&quot;, 10);        Student stu5=new Student(&quot;mary&quot;, 20);        stuList.add(stu1);        stuList.add(stu2);        stuList.add(stu3);        stuList.add(stu4);        stuList.add(stu5);        Student stu6=new Student(&quot;mary&quot;, 20);        //可以通过按住Ctrl键再点击相应的方法名来查看方法的具体实现。从而搞清楚下列方法在修改equals方法之后的变化。        System.out.println(stuList.indexOf(stu6));        System.out.println(stuList.contains(stu6));        System.out.println(stuList.remove(stu6));        System.out.println(stuList.indexOf(stu5));        System.out.println(stuList.size());    }}class Student{//学生类    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public boolean equals(Object obj) {//重写equals方法，只要姓名和年龄一致则是相同的对象。        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}</code></pre><h3 id="3、LinkedList及常用API"><a href="#3、LinkedList及常用API" class="headerlink" title="3、LinkedList及常用API"></a>3、LinkedList及常用API</h3><p>(1)LinkedList类扩展AbstractSequentialList并实现List接口。</p><p>(2)LinkedList提供了一个链表数据结构。(其中含有Node对象，并且有前引用和后引用)</p><p>(3)LinkedList有两个构造方法：LinkedList();LinkedList(Collection c);</p><p>(4)除了继承的方法之外，LinkedList类还定义了一些有用的方法用于操作和访问容器中的数据。void addFirst(E e);void addLast(E e);E removeFirst();E removeLast();</p><p>(5)由于Deque接口扩展了Queue接口，成为双端队列，而LinkedList继承了Deque接口。所以它可以提供add、poll先进先出队列的操作，以及其他堆栈和双端队列操作。</p><p>(6)LinkedList常用方法举例</p><pre><code>import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo1 {    public static void main(String[] args) {        /*         * LinkedList内部封装的是双向的链表数据结构，每个节点是一个Node对象，Node对象中封装的是你要         * 添加的元素，还有一个指向上一个Node对象的引用和下一个Node对象的引用。         *          * 不同的容器有不同的数据结构，不同的数据结构操作起来的性能是不一样的。链表数据结构做插入、删除         * 的效率较高，但查询的效率比较低。数组结构做查询的时候效率高，因为可以通过下标直接找到元素，但         * 插入和删除效率比较低，因为要做移位操作。         */        LinkedList&lt;String&gt; sList=new LinkedList&lt;String&gt;();        sList.add(&quot;zhangsan&quot;);//添加        sList.add(&quot;lisi&quot;);        sList.add(&quot;wangwu&quot;);        sList.add(&quot;rose&quot;);        sList.add(&quot;mary&quot;);        sList.add(&quot;jack&quot;);        sList.addFirst(&quot;chenhao&quot;);//添加至开头        sList.addLast(&quot;mandy&quot;);//添加至末尾        /*Iterator&lt;String&gt; iterator=sList.iterator();        while (iterator.hasNext()) {            String name = iterator.next();            System.out.println(name);        }*/        /*for(String name:sList){            System.out.println(name);        }*/        for(Iterator&lt;String&gt; iterator=sList.iterator();iterator.hasNext();){            String name=iterator.next();            System.out.println(name);        }        System.out.println(sList.removeFirst());//为空时返回异常        System.out.println(sList.size());        sList.clear();        System.out.println(sList.pollFirst());//为空时返回null    }}</code></pre><p>(7)使用LinkedList来实现栈和队列的功能</p><pre><code>import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo2 {    public static void main(String[] args) {        /*Mystack&lt;String&gt; mystack=new Mystack&lt;String&gt;();        mystack.push(&quot;zhangsan&quot;);        mystack.push(&quot;lisi&quot;);        mystack.push(&quot;wangwu&quot;);        mystack.push(&quot;zhaoliu&quot;);        mystack.pop();        mystack.pop();        Iterator&lt;String&gt; iterator = mystack.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }*/        MyQueue&lt;Integer&gt; myQueue=new MyQueue&lt;Integer&gt;();        myQueue.push(1);        myQueue.push(2);        myQueue.push(3);        myQueue.push(4);        myQueue.push(5);        myQueue.pop();        myQueue.pop();        Iterator&lt;Integer&gt; iterator=myQueue.iterator();        while(iterator.hasNext()){            System.out.println(iterator.next());        }    }}class Mystack&lt;T&gt;{//使用LinkedList来模拟栈的数据结构    private LinkedList&lt;T&gt; data=null;    public Mystack(){        data=new LinkedList&lt;T&gt;();    }    //压栈的方法    public void push(T obj){        data.addFirst(obj);    }    //出栈的方法    public T pop(){        return data.removeFirst();    }    public Iterator&lt;T&gt; iterator(){        return data.iterator();    }}class MyQueue&lt;T&gt;{//使用LinkedList来模拟队列的数据结构    private LinkedList&lt;T&gt; data=null;    public MyQueue(){        data=new LinkedList&lt;T&gt;();    }    //入队    public void push(T obj){        data.addLast(obj);    }    //出队    public T pop(){        return data.removeFirst();    }    public Iterator&lt;T&gt; iterator(){        return data.iterator();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、List容器特点&quot;&gt;&lt;a href=&quot;#1、List容器特点&quot; class=&quot;headerlink&quot; title=&quot;1、List容器特点&quot;&gt;&lt;/a&gt;1、List容器特点&lt;/h3&gt;&lt;p&gt;List容器是有序的collection(也称之为序列)，此接口的用户可以对
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的集合</title>
    <link href="http://www.echodemo.cc/2018/07/18/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>http://www.echodemo.cc/2018/07/18/Java中的集合/</id>
    <published>2018-07-18T11:29:49.000Z</published>
    <updated>2018-07-23T00:26:36.842Z</updated>
    
    <content type="html"><![CDATA[<p>1、集合框架：它是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口与类。集合框架包含了各种各样的容器，每一种容器都可以存放数据并且提供了操作容器当中数据的相关方法。</p><p>2、集合框架中不同的集合类有各自不同的数据结构，所以在使用中要根据应用的性能要求来选择不同的集合类。</p><p>3、集合类存放在java.util包中，今后进行程序编程时将大量使用集合类和相关接口。其中包括Iterable:迭代器接口；Collection：类集接口；List：列表接口；Set：数据集接口；Queue：队列；Map：键值对组合映射表。</p><p><img src="/images/2018/7/1.jpg" alt="&quot;集合框架&quot;"></p><p>(1)Iterable接口</p><p>实现该接口允许对象成为“foreach”语句的目标，即该集合对象允许迭代。类集接口Collection是Iterable的子接口，所以所有类集对象可以迭代访问，而映射Map不行。(Map并没有实现Iterable接口)</p><p>Iterator<t>iterator():功能：返回一个在一组T类型的元素上进行迭代的迭代器对象。迭代器是实现了Iterator/ListIterator接口的类的对象，可以通过遍历类集，访问操作其中的每个元素。ListIterator继承了父接口Iterator，允许双向遍历集合，并可以修改和删除元素。</t></p><p>(2)Collection接口</p><p>int size();boolean isEmpty();boolean contains(Object o);Iterator<e> iterator;Object[] toArray();boolean add(E e);boolean remove(Object o);void clear()。等等</e></p><p>(3)List、Set、Map接口</p><p>List接口扩展了Collection，有序且可重复；Set接口扩展了Collection，无序且不可重复；Map是一个存储关键字/值对的对象。映射不是Collection的子接口，所以它本身不能使用迭代器来进行遍历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、集合框架：它是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口与类。集合框架包含了各种各样的容器，每一种容器都可以存放数据并且提供了操作容器当中数据的相关方法。&lt;/p&gt;
&lt;p&gt;2、集合框架中不同的集合类有各自不同的数据结构，所以在使用
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.echodemo.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>成为职场人</title>
    <link href="http://www.echodemo.cc/2018/07/17/%E6%88%90%E4%B8%BA%E8%81%8C%E5%9C%BA%E4%BA%BA/"/>
    <id>http://www.echodemo.cc/2018/07/17/成为职场人/</id>
    <published>2018-07-17T10:58:27.000Z</published>
    <updated>2018-07-17T10:59:09.813Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>礼仪培训笔记</title>
    <link href="http://www.echodemo.cc/2018/07/17/%E7%A4%BC%E4%BB%AA%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.echodemo.cc/2018/07/17/礼仪培训笔记/</id>
    <published>2018-07-17T10:15:32.000Z</published>
    <updated>2018-07-17T10:50:41.212Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是礼仪？"><a href="#一、什么是礼仪？" class="headerlink" title="一、什么是礼仪？"></a>一、什么是礼仪？</h3><p>礼仪=礼节+原则=心理+形式</p><h3 id="二、简析服务礼仪"><a href="#二、简析服务礼仪" class="headerlink" title="二、简析服务礼仪"></a>二、简析服务礼仪</h3><p>1、顾客永远是对的（把面子留给客人，放弃自我，自主揽错）</p><p>2、永远不要辩解，服务中禁止使用推卸责任的语言。</p><p>3、注重首因效应、末轮效应。比如：缩短客人的等待时间。</p><p>4、在职场当中得体比漂亮更重要。包括面部，发型，举止，服饰，谈吐。如：不能穿短衬打领带，衬衣只买领围的大小。</p><h3 id="三、学会用眼睛说话"><a href="#三、学会用眼睛说话" class="headerlink" title="三、学会用眼睛说话"></a>三、学会用眼睛说话</h3><p>1、目光注视方式（PAC规律）</p><p>2、目光注视区域（三角定律）</p><p>3、目光注视时间规律（3~5秒）</p><p>4、目光注视的距离</p><h3 id="四、人际沟通“六到”"><a href="#四、人际沟通“六到”" class="headerlink" title="四、人际沟通“六到”"></a>四、人际沟通“六到”</h3><p>1、脑到：先三思，后言行。</p><p>2、眼到：专注，诚恳，体现尊重。</p><p>3、耳到：诚心聆听，不打岔。</p><p>4、口到：不吝啬鼓励、善意、赞美的语言。</p><p>5、心到：从他人角度理解，换位思考。</p><p>6、脚到：主动接近，距离合适。</p><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>1、服务距离：0.5~1.5米；展示距离：1~3米；引导距离：在客户左前方1~1.5米；待命距离：3米以外。</p><p>2、鞠躬距离控制：脚前方2米是15度；脚前方1.5米是30度；脚前方1.0米是45度。</p><p>3、在职场以职称论高低，在社交场合以女士为尊者，在家庭以年龄为长。</p><p>4、握手需要把握力度，距离。在不同的场合都是尊者先伸手握手。自我介绍在握手之前，且尊者后进行自我介绍。尊者有优先了解别人的权利。</p><p>5、名片：先客后主，先低后高，尊者优先收名片。尊者有优先了解别人的权利。</p><h5 id="6、先肯定全部，再否认局部。"><a href="#6、先肯定全部，再否认局部。" class="headerlink" title="6、先肯定全部，再否认局部。"></a>6、先肯定全部，再否认局部。</h5><h2 id="注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。"><a href="#注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。" class="headerlink" title="注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。"></a>注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、什么是礼仪？&quot;&gt;&lt;a href=&quot;#一、什么是礼仪？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是礼仪？&quot;&gt;&lt;/a&gt;一、什么是礼仪？&lt;/h3&gt;&lt;p&gt;礼仪=礼节+原则=心理+形式&lt;/p&gt;
&lt;h3 id=&quot;二、简析服务礼仪&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣入门单反购买文章推荐</title>
    <link href="http://www.echodemo.cc/2018/06/14/%E8%B1%86%E7%93%A3%E5%85%A5%E9%97%A8%E5%8D%95%E5%8F%8D%E8%B4%AD%E4%B9%B0%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/"/>
    <id>http://www.echodemo.cc/2018/06/14/豆瓣入门单反购买文章推荐/</id>
    <published>2018-06-14T12:47:04.000Z</published>
    <updated>2018-06-14T13:06:09.927Z</updated>
    
    <content type="html"><![CDATA[<p>1、<a href="https://www.douban.com/note/662799586/" target="_blank" rel="noopener">单反购机指南</a></p><p>2、<a href="https://www.douban.com/note/664275766/" target="_blank" rel="noopener">微单购机指南</a></p><p>3、<a href="https://www.douban.com/note/666401386/" target="_blank" rel="noopener">索尼微单购机指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;a href=&quot;https://www.douban.com/note/662799586/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单反购机指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.douban.com/not
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="PS" scheme="http://www.echodemo.cc/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>昨夜同门云集推杯又换盏</title>
    <link href="http://www.echodemo.cc/2018/06/10/%E6%98%A8%E5%A4%9C%E5%90%8C%E9%97%A8%E4%BA%91%E9%9B%86%E6%8E%A8%E6%9D%AF%E5%8F%88%E6%8D%A2%E7%9B%8F/"/>
    <id>http://www.echodemo.cc/2018/06/10/昨夜同门云集推杯又换盏/</id>
    <published>2018-06-09T16:25:30.000Z</published>
    <updated>2018-06-13T11:26:08.566Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有一些文字需要留给渐行渐远的昨日，那我想此时写下应是恰如其分的。从时光的长河里回溯，逆流而上，我将在哪个渡口停留呢？想了很多，试着写下，但却觉得文字的表述在此刻显得如此地苍白无力。貌似无法承载情感的洪流，犹如昨日的暴雨落地，地面的流水浩浩汤汤，奔涌而去，却仍然没有停止的迹象。或许过后回望，会像雨过天晴之后晨梦亭里的独坐、鸟儿与青蛙的鸣唱、不远处飘来的荷香还有洗净的天空那样云淡而风轻。但最为珍贵的仍是属于当下的自己，当下的我们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果有一些文字需要留给渐行渐远的昨日，那我想此时写下应是恰如其分的。从时光的长河里回溯，逆流而上，我将在哪个渡口停留呢？想了很多，试着写下，但却觉得文字的表述在此刻显得如此地苍白无力。貌似无
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《非暴力沟通》摘句</title>
    <link href="http://www.echodemo.cc/2018/06/04/%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E6%91%98%E5%8F%A5/"/>
    <id>http://www.echodemo.cc/2018/06/04/《非暴力沟通》摘句/</id>
    <published>2018-06-04T11:30:43.000Z</published>
    <updated>2018-06-13T12:01:37.964Z</updated>
    
    <content type="html"><![CDATA[<p>1、非暴力生活的一个关键就是：感激生活的赐予，而不贪心。</p><p>2、非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。</p><p>3、非暴力沟通四要素。首先：留意发生的事情，说出人们所做的事情，清楚地表达观察结果，而不判断或评估。其次：表达感受。然后：说出哪些需要导致那样的感受，诚实地表达自己。最后：提出具体的请求。</p><p>4、暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方。</p><p>5、我这样做，因为我想……陈述观察……我（感到）……因为我……</p><p>6、我们大多数的人使用的语言倾向于评判、比较、命令和指责，而不是鼓励我们倾听彼此的感受和需要。</p><p>7、道德评判就是其中的一种，它将不符合我们价值观的人看作是不道德的或邪恶的。进行比较也是一种评判，它会蒙蔽对人对己的爱意。异化的沟通方式还淡化了我们对自己的思想、情感和行为的责任意识。此外，强人所难也会造成心灵的隔阂。</p><p>8、如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。</p><p>9、真诚待人比委曲求全更为可贵。如果别人感到不安，我们可以认真地倾听，但无须责备自己。</p><p>10、我们提出的请求越具体越好。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。使用抽象的语言还会使我们无法深入了解自己。请求他人采取具体的行动将揭示我们的动机。</p><p>11、如果我们只是表达自己的感受，别人可能就不清楚我们想要什么。</p><p>12、由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要清楚地表明自己的期待。否则，讨论可能只是在浪费大家的时间。</p><p>13、在我们的文化中，直接谈论一个人的感受是很少见的。重要的是，我已经不再把他的话看作是对我的攻击，而注意体会他的感受和需要。</p><p>14、为了倾听他人，我们需要先放下已有的想法和判断，全心全意地体会对方。倾听他人有助于对他人的理解和接纳。</p><p>15、听到不中听的话时，我们有四种选择：1.责备自己；2.指责他人；3.体会自己的感受和需要；4.体会他人的感受和需要。</p><p>16、如果你希望自己在生气的时候也能运用非暴力沟通，我建议你做以下的练习。在前面，我们已经提到，我们生气是因为我们的想法——我们认为人们“应该”或“不应该”做什么，我们还给人贴上各种标签，并说长论短。请留意我们头脑中“我不喜欢抽烟的人……”之类的想法。然后，问自己：“我不喜欢他们……，是因为我什么样的需要没有得到满足？”通过这样的方式，我们就把注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。</p><p>17、在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。</p><p>18、在使用惩罚性的强制力时，我们认为某些人是邪恶的，为了让他们悔改，必须给他们一点颜色看看。此时，我们希望痛苦能让他们：（1）意识到自己的过错；（2）感到懊悔；（3）改变行为。然而，在实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。</p><p>19、个人的成长是通过与他人的坦诚交流来实现的——在交流中，彼此能够自由地表达内心的软弱。</p><p>20、非暴力沟通表达感激的方式包含三个部分：1.对方做了什么事情使我们的生活得到了改善；2.我们有哪些需要得到了满足；3.我们的心情怎么样？</p><p>21、诚实地表达自己，而不批评、指责（1）观察我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：“当我（看、听、想到我看到的/听到的） ……”（2）感受对于这些行为，我有什么样的感受（情感而非思想）：“我感到……”（3）需要什么样的需要或价值（而非偏好或某种具体的行为）导致我那样的感受：“因为我需要／看重……”（4）请求清楚地请求（而非命令）那些能丰富我生命的具体行为：“你是否愿意……？”</p><p>22、关切地倾听他人，而不解读为批评或指责（1）观察你所观察（看、听、回忆、想）到的有助于（或无助于）你的福祉的具体行为：“当你（看、听、想到你看到的/听到的） ……”（2）感受对于这些行为，你有什么样的感受（是情感而非思想）：“你感到……吗？”（3）需要什么样的需要或价值（而非偏好或某种具体的行为）导致你那样的感受：“因为你需要／看重……”（4）请求关切地倾听那些能丰富你生命的具体请求，而不解读为命令：“所以，你想……”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、非暴力生活的一个关键就是：感激生活的赐予，而不贪心。&lt;/p&gt;
&lt;p&gt;2、非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。&lt;/p&gt;
&lt;p&gt;3、非暴力沟通四要素。首先：留意发生的事情，说出人们所做的事情，清楚地表达观
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书笔记" scheme="http://www.echodemo.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PS制图</title>
    <link href="http://www.echodemo.cc/2018/06/03/PS%E5%88%B6%E5%9B%BE/"/>
    <id>http://www.echodemo.cc/2018/06/03/PS制图/</id>
    <published>2018-06-03T12:24:31.000Z</published>
    <updated>2018-06-03T12:25:44.580Z</updated>
    
    <content type="html"><![CDATA[<p>1、一寸照的尺寸为：宽度2.5厘米，高度3.5厘米，分辨率设为300，选择CMYK颜色。将图片拖入新建的空白图片当中，快捷键Ctrl+T进行自由变换(如果此时看不到控点，可以通过Ctrl+减号快捷键来进行缩小)。如果需要变换背景色，则使用快速选择工具选择空白区域。然后按住Alt键来添加图层蒙版。此时可以删除背景图层，选中蒙版来对图层蒙版进行调节。接下来新建一个图层，下拉到带有蒙版的图层的下方，再进行颜色填充即可。如果此时还需要对服装进行变换，那么就将做好选区的衣服图片拖入图中进行变换。之后还可以建立矩形选区，通过Ctrl+T快捷键，然后通过移动来消除譬如T恤这种色块。最后保存为jpg格式。</p><p>如果需要将一寸照片打印多张在一张国际标准纸张上面。那么可以新建一个文件，选择国际标准纸张，选择CMYK模式，然后将刚才的jpg文件移动到新建的纸张里面。可以通过Ctrl+R快捷键调出标尺，然后拖出两条分别距离左顶点一厘米的参考线，回车之后。双击图层，打开图层样式，勾选描边，像素设置为5像素，位置选择内部，颜色选择白色，点击确定。然后在移动工具下按住Alt键来拖拽图片进行复制。当复制出两个之后，在图层工作区上选择两个图层继续按住Alt键来复制，这样以此类推，就可以不需要一张一张复制，而是以2的幂次方递增了。在复制出一整行图片之后，可以在图层的缩览图当中选择最小的样式，之后选择所有的图层，使用Ctrl+E将他们全部合并为一个图层。此时用之前的复制方法就可以很快地对图片进行复制，直到基本铺满整个国际标准纸张。</p><p>2、制作全景图片：在文件菜单中选择脚本，将脚本载入堆栈，然后选择文件夹，打开。选择所有的图层，选择移动工具，在移动工具菜单栏的最右边选择自动对齐图层，常规情况下选择自动即可，点击确定。接下来继续选中这些图层，在编辑菜单中选择自动混合图层，选择全景图，点击确定。然后再对图片进行裁剪。自动回合图层还可以用于堆叠混合。</p><p>3、服装操控变形：打开图像，在编辑菜单栏中选择操控变形选项。在图片中打上图钉之后即可进行变形，图钉深度可以将图钉在前面和后面进行切换。</p><p>4、内容识别比例：打开图片，使用套索工具对需要进行放大或者是缩小的部分进行大致地选取，然后右击鼠标进行存储选区，接下来Ctrl+D取消选区。在编辑菜单当中，选择内容识别比例，在保护项当中选取刚才存储的选区。如果选取的是人物，还可以勾选，保护项后面的保护肤色选项。</p><p>5、图层复制：按住Alt键直接拖拽来复制图层。在图层面板中将图层移动到新建图层按钮上。也可以通过快捷键Ctrl+J来复制图层。</p><p>选区复制：按住Alt键来对选区进行拖拽即可，这样复制出来的是在同一个图层。如果是通过快捷键Ctrl+J来复制选区的话，就是新建出了一个只包含选区内容的图层。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、一寸照的尺寸为：宽度2.5厘米，高度3.5厘米，分辨率设为300，选择CMYK颜色。将图片拖入新建的空白图片当中，快捷键Ctrl+T进行自由变换(如果此时看不到控点，可以通过Ctrl+减号快捷键来进行缩小)。如果需要变换背景色，则使用快速选择工具选择空白区域。然后按住A
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="PS" scheme="http://www.echodemo.cc/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>PS抠图</title>
    <link href="http://www.echodemo.cc/2018/05/31/PS%E6%8A%A0%E5%9B%BE/"/>
    <id>http://www.echodemo.cc/2018/05/31/PS抠图/</id>
    <published>2018-05-31T01:47:29.000Z</published>
    <updated>2018-05-31T01:49:37.137Z</updated>
    
    <content type="html"><![CDATA[<p>1、调整边缘抠图：先使用快速选择工具做出选区，然后通过调整边缘(选择并遮住)来调整。先选择黑底，然后根据需要来调整半径，平滑，羽化(对比度)，移动边缘等命令。之后新建带有图层蒙版的图层。</p><p>2、当打开一张已经抠好的图片，并且此时没有设置蒙版，那么为了节省时间可以使用图层下拉菜单中的修边选项中的各个命令来处理图片的边缘。</p><p>3、钢笔工具抠图：选择钢笔工具，选择路径选项，建立锚点直到闭合选区。添加矢量蒙版，选择减去顶层形状来，通过新建锚点来再建一条路径(此时需要选中蒙版来操作)，直到闭合路径。新建图层，添加背景。之后可以对图片中局部镂空的地方，继续选择减去顶层形状来做精细的路径抠图(依然需要选中蒙版才能进行操作)。在这之后，我们还可以选择路径选择工具和直接选择工具对路径进行再调整。</p><p>4、蒙版抠图：通过蒙版来进行粗抠图，可以产生不一样的效果，使用椭圆选区大致地选出需要抠取的部分，在选择下拉菜单当中选择修改中的羽化，建立蒙版。将其拖入其他的图片当中进行变换即可。</p><p>融合两张图片：可以先将一张图片拖入另一张图片，然后对拖入的图片创建蒙版。选中蒙版，使用黑白渐变工具(这里注意前景色和背景色)，然后进行渐变调节，即可将两张图片融合在一起。如果是有倒影的情况，可以选中图层，然后进行复制，右击进行垂直翻转，同时选择正片叠底，再降低它的不透明度即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、调整边缘抠图：先使用快速选择工具做出选区，然后通过调整边缘(选择并遮住)来调整。先选择黑底，然后根据需要来调整半径，平滑，羽化(对比度)，移动边缘等命令。之后新建带有图层蒙版的图层。&lt;/p&gt;
&lt;p&gt;2、当打开一张已经抠好的图片，并且此时没有设置蒙版，那么为了节省时间可以
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="PS" scheme="http://www.echodemo.cc/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>PS基础知识(杂)</title>
    <link href="http://www.echodemo.cc/2018/05/30/PS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E6%9D%82)/"/>
    <id>http://www.echodemo.cc/2018/05/30/PS基础知识(杂)/</id>
    <published>2018-05-30T10:55:38.000Z</published>
    <updated>2018-05-30T11:08:59.636Z</updated>
    
    <content type="html"><![CDATA[<p>1、分辨率和图片的用途是相关的。常用分辨率设置：洗印照片：300或以上；杂志、名片等印刷物：300；海报高清写真：96~200；网络图片、网页界面：72；大型喷绘：25~50。总像素值=像素宽度X像素高度=文档宽度X文档高度X分辨率的平方</p><p>2、常用快捷键：</p><pre><code>(1)打开首选项：Ctrl+K(2)缩放图片：Alt+鼠标滚轮(3)新建时复位：按住Alt不松(4)打开文件：双击工作区(5)新建图层：Alt+创建图层(6)创建图层副本：Alt+拖拽至指定位置或者Ctrl+J(7)抓手工具：按住空格键不松(8)放大工具：空格+Ctrl(9)缩小工具：空格+Alt(10)快速填充前景色:Alt+delete(11)快速填充背景色:Ctrl+delete</code></pre><p>3、移动图层位置不变：在拖拽至另一个文件时，先按住Shift再松鼠标(前提是两个图像大小一样)。如果两个图像大小不一样的话，按上面操作会跑到正中央；如果图像中有选区，则跑到选区的正中央。在移动工具状态下，按住Ctrl键就可以自动选择图层。在非移动工具状态下，按住Ctrl键可以切换到移动工具状态。Shift键加方向键可以微调。</p><p>4、选区时按住Shift键，选框变成正方形。按住Alt键从中心点建立选区。Ctrl+D取消选区，Ctrl+Shift+D恢复之前的选区</p><p>5、套索工具按住Alt键可以在套索工具和多边形套索工具之间切换。磁性套索工具按住Alt键可以在磁性套索工具和多边形套索工具之间切换。delete键可以用于取消套索的上一个锚点。</p><p>6、按住Alt键，点击鼠标右键左右移动，改变画笔大小。上下移动改变画笔硬度。</p><p>7、虽然修复画笔工具和仿制图章工具共享仿制源，但是修复画笔工具不同于仿制图章工具。修复画笔工具更智能，它能够尽可能地和周围的环境进行融合。</p><p>8、通道的概念类似于图层的概念，只不过通道是从另一个角度(图像的色彩或透明度)来诠释图像的构成。 Alpha通道就是记录透明度信息的特殊层，在Alpha通道当中，黑色代表着透明，白色代表拥有颜色信息，不透明。说白了，通道当中的颜色代表的是当前通道的颜色强度(黑白灰)，而不是颜色本身。Alpha通道是一个选区加工厂。不管是通道还是图层，都可以通过按住Ctrl键，点击相应的通道或者是图层来建立相应的选区。</p><p>9、图层蒙版可以隐藏和显示图层上的部分区域，按住Alt键点击添加图层蒙版，隐藏的是选区的部分。按住Alt键点击建立好的图层蒙版，图层蒙版此时处于编辑状态之下，对应的是一个临时的Alpha通道。快速蒙版方便查看。</p><p>10、锁定透明像素：禁止对透明区域进行操作。快速建组：Ctrl+G。一个组合一个图层同时选中，Ctrl+G也可以再建组。取消分组：Ctrl+Shift+G。Ctrl+E向下合并图层，Ctrl+Alt+E向下合并并且保留向下合并的图层。创建图层剪贴蒙版，图层只能在下方图层内显示。</p><p>11、色相：颜色的品相。通过改变色相环上色彩的角度(一共360度)可以进行变色。从红色到蓝色需要逆时针旋转120度，就把色相的值变换为-120。从红色到绿色需要顺时针旋转120，就把色相的值变换为120。</p><p>饱和度：是指色彩的鲜艳程度，其实就是加入中性灰的程度。当饱和度降到最低的时候，图像显示的是灰色，灰色是没有色相的。灰色的红绿蓝RGB值是相等的，只要RGB值是相等的，那么只可能是黑、白、灰三种颜色。</p><p>明度：就是发光量，加入额外的白光。</p><p>RGB模式：光的三基色，它是发光色。</p><p>CMYK模式：印刷色彩模式。青色(Cyan)，品红色(Magenta)，黄色(Yellow)，黑色(Black)。代表印刷用的四种油墨，它是反光色。CMYK通道里面，黑色代表100%浓度的油墨。</p><p>12、色阶：是表示图像亮度强弱的指数标准，表现了一副图的明暗关系，它和颜色无关。通过色阶编辑框可以看出图片整体的明暗分布。移动X轴上的最左边的黑色滑块，如果从0移动到70，黑场的数值变大，画面变暗(仅是黑场部分发生了变化，而灰场和白场没有)，它是把亮度级别为70以下的像素，都合并为最低的0。调节黑场，就是合并暗部的颜色，对亮部暂无影响。如果是移动X轴最右边的白色滑块，从255移动到180的话，和黑色滑块的原理是一样的，再180到255这个亮度级别的像素，都合并成为255级别。</p><p>13、曲线命令：Ctrl+M。曲线直方图的X轴上的黑色滑块和白色滑块的功能和色阶上的对应滑块功能相似。所不同的是，它们是对整个图片的明暗度进行整体的变暗和变亮。而不仅仅是对移动滑块区域的像素进行调整。但对于复杂的图片来说，色阶、曲线等最好都去使用调整图层，这样可以针对图片的某个图层进行调整。</p><p>14、色彩平衡不同于色相的改变。保持明度，可以保证调整后的颜色发光总量不变。</p><p>15、使用钢笔工具时按住Shift键，可以根据角度来创建水平，垂直和45度的线段。在相应的路径点击回车，图像上的路径会被隐藏。黑色的路径选择工具是选择整体的，而白色的路径选择工具是选择单个的锚点的，按住Ctrl键可以在两者之间进行转换。按住Alt键，可以调节单个的控杆。Ctrl+enter将路径变成选区。文字可以依附路径的形状输入。</p><p>16、调节行距，字距。Alt+上下左右箭头就可以。在视图的显示当中有网格。视图当中的标尺可以在标尺的区域通过单击右键来修改单位，也可以从左上角的方块拉出十字交叉线来改变原点的位置，双击方块可以恢复到原状态。视图中可以新建参考线，也可以从标尺当中拖拽出参考线，按住Alt键来单击左键可以将水平和垂直的参考线进行转换，将参考线拉回标尺区域即可删除参考线。视图中的显示额外内容(Ctrl+H)，可以将隐藏参考线，网格以及选区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、分辨率和图片的用途是相关的。常用分辨率设置：洗印照片：300或以上；杂志、名片等印刷物：300；海报高清写真：96~200；网络图片、网页界面：72；大型喷绘：25~50。总像素值=像素宽度X像素高度=文档宽度X文档高度X分辨率的平方&lt;/p&gt;
&lt;p&gt;2、常用快捷键：&lt;/
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="PS" scheme="http://www.echodemo.cc/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 从排序数组中删除重复项</title>
    <link href="http://www.echodemo.cc/2018/05/18/LeetCode-%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://www.echodemo.cc/2018/05/18/LeetCode-从排序数组中删除重复项/</id>
    <published>2018-05-18T07:25:45.000Z</published>
    <updated>2018-05-18T07:28:46.071Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><pre><code>示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><p>题目代码：</p><pre><code>class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        if(nums.size()==0) return 0;        else if(nums.size()==1) return 1;        int i=1,k=1;        int len=nums.size();        while(k&lt;len){            if(nums[k-1]!=nums[k]){                nums[i++]=nums[k];            }            k++;        }        nums.erase(nums.begin()+i,nums.end());        return i;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;示例 1:

给定数组 nums = 
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LeetCode" scheme="http://www.echodemo.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LintCode 旋转字符串</title>
    <link href="http://www.echodemo.cc/2018/05/18/LintCode-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.echodemo.cc/2018/05/18/LintCode-旋转字符串/</id>
    <published>2018-05-18T05:18:04.000Z</published>
    <updated>2018-05-18T05:50:05.772Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转)</p><pre><code>样例：对于字符串 &quot;abcdefg&quot;.offset=0 =&gt; &quot;abcdefg&quot;offset=1 =&gt; &quot;gabcdef&quot;offset=2 =&gt; &quot;fgabcde&quot;offset=3 =&gt; &quot;efgabcd&quot;</code></pre><p>挑战：在数组上原地旋转，使用O(1)的额外空间</p><p>分析：注意offset为0和str长度为0的情况，还有offset大于str的长度的情况。</p><p>题目代码：</p><pre><code>class Solution {public:    /**     * @param str: An array of char     * @param offset: An integer     * @return: nothing     */    void rotateString(string &amp;str, int offset) {        // write your code here        if(str.size()==0) return;        if(offset==0) return;        int offs=offset%str.size();        reverse(str.begin(),str.end());        reverse(str.begin(),str.begin()+offs);        reverse(str.begin()+offs,str.end());    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;样例：对于字符串 &amp;quot;abcdefg&amp;quot;.

offset=0 =&amp;gt; &amp;quot;abcdefg&amp;quot;
offset=1 =&amp;gt; &amp;quot;ga
      
    
    </summary>
    
      <category term="技术" scheme="http://www.echodemo.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CPP" scheme="http://www.echodemo.cc/tags/CPP/"/>
    
      <category term="LintCode" scheme="http://www.echodemo.cc/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>买包子</title>
    <link href="http://www.echodemo.cc/2018/05/18/%E4%B9%B0%E5%8C%85%E5%AD%90/"/>
    <id>http://www.echodemo.cc/2018/05/18/买包子/</id>
    <published>2018-05-17T22:30:19.000Z</published>
    <updated>2018-05-30T11:11:53.344Z</updated>
    
    <content type="html"><![CDATA[<p>早上去九食堂买包子。</p><pre><code>我：“一个梅菜和一个扣肉。”对方：“梅菜和扣肉是同一种，同学。”</code></pre><p>等到付款的时候，点开支付宝。</p><pre><code>对方：“你这是收钱，不是付款，同学。”心里想：“是不是起早了，人也变傻了？”</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上去九食堂买包子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我：“一个梅菜和一个扣肉。”
对方：“梅菜和扣肉是同一种，同学。”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等到付款的时候，点开支付宝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对方：“你这是收钱，不是付款，同学。”
心里想：“是不是起早了
      
    
    </summary>
    
      <category term="生活" scheme="http://www.echodemo.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日志" scheme="http://www.echodemo.cc/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
