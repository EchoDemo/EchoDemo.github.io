<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[论文参考文献标准格式要求]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1、参考文献的分类按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类: (1)引文文献是著者在撰写或编辑论著的过程中,为正文中的直接引语(如数据、公式、理论、观点、图表等)或间接引语而提供的有关文献信息资源。 (2)阅读型文献是著者在撰写或编辑论著的过程中,曾经阅读过的文献信息资源。 (3)推荐型文献通常是专家或教师为特定读者、特定目的而提供的、可供读者查阅的文献信息资源。 2、文献类型和标识代码参考文献目前共有16个文献类型和标识代码:普通图书M,会议录C,汇编G,报纸N,期刊J,学位论文D,报告R,标准S,专利P,数据库DB,计算机程序CP,电子公告EB,档案A,舆图CM,数据集DS,其他Z.凡无法归属于前15个类型的文献,均可以用Z来标志。 3、参考文献格式要求1、参考文献按正文部分标注的序号依次列出,并在序号中加[]。 2、对于常见的各类参考文献标注方法如下: (1)著作:作者姓名,题名[M].出版地:出版者,出版年. (2)期刊论文:作者姓名.题名[J].期刊名称,年,卷(期):页码. (3)会议论文集:作者姓名.题名[C]//论文集名称,会议地点,会议日期. (4)学位论文:作者姓名.题名[D].出版地:出版者,出版年. (5)专利文献:专利申请者或所有者姓名.专利题名:专利国别,专利号[P].公告日期或公开日期.获取路径. (6)电子文献:作者姓名.题名[文献类型标志(含文献载体标志)见其它].出版地:出版者,出版年(更新或修改日期),获取路径. (7)报告:作者姓名. 题名[R].出版地:出版者,出版年. (8)标准:标准号.题名[S].出版地:出版者,出版年. 3、同一著作中作者姓名不超过3名时,全部照录,超过3名时,只著录前3名作者,其后加“, 等”。 4、其他:数据库(DB),计算机程序(GP),光盘(CD),联机网络(OL)。 4、参考文献著录格式参考文献按在正文中出现的先后次序列表于文后;表上以“参考文献:” (左顶格) 或“[参考文献]”(居中)作为标识;参考文献的序号左顶格,并用数字加方括号表示,如[1], [2],…,以与正文中的指示序号格式一致. 参照ISO690及ISO 6 9 0-2,每一参考文献条目的最后均以结束. 各类参考文献条目的编排格式及示例如下: a.专著、论文集、学位论文、报告 [序号]主要责任者. 文献题名[文献类型标识].出版地:出版者,出版年. [1]刘国钧,陈绍业,王凤者. 图书馆目录[M].北京:高等教育出版社,1957. [2]辛希孟. 信息技术与信息服务国际研讨会论文集:A集[C].北京:中国社会科学出版社,1994. [3]张筑生. 微分半动力系统的不变集[D].北京:北京大学数学系数学研究所,1983. [4]冯西桥. 核反应堆压力管道与压力容器的LBB分析[R].北京:清华大学核能技术设计研究院,1997. [5]尼葛洛庞帝. 数字化生存[M].胡泳,范海燕,译. 海口:海南出版社,19%. b.期刊文章 [序号]主要责任者. 文献题名[J].刊名,年,卷 (期) :起止页码. [5]何龄修. 读顾城《南明史》[J].中国史研究,1998, (3) :167-173. [6]金显贺,王昌长,王忠东,等·一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版) , 1993, 33 (4) :62-67. c.论文集中的析出文献 [序号]析出文献主要责任者. 析出文献题名[A].原文献主要责任者 (任选}.原文献题名[C].出版地:出版者,出版年. 析出文献起止页码. [7]钟文发·非线性规划在可燃毒物配置中的应用[A].赵玮. 运筹学的理论与应用-中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996.468-471. d.报纸文章 [序号]主要责任者. 文献题名[N].报纸名,出版日期 (版次) . [8]谢希德. 创造学习的新思路[N].人民日报,1998-12-25 (10) . e.国际、国家标准 [序号]标准编号,标准名称[S]. [9]GB/T 16159-1996, 汉语拼音正词法基本规则[S]. f.专利 [序号]专利所有者,专利题名[P].专利国别:专利号,出版日期. [10]姜锡洲. 一种温热外敷药制备方案[P].中国专利:881056073, 1989-07-26. g.电子文献 [序号]主要责任者. 电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址,发表或更新日期/引用曰期 (任选) . [11]学术堂. 论文参考文献标准格式要求[EB/OL].http://www.lunwenstudy.com/cankaowenxian/130239.html.2018-03-14. [12]万锦堃. 中国大学学报论文文摘 (1983-1993) .英文版[D B/C D].北京:中国大百科全书出版社,19%. h.各种未定义类型的文献 [序号]主要责任者. 文献题名[Z].出版地:出版者,出版年. 5、文内参考文献标注格式文内所列参考文献应限于作者直接阅读过的、最主要的、且为发表在正式出版物上的文章.私人通信和未发表 (含待发表) 的著作及论文,一般不宜作为参考文献. 参考文献还应注重权威性和时效性.文内标注参考文献时应按文献出现的先后顺序用阿拉伯数字连续编码,并将序号置于方括号中.可根据具体情况分别按下述3种格式之一标注. (1) 文中已标明原始文献作者姓名时,序号标注于作者姓名右上角. 例如：Vairaktaris等[7]研究表明,MMP-9-1562C/T基因多态性与口腔癌关系密切. (2) 正文未标明作者或非原始文献作者时,序号标注于引用内容的句末. 例如：……在中枢神经系统中具有保护神经的作用,减少缺氧、缺血对动物脑神经元的损害[1]. (3) 正文直接述及文献序号时则将之作为语句的组成部分时不用角码标注. 例如：肱动脉超声检查的方法见文献[2]. 文中多次引用同一参考文献,只在第一次出现时编排序号 (在参考文献表中也只出现一次) , 其他处使用同一序号；如果多次引用的是同一参考文献的不同页的内容,则应参考文献表中按引用顺序一一列出页码.若某一问题使用了多篇文献说明,这时将各文献的序号在一个方括号内全部列出,中间加逗号,若遇连续序号,则在起止序号中间加“-”表示.如：……组织型RAS激活也成为心肌肥厚、心肌纤维化、心腔扩大、心力衰竭的主要因素[1,3,9-10].]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>参考文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的成员变量、全局变量和局部变量]]></title>
    <url>%2F2018%2F03%2F22%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。 注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。 存储:堆(当前对象对应的堆的存储空间中)存储在堆中的数据,不会被自动释放,只能程序员手动释放。 2、全局变量:写在函数和大括号外部的变量,称之为全局变量。 作用域:从定义的那一行开始,一直到文件末尾。全局变量可以先定义再初始化,也可以定义的同时初始化。 存储:静态区。程序一启动就会分配存储空间,直到程序结束才会释放。 3、局部变量:写在函数或者代码块中的变量,称之为局部变量。 作用域:从定义的那一行开始,一直到遇到大括号或者return。局部变量可以先定义再初始化,也可以定义的同时初始化。 存储:栈。存储在栈中的数据有一个特点,系统会自动给我们释放。 *全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。 *非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(一)]]></title>
    <url>%2F2018%2F03%2F22%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、文字具备即刻的意义，记下的观点和细节，过后回望，已显得不在重要或已无关。但从记录中回溯，可看到自我构建和行进的一个过程。 2、感情的结果最终是一种理性。是人的天性不具备足够的留恋，还是前进的生活强迫抛却蜕除下来的旧壳？我们远比自己想象的更为无情和客观。 3、他说，要善待自己，放下和消融内在积存的创伤。它们使你沉重而不够轻盈，要不断去清洗。我说，我在你面前仿佛一览无余。他说，人是有很多面的，哪有一览无余。你对我来说，始终是一个没有答案的谜语。但你的谜题措辞优美。 4、应尽量保持真实和自在地去生活。不违背不辜负，无需他人旁观，更无需他人同情。只需始终忠于自我。 5、不知道杭州苏堤白堤的花开了没有，柳树绿了没有。想孤身前往去看一场花事。如果午后微雨突袭，你恰好渡船而过，不妨让我们在春柳拂面的桥头相见。 6、自我摧毁是有快感的，所有下堕的行为都伴随着快感。摔破一个罐子与长时间塑造和建设一个罐子，前者让你享受到更为强大的自我妄想，觉得自己具有力量。但事实并非如此，行动应该携带和突破重力而上升。 7、男女不管关系性质如何，有些原则不能随意更改，底线不能突破。一旦突破，破镜难圆。感情忌讳懈怠及理所当然，至少要始终保持尊重、克制、发力、欣赏及感恩之心。 8、一个印第安巫师说，如果让儿童目睹一次葬礼，抚摸死人的尸体，会驯服孩子内心的浅薄和顽劣不羁。他获得了真正的灵魂的成长。死亡是最需要被学习和认识的内容。 9、泛滥的感情方式，不严格区分对象，只以获取难易作为是否前进的指标。对待不同的人，所给予的内容完全重复，是一次批量化生产之后的零售生意。润滑一些的方式，无非是让不同客户拿到这只被复制的点心盒子，产生为自己特制的幻觉。始乱终弃，以满足欲望为前提，不管这欲望是虚荣、寂寞、爱欲、证明还是其他。这何尝不是一种乏味而肤浅的恋爱方式。无法视对方为独特个体，因此也无法获取来自对方的源泉和力量(也许这是不需要的东西，他们要的只是乐趣)。把对方视为猎物，忽略人的内在生命，以占有和征服为目的。低级的方式决定这关系没有创造力，不具有可追索的深度。是对生命能量的贬低和消费。 10、奥修说，死去的人，将在他生前所爱的人身上收回他的能量，这些能量会被他带走。因此，那个被爱着的人，会感觉到自己的身心被挖掉一块。这一块区域将始终是空的，是匮乏的。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自省]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%87%AA%E7%9C%81%2F</url>
    <content type="text"><![CDATA[连续几日在图书馆的自习，对面的人换了又换，然而他(她)们都有一个令人心生厌恶之处：吃零食或者喝牛奶不断产生的声响和气味。对旁人的感受持漠然的态度。对此，虽完全可以凭借自身的力量尽量避免，但从中自身须得到反省：在生活中，是否具有其他不当的行为让他人感到不适(包括除图书馆以外的场所)。答案是有。有些是一时半会无法去除的缺点，有些是当下即可做到的修改。这些都需要内心的自持和坚韧才能实现，结果要交给时间去检验。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水流众生]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%B0%B4%E6%B5%81%E4%BC%97%E7%94%9F%2F</url>
    <content type="text"><![CDATA[李健的《水流众生》是诞生在他西藏的旅途中的，他的歌，总是充满了灵性与自然。在平淡当中述说，却又蕴含深切的主题。这首歌是写给他自己的，也是给众生的，同时还是写给这个社会的。当今社会物质的极大丰富满足不了人们的欲望，对物质无止境的追求、对自然的过分索取导致人们都迷失了自我，深陷其中，无法自拔却并不自知。李健为了寻求他的解脱之法，于是踏上旅途，当然他的旅途不是我们当下传统意义上的旅行，不是组团或者邀约三五好友匆匆赶赴著名的旅游景点拍照留恋而后又匆匆而归的旅行。他的旅途是内心和自然的相互倾听和感受。当然，最终他还是从自然里、在旅途中找到了自我，看见了辽阔的。每一个人都需要反省，自我观照，在水自成旋涡之前及时转身。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1051 Pop Sequence]]></title>
    <url>%2F2018%2F03%2F21%2FPAT-A1051-Pop-Sequence%2F</url>
    <content type="text"><![CDATA[Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. Output Specification: For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO 题目大意：给出size为M大小的栈，分别把1…N入栈，给出K组出栈顺序，问入栈出栈顺序是否顺利。 分析：先把需要判断的序列放进一维数组当中，给出数组的当前下标为0，然后1…N顺序入栈，如果元素入栈之后，栈的size大于M，则此序列不符合；如果栈的size小于等于M，在while循环中如果栈非空且其值等于此时的数组元素，则栈顶元素出栈，数组的下标自增一位。以上所有步骤进行K次。 注意：能用一维数组时尽量别用二维数组 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;stdlib.h&gt; using namespace std; int main() { int M, N, K; cin &gt;&gt; M &gt;&gt; N &gt;&gt; K; vector&lt;int&gt; a(N);//定义可变长的一维数组 stack&lt;int&gt; st;//引入STL中的栈 for (int i = 0;i &lt; K;i++) {//一共有K组数据 while (!st.empty()) st.pop();//清空栈 for (int j = 0;j &lt; N;j++) {//读入一组数据 cin &gt;&gt; a[j]; } int n=0; for (int x = 1;x &lt;= N;x++) { st.push(x); if (st.size() &gt; M) {//序列有误 break; }else{ while (!st.empty() &amp;&amp; st.top() == a[n]) {//如果栈非空且栈顶元素等于当前的序列当前位置值就把顶部元素出栈，验证序列后移一位 st.pop(); n++; } } } if (!st.empty()) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL基础]]></title>
    <url>%2F2018%2F03%2F21%2FMYSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Mysql是最流行的关系型数据库管理系统(关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。)，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。 1、MYSQL的特点(1)Mysql是开源的，所以你不需要支付额外的费用。 (2)Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 (3)MySQL使用标准的SQL数据语言形式。 (4)Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。 (5)Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。 2、MYSQL的管理(1)为MYSQL数据库中的user表添加新用户root@host# mysql -u root -p Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES (&apos;localhost&apos;, &apos;guest&apos;, PASSWORD(&apos;guest123&apos;), &apos;Y&apos;, &apos;Y&apos;, &apos;Y&apos;); Query OK, 1 row affected (0.20 sec) mysql&gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0.01 sec) mysql&gt; SELECT host, user, password FROM user WHERE user = &apos;guest&apos;; +-----------+---------+------------------+ | host | user | password | +-----------+---------+------------------+ | localhost | guest | 6f8c114b58f2ce9e | +-----------+---------+------------------+ 1 row in set (0.00 sec) 注意需要执行FLUSH PRIVILEGES语句。 这个命令执行后会重新载入授权表。如果你不使用该命令，你就无法使用新创建的用户来连接MYSQL服务器，除非你重启MYSQL服务器。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的GRANT命令，以下命令会给指定数据库TUTORIALS添加用户zara，密码为zara123 。 root@host# mysql -u root -p password; Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO &apos;zara&apos;@&apos;localhost&apos; -&gt; IDENTIFIED BY &apos;zara123&apos;; *MySQL的SQL语句以分号 (;) 作为结束标识。 (2)管理MySQL的命令a、USE 数据库名;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。mysql&gt; use RUNOOB; Database changed b、SHOW DATABASES;列出MySQL数据库管理系统当前的数据库列表。mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | RUNOOB | | cdcol | | mysql | | onethink | | performance_schema | | phpmyadmin | | test | | wecenter | | wordpress | +--------------------+ 10 rows in set (0.02 sec) c、SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。mysql&gt; use RUNOOB; Database changed mysql&gt; SHOW TABLES; +------------------+ | Tables_in_runoob | +------------------+ | employee_tbl | | runoob_tbl | | tcount_tbl | +------------------+ 3 rows in set (0.00 sec) d、SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。mysql&gt; SHOW COLUMNS FROM runoob_tbl; +-----------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+--------------+------+-----+---------+-------+ | runoob_id | int(11) | NO | PRI | NULL | | | runoob_title | varchar(255) | YES | | NULL | | | runoob_author | varchar(255) | YES | | NULL | | | submission_date | date | YES | | NULL | | +-----------------+--------------+------+-----+---------+-------+ 4 rows in set (0.01 sec) e、SHOW INDEX FROM 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。mysql&gt; SHOW INDEX FROM runoob_tbl; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | runoob_tbl | 0 | PRIMARY | 1 | runoob_id | A | 2 | NULL | NULL | | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) f、SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G;该命令将输出Mysql数据库管理系统的性能及统计信息。mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;; # 表名以runoob开头的表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;\G; # 加上 \G，查询结果按列打印 3、数据库的基本操作语句(1)创建数据表CREATE TABLE table_name (column_name column_type); root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.16 sec) mysql&gt; *如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 *AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 *PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 *ENGINE 设置存储引擎，CHARSET 设置编码。 (2)删除数据表DROP TABLE table_name ; root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; DROP TABLE runoob_tbl Query OK, 0 rows affected (0.8 sec) mysql&gt; 查看一下： mysql&gt; show tables; Empty set (0.01 sec) (3)插入数据INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1,value2,...valueN ); root@host# mysql -u root -p password; Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;); Query OK, 1 rows affected (0.00 sec) mysql&gt; *如果数据是字符型，必须使用单引号或者双引号，如：&quot;value&quot;。 *使用箭头标记-&gt;不是SQL语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写SQL语句，SQL语句的命令结束符为分号 ;。 (4)查询数据SELECT column_name,column_name FROM table_name [WHERE Clause][LIMIT N][ OFFSET M]; select * from runoob_tbl; SELECT * from runoob_tbl WHERE runoob_author=&apos;菜鸟教程&apos;; *查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 *SELECT 命令可以读取一条或者多条记录。你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 *你可以使用 WHERE 语句来包含任何条件。例如使用 AND 或者 OR 指定一个或多个条件。WHERE子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。WHERE子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 *你可以使用 LIMIT 属性来设定返回的记录数。 *你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 (5)更新数据表UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]; mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3; Query OK, 1 rows affected (0.01 sec) mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3; +-----------+--------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+--------------+---------------+-----------------+ | 3 | 学习 C++ | RUNOOB.COM | 2016-05-06 | +-----------+--------------+---------------+-----------------+ 1 rows in set (0.01 sec) *你可以同时更新一个或多个字段。 *你可以在 WHERE 子句中指定任何条件。 *你可以在一个单独表中同时更新数据。 (6)删除MySQL数据表中的记录DELETE FROM table_name [WHERE Clause]; mysql&gt; use RUNOOB; Database changed mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3; Query OK, 1 row affected (0.23 sec) *如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 *你可以在 WHERE 子句中指定任何条件 *您可以在单个表中一次性删除记录。 (7)删除，添加或修改表字段删除：ALTER TABLE alter_tbl DROP columnname;删除指定字段 添加：ALTER TABLE alter_tbl ADD new_column_name new_typename AFTER columnname;指定添加位置 修改： ALTER TABLE alter_tbl MODIFY columnname new_typename;修改字段类型 ALTER TABLE alter_tbl CHANGE oldcolumnname newcolumnname newtypename;修改字段及类型 ALTER TABLE alter_tbl RENAME TO alter_tb2;修改表名 (8)UNION操作符SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; *expression1, expression2, ... expression_n: 要检索的列。 *tables: 要检索的数据表。 *WHERE conditions: 可选， 检索条件。 *DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 *ALL: 可选，返回所有结果集，包含重复数据。 (9)排序SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]]; SELECT * from runoob_tbl ORDER BY submission_date ASC; SELECT * from runoob_tbl ORDER BY submission_date DESC; *你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 *你可以设定多个字段来排序。 *你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列。 *你可以添加 WHERE...LIKE 子句来设置条件。 (10)GROUP BY语法SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;将数据表按名字进行分组，并统计每个人有多少条记录]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1052 Linked List Sorting]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1052-Linked-List-Sorting%2F</url>
    <content type="text"><![CDATA[A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification: Each input file contains one test case. For each case, the first line contains a positive N (&lt; 105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Key next where Address is the address of the node in memory, Key is an integer in [-105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification: For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input: 5 00001 11111 100 -1 00001 0 22222 33333 100000 11111 12345 -1 33333 22222 1000 12345 Sample Output: 5 12345 12345 -1 00001 00001 0 11111 11111 100 22222 22222 1000 33333 33333 100000 -1 题目大意：给出一个静态链表，将链表按照数据域data的值从小到大进行排序，然后把排序后的静态链表上的结点从头结点顺序输出。 分析：建立存储静态节点的结构体数组，从首节点开始的顺序(直到-1)遍历整个静态链表，将在静态链表中节点的flag标记为true，并且统计count(有效结点的个数)大小，这里是因为有的你输入的节点根本不在静态链表上。之后将静态链表进行排序，这里需要进行二次排序：如果两个节点中有一个节点的标志位为false就把它移动到后面(reuturn a.flag&gt;b.flag)，否则就按照节点数据域从小到大进行排序(return a.data&lt;b.data)。最后只输出前count个静态链表节点。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;stdlib.h&gt; using namespace std; const int maxn = 100010; struct Node { int address; int data; int next; bool flag; }node[maxn]; bool cmp(Node a, Node b) { if (a.flag == false || b.flag == false) { return a.flag &gt; b.flag;//将无效节点放到后面 } else { return a.data &lt; b.data;//按照数据域的顺序从大到小排列 } } int main() { int n, x; cin &gt;&gt; n &gt;&gt; x; int address, data, next; for (int i = 0;i&lt;n;i++) {//初始化静态链表 cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].address = address; node[address].data = data; node[address].next = next; } for (int i = 0;i &lt; maxn;i++) { node[i].flag = false;//初始化标志位 } int count = 0; while (x != -1) {//遍历静态链表，对有效的节点进行标记，同时统计有效节点的个数(因为存在一些你输入的节点但是不在链表上情况) node[x].flag = true; count++; x = node[x].next; } if (count == 0) {//如果头结点为-1，即链表中没有节点 cout &lt;&lt; &quot;0 -1&quot; &lt;&lt; endl; } else { sort(node, node + maxn, cmp);//筛选有效节点，按data从小到大排列 printf(&quot;%d %05d\n&quot;, count, node[0].address); for (int i = 0;i &lt; count;i++) { if (i==count-1) printf(&quot;%05d %d -1\n&quot;, node[i].address, node[i].data); else printf(&quot;%05d %d %05d\n&quot;, node[i].address, node[i].data, node[i+1].address); } } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1032 Sharing]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1032-Sharing%2F</url>
    <content type="text"><![CDATA[To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, “loading” and “being” are stored as showed in Figure 1.You are supposed to find the starting position of the common suffix (e.g. the position of “i” in Figure 1). Input Specification: Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (&lt;= 105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node. Output Specification: For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output “-1” instead. Sample Input 1: 11111 22222 9 67890 i 00002 00010 a 12345 00003 g -1 12345 D 67890 00002 n 00003 22222 B 23456 11111 L 00001 23456 e 67890 00001 o 00010 Sample Output 1: 67890 Sample Input 2: 00001 00002 4 00001 a 10001 10001 s -1 00002 a 10002 10002 t -1 Sample Output 2: -1 题目大意：求两个存储英语单词的字母链表的首个公共结点的地址。如果没有，就输出-1 分析：本题是在链表当中寻找起始公共节点的位置且地址的范围比较小，此处选择使用静态链表来处理。用结构体数组进行存储，node[i]表示地址为i的结点，data表示值，next为下一个结点的地址，flag表示第一条链表有没有该结点。遍历第一条链表，将访问过的结点的flag都标记为true，当遍历第二条结点的时候，如果遇到了true的结点就输出并结束程序，没有遇到就输出-1。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct Node { char data; int next; bool flag;//用于判断公共节点的初始位置 }node[100010]; void Create(int n) {//创建一个静态链表 int address, next; char data; for (int i = 0;i &lt; 100010;i++) {//初始化链表节点的标志为false node[i].flag = false; } for (int i = 0;i &lt; n;i++) { cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].data = data; node[address].next = next; } } int main() { int x, y, n,i; cin &gt;&gt; x &gt;&gt; y &gt;&gt; n; Create(n);//创建一个静态链表 for (i = x;i != -1;i = node[i].next) {//将第一个单词走过的节点的标志位设为true node[i].flag = true; } for (i = y;i != -1;i = node[i].next) { if (node[i].flag == true) { printf(&quot;%5d&quot;, i);//如果此时的节点的标志位为true说明是公共节点 system(&quot;pause&quot;); return 0; } } printf(&quot;-1&quot;);//否则输出-1 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表属于线性表中的一种数据结构，它由若干个节点组成(每个节点代表一个元素)，且节点在内存中的存储位置通常是不连续的。这里我们先来了解动态链表，动态链表的两个节点之间一般通过一个指针来从一个节点指向另一个节点 ，因此动态链表的节点一般由两部分构成，即数据域和指针域： struct node{ int data; node* next; }; (1)创建一个动态链表： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct node { int data; node* next; }; node* create(int Array[]) { node *p, *pre, *head;//pre保存当前节点的前驱节点，head为头结点 head = new node;//创建头结点 head-&gt;next = NULL;//头结点不需要数据，且指针域指向NULL pre = head;//记录pre为head for (int i = 0;i &lt; 5;i++) { p = new node;//新建节点 p-&gt;data = Array[i];//将Array[i]赋给新建的节点作为数据域，也可以cin输入 p-&gt;next = NULL;//新节点的指针域设为NULL pre-&gt;next = p;//前驱节点的指针域设为当前新建节点的地址 pre = p;//把p设为pre，作为下一个节点的前驱节点 } return head;//返回头结点指针 } int main() { int Array[5] = { 5,3,6,1,2 }; node* L = create(Array);//新建链表，返回头指针head给L L = L-&gt;next;//从第一个节点开始有数据域 while (L != NULL) { cout &lt;&lt; L-&gt;data &lt;&lt; endl;//输出每个节点的数据域 L = L-&gt;next; } system(&quot;pause&quot;); return 0; } (2)动态链表查找元素： int search(node* head, int x) { int count = 0;//计数器 node* p = head-&gt;next;//指向链表的第一个节点 while (p != NULL) {//遍历整个链表 if (p-&gt;data == x) count++;//当节点数据域为x时，则count++ p = p-&gt;next;//指向下一个节点 } return count; } (3)动态链表插入元素： void insert(node* head, int pos, int x) { node* p = head;//指向链表的头节点 for (int i = 0;i &lt; pos - 1;i++) {//遍历到链表的pos-1的位置，即插入位置的前一个节点位置 p = p-&gt;next; } node* q = new node;//新建节点 q-&gt;data = x;//其数据域为x q-&gt;next = p-&gt;next;//新节点的下一个节点指向原先插入位置的节点 p-&gt;next = q;//前一个位置的节点指向新节点 } (4)动态链表删除元素： void del(node* head, int x) { node* p = head;//指向链表的头结点 node* q = p-&gt;next;//指向链表的第一个节点 while (q != NULL) { if (q-&gt;data == x) {//数据域为x，删除q节点 p-&gt;next = q-&gt;next;//删除q节点 delete(q);//释放内存空间 q = p-&gt;next; }else {//数据域不为x，p、q节点同时后移一位 p = q; q = q-&gt;next; } } } 以上所述都是动态链表的范畴，需要指针来建立节点之间的连接关系。而对于有些问题来说，节点的地址是比较小的整数(例如5位数的地址)，这样就没有必要去建立动态链表，而应该使用方便得多的静态链表。静态链表的实现原理是hash，即通过建立一个结构体数组，并令数组的下标直接表示节点的地址，以此来达到直接访问数组中的元素就能访问节点的效果。需要注意的是：在使用静态链表时，尽量不要把结构体类型名和结构体变量名取成相同的名字。其定义方法如下： struct Node{ typename date;//数据域 int next;//指针域 XXX;//节点的某个性质，不同的题目会有不同的设置 }node[maxn]; 其中的next是一个int型的整数，用来存放下一个节点的地址(事实上就是数组下标)，例如：如果初始节点的地址为11111，第二个节点的地址为22222，第三个节点的地址为33333，且第三个节点为链表末尾，那么整个静态链表的节点就可以通过下面的写法连接起来： node[11111].next=22222; node[22222].next=33333; node[33333].next=-1;//-1对应动态链表中的NULL，表示没有后继节点 一般来说，静态链表的初始化需要对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字(而常常需要小于所能达到的数字)，例： for(int i=0;i&lt;maxn;i++){ node[i].XXX=0; } 一般的题目都会给出一条静态链表的首节点的地址，因此我们可以依据这个地址来遍历得到整条链表。这一步同时也是对节点性质XXX进行标记，并且对有效节点的个数进行计数的时候，例如对节点是否在链表上这个性质来说，当我们遍历链表时，就可以把XXX置为1。 int p=begin,count=0; while(p!=-1){//-1代表静态链表结束 XXX=1; count++; p=node[p].next; } 由于使用静态链表时时直接采用地址映射的方式，这就会使得数组小标的不连续。而很多时候题目给出的节点并不都是有效节点(即不在静态链表上的节点)。为了能够可控地访问有效节点，一般都需要对数组进行排序来把有效节点移动到数组的左端。这里我们用到上面所提及的XXX，这也就是为什么在XXX进行初始化时要取比正常取值要小的值。因为无效节点并不会执行XXX=1这一步，因此一定比有效节点的XXX小。于是在写sort函数的排序函数cmp时就可以在cmp的两个参数节点中有无效节点时按XXX从大到小排序，这样就能把有效节点全部移动到数组左端。当然，在cmp函数中还可以有第二级的排序，例如：题目可能要求把链表按节点顺序排序，此时就需要在cmp函数中建立第二级的排序： bool cmp(Node a,Node b){ if(a.XXX==-1||b.XXX==-1){//如果有节点是无效节点，就把它放到数组的后端 return a.XXX&gt;b.XXX; }else{//否则就按节点的数据域从大到小排序 return a.data&gt;b.data; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++申请动态内存]]></title>
    <url>%2F2018%2F03%2F19%2FC-C%2B%2B%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[(1)malloc函数 malloc函数是C语言中#include&lt;stdlib.h&gt;头文件下用于申请动态内存的函数，其返回类型是申请的同变量类型的指针，其基本用法如下： typename* p=(typename*)malloc(sizeof(typename)); int* p=(int*)malloc(sizeof(int)); node* p=(node*)malloc(sizeof(node)); 这个写法的解释如下：以需要申请的内存空间大小(即sizeof(node))为malloc函数的参数，这样malloc函数就会向内存申请一块大小为sizeof(node)的空间，并且返回指向这块空间的指针。但是此时这个指针是一个为确定类型的指针void，因此需要把它强制转换成node型的指针，在malloc之前加上(node)。再把这个指针赋给node型的指针变量p，就成功地申请了一块node类型大小的内存空间。如果申请失败，则会返回空指针NULL。申请失败一般在使用malloc申请了较大动态数组时发生。 在使用完malloc开辟出来的空间后必须将其释放，否则会造成内存的泄露。malloc函数需要使用free函数来进行内存的释放。假设需要释放的内存空间的指针变量为p，则：free(p);就可以实现内存的释放了。 (2)new运算符 new是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变量类型的指针，其基本用法如下： typename* p=new typename; int* p=new int; node* p=new node; 相比于malloc函数来说，new的写法要简洁得多。另外，如果new运算符申请动态空间失败，则会启动异常机制处理而不是像malloc那样返回NULL。和malloc一样的是：申请失败一般是在申请了较大动态数组时发生。与此同时，new运算符也有对应的释放内存函数：delete(p);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeup 1918 简单计算器]]></title>
    <url>%2F2018%2F03%2F19%2FCodeup-1918-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述： 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入： 测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出： 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 样例输入： 30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 * 6 + 51 / 29 + 79 * 87 + 57 * 92 0 样例输出： 12178.21 分析：本题需要分两个步骤进行解答：一是中缀表达式转化为后缀表达式；二是计算后缀表达式。 步骤一： (1)分别设立一个操作符栈和一个队列，操作符栈用来暂时存放操作符，而队列则用来存放后缀表达式。 (2)从左到右扫描中缀表达式。 (3)如果碰到操作数(这里的操作数可能占几位，所以需要一位一位读取再合并)，就把操作数处理之后加入后缀表达式中。如果碰到的是操 作符，就将其优先级与操作符栈的栈顶元素比较：如果优先级高于栈顶操作符则直接入栈；如果优先级小于或等于栈顶操作符，则将操作符 栈的操作符不断弹出到后缀表达式，直到其优先级高于栈顶操作符为止。 (4)重复执行(2)(3)步骤，直到中缀表达式扫描完为止，之后若操作符栈中还有元素，则将他们依次弹出至后缀表达式当中。 步骤二： 从左到右扫描后缀表达式，如果是操作数，则压入栈中；如果是操作符，就连续弹出两个操作数(这里先弹出的是第二操作数，后弹出的是 第一操作数)，然后进行操作符的运算，生成的新操作符压入栈中。反复执行，直到后缀表达式扫描完毕。此时栈中只剩下一个数，就是计算 结果。 注意： (1)操作数的类型需要设置为double型。 (2)为了便于在后缀表达式中判断出队的是操作符还是操作数，这里使用了具有操作数、操作符和判别两者类型的bool类型的结构体， 当然，在这种情况之下就需要引进STL中的queue和stack容器来存储相应的结构体类型的数据。 (3)另外还需要引进STL中的map容器，从而来定义操作符所对应的优先级。 具体的程序如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; struct node { double num;//操作数 char op;//操作符 bool flag;//true表示操作数，false表示操作符 }; string s; queue&lt;node&gt; q;//定义node类型的队列用于存储后缀表达式 stack&lt;node&gt; st;//定义node类型的栈用于在转化为后缀表达式时暂存操作符和在计算后缀表达式时存储操作数 map&lt;char, int&gt; op;//map用于匹配操作符和优先级数字 void Change() {//将中缀表达式转化为后缀表达式 node temp; for (string::iterator it = s.begin();it != s.end();it++) {//删除字符串当中的空格 if (*it == &apos; &apos;) s.erase(it); } for (int i = 0;i &lt; s.length();) { if (s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) {//如果是数字的话 temp.flag = true;//标记为数字 temp.num = s[i++] - &apos;0&apos;; while (i&lt;s.length()&amp;&amp;s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) { temp.num = temp.num * 10 + (s[i++] - &apos;0&apos;); } q.push(temp);//将操作数压入后缀表达式队列 }else {//如果是操作符 temp.flag = false; while (!st.empty() &amp;&amp; op[s[i]] &lt;= op[st.top().op]) {//如果栈不空且当前操作符的优先级小于等于栈顶的优先级 q.push(st.top());//将栈顶元素放入后缀表达式队列 st.pop();//栈顶元素出栈 } temp.op = s[i++]; st.push(temp);//将此操作符入栈 } } while (!st.empty()) {//如果栈中还有操作符就把它们都放入后缀表达式队列 q.push(st.top()); st.pop(); } } double Calculate() {//计算后缀表达式 double temp1=0, temp2=0; node temp; while (!st.empty()) st.pop();//将栈清空 while (!q.empty()) { if (q.front().flag == true) st.push(q.front());//如果是操作数就直接入栈 else {//如果是操作符 temp2 = st.top().num;//取第二个操作数 st.pop();//栈顶元素出栈 temp1 = st.top().num;//取第一个操作数 st.pop(); if (q.front().op == &apos;+&apos;) temp.num = temp1 + temp2; else if (q.front().op == &apos;-&apos;) temp.num = temp1 - temp2; else if (q.front().op == &apos;*&apos;) temp.num = temp1*temp2; else temp.num = temp1 / temp2; temp.flag = true; st.push(temp);//将本次的计算结果压入栈中 } q.pop();//将该操作符或者操作数出队列 } return st.top().num;//返回后缀表达式的计算结果 } int main() { op[&apos;+&apos;] = op[&apos;-&apos;] = 1;//map设定操作符的优先级 op[&apos;*&apos;] = op[&apos;/&apos;] = 2; while (getline(cin, s), s != &quot;0&quot;) { while (!st.empty()) st.pop();//初始化栈 Change();//将中缀表达式转化为后缀表达式 printf(&quot;%.2f\n&quot;,Calculate());//计算后缀表达式 } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Codeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1060 Are They Equal]]></title>
    <url>%2F2018%2F03%2F19%2FPAT-A1060-Are-They-Equal%2F</url>
    <content type="text"><![CDATA[If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification: Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100. Output Specification: For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1: 3 12300 12358.9 Sample Output 1: YES 0.123*10^5 Sample Input 2: 3 120 128 Sample Output 2: NO 0.120*10^3 0.128*10^3 题目大意：给出两个数，问将它们写成保留N位小数的科学计数法后是否相等。如果相等，输出YES，同时输出他们的科学记数法表示的方式；如果不相等输出NO，分别输出他们的科学计数法表示方式。 注意：无需四舍五入。 分析：将两个数以字符串的形式输入，如果他们有前导0则删除前导0。删除前导0之后会碰到两种情况：如果是小数点，说明这个数小于1，接下来将小数点删除，如果删除小数点之后的那个数值是0需要把0删除同时令指数相应地减1，直到不为0为止；如果不是小数点的话，则在while循环当中去寻找后面可能存在的小数点，在没有找到小数点之前，字符串下标每向后移动一位，指数便加1。跳出while循环之后，如果字符串下标小于字符串此时的长度，说明找到了小数点，删除小数点。在这两种情况都处理完之后，如果字符串的长度为0，则说明这个数为0。接下来令数组下标为0，在while循环中只要题目要求的精度没有达到就不断执行。而只要字符串此时的下标还小于字符串的长度就直接把数字加到新字符串的末尾，否则就添0。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; using namespace std; int n;//有效位数 string deal(string s, int &amp;e) { int k = 0;//s的下标 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除前导0 } if (s[0] == &apos;.&apos;) {//删除前导0之后是小数点，说明s是小于1的小数 s.erase(s.begin());//删除小数点 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除小数点后非0位前的所有0 e--;//每删除一个0，指数就减1 } }else {//删除前导0之后不是小数点，则找到后面的小数点删除 while (k &lt; s.length() &amp;&amp; s[k] != &apos;.&apos;) { k++; e++;//只要没碰到小数点指数就加1 } if (k &lt; s.length()) s.erase(s.begin() + k);//如果此时k&lt;s.length()则说明碰到了小数点，删除小数点 } if (s.length() == 0) e = 0;//删除前导0之后s的长度变为0，说明这个数是0 int num = 0; k = 0; string res; while (num &lt; n) { if (k &lt; s.length()) res += s[k++];//只要还有数字，就加到res的末尾 else res += &apos;0&apos;;//否则就在res的末尾加0 num++;//精度加1 } return res; } int main() { string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if (s3 == s4&amp;&amp;e1 == e2) cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; endl; else cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot;&lt;&lt; e2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的sort函数]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84sort%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[sort()函数使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)。要使用algorithm头文件下的sort()函数,需要加上#include头文件和”using namespace std;” 1、在介绍sort()函数之前,先来了解algorithm头文件下一些其他的函数 (1)max(x,y)和min(x,y)分别返回x和y中的最大值和最小值(x和y可以是浮点数)。 (2)abs(x)返回x的绝对值,这里的x必须是整数,浮点数需要使用math头文件下的fabs。 (3)swap()用来交换x和y的值,注意:这里的swap()函数和Java中的swap()函数有着本质的不同。 (4)reverse(x,y)将数组指针在[x,y)之间的元素或容器的迭代器在[x,y)范围内的元素进行反转。 (5)next_permutation(x,y)给出一个序列在全排列的下一个序列。 (6)fill(x,y,a)可以把数组或容器中的array[x]~array[y-1]区间赋值为a。和memset不同,这里的赋值可以是数组类型对应范围中的任意值。 (7)lower_bound(first,last,val)和upper_bound(first,last,val)分别用来寻找在数组或容器[first,last)范围内第一个值大于等于val和第一个值大于val的元素的位置,如果是数组,则返回该位置的指针;如果是容器,则返回该位置的迭代器。如果数组或者容器中没有需要寻找的元素,则两个函数均返回可以插入该元素的位置的指针或者迭代器,它们的时间复杂度均为O(log(last-first))。 2、sort()函数 (1)使用方式:sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数(非必填)); 如果不填比较函数,则默认对前面给出的区间[first,last)进行递增排序。 (2)比较函数cmp a、基本数据类型数组的排序 bool cmp(int a,int b){//int型数据递减排序 return a&gt;b;//当a&gt;b是把a放在b前面 } bool cmp(double a,double b){//double型数据递减排序 return a&gt;b; } bool cmp(char a,char b){//char型数据递减排序 return a&gt;b; } 其实这里也可不必如此:sort(a,a+10,greater&lt;typename&gt;());也可以实现以上三个比较函数的功能。 b、结构体数组的排序 struct node{ int x,y; }st[10]; bool cmp(node a,node b){//递减排序 return a.x&gt;b.x; } bool cmp(node a,node b){//先按x从大到小排序,但当x相等时,按照y从小到大来排序 if(a.x!=b.x) return a.x&gt;b.x; else return a.y&lt;b.y; } sort(st,st+3,cmp);//对下标为0,1,2的结构体类型排序 c、容器的排序 在STL标准容器中,只有vector、string、deque是可以使用sort的。这是因为set、map这种容器是用红黑树实现的,元素本身有序,故不允许使用sort排序。以vector为例: bool cmp(int a,int b){ return a&gt;b; } vector&lt;int&gt; v; v.push_back(3); v.push_back(1); v.push_back(2); sort(v.begin(),v.end(),cmp);//对整个vector排序]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的stack]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84stack%2F</url>
    <content type="text"><![CDATA[在编程过程中，常常使用stack用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函数来递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题。stack是一种先进后出的数据结构。要使用stack，必须包含头文件#include还有命名空间”using namespace std;”。 1、stack的定义:stack&lt;typename> name;例如: stack&lt;int&gt; name; 2、stack容器内元素的访问 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main(){ stack&lt;int&gt; st; for(int i=1;i&lt;=5;i++){ st.push(i);//push(i)将i压入队列 } cout&lt;&lt;st.top();//取栈顶元素 return 0; } 3、stack常用的函数 (1)push(x):将x进行入栈，时间复杂度为O(1)。 (2)pop():栈顶元素出栈，时间复杂度为O(1)。 (3)top():获得栈顶元素，时间复杂度为O(1)。 (4)empty():检测stack是否为空，时间复杂度为O(1)。 (5)size():返回stack内的元素个数，时间复杂度为O(1)。 (6)STL中没有实现栈的清空，如果需要实现栈的清空，可以用一个while循环反复pop出元素直到栈为空： while(!st.empty){ st.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的queue]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84queue%2F</url>
    <content type="text"><![CDATA[在编程过程中，当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue作为代替，以提高程序的准确性。要使用queue，必须包含头文件#include还有命名空间”using namespace std;”。STL的容器中还有两种容器和队列有关，分别是双端队列(deque)和优先队列(priority_queue)，前者是首位皆可以插入和删除的队列，后者是使用堆实现的默认将当前队列最大元素置于队首的容器。 1、queue的定义:queue&lt;typename> name;例如: queue&lt;int&gt; name;//typename可以是任意基本数据类型或容器 2、queue容器内元素的访问 由于队列queue是一种先进先出的限制性数据结构,因此在STL中只能通过front()来访问队首元素,或者通过back()来访问队尾元素。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main(){ queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++){ q.push(i);//push(i)将i压入队列 } cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;&lt;&lt;q.back(); return 0; } 3、queue常用的函数 (1)push(x):将x进行入队，时间复杂度为O(1)。 (2)pop():令队首元素出队，时间复杂度为O(1)。使用pop()函数之前必须用empty()判断队列是否为空。 (3)front():获得队首元素，时间复杂度为O(1)。使用front()函数之前必须用empty()判断队列是否为空。 (4)back():获得队尾元素，时间复杂度为O(1)。 (5)empty():检测queue是否为空，时间复杂度为O(1)。 (6)size():返回queue内的元素个数，时间复杂度为O(1)。 (7)STL中没有实现队列的清空，如果需要实现队列的清空，可以用一个while循环反复pop出元素直到队列为空： while(!q.empty){ q.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的map]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84map%2F</url>
    <content type="text"><![CDATA[在编程过程中，如果需要建立字符(或者字符串)与整数之间的映射;判断大整数或者其他类型数据是否存在;甚至是字符串和字符串之间的映射。此时我们应当想到map，因为map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)。map和其他的STL容器有点不一样，因为map需要确定映射前类型(键key)和映射后类型(值value),所以需要在&lt;&gt;内填写两个类型。需要注意的是:map中的键是唯一的，而且map会以键从小到大的顺序自动排序(这是由于map内部是使用红黑树实现的，set也是，在建立映射的过程中会自动实现从小到大的排序功能)。如果需要使用map，必须包含头文件#include还有命名空间”using namespace std;”。 1、map的定义:map&lt;typename1,typename2> name;例如: map&lt;string,int&gt; name;//如果是字符串到整型的映射，必须使用string而不能用char数组 map&lt;set&lt;int&gt;,string&gt; name;//将一个set容器映射到一个字符串 2、map容器内元素的访问 (1)通过下标访问，例如：一个定义为map&lt;char,int&gt; name的map来说，可以直接使用name[&apos;c&apos;]来访问对应的整数。 (2)通过迭代器访问,其定义是:map&lt;typename1,typename2&gt;::iterator it;但map迭代器的使用方式和其他STL容器的迭代器不同,因为map的每一对映射都有两个typename,此时我们可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main(){ map&lt;char,int&gt; mp; mp[&apos;m&apos;]=20; mp[&apos;r&apos;]=30; mp[&apos;a&apos;]=40; for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,map的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 3、map常用的函数 (1)find(key):用以返回键为key的映射的迭代器，时间复杂度为O(logN)。map&lt;char,int&gt;::iterator it=mp.find(&apos;b&apos;) (2)size():用来获得map中映射的对数，时间复杂度为O(1)。 (3)clear():用来清空map中的所有元素，时间复杂度为O(N)。 (4)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:mp.erase(it),it位所需要删除元素的迭代器,时间复杂度O(1);mp.erase(key),key为欲删除的映射的键,时间复杂度为O(logN)。删除一个区间内的所有元素:mp.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。时间复杂度为O(last-first)。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的set]]></title>
    <url>%2F2018%2F03%2F17%2FC%2B%2B%E4%B8%AD%E7%9A%84set%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现去掉重复元素的情况，而且有可能因为这些元素比较大或者类型不是int型而不能直接开散列表。此时我们应当想到set，set是关联式容器。其作为一个容器是用来存储同一类型数据的数据类型，比如：int、char、double、结构体等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行递增排序,这是因为其内部是用红黑树实现的。如果需要使用set，必须包含头文件#include还有命名空间”using namespace std;”。 1、set的定义:set&lt;typename> name;例如: set&lt;int&gt; name; //声明一个int容器 set&lt;int&gt; name(10); //声明一个初始大小为10的int型容器 set&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型容器 set&lt;int&gt; name(a); //声明一个初始大小为a的int型容器 set&lt;node&gt; name; //node是结构体的类型 如果typename是set，定义的时候记得在&gt;&gt;符号之间加上空格: set&lt;set&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、set数组的定义:set&lt;typename> arrayname[arraysize];例如: set&lt;int&gt; a[100];//a[0]~a[99]中的每一个都是一个set容器 与set&lt;set&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、set容器内元素的访问 set只能通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:set&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问set中的元素例如: #include&lt;iostream&gt; #include&lt;set&gt; using namespace std ; int main(){ set&lt;int&gt; a; a.insert(3);//将3插入set中 a.insert(5); a.insert(2); a.insert(3); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++){//a.begin()为取a的首元素地址，而it指向这个地址 cout&lt;&lt;*it; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,set的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。另外,除vector和string之外的STL容器都不支持*(it+i)的访问方式。因此只能按如上的方式枚举。 4、set常用的函数 (1)insert(x):在set容器中添加一个元素,并自动递增排序,时间复杂度为O(logN),N为set内元素个数。 (2)find(x):用以返回set中对应值为x的迭代器，时间复杂度为O(logN)。set&lt;int&gt;::iterator it=a.find(2) (3)size():用来获得set中的元素的个数，时间复杂度为O(1)。 (4)clear():用来清空set中的所有元素，时间复杂度为O(N)。 (5)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(1);a.erase(x),x为所要删除元素的值,时间复杂度为O(logN)。删除一个区间内的所有元素:a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的vector]]></title>
    <url>%2F2018%2F03%2F16%2FC%2B%2B%E4%B8%AD%E7%9A%84vector%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现普通数组浪费大量的内存空间或者无法使用邻接矩阵(节点数太多)又害怕使用指针实现邻接表的情况。此时我们应当想到vector。向量vector是一种对象实体, 能够容纳许多其他类型相同的元素,比如：int、char、double、结构体等。 因此又被称为容器。与string相同,vector同属于STL(Standard Template Library,标准模板库)中的一种自定义的数据类型, 可以广义上认为是数组的增强版。vector是一个能够存放任意类型的动态数组。如果需要使用vector，必须包含头文件#include还有命名空间”using namespace std;”。 1、vector的定义:vector&lt;typename> name;例如: vector&lt;int&gt; name; //声明一个int向量 vector&lt;int&gt; name(10); //声明一个初始大小为10的int型向量 vector&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型向量 vector&lt;int&gt; name(a); //声明一个初始大小为a的int型向量 vector&lt;node&gt; name; //node是结构体的类型 如果typename是vector，定义的时候记得在&gt;&gt;符号之间加上空格: vector&lt;vector&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、vector数组的定义:vector&lt;typename> arrayname[arraysize];例如: vector&lt;int&gt; vi[100];//vi[0]~vi[99]中的每一个都是一个vector容器 与vector&lt;vector&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、vector容器内元素的访问 (1)通过下标访问，即vi[0]~vi[size-1]进行访问。 (2)通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:vector&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问vector中的元素例如: #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std ; int main(){ vector&lt;int&gt; vi; for(int i=1;i&lt;=5;i++){ vi.push_back(i); } vector&lt;int&gt;::iterator it=vi.begin();//vi.begin()为取vi的首元素地址，而it指向这个地址 for(int i=0;i&lt;5;i++){ cout&lt;&lt;*(it+i); } return 0; } 上述程序中出现了去vi的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外，vector的迭代器不支持it&lt;vi.end()的写法，因此循环条件只能用it!=vi.end()。除此之外，迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 4、vector常用的函数 (1)push_back(x):在vector后面添加一个元素，时间复杂度为O(1)。 (2)pop_back():用以删除vector的尾元素，时间复杂度为O(1)。 (3)size():用来获得vector中的元素的个数，时间复杂度为O(1)。返回的是unsigned类型。 (4)clear():用来清空vector中的所有元素，时间复杂度为O(N)。N为vector中元素的个数。 (5)insert(it,x):用来向vector的任意迭代器it处插入一个元素x，时间复杂度O(N)。 (6)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(N);a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题使用过程中所遇见的问题及解决措施]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[1、有时在hexo s之后本地没有问题，但是在hexo d推送到GitHub之后没有样式显示，此时很可能是GitHub网站本身的原因，稍微等等再刷新就没事了。实在不行的话就把刚才的修改内容改回之前的状态。先hexo clean清理缓存，再hexo g;hexo d刷新查看。 2、平时对博客的修改和更新直接使用hexo g;hexo s查看本地无误之后一般直接hexo d就行了。但是在其中某一步执行完报错之后，记得要先hexo clean再重新执行其他的操作。 3、博客在本地显示正常，hexo d到github上后只显示框架，内容空白时。进入next主题的source目录，将vendors文件的文件名改成任意其他名字，如：VEN。接着在next主题的配置文件_config.yml中,将vendors: 块中的_internal: vendors项改成前面重命名文件夹的名称,如_internal: VEN，保存。(注意在hexo中的大多数情况之下冒号和要填写数据之间必须有一个空格符，否则会在hexo g时便报错)。接下来hexo clean;hexo g;hexo d;打开博客主页，清理缓存，多刷新几次即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的除法]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的除法也可以叫做高精度与低精度的除法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相除呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从大整数的高位开始，上一步的余数(余数的初始值为0)乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步需要注意高位可能有多余的0，要去除，但同时也要保证至少有一位数。有一点需要注意的是：这里的除法函数当中使用了引用变量，引用不产生副本，而是给原变量取了一个别名，对引用变量的操作就是对原变量(即算法中的全局变量)的操作。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign divide(bign a, int b,int &amp;r) {//a/b bign c; c.len = a.len;//被除数的每一位和商的每一位是一一对应的。 for (int i = c.len - 1;i &gt;= 0;i--) {//从高位开始除。 r = r * 10 + a.d[i];//和上一位的余数进行组合。这里的r是引用变量，对引用变量的操作就是对原全局变量的操作。 if (r &lt; b) c.d[i] = 0;//不够除，该位的商为0。 else { c.d[i] = r / b;//商 r = r % b;//获得新的余数。 } } while((c.len-1&gt;=1)&amp;&amp;c.d[c.len-1]==0){ c.len--;//去除高位的0，同时至少保留一位最低位。 } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b,r=0; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(divide(a, b,r));//商 cout &lt;&lt;&quot; &quot;&lt;&lt; r;//余数 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的乘法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的乘法也可以叫做高精度与低精度的乘法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相乘呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从int型数组的低位开始取数与int型数据相乘，再与进位相加，所得的结果的个位数作为该位的结果，高部位作为新的进位。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign multi(bign a, int b) {//a*b bign c; int carry = 0;//进位 for (int i = 0;i &lt; a.len;i++) { int temp = a.d[i] * b + carry; c.d[c.len++] = temp % 10;//个位作为该位的结果。 carry = temp / 10;//高位部分作为新的进位。 } while (carry != 0) {//此处和加法略有不同，乘法的进位可能不止一位。 c.d[c.len++] = carry % 10; carry /= 10; } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(multi(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数减法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数减法又称之为高精度减法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相减呢？其实本质上和小学的减法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相减之前去比较两者的大小，如果是小的减大的则先把负号输出来，将两者进行交换之后再按大的减小的的步骤来。在减的过程中如果当前位是小减大，那么当前位先加10再减，被减数的当前位的下一位同时需要减1。在所有的位都彼此相减完之后，此时还需要考虑高位为0的情况：例如两数是相等的情况，那么就需要消去高位的0。完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign sub(bign a, bign b) {//a-b。 bign c; for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { if (a.d[i] &lt; b.d[i]) { a.d[i + 1]--;//向高位借位。 a.d[i] += 10;//当前位加10。 } c.d[c.len++] = a.d[i] - b.d[i];//当前位相减。 } while ((c.len - 1 &gt;= 1) &amp;&amp; c.d[c.len - 1] == 0) { c.len--;//去除高位的0，同时如果两数相等保留一个0。 } return c; } int compare(bign a, bign b) {//比较两数的大小，先比较长度，再比较各个位的数值大小。 if (a.len &gt; b.len) return 1;//a大 else if (b.len &gt; a.len) return -1;//b大 else { for (int i = a.len - 1;i &gt;= 0;i--) { if (a.d[i] &gt; b.d[i]) return 1; else if (a.d[i] &lt; b.d[i]) return -1; } return 0; } } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); if (compare(a, b) &lt; 0) {//如果a小于b，就交换。 cout &lt;&lt; &quot;-&quot;; bign c = a; a = b; b = c; } print(sub(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数加法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数加法又称之为高精度加法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相加呢？其实本质上和小学的加法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相加完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign add(bign a, bign b) {//a+b。 bign c; int carry = 0;//存储进位。 for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10;//两数之和的个位。 carry = temp / 10;//两数之和的十位。 } if (carry != 0) c.d[c.len++] = carry;//两个大整数的最高位相加之后有进位。 return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); print(add(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的String]]></title>
    <url>%2F2018%2F03%2F14%2FJava%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[1、在Java中字符串是一个对象，同样的，String变量存储的是对String对象的引用。且Sting对象的内容是不可变的，但保存String引用的变量是可变的，即String变量存储其他的String对象的引用。 2、Java虚拟机为了提高效率并节约内存，对具有相同字符串序列的字符串直接量(请注意这里不是指具有相同字符串序列的String对象)使用同一个实例。 3、字符串的比较：运算符==只能检测两个String是否指向同一个对象，但不会告诉你他们的内容是否相等。而equals方法则可以用来判断两个字符串变量的内容是否相等。compareTo方法用来比较两个字符串时的返回值是，两个字符串从左到右第一个不同字符之间的差值。 4、StringBuffer类和StringBuilder类都比String类更灵活且这两个类是很相似的，它们创建的对象的值都可以被修改。不过在多任务并发访问的情况下就使用StringBuffer；而如果是单任务访问，就使用StringBuilder更有效。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%97%A9%2F</url>
    <content type="text"><![CDATA[昨夜雨疏风骤，晨起的道上落满了香樟树的叶子，叶子大多橙黄，意味着新生。空气湿润，给人以深呼吸的欲望。上课的人群络绎不绝；环游车从耳旁呼啸而过；还有鸟儿藏在春日的绿里，送来阵阵悦耳的啼鸣。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo的next主题添加点击出现桃心效果的功能]]></title>
    <url>%2F2018%2F03%2F11%2F%E4%B8%BAhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%A1%83%E5%BF%83%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、在路径/themes/next/source/js/src里面新建love.js文件。 2、将下列代码copy进去: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 3、然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 4、接下来你懂的: hexo g hexo s hexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中需要注意的Points]]></title>
    <url>%2F2018%2F03%2F11%2FJava%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84Points%2F</url>
    <content type="text"><![CDATA[1、数组的创建不同于基本数据类型变量的声明，声明一个数组变量时并不在内存中给数组分配任何空间。它只是创建一个对数组的引用的存储位置。 2、在给方法传值的过程中，对于基本数据类型来说，传递的是实参的值，而方法内部的形参获得的值的改变并不会造成方法外部的值的变化；而对于数组类型来说，传递的是数组的引用，也就是说方法中的数组和方法外的数组是一样的，所以如果改变方法中的数组，那么方法外的数组也跟着变化了。 3、对象是通过对象引用变量来访问的，通常在实例化一个类时包括：声明对象引用变量、创建对象以及将对象的引用赋值给这个变量。其实此处类似于数组的创建，从严格意义上来讲，对象引用变量和对象是不同的，但大多数情况下可以忽略这种不同。另外，类中的数据域(即类中的属性)如果未被初始化，那么会被赋予默认值：引用类型的数据域的默认值是null，数值类型的数据域的默认值是0，boolean是false，char是’\u0000’。但是java没有给方法中的局部变量赋默认值。 4、java中的静态变量可以被一个类的所有实例共享数据，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。java中的静态变量和静态方法都无须创建类的实例就可以被调用。但是实例方法和实例变量只能在实例方法中使用，不能在静态方法中使用。由此可知，math类中的所有数据域和方法都是静态的。 5、在类、方法、和数据域前使用public修饰符表示可以在任何其他的类中进行访问；如果没有使用可见性修饰符，那么默认为类、方法和数据域是可以被同一个包中的任何一个类访问；private修饰符限定方法和数据域只能在它自己的类中被访问。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加标签和分类页面]]></title>
    <url>%2F2018%2F03%2F09%2FAdd-tags-and-categories-to-Blogs%2F</url>
    <content type="text"><![CDATA[1、添加标签页面 定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page: $ cd hexo目录 $ hexo new page tags 内容如下所示，如果要关闭tags页面的评论可以设置comments为false: --- title: 标签 date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 这样以后tags页面在每次执行hexo generate后自动更新。 2、添加分类页面 和上面的一样，在hexo目录下执行下面命令： $ hexo new page categories 内容为： --- title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 3、添加404页面 新建一个404.html文件，放到themes\next\source目录下，内容你自己定。 4、添加博文 $ hexo new [filename] --- title: filename! date: create_time tags: tags categories: categories --- 或者写好文章后，找到菜单栏的“导出到本地”选项.以md格式导出到本地，然后copy该md文件，粘贴到你当初建的博客站点文件夹下的source\ _posts目录下，一个md文件对应一篇博客文章。 5、多标签和多分类的表示方法 tags: [tags1,tags2,tags3] categories: [cat1,cat2,cat3] 6、对本地作出的修改进行测试和上传 在你博客站点文件夹下右键空白处，选择Git Bash Here， 输入：hexo generate，回车，生成静态页面， 再输入：hexo server，回车，到localhost:4000预览博客效果， 最后输入：hexo deploy，回车，同步到github上去就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git push to github]]></title>
    <url>%2F2018%2F03%2F08%2FGit-push-to-github%2F</url>
    <content type="text"><![CDATA[1、git status 查看目前代码的修改状态 a) 已暂存 (changes to be committed) new file //表示新建文件 modified //表示修改文件 deleted //表示删除文件 b) 已修改 (changed but not updated) modified //表示修改文件 deleted //表示删除文件 c) 未跟踪 (untracked files) 另外，git 给出了可能需要的操作命令，git add/rm, gitcheckout – 2、git diff 查看代码修改的内容(按q键退出) 比较某文件与最近提交节点的差异。 注意：如果该文件已暂存，那么应该使用git diff –cached 技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。(也可以利用^运算符) 3、git add [filename] 暂存需要提交的文件 如果是新建的文件则git add 如果是修改的文件则git add 如果是删除的文件则 git rm 4、git commit -m “description informations” 提交已暂存的文件(注意注释填写规范) git commit –amend 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。 5、git pull origin master –allow-unrelated-histories 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 命令：git checkout – &lt;有冲突的文件路径&gt; 6、git push -u origin master&lt;本地分支名&gt; 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。 7、如果过程中出现‘please enter a commit message…’(即进入了vim),首先esc然后输入:wq即可。 git rm −r 我的文件夹/此处−r表示递归所有子目录，如果你要删除的，是空的文件夹，此处可以不用带上−r。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于等到你]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[不知道不知道 头顶遥远的苍穹闪烁的星光 在无穷无尽里飞行了多少光年 终于赶来与我的目光相会 不知道 手中捧握的书卷古老的诗篇 在岁月长河中留存了多少记忆 此刻也将属于我的悉心珍藏 不知道 你与我不断发酵生酯的相逢 在冥冥注定中酝酿了多少韶华 但我仍然记得你发梢的芳香]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
</search>
