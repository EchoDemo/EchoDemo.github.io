<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[诗词入门(二)]]></title>
    <url>%2F2018%2F04%2F05%2F%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、拗救(1)拗：不符合诗律的一般规律(出律了) (2)救：在拗的前提下调节平仄使音感和谐。 2、拗救的常见形式以下皆以五言作为例句进行说明，那么也就是说七言的后五字同样适用于这些情况。 (1)本句自救(准律句)：平平平仄仄=》平平仄平仄 例： 凉风起天末，君子意如何。 平平仄平仄，平仄仄平平。 根据诗律的原则，这里的“凉风起天末”句明显出律了。那么是“风”字出律还是“天”字出律呢？我们可以通过“君子意如何”句的平仄来判断。在这一联当中，对句的二四字的平仄为仄、平，那么就可以推出出句的二四字的平仄就为平、仄。也就是说是“天”字出律了(当仄为平时)，那么为什么明明“天”字出律了还会认为是对的呢？这种情况就是属于拗救中的本句自救。我们先来看一下出句的正确的平仄：“平平平仄仄”。这里有这样的规定：如果在诗的创作过程中碰到了上述这种情况，就可以把它的平仄直接改写为“平平仄平仄”。这种形式只能出现在出句当中(因为对句必须是押韵的，而近体诗当中是不能压仄声韵的)，同时又由于诗律中的相对和相粘原则，出句之中也只有两句才能出现这种情况。(且首字必为平才能用) 若首字为仄，则是特例，初学者不建议使用。如：昔闻洞庭水(仄平仄平仄)。虽然说首字为仄的情况也是存在的，但毕竟与首字为平相比还是及其少见的。老杜虽是及其注重格律之人，但他毕竟生活在格律成形的那个年代，那个时候的格律还是处于可以推敲的阶段，当然也就不能说他是错的。(这里只是希望初学者不要钻牛角尖，只要记住这种拗救的形式就行) 又例： 遥怜小儿女，未解忆长安。 平平仄平仄，仄仄仄平平。 何时倚虚晃，双照泪痕干。 平平仄平仄，平仄仄平平。 西望瑶池降王母(平仄平平仄平仄) (2)对句相救：出句第四字当平为仄时，对句第三字只能是平声。 例： 向晚意不适，驱车登古原。 仄仄仄仄仄，平平平仄平。 *在诗词当中，“不”字几乎可以说是只能为仄声。但也不是绝对的，当“不”字通“否”字时且作为韵脚时，它是平声的。如果它位于句中就一定是仄声。 同样，这里根据对句的平仄可以判断出，是出句当中的第四字“不”字出律了(当平为仄时)。此时，可以通过对句的第三字(此时必为平声)来救，也就是例句中的“登”字。按照“一三五不论”的原则，“登”字本是可平可仄的，但是在这种情况之下就只能为平声了。因为是出句由对句来救，所以这种情况只能发生在出句当中。 又例： 野火烧不尽，春风吹又生。 仄仄平仄仄，平平平仄平。 *吹字是可平可仄的，作名词的时候为仄声(歌吹是扬州)，作动词的时候为平声。 3、“一三五不论”需要排除的三种情况(1)三平尾：在已经确定倒数第一和倒数第二字为平声的情况之下，如果仍然令倒数第三字为平声的话，就会变成“平平平”。三平尾是写诗的大忌。 (2)三仄尾：在已经确定倒数第一和倒数第二字为仄声的情况之下，如果仍然令倒数第三字为仄声的话，就会变成“仄仄仄”。三仄尾也是写诗的大忌。 (3)孤平：就是“仄平仄仄平”。七言看后五字。孤平同样是写诗的大忌。 4、根据平仄判断律句，若非律句再判断是否可救的步骤(1)先判断二四六字是否是平仄交替的。如果是则说明暂时是一个律句，进行第二步；否则说明此句不是一个标准的律句，进行第三步。 (2)是否出现了三平尾、三仄尾或者是孤平。如果出现了其中一种，则必定是错误的。若没有，则说明是可以用的。 (3)判断是否符合拗救的两种基本形式。如果符合其中之一说明是可以用的；如果都不符合则说明是错误的。 5、作业如果是本句自救(准律句)，打半钩；如果是对句自救，则标记出其对句该如何。如果最终不符合则打叉，符合打钩。若有余力，为正确的律句查找相应的诗句。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的问题整理]]></title>
    <url>%2F2018%2F04%2F05%2FMySQL%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、mysql共享锁和排他锁 (1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排它锁。 (2)共享锁也叫读锁，简称S锁，原理：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改。 (3)排他锁也叫写锁，简称x锁，原理：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁(排他锁或者共享锁)，即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改。但是获取排他锁的事务是可以对数据进行读取和修改。 (4)设置共享锁：SELECT … LOCK IN SHARE MODE;设置排他锁：SELECT … FOR UPDATE; (5)对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。 对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。 2、MySQL几种备份方式 (1)逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。 优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。 缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。 (2)物理备份：直接拷贝mysql的数据目录。直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。 缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。 (3)双机热备份。mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备)。 优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。 3、数据库范式：一张数据表的表结构所符合的某种设计标准的级别 (1)第一范式(1NF) 在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。所谓第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 (2)第二范式(2NF) 第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是消除了非主属性对于码的部分函数依赖。 (3)第三范式(3NF) 满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是消除了非主属性对于码的传递函数依赖。 4、SQL语句优化 (1)应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 (2)应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 (3)很多时候用 exists 代替 in 是一个好的选择。 (4)用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过。 5、存储过程与触发器的区别 (1)触发器与存储过程非常相似，它是一种特殊类型的存储过程。触发器也是SQL语句集，他们都像是数据库中运行的方法。两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发(激活)执行。 (2)触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。 (3)触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。 6、union 与union all的区别 union 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all 则会显示重复结果,只是简单的两个结果合并并返回.所以效率比union高,在保证没有重复数据的情况下用union all。 7、MyISAM和InnoDB区别 (1)InnoDB支持外键，而MyISAM不支持。 (2)InnoDB不支持全文索引，而MyISAM支持。 (3)InnoDB支持行级锁，而MyISAM支持表级锁。 (4)MyISAM不提供事务支持。InnoDB提供事务支持。 (5)MyISAM保存有表的总行数，如果select count() from table;会直接取出出该值。InnoDB：没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 (6)MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 (7)MyISAM可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。 (8)如果执行大量的SELECT，MyISAM是更好的选择。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 (9)每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 8、MySQL的三级模式 (1)模式(逻辑模式)：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 (2)外模式(用户模式)：是数据库用户的数据视图，是局部数据的逻辑结构和特征的描述。 (3)内模式(存储模式)：一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。 9、mysql中视图和表的区别以及联系 区别： (1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。 (2)视图没有实际的物理记录，而表有。 (3)视图是窗口，表是内容。 (4)视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。 (5)表可以及时对它进行修改；而视图只能用创建语句来修改。 (6)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。 (7)从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。 (8)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 (9)视图的建立和删除只影响视图本身，不影响对应的表。 联系： (1)视图是在表之上建立的虚表，它的结构(所定义的列)和内容(所有记录)都来自表，视图依据表存在而存在。一个视图可以对应多个表。视图是表的抽象和在逻辑意义上建立的新关系。 (2)删除视图中的数据,数据库中表的数据会一起被删除。 10、存储过程(procedure)和函数(function)区别 (1)本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。 (2)函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。 (3)函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务]]></title>
    <url>%2F2018%2F04%2F04%2FMySQL%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ (1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 (2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 (3)事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 (1)原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 (2)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 (3)隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 a、未提交读（RU）：最弱的隔离级别，事务中的修改即使没有提交，对其他事务也都是可见的。（即脏读） b、不可重复读（RC）：大多数数据库系统的默认隔离级别。解决了脏读的问题，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。一个事务两次执行同样的查询，可能会得到不一样的结果。 c、可重复读（RR）：mysql默认隔离级别。解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。 该级无法解决幻读的问题，幻读是当某个事务在读取某个范围内的记录时，一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。 innodb和xtradb存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。 d、可串行化：该级是最高的级别，通过强制事务串行执行，避免了幻读的问题，该级会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题， (4)持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务必使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： (1)BEGIN或START TRANSACTION；显式地开启一个事务； (2)COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； (3)ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； (4)SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； (5)RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； (6)ROLLBACK TO identifier；把事务回滚到标记点； (7)SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT来实现 (1)BEGIN 开始一个事务 (2)ROLLBACK 事务回滚 (3)COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: (1)SET AUTOCOMMIT=0 禁止自动提交 (2)SET AUTOCOMMIT=1 开启自动提交]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F04%2F04%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次递减时，它会不断地插在节点的左子树)。此时的二叉查找树的查找性能几乎变成了线性。那么如何解决二叉查找树多次插入新节点而导致的不平衡呢？红黑树也就应运而生了。 二叉查找树的性质： a、左子树上所有结点的值均小于或等于它的根结点的值。 b、右子树上所有结点的值均大于或等于它的根结点的值。 c、左、右子树也分别为二叉排序树。 2、红黑树(Red Black Tree)是一种平衡的二叉查找树(但不是一个完美的平衡二叉树)。它的应用有很多，Java中的TreeSet和TreeMap数据结构，Java8中的HashMap也用到了红黑树；在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。 (1)性质 a、节点是红色或黑色。 b、根节点是黑色。 c、每个叶子节点都是黑色的空节点（NIL节点）。 d、每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) e、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 以上这些限制强化了红黑树的关键属性：从根节点到最远叶节点的路径不超过从根到最近叶节点的路径的两倍(最短的路径是:全部都是黑色节点，最长的路径是:在红色和黑色节点之间交替)。这也是红黑树和二叉查找树之间最大的不同。 (2)左旋转和右旋转 a、左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子树取代，而父节点自己成为自己右子树(现在已经是父节点了)的左子树。现在已经是父节点的的左子树成为曾经的父节点的右子树。 b、右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子树取代，而父节点自己成为自己左子树(现在已经是父节点了)的右子树。现在已经是父节点的的右子树成为曾经的父节点的左子树。 (3)插入节点 a、当前节点位于树的根部。为了满足（根节点是黑色），将其颜色变成黑色。由于这会向每条路径都添加一个黑色节点，所以（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）不会被违反。 b、当前节点的父节点是黑色的。所以（每个红色节点的两个子节点都是黑色）不会失效。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）没有受到威胁，因为当前节点有两个黑色节点，但由于当前节点是红色，所以到达其每个叶子节点路径上的黑色节点的数量与它所替换的叶子节点路径上的黑色节点的数量是相同的。 c、如果父节点和父节点的兄弟节点都是红色的，那么可以将他们的颜色都变成黑色，并且将祖父母节点的颜色变成红色以维持（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）。由于通过父节点和父节点的兄弟节点的任何路径必须经过祖父母节点，所以这些路径上的黑色节点的数目并没有改变。然而，祖父母节点现在可能违反了（根节点是黑色），如果它是根或（每个红色节点的两个子节点都是黑色），如果它具有红色的父母节点。为了解决这个问题，树上的红黑修复程序在祖父母节点上重新运行。 d、父节点是红色的，但是父节点的兄弟节点是黑色的。最终目标是将当前节点旋转到祖父母节点的位置，但如果当前节点位于祖父母节点下子树的“内部” （即，如果当前节点是祖父母节点的右子节点的左子节点或者是祖父母节点的左子节点的右子节点）。在这种情况下，可以在父节点上执行左旋转以切换当前节点及其父节点的位置。由于父节点和当前的插入节点都是红色的，所以旋转这两个节点不会使（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）受到旋转的影响。这一步完成后（每个红色节点的两个子节点都是黑色）仍然被违反。此时，当前节点现在肯定位于祖父母节点的子树的外部（左子节点或右子节点）。在这种情况下，执行祖父母节点上的右旋转;其中前父母节点现在是当前节点和前祖父母节点的父母节点。此时前父母节点和前祖父母节点的颜色互换，结果树满足（每个红色节点的两个子节点都是黑色）。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）也依然不满足，再将前祖父母节点和其右子节点的颜色互换即可。 *具体的红黑树中插入和删除出现的有关旋转和变色的情况，请自行跳转至维基百科查看：维基百科红黑树]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柴]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%9F%B4%2F</url>
    <content type="text"><![CDATA[你本是泥土里的种子 春雨下来，便破土而出，发芽又抽绿 阳光透过乔木和灌木的叶子漏下来 照耀着你微弱的身体 后来呀，雨露下来，寒风穿过 土壤也时而干燥 根在土里生长 叶在空气里徜徉 向着更广阔的空间里延伸 春夏秋冬地过去，轮回。 那一日，我手持柴刀独自上山 无意间来到你的身旁 此时的你已巍然成木 在多少次的手起刀落后 在洁白的木屑四散飞溅后 你轰然倒下 倒在你无比熟悉的地点 我残忍地脱去你的外衣，卸下你的臂膀 甚至头颅。 你已经死了 你的尸体跟随我下了山 你永远地离开了生生世世守护的这方土地 被我丢弃在陌生的沙土之上 无情的斧子借着外力将你的尸体大卸八块 陈列在清灰色瓦片盖的土坯房子里 静静等候与烈火的相遇 化为炊烟又化为尘土]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全文”的扩展链接，你会知道自己在某天的某个时间段做了什么。可能是有关学习的知识点，可能是有关生活的感悟或自己的思考，又或者仅仅是记录了一件事情的发生。所有这些，过后回望的确会有及其深刻的意义。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(三)]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。 2、经过提纯的内心空间，不是不懂，不知，而是不问，不计较，不介意，不追究。愿意把别人想得好一些，不把人想得复杂，考虑到对方的立场。可说，可不说时，不如选择不说。 4、不存在无可救药的人、感情、生活。一切终究有变化。如果你认为它无可救药，不过是沉溺。我们可以选择完全的放下，或者完全的承担。唯独不能伪装成一个懒怠的理所当然的姿势。你尽可拖延和故作不知，企图获得其他妥协。命运静静等待一侧，旁观你辗转煎熬，最终会逼迫你把脚步移向注定的一格。实践一旦进行，错误和方式就会自动调整和归位。出发时首要的。 5、跪拜只是一个仪式，为了让心恭敬谦卑平和柔顺，在毫无杂念从事这一重复举动时训练和观照自己。调伏这颗充满傲慢我执的刚硬的心。这是一个修行的任务。 6、]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的抽象类和接口]]></title>
    <url>%2F2018%2F03%2F31%2FJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是GeometricObject类型的数组，然后创建一个GeometricObject的实例，并将它的引用赋值给数组是可以的。虽然不能使用new操作符创建它的实例，但仍然可以定义它的构造方法，抽象类的构造方法定义为protected，因为它只被子类使用。抽象方法只有定义而没有实现。它的实现由子类提供。 2、抽象方法不能包含在非抽象类中，也就是说一个包含抽象方法的类必须声明为抽象类。但是，可以定义一个不包含抽象方法的抽象类(同样不能使用new操作符创建它的实例)，这种类是用来定义新子类的基类的。如果抽象父类的子类不能实现所有的抽象方法，那么这个子类也必须定义为抽象的。另外，抽象方法是非静态的。 3、即使子类的父类是具体的，这个子类也可以是抽象的。比如：object类是具体的，但继承于它的类却可以是抽象的。子类可以覆盖父类的方法并将它定义为abstract(这是很少见的)，但是它在当父类的方法实现在子类中变得不合法时是很有用的。在这种情况下，子类必须为abstract。 4、接口是一种与类相似的结构，只包含常量和抽象方法。它和抽象类相似，不能使用new操作创建接口的实例。由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以java允许忽略这些修饰符。 5、Java只允许为类的扩展做单一继承，但是允许使用接口做多重继承。用关键字extends，接口可以继承其他接口，但是不可扩展类。一个类可以扩展它的父类同时实现多个接口。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[画地为牢]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2%2F</url>
    <content type="text"><![CDATA[人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一双发现美的眼睛，同时也需要有伸向外界的触角和勇气。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strcpy函数的实现]]></title>
    <url>%2F2018%2F03%2F28%2FStrcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[(1)strcpy函数的代码实现 char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。 assert(dst != NULL &amp;&amp; src != NULL);//检查指针的有效性，如果它的条件返回错误，则终止程序执行。 char *ret = dst; while ((*dst++=*src++)!=&apos;\0&apos;); return ret; } (2)为什么要返回char *? 返回dst的原始值使函数能够支持链式表达式。链式表达式的形式如：int l=strlen(strcpy(strA,strB));又如：char * strA=strcpy(new char[10],strB); 返回strSrc的原始值是错误的。 其一，源字符串肯定是已知的，返回它没有意义。 其二，不能支持形如第二例的表达式。 其三，把const char *作为char *返回，类型不符，编译报错。 (3)考虑dst和src内存重叠的情况 所谓重叠，就是src未处理的部分已经被dst给覆盖了，只有一种情况：src&lt;=dst&lt;=src+strlen(src)。C函数memcpy自带内存重叠检测功能，下面给出memcpy的实现my_memcpy。 char *strcpy(char *dst,const char *src){ assert(dst != NULL &amp;&amp; src != NULL); char *ret = dst; my_memcpy(dst, src, strlen(src)+1); return ret; } my_memcpy的实现： char *my_memcpy(char *dst, const char* src, int cnt){ assert(dst != NULL &amp;&amp; src != NULL); char *ret = dst; if(dst &gt;= src &amp;&amp; dst &lt;= src+cnt-1){//内存重叠，从高地址开始复制 dst = dst+cnt-1; src = src+cnt-1; while (cnt--) *dst-- = *src--; }else{//正常情况，从低地址开始复制 while (cnt--) *dst++ = *src++; } return ret; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三月二十七号]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%89%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量的传递与引导，人与自然需要一定的联结。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(二)]]></title>
    <url>%2F2018%2F03%2F27%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。仿佛一种强悍的无法屈服的意愿。 2、我们最终所得到的训练无非是，面对无所知、无常、虚妄，时时抚平心绪，保持警惕、平静、坚强、有方向地活下去。并且静观这个世间所有破落的碎片擦身而过。 3、人的生活需要公园。它为日常生活提供一处停顿。停顿意味暂时没有心念，没有目标，略作小憩，与己共存。 4、如果要做到不伤害他人，前提是不要对他人抱有期待。同时也不让他人抱有对你的期待。做到后一条更为困难。这意味着在某些时刻，你必须显示你自己真实的立场，而没有一丝自私的隐藏或者造作。 5、有时，我们爱人，是取悦自己渴望被爱的欲求；对他人的提供，是试图填补内在匮乏的需求；憎恶或攻击他人，是被对方提醒了不愿意被揭示的遮蔽的暗处；愤恨或者狂躁，联结着内心长期积累的软弱和无力。。。自我战争不过是冲突于牢笼之中。 6、时间很重要，物证很重要。它们会使某些曾经被蒙蔽或忽略的情感，在很久之后被澄清和浮出。我也会手写书信给生命中真正重要的人。只为了让他或她，在以后某天终会明白我的心。 7、摘完杏，和农夫闲聊。他说果实在树上，阳光的温度或突降的暴雨都会给予它影响。每一天它的内在都在发生变化，都在面临无常。所以，及时地摘下并享用它即是最好的方式。 8、人由自我限制而生发的对他人的狭窄念头，毫发无损于对方，只使自己捉襟见肘。若能置身事外，才不会画地为牢。 9、当下享受是最好的态度。接受无常，接纳完整的存在，而不试图重新塑造，也不扭曲自己和他人。关系第一原则，应是允许他人以独立和自愿的方式存在。期望是自以为是的权力。 10、在一本书里，读者感受到作者的精神方式、观念、特质，觉得与之契合，有共鸣，遂在心里把他当作一个知己。他们之间的关系，有时会比生活中实际相处的人抵达更为深邃的心灵限度。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(三)]]></title>
    <url>%2F2018%2F03%2F26%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[1、define与const的区别 (1)define在预处理阶段进行替换;const在编译时确定其值。 (2)用define可以定义一些简单的函数，const是不可以定义函数的。 (3)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的。 (4)define无类型，不进行类型安全检查，可能会产生意想不到的错误;const有数据类型,编译时会进行类型检查。 (5)define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大;const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。 (6)宏定义的作用范围仅限于当前文件;而const对象在默认状态下，只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字(在声明和定义时都要加。 2、构造函数不能为虚函数，而析构函数可以且常常是虚函数 (1)如果构造函数是虚函数，那么就需要通过vtable来调用，但此时面对一块raw memeory是找不到vtable的，vtable是在构造函数中才初始化的，而不是在其之前。因此构造函数不能为虚函数。 (2)析构函数可以是虚函数,此时vtable已经初始化了,况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。 3、虚函数和纯虚函数的作用与区别 (1)虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不重写基类中的此函数。 (2)纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数。它不能直接实例化，需要派生类来实现函数定义。 4、面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。他们之间的共同点是抽象和创建可重用代码，但它们的理念决然不同。泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板，模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型，它们都是STL通用方法的重要组成部分。 5、头文件中的#ifndef/#define/#endif的作用 其作用是防止该头文件被重复引用。”被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include “c.h”而此时b.cpp文件导入了#include”a.h”和#include”c.h”此时就会造成c.h重复引用。有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些。但是对于大工程而言编译效率低下就会是一件很痛苦的事情了。 6、动态内存分配的初始化问题 1)malloc函数：void *malloc(unsigned int size) 在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。 2)calloc函数： void *calloc(unsigned int num, unsigned int size) 按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。 3)realloc函数：void realloc(void ptr, unsigned int size) 动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。申请的内存空间不会进行初始化。 4)new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。 7、指针和const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值可以改变。 const int *x = &amp;y; //指针所指向的内存可变，但内存中的值不能通过指针改变。 int const *x = &amp;y; //指针所指向的内存可变，但内存中的值不能通过指针改变。 const int const *x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。 const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。 当const在*的左边，则表示指针所指向的空间的内容不能通过改变*p的值来修改，或者说指针所指向空间的值不能被修改。 当const在*的右边，则表示指针的地址不能被修改，或者说指针的指向不能被修改。 8、无论是整型数组还是字符数组，数组名作为右值的时候都代表数组首元素的首地址。数组发生降级(数组名退化为数组首元素的地址)的情况：数组传参、数组名参与运算。数组名不会发生降级的情况：sizeof(数组名)、取地址数组名(取到的是整个数组的地址而不是首元素的地址)。 9、重载、覆盖和隐藏 (1)成员函数被重载的特征： a、相同的范围(在同一个类中)； b、函数名字相同； c、参数不同； d、virtual关键字可有可无。 (2)覆盖是指派生类函数覆盖基类函数，只作用于派生类函数，特征是： a、不同的范围(分别位于派生类与基类)； b、函数名字相同； c、参数相同； d、基类函数必须有virtual关键字。实际上虚函数的作用，就是实现覆盖。 (3)“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： a、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)。 b、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)。 10、类模板与模板类的概念 (1)类模板:一个类模板(也称为类属类或类生成类)允许用户为类定义一种模式，使得类中的某些数据成员、默认成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。 (2)模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。类模板的重点是模板，表示的是一个模板，专门用于产生类的模子。模板类的重点是类，表示的是由一个模板生成而来的类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(二)]]></title>
    <url>%2F2018%2F03%2F26%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。 2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。 3、构造函数初始化时必须采用初始化列表的一共有三种情况 (1)需要初始化的数据成员是对象(继承时调用基类构造函数) (2)需要初始化const修饰的类成员 (3)需要初始化引用成员数据 *由于static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的。static const成员也不在初始化列表中。 *static属于类，它在未实例化的时候就已经存在了，而构造函数的初始化列表，只有在实例化的时候才执行。 *static成员不属于对象。我们在调用构造函数自然是创建对象，一个跟对象没直接关系的成员没有必要初始化。 4、实参可以是任何类型（可以是常量，变量或表达式），但是形参却不能是表达式。C语言中最简单的数据类型包括整型、实型(实型又称浮点数或者实数)、字符型。在C语言中，没有专门的逻辑型数据类型，而是用0和1来表示逻辑值。 5、类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐。基类中存在虚函数时，派生类会继承基类的虚函数(虚函数也是类的成员函数)，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。(指向虚函数的指针为4个字节) 6、fork()与clone的区别 函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；clone()函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可以通过参数设定选择的，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。 7、关于浅复制和深复制 所谓浅复制，就是在构造函数当中直接为复制的对象的数据成员赋值。在很多情况下，这是可以的。创建新的对象，要为对象的数据成员分配存储空间，直接赋值就将值保存在相应的空间中。但是如果在构造函数当中出现了指针类型的数据成员时，也按照上面那样直接赋值而未经过地址的分配就会在调试的时候出错，这种指针被称为“野指针”。解决这样的问题的方法，就是在构造函数中，为指针类型的成员，分配专门的空间。以这条规则构建的复制，称作为深复制。 8、C语言中的未定义行为(Undefined Behavior) 未定义行为是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。 9、C++面向对象的三个基本特征(封装、继承和多态) (1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行。封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。 (2)继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 (3)多态：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上。同时又有这些多态的形式，参数多态：指参数方面，包含函数模板与类模板；包含多态：含有virtual关键字；重载多态：函数名相同，但函数参数的个数或类型不同构成多态；强制多态：通过强制类型转换形成；重载多态和强制多态是指特定多态。参数多态和包含多态是指通用多态。 *封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现接口重用！ 10、虚函数如何实现的 (1)虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针。 (2)在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。 (3)实际上在编译的时候，编译器会自动加上虚表。 (4)虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函 数重新定义。 (5)虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续 表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。 (6)必须通过基类类型的引用或指针进行函数调用才会发生多态。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中个人常用快捷键]]></title>
    <url>%2F2018%2F03%2F26%2FWindows%E4%B8%AD%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1、Ctrl类 (1)撤消操作：Ctrl+Z (2)复制选定文本：Ctrl+C (3)粘贴选定文本：Ctrl+V (4)剪切选定文本：Ctrl+X (5)打开新窗口：Ctrl+N (6)关闭当前所在窗口：Ctrl+W (7)恢复关闭的窗口：ctrl+shift+T (8)新建文件夹：Ctrl+Shift+N (9)选择文档或窗口中的所有项目：Ctrl+A (10)在本应用下的窗口之间进行切换：Ctrl+Tab 2、Windows类 (1)电脑锁屏：Windows+L (2)显示和隐藏桌面：Windows+D (3)打开任务视图：Windows+Tab (4)打开“运行”对话框：Windows+R (5)打开文件资源管理器：Windows+E (6)添加虚拟桌面：Windows+Ctrl+D (7)关闭你正在使用的虚拟桌面：Windows+Ctrl+F4 (8)在你于右侧创建的虚拟桌面之间切换：Windows+Ctrl+向右键 (9)在你于左侧创建的虚拟桌面之间切换：Windows+Ctrl+向左键 3、其他 (1)刷新当前窗口：F5 (2)在所有打开的应用之间进行切换：Alt+Tab]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和引用的区别]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[(1)可以有const指针，但是没有const引用。 (2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;&a;是不合法的)。 (3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。 (4)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 (5)指针可以是空值，可以在任何时候被初始化。而引用不可以为空且在被创建的时候，必须初始化。此处引用类似于const的指针。 (6)指针和引用的自增(++)运算意义不一样。指针自增是所指的数据类型变量的下一个数据类型的地址。而引用是引用所指向的变量的值加1。 (7)”sizeof(引用)”得到的是所指向的变量(对象)的大小(即引用的sizeof为所引用的对象在内存中分配空间的大小(单位字节))，而”sizeof(指针)”得到的是指针本身的大小。在C++当中，存放一个地址和一个int类型的大小相同：4字节。即sizeof(指针)=4。 (8)指针是一个变量，只不过这个变量存储的是一个地址，是指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。引用变量的主要作用是用作函数的形参，通过将引用变量用作形参，函数将使用原始数据，而不是其副本。 注意：要把引用的&amp;和取地址运算符&amp;区分开来，引用并不是取地址的意思，引用符号是类型标识的一部分。由于引用是产生变量的别名，故常量不可使用引用。指针变量其实是unsigned类型的整数，这也解释了为什么在C++当中指针类型的变量的sizeof就是4个字节。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(一)]]></title>
    <url>%2F2018%2F03%2F25%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?答：对于#include&lt;filename.h&gt;,编译器从标准库路径开始搜索filename.h,而对于#include “filename.h”,编译器从用户的工作路径开始搜索filename.h。 2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?答：C++语言支持函数重载,C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为:void foo(int x, int y);该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int 之类的名字。C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。 3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?答：先执行基类的(如果基类当中有虚基类,要先执行虚基类的,其他基类则按照声明派生类时的顺序依次执行),再执行成员对象的,最后执行自己的。 4、New/delete与malloc/free的区别是什么？(1)new/delete是C++的操作符，而malloc/free是C中的函数。 (2)new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。 (3)new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。 (4)new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。 5、Struct和class的区别是什么？答：struct中成员变量和成员函数默认访问权限是public,class是private。 6、多态有哪些分类？答：多态可以分为编译时多态和运行时多态。编译时多态可以通过函数的重载来实现，具体表现在根据参数的个数和类型的不同选择合适的同名函数。运行时多态通过虚函数实现，就是运行时根据对象类型自动选择正确的调用函数(也叫动态绑定)。模板属于编译时多态性，因为编译时自动根据模板生成模板函数。虚函数的动态绑定仅在基类指针或引用绑定派生类对象时发生。如果函数的形参不是指针或者引用，则调用哪个类的函数就已经确定。 7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？(1)默认情况下，编译器的对齐系数为8 (2)内存对齐：就是每个成员的起始位置必须是对齐系数与成员自身大小二者中较小者的整数倍。 (3)内存补齐：取结构体或类的成员中最大的那个值，与对齐系统相比，取二者中的较小者。然后保证整个对象结尾地址的下一个地址是较小者的整数倍。 (4)结构体对齐除了第1点之外还要求结构体数组也必须是对齐的，也就是说每个相邻的结构体内部都是对齐的。 可以看一下这篇文章:http://www.cppblog.com/cc/archive/2006/08/01/10765.html 8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。9、const 有什么用途？(1)可以定义const常量。 (2)const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。被const修饰的函数定义体的函数能被const或者非const对象调用，但是const对象只能调用被const修饰过定义体的函数。 10、什么是内联函数？(1)编译器使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存。例如：如果程序在10个不同的地方调用了同一个内联函数，则该程序将包含该代码的10个副本。 (2)在函数声明之前加上关键字inline或者在函数定义之前加上inline。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗词入门(一)]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、格律(1)平仄:单个汉字发音的音调 a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平。四声当中平声属于平仄当中的平声,而另外三声上、去、入则属于平仄中的仄声。 b、古代汉语的四声和今天普通话的声调种类不完全相同。上图中的黑色线条对古代汉语四声和现代汉语四声的连接是比较容易区分的：平声分为阴平和阳平，其中阴平对应现代汉语中的第一声，而阳平则对应现代汉语中的第二声；属于仄声的上声对应现代汉语中的第三声；属于仄声的去声则对应现代汉语中的第四声。 c、上图中用灰色线条连接起来的有关属于仄声的入声的演化是学习近体诗中平仄最让人费解的了。虽然现代江浙、福建、广东、广西、湖南和江西等处都还保存着入声，北方也有不少地方保存着入声这一个调类。但在普通话当中，入声字已经不复存在了。而是分别演化派进了现代汉语中的一、二、三、四声中去(也就是派进了古代汉语中的平、上、去三声当中，也称之为‘入派三声’)。当然对于演化成现代汉语中的三、四声的字我们无需担心(因为三、四声所对应的上声和去声本就是属于古代汉语中的仄声)，所以令我们困惑的就只是演化成现代汉语中一、二声的入声字(即入声演化为平声的情况)。而这一困惑是需要依靠查字典或者韵书才能消除的(当然如果你非常幸运地发现自己的方言就能辨别入声字，那你就一个人自己偷着乐吧)。这里素师推荐使用龙榆生的《唐宋词格律》。 d、这里引用大家耳熟能详的柳宗元的《江雪》作为例子来说明入派三声 《江雪》柳宗元 千山鸟飞绝，万径人踪灭。 孤舟蓑笠翁，独钓寒江雪。 这里的绝(jue)、雪(xue)、灭(mie)都是入声字，分别演化派入于平、上、去三声当中。 e、古仄今平、古平今仄和可平可仄。 古仄今平：就是上面提到过的入声派入平声。例：黑、白、竹、屋、绝、笛。。。 古平今仄：俱(ju第一声)、论(lun第二声)语 可平可仄：看;听;骑(qi)马(平)、一骑(ji)红尘妃子笑(仄) *素师说，在读近体诗的时候要么用方言，要么用普通话。不要四不像。 (2)韵律:诗从平水韵，词从词林正韵。不可用中华新韵(完全丢弃了入声的概念)，中原音韵。 2、体式(1)诗体 一般而言，我们当下所说的古诗指的是诗体当中的古体诗。古体诗不受平仄的束缚，但是受韵的束缚(这是在沈佺期和宋之问等人在以沈约、谢眺等为代表的永明体基础上，从原来的讲求四声发展到只辨平仄，从消极的“回忌声病”发展到悟出积极的平仄规律，又由原来只讲求一句一联的音节、协调发展到全篇平仄的粘对，以及中间二联必须上下句属对，从而形成完整的律诗。规范了格律之后脱离出来的体裁)。 那诗体中的近体诗(也叫今体诗)就是我们当下学习的诗体。它不但受平仄的束缚，而且受到押韵的束缚。其中由八句组成的称之为律诗，四句组成的称之为绝句。在律诗当中又有五律(每句五个字)和七律(每句七个字)之分，相应的绝句也有五绝和七绝之分。 (2)词体 3、诗律(以杜甫的登高为例) 上图中的竖线表示仄声，横线表示平声，三角形表示押韵。在一首诗当中有四联，分别为首联(第一、二句)、颔联(第三、四句)、颈联(第五、六句)和尾联(第七、八句)。一联的前一句称之为出句，后一句称之为对句。 (1)一三五不论，二四六分明。第一、三、五字不考虑平仄，第二、四、六字平仄分明。 (2)一句之内平仄相间，一联之间平仄相对(不符合即为：失对)，两联之间平仄相粘(上一联对句和下一联出句的平仄一致。不符合即为：失粘) (3)首句可入韵可不入韵 (4)不入韵的句末必为仄 *三平尾和三仄尾是大忌(此时的五须论，五律和七律皆如此) *平起还是仄起看的是首联出句的第二个字。 4、作业(1)在唐诗三百首当中找出一首诗：平起首句不入韵的七言律诗，抄写一遍标注平仄、押韵。 (2)预习拗救]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文参考文献标准格式要求]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1、参考文献的分类按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类: (1)引文文献是著者在撰写或编辑论著的过程中,为正文中的直接引语(如数据、公式、理论、观点、图表等)或间接引语而提供的有关文献信息资源。 (2)阅读型文献是著者在撰写或编辑论著的过程中,曾经阅读过的文献信息资源。 (3)推荐型文献通常是专家或教师为特定读者、特定目的而提供的、可供读者查阅的文献信息资源。 2、文献类型和标识代码参考文献目前共有16个文献类型和标识代码:普通图书M,会议录C,汇编G,报纸N,期刊J,学位论文D,报告R,标准S,专利P,数据库DB,计算机程序CP,电子公告EB,档案A,舆图CM,数据集DS,其他Z.凡无法归属于前15个类型的文献,均可以用Z来标志。 3、参考文献格式要求1、参考文献按正文部分标注的序号依次列出,并在序号中加[]。 2、对于常见的各类参考文献标注方法如下: (1)著作:作者姓名,题名[M].出版地:出版者,出版年. (2)期刊论文:作者姓名.题名[J].期刊名称,年,卷(期):页码. (3)会议论文集:作者姓名.题名[C]//论文集名称,会议地点,会议日期. (4)学位论文:作者姓名.题名[D].出版地:出版者,出版年. (5)专利文献:专利申请者或所有者姓名.专利题名:专利国别,专利号[P].公告日期或公开日期.获取路径. (6)电子文献:作者姓名.题名[文献类型标志(含文献载体标志)见其它].出版地:出版者,出版年(更新或修改日期),获取路径. (7)报告:作者姓名. 题名[R].出版地:出版者,出版年. (8)标准:标准号.题名[S].出版地:出版者,出版年. 3、同一著作中作者姓名不超过3名时,全部照录,超过3名时,只著录前3名作者,其后加“, 等”。 4、其他:数据库(DB),计算机程序(GP),光盘(CD),联机网络(OL)。 4、参考文献著录格式参考文献按在正文中出现的先后次序列表于文后;表上以“参考文献:” (左顶格) 或“[参考文献]”(居中)作为标识;参考文献的序号左顶格,并用数字加方括号表示,如[1], [2],…,以与正文中的指示序号格式一致. 参照ISO690及ISO 6 9 0-2,每一参考文献条目的最后均以结束. 各类参考文献条目的编排格式及示例如下: a.专著、论文集、学位论文、报告 [序号]主要责任者. 文献题名[文献类型标识].出版地:出版者,出版年. [1]刘国钧,陈绍业,王凤者. 图书馆目录[M].北京:高等教育出版社,1957. [2]辛希孟. 信息技术与信息服务国际研讨会论文集:A集[C].北京:中国社会科学出版社,1994. [3]张筑生. 微分半动力系统的不变集[D].北京:北京大学数学系数学研究所,1983. [4]冯西桥. 核反应堆压力管道与压力容器的LBB分析[R].北京:清华大学核能技术设计研究院,1997. [5]尼葛洛庞帝. 数字化生存[M].胡泳,范海燕,译. 海口:海南出版社,19%. b.期刊文章 [序号]主要责任者. 文献题名[J].刊名,年,卷 (期) :起止页码. [5]何龄修. 读顾城《南明史》[J].中国史研究,1998, (3) :167-173. [6]金显贺,王昌长,王忠东,等·一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版) , 1993, 33 (4) :62-67. c.论文集中的析出文献 [序号]析出文献主要责任者. 析出文献题名[A].原文献主要责任者 (任选}.原文献题名[C].出版地:出版者,出版年. 析出文献起止页码. [7]钟文发·非线性规划在可燃毒物配置中的应用[A].赵玮. 运筹学的理论与应用-中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996.468-471. d.报纸文章 [序号]主要责任者. 文献题名[N].报纸名,出版日期 (版次) . [8]谢希德. 创造学习的新思路[N].人民日报,1998-12-25 (10) . e.国际、国家标准 [序号]标准编号,标准名称[S]. [9]GB/T 16159-1996, 汉语拼音正词法基本规则[S]. f.专利 [序号]专利所有者,专利题名[P].专利国别:专利号,出版日期. [10]姜锡洲. 一种温热外敷药制备方案[P].中国专利:881056073, 1989-07-26. g.电子文献 [序号]主要责任者. 电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址,发表或更新日期/引用曰期 (任选) . [11]学术堂. 论文参考文献标准格式要求[EB/OL].http://www.lunwenstudy.com/cankaowenxian/130239.html.2018-03-14. [12]万锦堃. 中国大学学报论文文摘 (1983-1993) .英文版[D B/C D].北京:中国大百科全书出版社,19%. h.各种未定义类型的文献 [序号]主要责任者. 文献题名[Z].出版地:出版者,出版年. 5、文内参考文献标注格式文内所列参考文献应限于作者直接阅读过的、最主要的、且为发表在正式出版物上的文章.私人通信和未发表 (含待发表) 的著作及论文,一般不宜作为参考文献. 参考文献还应注重权威性和时效性.文内标注参考文献时应按文献出现的先后顺序用阿拉伯数字连续编码,并将序号置于方括号中.可根据具体情况分别按下述3种格式之一标注. (1) 文中已标明原始文献作者姓名时,序号标注于作者姓名右上角. 例如：Vairaktaris等[7]研究表明,MMP-9-1562C/T基因多态性与口腔癌关系密切. (2) 正文未标明作者或非原始文献作者时,序号标注于引用内容的句末. 例如：……在中枢神经系统中具有保护神经的作用,减少缺氧、缺血对动物脑神经元的损害[1]. (3) 正文直接述及文献序号时则将之作为语句的组成部分时不用角码标注. 例如：肱动脉超声检查的方法见文献[2]. 文中多次引用同一参考文献,只在第一次出现时编排序号 (在参考文献表中也只出现一次) , 其他处使用同一序号；如果多次引用的是同一参考文献的不同页的内容,则应参考文献表中按引用顺序一一列出页码.若某一问题使用了多篇文献说明,这时将各文献的序号在一个方括号内全部列出,中间加逗号,若遇连续序号,则在起止序号中间加“-”表示.如：……组织型RAS激活也成为心肌肥厚、心肌纤维化、心腔扩大、心力衰竭的主要因素[1,3,9-10].]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>参考文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的成员变量、全局变量和局部变量]]></title>
    <url>%2F2018%2F03%2F22%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。 注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。 存储:堆(当前对象对应的堆的存储空间中)存储在堆中的数据,不会被自动释放,只能程序员手动释放。 2、全局变量:写在函数和大括号外部的变量,称之为全局变量。 作用域:从定义的那一行开始,一直到文件末尾。全局变量可以先定义再初始化,也可以定义的同时初始化。 存储:静态区。程序一启动就会分配存储空间,直到程序结束才会释放。 3、局部变量:写在函数或者代码块中的变量,称之为局部变量。 作用域:从定义的那一行开始,一直到遇到大括号或者return。局部变量可以先定义再初始化,也可以定义的同时初始化。 存储:栈。存储在栈中的数据有一个特点,系统会自动给我们释放。 *全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。 *非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。另外，静态全局变量只初使化一次，防止在其他文件单元中被引用。 *局部变量和静态局部变量的区别在于它们的存储方式不同，前者存储在栈当中，而后者存储在静态区当中。 *静态函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。类中的非静态函数默认是有this指针的，表明为该类的对象所有，静态函数不属于任何类的对象，没有this指针，由类直接调用。也就是说全局函数，静态函数都不能使用this。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(一)]]></title>
    <url>%2F2018%2F03%2F22%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关。但从记录中回溯，可看到自我构建和行进的一个过程。 2、感情的结果最终是一种理性。是人的天性不具备足够的留恋，还是前进的生活强迫抛却蜕除下来的旧壳？我们远比自己想象的更为无情和客观。 3、他说，要善待自己，放下和消融内在积存的创伤。它们使你沉重而不够轻盈，要不断去清洗。我说，我在你面前仿佛一览无余。他说，人是有很多面的，哪有一览无余。你对我来说，始终是一个没有答案的谜语。但你的谜题措辞优美。 4、应尽量保持真实和自在地去生活。不违背不辜负，无需他人旁观，更无需他人同情。只需始终忠于自我。 5、不知道杭州苏堤白堤的花开了没有，柳树绿了没有。想孤身前往去看一场花事。如果午后微雨突袭，你恰好渡船而过，不妨让我们在春柳拂面的桥头相见。 6、自我摧毁是有快感的，所有下堕的行为都伴随着快感。摔破一个罐子与长时间塑造和建设一个罐子，前者让你享受到更为强大的自我妄想，觉得自己具有力量。但事实并非如此，行动应该携带和突破重力而上升。 7、男女不管关系性质如何，有些原则不能随意更改，底线不能突破。一旦突破，破镜难圆。感情忌讳懈怠及理所当然，至少要始终保持尊重、克制、发力、欣赏及感恩之心。 8、一个印第安巫师说，如果让儿童目睹一次葬礼，抚摸死人的尸体，会驯服孩子内心的浅薄和顽劣不羁。他获得了真正的灵魂的成长。死亡是最需要被学习和认识的内容。 9、泛滥的感情方式，不严格区分对象，只以获取难易作为是否前进的指标。对待不同的人，所给予的内容完全重复，是一次批量化生产之后的零售生意。润滑一些的方式，无非是让不同客户拿到这只被复制的点心盒子，产生为自己特制的幻觉。始乱终弃，以满足欲望为前提，不管这欲望是虚荣、寂寞、爱欲、证明还是其他。这何尝不是一种乏味而肤浅的恋爱方式。无法视对方为独特个体，因此也无法获取来自对方的源泉和力量(也许这是不需要的东西，他们要的只是乐趣)。把对方视为猎物，忽略人的内在生命，以占有和征服为目的。低级的方式决定这关系没有创造力，不具有可追索的深度。是对生命能量的贬低和消费。 10、奥修说，死去的人，将在他生前所爱的人身上收回他的能量，这些能量会被他带走。因此，那个被爱着的人，会感觉到自己的身心被挖掉一块。这一块区域将始终是空的，是匮乏的。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自省]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%87%AA%E7%9C%81%2F</url>
    <content type="text"><![CDATA[连续几日在图书馆的自习，对面的人换了又换，然而他(她)们都有一个令人心生厌恶之处：吃零食或者喝牛奶不断产生的声响和气味。对旁人的感受持漠然的态度。对此，虽完全可以凭借自身的力量尽量避免，但从中自身须得到反省：在生活中，是否具有其他不当的行为让他人感到不适(包括除图书馆以外的场所)。答案是有。有些是一时半会无法去除的缺点，有些是当下即可做到的修改。这些都需要内心的自持和坚韧才能实现，结果要交给时间去检验。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水流众生]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%B0%B4%E6%B5%81%E4%BC%97%E7%94%9F%2F</url>
    <content type="text"><![CDATA[李健的《水流众生》是诞生在他西藏的旅途中的，他的歌，总是充满了灵性与自然。在平淡当中述说，却又蕴含深切的主题。这首歌是写给他自己的，也是写给众生的，同时还是写给这个社会的。当今社会物质的极大丰富满足不了人们的欲望，对物质无止境的追求、对自然的过分索取导致人们都迷失了自我，深陷其中，无法自拔却并不自知。李健为了寻求他的解脱之法，于是踏上旅途，当然他的旅途不是我们当下传统意义上的旅行，不是组团或者邀约三五好友匆匆赶赴著名的旅游景点拍照留恋而后又匆匆而归的旅行。他的旅途是内心和自然的相互倾听和感受。当然，最终他还是从自然里、在旅途中找到了自我，看见了辽阔的。每一个人都需要反省，自我观照，在水自成旋涡之前及时转身。(另外李健的《水流众生》和庆山的《莲花》很般配)]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1051 Pop Sequence]]></title>
    <url>%2F2018%2F03%2F21%2FPAT-A1051-Pop-Sequence%2F</url>
    <content type="text"><![CDATA[Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. Output Specification: For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO 题目大意：给出size为M大小的栈，分别把1…N入栈，给出K组出栈顺序，问入栈出栈顺序是否顺利。 分析：先把需要判断的序列放进一维数组当中，给出数组的当前下标为0，然后1…N顺序入栈，如果元素入栈之后，栈的size大于M，则此序列不符合；如果栈的size小于等于M，在while循环中如果栈非空且其值等于此时的数组元素，则栈顶元素出栈，数组的下标自增一位。以上所有步骤进行K次。 注意：能用一维数组时尽量别用二维数组 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;stdlib.h&gt; using namespace std; int main() { int M, N, K; cin &gt;&gt; M &gt;&gt; N &gt;&gt; K; vector&lt;int&gt; a(N);//定义可变长的一维数组 stack&lt;int&gt; st;//引入STL中的栈 for (int i = 0;i &lt; K;i++) {//一共有K组数据 while (!st.empty()) st.pop();//清空栈 for (int j = 0;j &lt; N;j++) {//读入一组数据 cin &gt;&gt; a[j]; } int n=0; for (int x = 1;x &lt;= N;x++) { st.push(x); if (st.size() &gt; M) {//序列有误 break; }else{ while (!st.empty() &amp;&amp; st.top() == a[n]) {//如果栈非空且栈顶元素等于当前的序列当前位置值就把顶部元素出栈，验证序列后移一位 st.pop(); n++; } } } if (!st.empty()) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2018%2F03%2F21%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Mysql是最流行的关系型数据库管理系统(关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。)，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。 1、MYSQL的特点(1)Mysql是开源的，所以你不需要支付额外的费用。 (2)Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 (3)MySQL使用标准的SQL数据语言形式。 (4)Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。 (5)Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。 2、MYSQL的管理(1)为MYSQL数据库中的user表添加新用户root@host# mysql -u root -p Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES (&apos;localhost&apos;, &apos;guest&apos;, PASSWORD(&apos;guest123&apos;), &apos;Y&apos;, &apos;Y&apos;, &apos;Y&apos;); Query OK, 1 row affected (0.20 sec) mysql&gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0.01 sec) mysql&gt; SELECT host, user, password FROM user WHERE user = &apos;guest&apos;; +-----------+---------+------------------+ | host | user | password | +-----------+---------+------------------+ | localhost | guest | 6f8c114b58f2ce9e | +-----------+---------+------------------+ 1 row in set (0.00 sec) 注意需要执行FLUSH PRIVILEGES语句。 这个命令执行后会重新载入授权表。如果你不使用该命令，你就无法使用新创建的用户来连接MYSQL服务器，除非你重启MYSQL服务器。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的GRANT命令，以下命令会给指定数据库TUTORIALS添加用户zara，密码为zara123 。 root@host# mysql -u root -p password; Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO &apos;zara&apos;@&apos;localhost&apos; -&gt; IDENTIFIED BY &apos;zara123&apos;; *MySQL的SQL语句以分号 (;) 作为结束标识。 (2)管理MySQL的命令a、USE 数据库名;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。mysql&gt; use RUNOOB; Database changed b、SHOW DATABASES;列出MySQL数据库管理系统当前的数据库列表。mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | RUNOOB | | cdcol | | mysql | | onethink | | performance_schema | | phpmyadmin | | test | | wecenter | | wordpress | +--------------------+ 10 rows in set (0.02 sec) c、SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。mysql&gt; use RUNOOB; Database changed mysql&gt; SHOW TABLES; +------------------+ | Tables_in_runoob | +------------------+ | employee_tbl | | runoob_tbl | | tcount_tbl | +------------------+ 3 rows in set (0.00 sec) d、SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。mysql&gt; SHOW COLUMNS FROM runoob_tbl; +-----------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+--------------+------+-----+---------+-------+ | runoob_id | int(11) | NO | PRI | NULL | | | runoob_title | varchar(255) | YES | | NULL | | | runoob_author | varchar(255) | YES | | NULL | | | submission_date | date | YES | | NULL | | +-----------------+--------------+------+-----+---------+-------+ 4 rows in set (0.01 sec) e、SHOW INDEX FROM 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。mysql&gt; SHOW INDEX FROM runoob_tbl; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | runoob_tbl | 0 | PRIMARY | 1 | runoob_id | A | 2 | NULL | NULL | | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) f、SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G;该命令将输出Mysql数据库管理系统的性能及统计信息。mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;; # 表名以runoob开头的表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;\G; # 加上 \G，查询结果按列打印 3、数据库的基本操作语句(1)创建数据表CREATE TABLE table_name (column_name column_type); root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.16 sec) mysql&gt; *如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 *AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 *PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 *ENGINE 设置存储引擎，CHARSET 设置编码。 (2)删除数据表DROP TABLE table_name ; root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; DROP TABLE runoob_tbl Query OK, 0 rows affected (0.8 sec) mysql&gt; 查看一下： mysql&gt; show tables; Empty set (0.01 sec) (3)插入数据INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1,value2,...valueN ); root@host# mysql -u root -p password; Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;); Query OK, 1 rows affected (0.00 sec) mysql&gt; *如果数据是字符型，必须使用单引号或者双引号，如：&quot;value&quot;。 *使用箭头标记-&gt;不是SQL语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写SQL语句，SQL语句的命令结束符为分号 ;。 (4)查询数据SELECT column_name,column_name FROM table_name [WHERE Clause][LIMIT N][ OFFSET M]; select * from runoob_tbl; SELECT * from runoob_tbl WHERE runoob_author=&apos;菜鸟教程&apos;; *查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 *SELECT 命令可以读取一条或者多条记录。你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 *你可以使用 WHERE 语句来包含任何条件。例如使用 AND 或者 OR 指定一个或多个条件。WHERE子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。WHERE子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 *你可以使用 LIMIT 属性来设定返回的记录数。 *你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 (5)更新数据表UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]; mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3; Query OK, 1 rows affected (0.01 sec) mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3; +-----------+--------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+--------------+---------------+-----------------+ | 3 | 学习 C++ | RUNOOB.COM | 2016-05-06 | +-----------+--------------+---------------+-----------------+ 1 rows in set (0.01 sec) *你可以同时更新一个或多个字段。 *你可以在 WHERE 子句中指定任何条件。 *你可以在一个单独表中同时更新数据。 (6)删除MySQL数据表中的记录DELETE FROM table_name [WHERE Clause]; mysql&gt; use RUNOOB; Database changed mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3; Query OK, 1 row affected (0.23 sec) *如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 *你可以在 WHERE 子句中指定任何条件 *您可以在单个表中一次性删除记录。 (7)删除，添加或修改表字段删除：ALTER TABLE alter_tbl DROP columnname;删除指定字段 添加：ALTER TABLE alter_tbl ADD new_column_name new_typename AFTER columnname;指定添加位置 修改： ALTER TABLE alter_tbl MODIFY columnname new_typename;修改字段类型 ALTER TABLE alter_tbl CHANGE oldcolumnname newcolumnname newtypename;修改字段及类型 ALTER TABLE alter_tbl RENAME TO alter_tb2;修改表名 (8)UNION操作符SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; 使用 UNION ALL 从 &quot;Websites&quot; 和 &quot;apps&quot; 表中选取所有的中国(CN)的数据（也有重复的值）： SELECT country, name FROM Websites WHERE country=&apos;CN&apos; UNION ALL SELECT country, app_name FROM apps WHERE country=&apos;CN&apos; ORDER BY country; *expression1, expression2, ... expression_n: 要检索的列。 *tables: 要检索的数据表。 *WHERE conditions: 可选，检索条件。 *DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 *UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值。 (9)排序SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]]; SELECT * from runoob_tbl ORDER BY submission_date ASC; SELECT * from runoob_tbl ORDER BY submission_date DESC; *你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 *你可以设定多个字段来排序。 *你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列。 *你可以添加 WHERE...LIKE 子句来设置条件。 (10)GROUP BY语法SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;将数据表按名字进行分组，并统计每个人有多少条记录 (11)LIKE子句SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; 在 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录： mysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE &apos;%COM&apos;; +-----------+---------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+---------------+---------------+-----------------+ | 3 | 学习 Java | RUNOOB.COM | 2015-05-01 | | 4 | 学习 Python | RUNOOB.COM | 2016-03-06 | +-----------+---------------+---------------+-----------------+ 2 rows in set (0.01 sec) *你可以在 WHERE 子句中指定任何条件。 *你可以在 WHERE 子句中使用LIKE子句。 *你可以使用LIKE子句代替等号 =。 *LIKE子句中使用百分号 % 字符来表示任意字符，类似于UNIX或正则表达式中的星号 * 。 *你可以使用 AND 或者 OR 指定一个或多个条件。 *你可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件。 (12)连接的使用INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 a、内连接示例 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; 等价于 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author; b、左连接示例 读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; c、右连接示例 读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; (13)NULL值处理IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 *关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。 *在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。 (14)索引CREATE INDEX indexName ON mytable(username(length)); 创建索引 ALTER table tableName ADD INDEX indexName(columnName); 修改表结构(添加索引) 创建表的时候直接指定索引 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); DROP INDEX [indexName] ON mytable; 删除索引 CREATE UNIQUE INDEX indexName ON mytable(username(length)); 创建唯一索引 ALTER table mytable ADD UNIQUE [indexName] (username(length)); 修改表结构 创建表的时候直接指定唯一索引 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1052 Linked List Sorting]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1052-Linked-List-Sorting%2F</url>
    <content type="text"><![CDATA[A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification: Each input file contains one test case. For each case, the first line contains a positive N (&lt; 105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Key next where Address is the address of the node in memory, Key is an integer in [-105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification: For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input: 5 00001 11111 100 -1 00001 0 22222 33333 100000 11111 12345 -1 33333 22222 1000 12345 Sample Output: 5 12345 12345 -1 00001 00001 0 11111 11111 100 22222 22222 1000 33333 33333 100000 -1 题目大意：给出一个静态链表，将链表按照数据域data的值从小到大进行排序，然后把排序后的静态链表上的结点从头结点顺序输出。 分析：建立存储静态节点的结构体数组，从首节点开始的顺序(直到-1)遍历整个静态链表，将在静态链表中节点的flag标记为true，并且统计count(有效结点的个数)大小，这里是因为有的你输入的节点根本不在静态链表上。之后将静态链表进行排序，这里需要进行二次排序：如果两个节点中有一个节点的标志位为false就把它移动到后面(reuturn a.flag&gt;b.flag)，否则就按照节点数据域从小到大进行排序(return a.data&lt;b.data)。最后只输出前count个静态链表节点。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;stdlib.h&gt; using namespace std; const int maxn = 100010; struct Node { int address; int data; int next; bool flag; }node[maxn]; bool cmp(Node a, Node b) { if (a.flag == false || b.flag == false) { return a.flag &gt; b.flag;//将无效节点放到后面 } else { return a.data &lt; b.data;//按照数据域的顺序从大到小排列 } } int main() { int n, x; cin &gt;&gt; n &gt;&gt; x; int address, data, next; for (int i = 0;i&lt;n;i++) {//初始化静态链表 cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].address = address; node[address].data = data; node[address].next = next; } for (int i = 0;i &lt; maxn;i++) { node[i].flag = false;//初始化标志位 } int count = 0; while (x != -1) {//遍历静态链表，对有效的节点进行标记，同时统计有效节点的个数(因为存在一些你输入的节点但是不在链表上情况) node[x].flag = true; count++; x = node[x].next; } if (count == 0) {//如果头结点为-1，即链表中没有节点 cout &lt;&lt; &quot;0 -1&quot; &lt;&lt; endl; } else { sort(node, node + maxn, cmp);//筛选有效节点，按data从小到大排列 printf(&quot;%d %05d\n&quot;, count, node[0].address); for (int i = 0;i &lt; count;i++) { if (i==count-1) printf(&quot;%05d %d -1\n&quot;, node[i].address, node[i].data); else printf(&quot;%05d %d %05d\n&quot;, node[i].address, node[i].data, node[i+1].address); } } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1032 Sharing]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1032-Sharing%2F</url>
    <content type="text"><![CDATA[To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, “loading” and “being” are stored as showed in Figure 1.You are supposed to find the starting position of the common suffix (e.g. the position of “i” in Figure 1). Input Specification: Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (&lt;= 105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node. Output Specification: For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output “-1” instead. Sample Input 1: 11111 22222 9 67890 i 00002 00010 a 12345 00003 g -1 12345 D 67890 00002 n 00003 22222 B 23456 11111 L 00001 23456 e 67890 00001 o 00010 Sample Output 1: 67890 Sample Input 2: 00001 00002 4 00001 a 10001 10001 s -1 00002 a 10002 10002 t -1 Sample Output 2: -1 题目大意：求两个存储英语单词的字母链表的首个公共结点的地址。如果没有，就输出-1 分析：本题是在链表当中寻找起始公共节点的位置且地址的范围比较小，此处选择使用静态链表来处理。用结构体数组进行存储，node[i]表示地址为i的结点，data表示值，next为下一个结点的地址，flag表示第一条链表有没有该结点。遍历第一条链表，将访问过的结点的flag都标记为true，当遍历第二条结点的时候，如果遇到了true的结点就输出并结束程序，没有遇到就输出-1。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct Node { char data; int next; bool flag;//用于判断公共节点的初始位置 }node[100010]; void Create(int n) {//创建一个静态链表 int address, next; char data; for (int i = 0;i &lt; 100010;i++) {//初始化链表节点的标志为false node[i].flag = false; } for (int i = 0;i &lt; n;i++) { cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].data = data; node[address].next = next; } } int main() { int x, y, n,i; cin &gt;&gt; x &gt;&gt; y &gt;&gt; n; Create(n);//创建一个静态链表 for (i = x;i != -1;i = node[i].next) {//将第一个单词走过的节点的标志位设为true node[i].flag = true; } for (i = y;i != -1;i = node[i].next) { if (node[i].flag == true) { printf(&quot;%5d&quot;, i);//如果此时的节点的标志位为true说明是公共节点 system(&quot;pause&quot;); return 0; } } printf(&quot;-1&quot;);//否则输出-1 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表属于线性表中的一种数据结构，它由若干个节点组成(每个节点代表一个元素)，且节点在内存中的存储位置通常是不连续的。这里我们先来了解动态链表，动态链表的两个节点之间一般通过一个指针来从一个节点指向另一个节点 ，因此动态链表的节点一般由两部分构成，即数据域和指针域： struct node{ int data; node* next; }; (1)创建一个动态链表： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct node { int data; node* next; }; node* create(int Array[]) { node *p, *pre, *head;//pre保存当前节点的前驱节点，head为头结点 head = new node;//创建头结点 head-&gt;next = NULL;//头结点不需要数据，且指针域指向NULL pre = head;//记录pre为head for (int i = 0;i &lt; 5;i++) { p = new node;//新建节点 p-&gt;data = Array[i];//将Array[i]赋给新建的节点作为数据域，也可以cin输入 p-&gt;next = NULL;//新节点的指针域设为NULL pre-&gt;next = p;//前驱节点的指针域设为当前新建节点的地址 pre = p;//把p设为pre，作为下一个节点的前驱节点 } return head;//返回头结点指针 } int main() { int Array[5] = { 5,3,6,1,2 }; node* L = create(Array);//新建链表，返回头指针head给L L = L-&gt;next;//从第一个节点开始有数据域 while (L != NULL) { cout &lt;&lt; L-&gt;data &lt;&lt; endl;//输出每个节点的数据域 L = L-&gt;next; } system(&quot;pause&quot;); return 0; } (2)动态链表查找元素： int search(node* head, int x) { int count = 0;//计数器 node* p = head-&gt;next;//指向链表的第一个节点 while (p != NULL) {//遍历整个链表 if (p-&gt;data == x) count++;//当节点数据域为x时，则count++ p = p-&gt;next;//指向下一个节点 } return count; } (3)动态链表插入元素： void insert(node* head, int pos, int x) { node* p = head;//指向链表的头节点 for (int i = 0;i &lt; pos - 1;i++) {//遍历到链表的pos-1的位置，即插入位置的前一个节点位置 p = p-&gt;next; } node* q = new node;//新建节点 q-&gt;data = x;//其数据域为x q-&gt;next = p-&gt;next;//新节点的下一个节点指向原先插入位置的节点 p-&gt;next = q;//前一个位置的节点指向新节点 } (4)动态链表删除元素： void del(node* head, int x) { node* p = head;//指向链表的头结点 node* q = p-&gt;next;//指向链表的第一个节点 while (q != NULL) { if (q-&gt;data == x) {//数据域为x，删除q节点 p-&gt;next = q-&gt;next;//删除q节点 delete(q);//释放内存空间 q = p-&gt;next; }else {//数据域不为x，p、q节点同时后移一位 p = q; q = q-&gt;next; } } } 以上所述都是动态链表的范畴，需要指针来建立节点之间的连接关系。而对于有些问题来说，节点的地址是比较小的整数(例如5位数的地址)，这样就没有必要去建立动态链表，而应该使用方便得多的静态链表。静态链表的实现原理是hash，即通过建立一个结构体数组，并令数组的下标直接表示节点的地址，以此来达到直接访问数组中的元素就能访问节点的效果。需要注意的是：在使用静态链表时，尽量不要把结构体类型名和结构体变量名取成相同的名字。其定义方法如下： struct Node{ typename date;//数据域 int next;//指针域 XXX;//节点的某个性质，不同的题目会有不同的设置 }node[maxn]; 其中的next是一个int型的整数，用来存放下一个节点的地址(事实上就是数组下标)，例如：如果初始节点的地址为11111，第二个节点的地址为22222，第三个节点的地址为33333，且第三个节点为链表末尾，那么整个静态链表的节点就可以通过下面的写法连接起来： node[11111].next=22222; node[22222].next=33333; node[33333].next=-1;//-1对应动态链表中的NULL，表示没有后继节点 一般来说，静态链表的初始化需要对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字(而常常需要小于所能达到的数字)，例： for(int i=0;i&lt;maxn;i++){ node[i].XXX=0; } 一般的题目都会给出一条静态链表的首节点的地址，因此我们可以依据这个地址来遍历得到整条链表。这一步同时也是对节点性质XXX进行标记，并且对有效节点的个数进行计数的时候，例如对节点是否在链表上这个性质来说，当我们遍历链表时，就可以把XXX置为1。 int p=begin,count=0; while(p!=-1){//-1代表静态链表结束 XXX=1; count++; p=node[p].next; } 由于使用静态链表时时直接采用地址映射的方式，这就会使得数组小标的不连续。而很多时候题目给出的节点并不都是有效节点(即不在静态链表上的节点)。为了能够可控地访问有效节点，一般都需要对数组进行排序来把有效节点移动到数组的左端。这里我们用到上面所提及的XXX，这也就是为什么在XXX进行初始化时要取比正常取值要小的值。因为无效节点并不会执行XXX=1这一步，因此一定比有效节点的XXX小。于是在写sort函数的排序函数cmp时就可以在cmp的两个参数节点中有无效节点时按XXX从大到小排序，这样就能把有效节点全部移动到数组左端。当然，在cmp函数中还可以有第二级的排序，例如：题目可能要求把链表按节点顺序排序，此时就需要在cmp函数中建立第二级的排序： bool cmp(Node a,Node b){ if(a.XXX==-1||b.XXX==-1){//如果有节点是无效节点，就把它放到数组的后端 return a.XXX&gt;b.XXX; }else{//否则就按节点的数据域从大到小排序 return a.data&gt;b.data; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++申请动态内存]]></title>
    <url>%2F2018%2F03%2F19%2FC-C%2B%2B%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[(1)malloc函数 malloc函数是C语言中#include&lt;stdlib.h&gt;头文件下用于申请动态内存的函数，其返回类型是申请的同变量类型的指针，其基本用法如下： typename* p=(typename*)malloc(sizeof(typename)); int* p=(int*)malloc(sizeof(int)); node* p=(node*)malloc(sizeof(node)); 这个写法的解释如下：以需要申请的内存空间大小(即sizeof(node))为malloc函数的参数，这样malloc函数就会向内存申请一块大小为sizeof(node)的空间，并且返回指向这块空间的指针。但是此时这个指针是一个为确定类型的指针void*，因此需要把它强制转换成node型的指针，在malloc之前加上(node)。再把这个指针赋给node*型的指针变量p，就成功地申请了一块node类型大小的内存空间。如果申请失败，则会返回空指针NULL。申请失败一般在使用malloc申请了较大动态数组时发生。 在使用完malloc开辟出来的空间后必须将其释放，否则会造成内存的泄露。malloc函数需要使用free函数来进行内存的释放。假设需要释放的内存空间的指针变量为p，则：free(p);就可以实现内存的释放了。 (2)new运算符 new是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变量类型的指针，其基本用法如下： typename* p=new typename; int* p=new int; node* p=new node; 相比于malloc函数来说，new的写法要简洁得多。另外，如果new运算符申请动态空间失败，则会启动异常机制处理而不是像malloc那样返回NULL。和malloc一样的是：申请失败一般是在申请了较大动态数组时发生。与此同时，new运算符也有对应的释放内存函数：delete(p);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeup 1918 简单计算器]]></title>
    <url>%2F2018%2F03%2F19%2FCodeup-1918-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述： 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入： 测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出： 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 样例输入： 30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 * 6 + 51 / 29 + 79 * 87 + 57 * 92 0 样例输出： 12178.21 分析：本题需要分两个步骤进行解答：一是中缀表达式转化为后缀表达式；二是计算后缀表达式。 步骤一： (1)分别设立一个操作符栈和一个队列，操作符栈用来暂时存放操作符，而队列则用来存放后缀表达式。 (2)从左到右扫描中缀表达式。 (3)如果碰到操作数(这里的操作数可能占几位，所以需要一位一位读取再合并)，就把操作数处理之后加入后缀表达式中。如果碰到的是操 作符，就将其优先级与操作符栈的栈顶元素比较：如果优先级高于栈顶操作符则直接入栈；如果优先级小于或等于栈顶操作符，则将操作符 栈的操作符不断弹出到后缀表达式，直到其优先级高于栈顶操作符为止。 (4)重复执行(2)(3)步骤，直到中缀表达式扫描完为止，之后若操作符栈中还有元素，则将他们依次弹出至后缀表达式当中。 步骤二： 从左到右扫描后缀表达式，如果是操作数，则压入栈中；如果是操作符，就连续弹出两个操作数(这里先弹出的是第二操作数，后弹出的是 第一操作数)，然后进行操作符的运算，生成的新操作符压入栈中。反复执行，直到后缀表达式扫描完毕。此时栈中只剩下一个数，就是计算 结果。 注意： (1)操作数的类型需要设置为double型。 (2)为了便于在后缀表达式中判断出队的是操作符还是操作数，这里使用了具有操作数、操作符和判别两者类型的bool类型的结构体， 当然，在这种情况之下就需要引进STL中的queue和stack容器来存储相应的结构体类型的数据。 (3)另外还需要引进STL中的map容器，从而来定义操作符所对应的优先级。 具体的程序如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; struct node { double num;//操作数 char op;//操作符 bool flag;//true表示操作数，false表示操作符 }; string s; queue&lt;node&gt; q;//定义node类型的队列用于存储后缀表达式 stack&lt;node&gt; st;//定义node类型的栈用于在转化为后缀表达式时暂存操作符和在计算后缀表达式时存储操作数 map&lt;char, int&gt; op;//map用于匹配操作符和优先级数字 void Change() {//将中缀表达式转化为后缀表达式 node temp; for (string::iterator it = s.begin();it != s.end();it++) {//删除字符串当中的空格 if (*it == &apos; &apos;) s.erase(it); } for (int i = 0;i &lt; s.length();) { if (s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) {//如果是数字的话 temp.flag = true;//标记为数字 temp.num = s[i++] - &apos;0&apos;; while (i&lt;s.length()&amp;&amp;s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) { temp.num = temp.num * 10 + (s[i++] - &apos;0&apos;); } q.push(temp);//将操作数压入后缀表达式队列 }else {//如果是操作符 temp.flag = false; while (!st.empty() &amp;&amp; op[s[i]] &lt;= op[st.top().op]) {//如果栈不空且当前操作符的优先级小于等于栈顶的优先级 q.push(st.top());//将栈顶元素放入后缀表达式队列 st.pop();//栈顶元素出栈 } temp.op = s[i++]; st.push(temp);//将此操作符入栈 } } while (!st.empty()) {//如果栈中还有操作符就把它们都放入后缀表达式队列 q.push(st.top()); st.pop(); } } double Calculate() {//计算后缀表达式 double temp1=0, temp2=0; node temp; while (!st.empty()) st.pop();//将栈清空 while (!q.empty()) { if (q.front().flag == true) st.push(q.front());//如果是操作数就直接入栈 else {//如果是操作符 temp2 = st.top().num;//取第二个操作数 st.pop();//栈顶元素出栈 temp1 = st.top().num;//取第一个操作数 st.pop(); if (q.front().op == &apos;+&apos;) temp.num = temp1 + temp2; else if (q.front().op == &apos;-&apos;) temp.num = temp1 - temp2; else if (q.front().op == &apos;*&apos;) temp.num = temp1*temp2; else temp.num = temp1 / temp2; temp.flag = true; st.push(temp);//将本次的计算结果压入栈中 } q.pop();//将该操作符或者操作数出队列 } return st.top().num;//返回后缀表达式的计算结果 } int main() { op[&apos;+&apos;] = op[&apos;-&apos;] = 1;//map设定操作符的优先级 op[&apos;*&apos;] = op[&apos;/&apos;] = 2; while (getline(cin, s), s != &quot;0&quot;) { while (!st.empty()) st.pop();//初始化栈 Change();//将中缀表达式转化为后缀表达式 printf(&quot;%.2f\n&quot;,Calculate());//计算后缀表达式 } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Codeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1060 Are They Equal]]></title>
    <url>%2F2018%2F03%2F19%2FPAT-A1060-Are-They-Equal%2F</url>
    <content type="text"><![CDATA[If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification: Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100. Output Specification: For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1: 3 12300 12358.9 Sample Output 1: YES 0.123*10^5 Sample Input 2: 3 120 128 Sample Output 2: NO 0.120*10^3 0.128*10^3 题目大意：给出两个数，问将它们写成保留N位小数的科学计数法后是否相等。如果相等，输出YES，同时输出他们的科学记数法表示的方式；如果不相等输出NO，分别输出他们的科学计数法表示方式。 注意：无需四舍五入。 分析：将两个数以字符串的形式输入，如果他们有前导0则删除前导0。删除前导0之后会碰到两种情况：如果是小数点，说明这个数小于1，接下来将小数点删除，如果删除小数点之后的那个数值是0需要把0删除同时令指数相应地减1，直到不为0为止；如果不是小数点的话，则在while循环当中去寻找后面可能存在的小数点，在没有找到小数点之前，字符串下标每向后移动一位，指数便加1。跳出while循环之后，如果字符串下标小于字符串此时的长度，说明找到了小数点，删除小数点。在这两种情况都处理完之后，如果字符串的长度为0，则说明这个数为0。接下来令数组下标为0，在while循环中只要题目要求的精度没有达到就不断执行。而只要字符串此时的下标还小于字符串的长度就直接把数字加到新字符串的末尾，否则就添0。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; using namespace std; int n;//有效位数 string deal(string s, int &amp;e) { int k = 0;//s的下标 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除前导0 } if (s[0] == &apos;.&apos;) {//删除前导0之后是小数点，说明s是小于1的小数 s.erase(s.begin());//删除小数点 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除小数点后非0位前的所有0 e--;//每删除一个0，指数就减1 } }else {//删除前导0之后不是小数点，则找到后面的小数点删除 while (k &lt; s.length() &amp;&amp; s[k] != &apos;.&apos;) { k++; e++;//只要没碰到小数点指数就加1 } if (k &lt; s.length()) s.erase(s.begin() + k);//如果此时k&lt;s.length()则说明碰到了小数点，删除小数点 } if (s.length() == 0) e = 0;//删除前导0之后s的长度变为0，说明这个数是0 int num = 0; k = 0; string res; while (num &lt; n) { if (k &lt; s.length()) res += s[k++];//只要还有数字，就加到res的末尾 else res += &apos;0&apos;;//否则就在res的末尾加0 num++;//精度加1 } return res; } int main() { string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if (s3 == s4&amp;&amp;e1 == e2) cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; endl; else cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot;&lt;&lt; e2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的sort函数]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84sort%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[sort()函数使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)。要使用algorithm头文件下的sort()函数,需要加上#include头文件和”using namespace std;” 1、在介绍sort()函数之前,先来了解algorithm头文件下一些其他的函数 (1)max(x,y)和min(x,y)分别返回x和y中的最大值和最小值(x和y可以是浮点数)。 (2)abs(x)返回x的绝对值,这里的x必须是整数,浮点数需要使用math头文件下的fabs。 (3)swap()用来交换x和y的值,注意:这里的swap()函数和Java中的swap()函数有着本质的不同。 (4)reverse(x,y)将数组指针在[x,y)之间的元素或容器的迭代器在[x,y)范围内的元素进行反转。 (5)next_permutation(x,y)给出一个序列在全排列的下一个序列。 (6)fill(x,y,a)可以把数组或容器中的array[x]~array[y-1]区间赋值为a。和memset不同,这里的赋值可以是数组类型对应范围中的任意值。 (7)lower_bound(first,last,val)和upper_bound(first,last,val)分别用来寻找在数组或容器[first,last)范围内第一个值大于等于val和第一个值大于val的元素的位置,如果是数组,则返回该位置的指针;如果是容器,则返回该位置的迭代器。如果数组或者容器中没有需要寻找的元素,则两个函数均返回可以插入该元素的位置的指针或者迭代器,它们的时间复杂度均为O(log(last-first))。 2、sort()函数 (1)使用方式:sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数(非必填)); 如果不填比较函数,则默认对前面给出的区间[first,last)进行递增排序。 (2)比较函数cmp a、基本数据类型数组的排序 bool cmp(int a,int b){//int型数据递减排序 return a&gt;b;//当a&gt;b是把a放在b前面 } bool cmp(double a,double b){//double型数据递减排序 return a&gt;b; } bool cmp(char a,char b){//char型数据递减排序 return a&gt;b; } 其实这里也可不必如此:sort(a,a+10,greater&lt;typename&gt;());也可以实现以上三个比较函数的功能。 b、结构体数组的排序 struct node{ int x,y; }st[10]; bool cmp(node a,node b){//递减排序 return a.x&gt;b.x; } bool cmp(node a,node b){//先按x从大到小排序,但当x相等时,按照y从小到大来排序 if(a.x!=b.x) return a.x&gt;b.x; else return a.y&lt;b.y; } sort(st,st+3,cmp);//对下标为0,1,2的结构体类型排序 c、容器的排序 在STL标准容器中,只有vector、string、deque是可以使用sort的。这是因为set、map这种容器是用红黑树实现的,元素本身有序,故不允许使用sort排序。以vector为例: bool cmp(int a,int b){ return a&gt;b; } vector&lt;int&gt; v; v.push_back(3); v.push_back(1); v.push_back(2); sort(v.begin(),v.end(),cmp);//对整个vector排序]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的stack]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84stack%2F</url>
    <content type="text"><![CDATA[在编程过程中，常常使用stack用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函数来递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题。stack是一种先进后出的数据结构。要使用stack，必须包含头文件#include还有命名空间”using namespace std;”。 1、stack的定义:stack&lt;typename> name;例如: stack&lt;int&gt; name; 2、stack容器内元素的访问 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main(){ stack&lt;int&gt; st; for(int i=1;i&lt;=5;i++){ st.push(i);//push(i)将i压入队列 } cout&lt;&lt;st.top();//取栈顶元素 return 0; } 3、stack常用的函数 (1)push(x):将x进行入栈，时间复杂度为O(1)。 (2)pop():栈顶元素出栈，时间复杂度为O(1)。 (3)top():获得栈顶元素，时间复杂度为O(1)。 (4)empty():检测stack是否为空，时间复杂度为O(1)。 (5)size():返回stack内的元素个数，时间复杂度为O(1)。 (6)STL中没有实现栈的清空，如果需要实现栈的清空，可以用一个while循环反复pop出元素直到栈为空： while(!st.empty){ st.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的queue]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84queue%2F</url>
    <content type="text"><![CDATA[在编程过程中，当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue作为代替，以提高程序的准确性。要使用queue，必须包含头文件#include还有命名空间”using namespace std;”。STL的容器中还有两种容器和队列有关，分别是双端队列(deque)和优先队列(priority_queue)，前者是首位皆可以插入和删除的队列，后者是使用堆实现的默认将当前队列最大元素置于队首的容器。 1、queue的定义:queue&lt;typename> name;例如: queue&lt;int&gt; name;//typename可以是任意基本数据类型或容器 2、queue容器内元素的访问 由于队列queue是一种先进先出的限制性数据结构,因此在STL中只能通过front()来访问队首元素,或者通过back()来访问队尾元素。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main(){ queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++){ q.push(i);//push(i)将i压入队列 } cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;&lt;&lt;q.back(); return 0; } 3、queue常用的函数 (1)push(x):将x进行入队，时间复杂度为O(1)。 (2)pop():令队首元素出队，时间复杂度为O(1)。使用pop()函数之前必须用empty()判断队列是否为空。 (3)front():获得队首元素，时间复杂度为O(1)。使用front()函数之前必须用empty()判断队列是否为空。 (4)back():获得队尾元素，时间复杂度为O(1)。 (5)empty():检测queue是否为空，时间复杂度为O(1)。 (6)size():返回queue内的元素个数，时间复杂度为O(1)。 (7)STL中没有实现队列的清空，如果需要实现队列的清空，可以用一个while循环反复pop出元素直到队列为空： while(!q.empty){ q.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的map]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84map%2F</url>
    <content type="text"><![CDATA[在编程过程中，如果需要建立字符(或者字符串)与整数之间的映射;判断大整数或者其他类型数据是否存在;甚至是字符串和字符串之间的映射。此时我们应当想到map，因为map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)。map和其他的STL容器有点不一样，因为map需要确定映射前类型(键key)和映射后类型(值value),所以需要在&lt;&gt;内填写两个类型。需要注意的是:map中的键是唯一的，而且map会以键从小到大的顺序自动排序(这是由于map内部是使用红黑树实现的，set也是，在建立映射的过程中会自动实现从小到大的排序功能)。如果需要使用map，必须包含头文件#include还有命名空间”using namespace std;”。 1、map的定义:map&lt;typename1,typename2> name;例如: map&lt;string,int&gt; name;//如果是字符串到整型的映射，必须使用string而不能用char数组 map&lt;set&lt;int&gt;,string&gt; name;//将一个set容器映射到一个字符串 2、map容器内元素的访问 (1)通过下标访问，例如：一个定义为map&lt;char,int&gt; name的map来说，可以直接使用name[&apos;c&apos;]来访问对应的整数。 (2)通过迭代器访问,其定义是:map&lt;typename1,typename2&gt;::iterator it;但map迭代器的使用方式和其他STL容器的迭代器不同,因为map的每一对映射都有两个typename,此时我们可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main(){ map&lt;char,int&gt; mp; mp[&apos;m&apos;]=20; mp[&apos;r&apos;]=30; mp[&apos;a&apos;]=40; for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,map的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 3、map常用的函数 (1)find(key):用以返回键为key的映射的迭代器，时间复杂度为O(logN)。map&lt;char,int&gt;::iterator it=mp.find(&apos;b&apos;) (2)size():用来获得map中映射的对数，时间复杂度为O(1)。 (3)clear():用来清空map中的所有元素，时间复杂度为O(N)。 (4)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:mp.erase(it),it位所需要删除元素的迭代器,时间复杂度O(1);mp.erase(key),key为欲删除的映射的键,时间复杂度为O(logN)。删除一个区间内的所有元素:mp.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。时间复杂度为O(last-first)。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的set]]></title>
    <url>%2F2018%2F03%2F17%2FC%2B%2B%E4%B8%AD%E7%9A%84set%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现去掉重复元素的情况，而且有可能因为这些元素比较大或者类型不是int型而不能直接开散列表。此时我们应当想到set，set是关联式容器。其作为一个容器是用来存储同一类型数据的数据类型，比如：int、char、double、结构体等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行递增排序,这是因为其内部是用红黑树实现的。如果需要使用set，必须包含头文件#include还有命名空间”using namespace std;”。 1、set的定义:set&lt;typename> name;例如: set&lt;int&gt; name; //声明一个int容器 set&lt;int&gt; name(10); //声明一个初始大小为10的int型容器 set&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型容器 set&lt;int&gt; name(a); //声明一个初始大小为a的int型容器 set&lt;node&gt; name; //node是结构体的类型 如果typename是set，定义的时候记得在&gt;&gt;符号之间加上空格: set&lt;set&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、set数组的定义:set&lt;typename> arrayname[arraysize];例如: set&lt;int&gt; a[100];//a[0]~a[99]中的每一个都是一个set容器 与set&lt;set&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、set容器内元素的访问 set只能通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:set&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问set中的元素例如: #include&lt;iostream&gt; #include&lt;set&gt; using namespace std ; int main(){ set&lt;int&gt; a; a.insert(3);//将3插入set中 a.insert(5); a.insert(2); a.insert(3); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++){//a.begin()为取a的首元素地址，而it指向这个地址 cout&lt;&lt;*it; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,set的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。另外,除vector和string之外的STL容器都不支持*(it+i)的访问方式。因此只能按如上的方式枚举。 4、set常用的函数 (1)insert(x):在set容器中添加一个元素,并自动递增排序,时间复杂度为O(logN),N为set内元素个数。 (2)find(x):用以返回set中对应值为x的迭代器，时间复杂度为O(logN)。set&lt;int&gt;::iterator it=a.find(2) (3)size():用来获得set中的元素的个数，时间复杂度为O(1)。 (4)clear():用来清空set中的所有元素，时间复杂度为O(N)。 (5)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(1);a.erase(x),x为所要删除元素的值,时间复杂度为O(logN)。删除一个区间内的所有元素:a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的vector]]></title>
    <url>%2F2018%2F03%2F16%2FC%2B%2B%E4%B8%AD%E7%9A%84vector%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现普通数组浪费大量的内存空间或者无法使用邻接矩阵(节点数太多)又害怕使用指针实现邻接表的情况。此时我们应当想到vector。向量vector是一种对象实体, 能够容纳许多其他类型相同的元素,比如：int、char、double、结构体等。 因此又被称为容器。与string相同,vector同属于STL(Standard Template Library,标准模板库)中的一种自定义的数据类型, 可以广义上认为是数组的增强版。vector是一个能够存放任意类型的动态数组。如果需要使用vector，必须包含头文件#include还有命名空间”using namespace std;”。 1、vector的定义:vector&lt;typename> name;例如: vector&lt;int&gt; name; //声明一个int向量 vector&lt;int&gt; name(10); //声明一个初始大小为10的int型向量 vector&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型向量 vector&lt;int&gt; name(a); //声明一个初始大小为a的int型向量 vector&lt;node&gt; name; //node是结构体的类型 如果typename是vector，定义的时候记得在&gt;&gt;符号之间加上空格: vector&lt;vector&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、vector数组的定义:vector&lt;typename> arrayname[arraysize];例如: vector&lt;int&gt; vi[100];//vi[0]~vi[99]中的每一个都是一个vector容器 与vector&lt;vector&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、vector容器内元素的访问 (1)通过下标访问，即vi[0]~vi[size-1]进行访问。 (2)通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:vector&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问vector中的元素例如: #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std ; int main(){ vector&lt;int&gt; vi; for(int i=1;i&lt;=5;i++){ vi.push_back(i); } vector&lt;int&gt;::iterator it=vi.begin();//vi.begin()为取vi的首元素地址，而it指向这个地址 for(int i=0;i&lt;5;i++){ cout&lt;&lt;*(it+i); } return 0; } 上述程序中出现了去vi的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外，vector的迭代器不支持it&lt;vi.end()的写法，因此循环条件只能用it!=vi.end()。除此之外，迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 4、vector常用的函数 (1)push_back(x):在vector后面添加一个元素，时间复杂度为O(1)。 (2)pop_back():用以删除vector的尾元素，时间复杂度为O(1)。 (3)size():用来获得vector中的元素的个数，时间复杂度为O(1)。返回的是unsigned类型。 (4)clear():用来清空vector中的所有元素，时间复杂度为O(N)。N为vector中元素的个数。 (5)insert(it,x):用来向vector的任意迭代器it处插入一个元素x，时间复杂度O(N)。 (6)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(N);a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题使用过程中所遇见的问题及解决措施]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[1、有时在hexo s之后本地没有问题，但是在hexo d推送到GitHub之后没有样式显示，此时很可能是GitHub网站本身的原因，稍微等等再刷新就没事了。实在不行的话就把刚才的修改内容改回之前的状态。先hexo clean清理缓存，再hexo g;hexo d刷新查看。 2、平时对博客的修改和更新直接使用hexo g;hexo s查看本地无误之后一般直接hexo d就行了。但是在其中某一步执行完报错之后，记得要先hexo clean再重新执行其他的操作。 3、博客在本地显示正常，hexo d到github上后只显示框架，内容空白时。进入next主题的source目录，将vendors文件的文件名改成任意其他名字，如：VEN。接着在next主题的配置文件_config.yml中,将vendors: 块中的_internal: vendors项改成前面重命名文件夹的名称,如_internal: VEN，保存。(注意在hexo中的大多数情况之下冒号和要填写数据之间必须有一个空格符，否则会在hexo g时便报错)。接下来hexo clean;hexo g;hexo d;打开博客主页，清理缓存，多刷新几次即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的除法]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的除法也可以叫做高精度与低精度的除法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相除呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从大整数的高位开始，上一步的余数(余数的初始值为0)乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步需要注意高位可能有多余的0，要去除，但同时也要保证至少有一位数。有一点需要注意的是：这里的除法函数当中使用了引用变量，引用不产生副本，而是给原变量取了一个别名，对引用变量的操作就是对原变量(即算法中的全局变量)的操作。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign divide(bign a, int b,int &amp;r) {//a/b bign c; c.len = a.len;//被除数的每一位和商的每一位是一一对应的。 for (int i = c.len - 1;i &gt;= 0;i--) {//从高位开始除。 r = r * 10 + a.d[i];//和上一位的余数进行组合。这里的r是引用变量，对引用变量的操作就是对原全局变量的操作。 if (r &lt; b) c.d[i] = 0;//不够除，该位的商为0。 else { c.d[i] = r / b;//商 r = r % b;//获得新的余数。 } } while((c.len-1&gt;=1)&amp;&amp;c.d[c.len-1]==0){ c.len--;//去除高位的0，同时至少保留一位最低位。 } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b,r=0; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(divide(a, b,r));//商 cout &lt;&lt;&quot; &quot;&lt;&lt; r;//余数 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的乘法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的乘法也可以叫做高精度与低精度的乘法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相乘呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从int型数组的低位开始取数与int型数据相乘，再与进位相加，所得的结果的个位数作为该位的结果，高部位作为新的进位。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign multi(bign a, int b) {//a*b bign c; int carry = 0;//进位 for (int i = 0;i &lt; a.len;i++) { int temp = a.d[i] * b + carry; c.d[c.len++] = temp % 10;//个位作为该位的结果。 carry = temp / 10;//高位部分作为新的进位。 } while (carry != 0) {//此处和加法略有不同，乘法的进位可能不止一位。 c.d[c.len++] = carry % 10; carry /= 10; } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(multi(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数减法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数减法又称之为高精度减法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相减呢？其实本质上和小学的减法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相减之前去比较两者的大小，如果是小的减大的则先把负号输出来，将两者进行交换之后再按大的减小的的步骤来。在减的过程中如果当前位是小减大，那么当前位先加10再减，被减数的当前位的下一位同时需要减1。在所有的位都彼此相减完之后，此时还需要考虑高位为0的情况：例如两数是相等的情况，那么就需要消去高位的0。完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign sub(bign a, bign b) {//a-b。 bign c; for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { if (a.d[i] &lt; b.d[i]) { a.d[i + 1]--;//向高位借位。 a.d[i] += 10;//当前位加10。 } c.d[c.len++] = a.d[i] - b.d[i];//当前位相减。 } while ((c.len - 1 &gt;= 1) &amp;&amp; c.d[c.len - 1] == 0) { c.len--;//去除高位的0，同时如果两数相等保留一个0。 } return c; } int compare(bign a, bign b) {//比较两数的大小，先比较长度，再比较各个位的数值大小。 if (a.len &gt; b.len) return 1;//a大 else if (b.len &gt; a.len) return -1;//b大 else { for (int i = a.len - 1;i &gt;= 0;i--) { if (a.d[i] &gt; b.d[i]) return 1; else if (a.d[i] &lt; b.d[i]) return -1; } return 0; } } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); if (compare(a, b) &lt; 0) {//如果a小于b，就交换。 cout &lt;&lt; &quot;-&quot;; bign c = a; a = b; b = c; } print(sub(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数加法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数加法又称之为高精度加法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相加呢？其实本质上和小学的加法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相加完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign add(bign a, bign b) {//a+b。 bign c; int carry = 0;//存储进位。 for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10;//两数之和的个位。 carry = temp / 10;//两数之和的十位。 } if (carry != 0) c.d[c.len++] = carry;//两个大整数的最高位相加之后有进位。 return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); print(add(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的String]]></title>
    <url>%2F2018%2F03%2F14%2FJava%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[1、在Java中字符串是一个对象，同样的，String变量存储的是对String对象的引用。且Sting对象的内容是不可变的，但保存String引用的变量是可变的，即String变量存储其他的String对象的引用。 2、Java虚拟机为了提高效率并节约内存，对具有相同字符串序列的字符串直接量(请注意这里不是指具有相同字符串序列的String对象)使用同一个实例。 3、字符串的比较：运算符==只能检测两个String是否指向同一个对象，但不会告诉你他们的内容是否相等。而equals方法则可以用来判断两个字符串变量的内容是否相等。compareTo方法用来比较两个字符串时的返回值是，两个字符串从左到右第一个不同字符之间的差值。 4、StringBuffer类和StringBuilder类都比String类更灵活且这两个类是很相似的，它们创建的对象的值都可以被修改。不过在多任务并发访问的情况下就使用StringBuffer；而如果是单任务访问，就使用StringBuilder更有效。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%97%A9%2F</url>
    <content type="text"><![CDATA[昨夜雨疏风骤，晨起的道上落满了香樟树的叶子，叶子大多橙黄，意味着新生。空气湿润，给人以深呼吸的欲望。上课的人群络绎不绝；环游车从耳旁呼啸而过；还有鸟儿藏在春日的绿里，送来阵阵悦耳的啼鸣。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo的next主题添加点击出现桃心效果的功能]]></title>
    <url>%2F2018%2F03%2F11%2F%E4%B8%BAhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%A1%83%E5%BF%83%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、在路径/themes/next/source/js/src里面新建love.js文件。 2、将下列代码copy进去: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 3、然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 4、接下来你懂的: hexo g hexo s hexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中需要注意的Points]]></title>
    <url>%2F2018%2F03%2F11%2FJava%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84Points%2F</url>
    <content type="text"><![CDATA[1、数组的创建不同于基本数据类型变量的声明，声明一个数组变量时并不在内存中给数组分配任何空间。它只是创建一个对数组的引用的存储位置。 2、在给方法传值的过程中，对于基本数据类型来说，传递的是实参的值，而方法内部的形参获得的值的改变并不会造成方法外部的值的变化；而对于数组类型来说，传递的是数组的引用，也就是说方法中的数组和方法外的数组是一样的，所以如果改变方法中的数组，那么方法外的数组也跟着变化了。 3、对象是通过对象引用变量来访问的，通常在实例化一个类时包括：声明对象引用变量、创建对象以及将对象的引用赋值给这个变量。其实此处类似于数组的创建，从严格意义上来讲，对象引用变量和对象是不同的，但大多数情况下可以忽略这种不同。另外，类中的数据域(即类中的属性)如果未被初始化，那么会被赋予默认值：引用类型的数据域的默认值是null，数值类型的数据域的默认值是0，boolean是false，char是’\u0000’。但是java没有给方法中的局部变量赋默认值。 4、java中的静态变量可以被一个类的所有实例共享数据，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。java中的静态变量和静态方法都无须创建类的实例就可以被调用。但是实例方法和实例变量只能在实例方法中使用，不能在静态方法中使用。由此可知，math类中的所有数据域和方法都是静态的。 5、在类、方法、和数据域前使用public修饰符表示可以在任何其他的类中进行访问；如果没有使用可见性修饰符，那么默认为类、方法和数据域是可以被同一个包中的任何一个类访问；private修饰符限定方法和数据域只能在它自己的类中被访问。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加标签和分类页面]]></title>
    <url>%2F2018%2F03%2F09%2FAdd-tags-and-categories-to-Blogs%2F</url>
    <content type="text"><![CDATA[1、添加标签页面 定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page: $ cd hexo目录 $ hexo new page tags 内容如下所示，如果要关闭tags页面的评论可以设置comments为false: --- title: 标签 date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 这样以后tags页面在每次执行hexo generate后自动更新。 2、添加分类页面 和上面的一样，在hexo目录下执行下面命令： $ hexo new page categories 内容为： --- title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 3、添加404页面 新建一个404.html文件，放到themes\next\source目录下，内容你自己定。 4、添加博文 $ hexo new [filename] --- title: filename! date: create_time tags: tags categories: categories --- 或者写好文章后，找到菜单栏的“导出到本地”选项.以md格式导出到本地，然后copy该md文件，粘贴到你当初建的博客站点文件夹下的source\ _posts目录下，一个md文件对应一篇博客文章。 5、多标签和多分类的表示方法 tags: [tags1,tags2,tags3] categories: [cat1,cat2,cat3] 6、对本地作出的修改进行测试和上传 在你博客站点文件夹下右键空白处，选择Git Bash Here， 输入：hexo generate，回车，生成静态页面， 再输入：hexo server，回车，到localhost:4000预览博客效果， 最后输入：hexo deploy，回车，同步到github上去就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git push to github]]></title>
    <url>%2F2018%2F03%2F08%2FGit-push-to-github%2F</url>
    <content type="text"><![CDATA[1、git status 查看目前代码的修改状态 a) 已暂存 (changes to be committed) new file //表示新建文件 modified //表示修改文件 deleted //表示删除文件 b) 已修改 (changed but not updated) modified //表示修改文件 deleted //表示删除文件 c) 未跟踪 (untracked files) 另外，git 给出了可能需要的操作命令，git add/rm, gitcheckout – 2、git diff 查看代码修改的内容(按q键退出) 比较某文件与最近提交节点的差异。 注意：如果该文件已暂存，那么应该使用git diff –cached 技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。(也可以利用^运算符) 3、git add [filename] 暂存需要提交的文件 如果是新建的文件则git add 如果是修改的文件则git add 如果是删除的文件则 git rm 4、git commit -m “description informations” 提交已暂存的文件(注意注释填写规范) git commit –amend 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。 5、git pull origin master –allow-unrelated-histories 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 命令：git checkout – &lt;有冲突的文件路径&gt; 6、git push -u origin master&lt;本地分支名&gt; 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。 7、如果过程中出现‘please enter a commit message…’(即进入了vim),首先esc然后输入:wq即可。 git rm −r 我的文件夹/此处−r表示递归所有子目录，如果你要删除的，是空的文件夹，此处可以不用带上−r。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于等到你]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[不知道 头顶遥远的苍穹闪烁的星光 在无穷无尽里飞行了多少光年 终于赶来与我的目光相会 不知道 手中捧握的书卷古老的诗篇 在岁月长河中留存了多少记忆 此刻也将属于我的悉心珍藏 不知道 你与我不断发酵生酯的相逢 在冥冥注定中酝酿了多少韶华 但我仍然记得你发梢的芳香]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
</search>
