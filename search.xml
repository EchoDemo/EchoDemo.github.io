<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis学习笔记(11)-一对多查询]]></title>
    <url>%2F2019%2F06%2F23%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)-%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[楼上谁将玉笛吹？山前水阔暝云低。劳劳燕子人千里，落落梨花雨一枝。修禊近，卖饧时。故乡惟有梦相随。夜来折得江头柳，不是苏堤也皱眉。—-宋·张炎《鹧鸪天·楼上谁将玉笛吹》 张炎（1248年－1320年），字叔夏，号玉田，晚年号乐笑翁。祖籍陕西凤翔。六世祖张俊，宋朝著名将领。父张枢，“西湖吟社”重要成员，妙解音律，与著名词人周密相交。张炎是勋贵之后，前半生居于临安，生活优裕，而宋亡以后则家道中落，晚年漂泊落拓。著有《山中白云词》，存词302首。张炎另一重要的贡献在于创作了中国最早的词论专著《词源》，总结整理了宋末雅词一派的主要艺术思想与成就，其中以“清空”，“骚雅”为主要主张。 本文实现一对多查询，查询订单及订单明细的信息。 示例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(10)-一对一查询]]></title>
    <url>%2F2019%2F06%2F23%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[梅子留酸软齿牙，芭蕉分绿与窗纱。日长睡起无情思，闲看儿童捉柳花。—-宋·杨万里《闲居初夏午睡起·其一》 本文使用两种方式(resultType和resultMap)实现一对一查询，查询订单信息，关联查询创建订单的用户信息。 resultType实现（1）sql语句 1、确定查询的主表：订单表。 2、确定查询的关联表：用户表。 3、关联查询使用内连接？还是外连接？ 4、由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。 sql语句如下： SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id （2）创建pojo 1、将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。 2、原始的Orders.java不能映射全部字段，需要新创建的pojo。 3、创建一个pojo继承包括查询字段较多的po类。 4、对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类OrdersCustom的代码。 pojo类如下： /** * * &lt;p&gt;Title: OrdersCustom&lt;/p&gt; * &lt;p&gt;Description: 订单的扩展类&lt;/p&gt; */ //通过此类映射订单和用户查询的结果，让此类继承包括字段较多的pojo类 public class OrdersCustom extends Orders{ //添加用户属性 /*user.username, user.sex, user.address */ private String username; private String sex; private String address; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } （3）OrdersCustomMapper.xml &lt;!-- 查询订单关联查询用户信息 --&gt; &lt;select id=&quot;findOrdersUser&quot; resultType=&quot;com.echodemo.mybatislearning.bean.OrdersCustom&quot;&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; （4）OrdersCustomMapper.java // 查询订单关联查询用户信息 public List&lt;OrdersCustom&gt; findOrdersUser()throws Exception; } resultMap实现使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。 （1）定义resultMap &lt;!-- 订单查询关联用户的resultMap 将整个查询的结果映射到com.echodemo.mybatislearning.bean.Orders中 --&gt; &lt;resultMap type=&quot;com.echodemo.mybatislearning.bean.Orders&quot; id=&quot;OrdersUserResultMap&quot;&gt; &lt;!-- 配置映射的订单信息 --&gt; &lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id column：订单信息的唯一标识列 property：订单信息的唯一标识列所映射到Orders中哪个属性 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt; &lt;!-- 配置映射的关联的用户信息 --&gt; &lt;!-- association：用于映射关联查询单个对象的信息 property：要将关联查询的用户信息映射到Orders中哪个属性 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt; &lt;!-- id：关联查询用户的唯 一标识 column：指定唯 一标识用户信息的列 javaType：映射到user的哪个属性 --&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; （2）statement定义 &lt;!-- 查询订单关联查询用户信息 --&gt; &lt;select id=&quot;findOrdersUserResultMap&quot; resultMap=&quot;OrdersUserResultMap&quot;&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; （3）OrdersMapper.java // 查询订单关联查询用户使用resultMap public List&lt;Orders&gt; findOrdersUserResultMap()throws Exception; （4）测试代码 @Test public void testFindOrdersUserResultMap() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 OrdersMapperCustom ordersMapperCustom = sqlSession .getMapper(OrdersMapperCustom.class); // 调用maper的方法 List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap(); System.out.println(list); sqlSession.close(); } resultType和resultMap实现一对一查询小结（1）resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。 （2）resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。 （3）resultMap可以实现延迟加载，resultType无法实现延迟加载。 改文章转载自：mybatis学习笔记(10)-一对一查询]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(9)-订单商品数据模型分析]]></title>
    <url>%2F2019%2F06%2F23%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)-%E8%AE%A2%E5%8D%95%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[九月江南花事休, 芙蓉宛转在中洲。美人笑隔盈盈水, 落日还生渺渺愁。露洗玉盘金殿冷, 风吹罗带锦城秋。相看未用伤迟暮, 别有池塘一种幽。—-明·文徵明《钱氏池上芙蓉》 本文对接下来几篇博客中用到的数据模型进行分析，并附上建表sql文件和测试数据文件。 数据模型分析思路（1）每张表记录的数据内容 分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。 （2）每张表重要的字段设置 非空字段、外键字段。 （3）数据库级别表与表之间的关系 外键关系。 （4）表与表之间的业务关系 在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析。 数据模型分析1、用户表user：记录了购买商品的用户信息。 2、订单表orders：记录了用户所创建的订单（购买商品的订单）。 3、订单明细表orderdetail：记录了订单的详细信息以及购买商品的信息。 4、商品表items：记录了商品信息。 表与表之间的业务关系（在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。先分析数据级别之间有关系的表之间的业务关系）： （1）user和orders： user—&gt;orders：一个用户可以创建多个订单，一对多。 orders—&gt;user：一个订单只由一个用户创建，一对一。 （2）orders和orderdetail： orders—&gt;orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系。 orderdetail—&gt; orders：一个订单明细只能包括在一个订单中，一对一。 （3）orderdetail和items： orderdetail—&gt;itesms：一个订单明细只对应一个商品信息，一对一。 items—&gt; orderdetail:一个商品可以存在于多个订单明细中，一对多。 再分析数据库级别没有关系的表之间是否有业务关系： （4）orders和items： orders和items之间可以通过orderdetail表建立关系。 订单商品数据模型建表sql（1）商品信息表 CREATE TABLE `items` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) NOT NULL COMMENT &apos;商品名称&apos;, `price` float(10,1) NOT NULL COMMENT &apos;商品定价&apos;, `detail` text COMMENT &apos;商品描述&apos;, `pic` varchar(64) DEFAULT NULL COMMENT &apos;商品图片&apos;, `createtime` datetime NOT NULL COMMENT &apos;生产日期&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; （2）用户信息表 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` date DEFAULT NULL COMMENT &apos;生日&apos;, `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;, `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8; （3）订单表 CREATE TABLE `orders` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL COMMENT &apos;下单用户id&apos;, `number` varchar(32) NOT NULL COMMENT &apos;订单号&apos;, `createtime` datetime NOT NULL COMMENT &apos;创建订单时间&apos;, `note` varchar(100) DEFAULT NULL COMMENT &apos;备注&apos;, PRIMARY KEY (`id`), KEY `FK_orders_1` (`user_id`), CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8; （4）订单详情表 CREATE TABLE `orderdetail` ( `id` int(11) NOT NULL AUTO_INCREMENT, `orders_id` int(11) NOT NULL COMMENT &apos;订单id&apos;, `items_id` int(11) NOT NULL COMMENT &apos;商品id&apos;, `items_num` int(11) DEFAULT NULL COMMENT &apos;商品购买数量&apos;, PRIMARY KEY (`id`), KEY `FK_orderdetail_1` (`orders_id`), KEY `FK_orderdetail_2` (`items_id`), CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; 测试数据（1）商品信息表数据 insert into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,&apos;台式机&apos;,3000.0,&apos;该电脑质量非常好！！！！&apos;,NULL,&apos;2015-02-03 13:22:53&apos;),(2,&apos;笔记本&apos;,6000.0,&apos;笔记本性能好，质量好！！！！！&apos;,NULL,&apos;2015-02-09 13:22:57&apos;),(3,&apos;背包&apos;,200.0,&apos;名牌背包，容量大质量好！！！！&apos;,NULL,&apos;2015-02-06 13:23:02&apos;); （2）用户信息表数据 insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&apos;王五&apos;,NULL,&apos;2&apos;,NULL),(10,&apos;张三&apos;,&apos;2014-07-10&apos;,&apos;1&apos;,&apos;北京市&apos;),(16,&apos;张小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(22,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(24,&apos;张三丰&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(25,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(26,&apos;王五&apos;,NULL,NULL,NULL); （3）订单表数据 insert into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,&apos;1000010&apos;,&apos;2015-02-04 13:22:35&apos;,NULL),(4,1,&apos;1000011&apos;,&apos;2015-02-03 13:22:41&apos;,NULL),(5,10,&apos;1000012&apos;,&apos;2015-02-12 16:13:23&apos;,NULL); （4）订单详情表数据 insert into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3); 改文章转载自：mybatis学习笔记(9)-订单商品数据模型分析]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(8)-动态sql]]></title>
    <url>%2F2019%2F06%2F23%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)-%E5%8A%A8%E6%80%81sql%2F</url>
    <content type="text"><![CDATA[碧圆自洁。向浅洲远渚，亭亭清绝。犹有遗簪，不展秋心，能卷几多炎热。鸳鸯密语同倾盖，且莫与、浣纱人说。恐怨歌、忽断花风，碎却翠云千叠。 回首当年汉舞，怕飞去、谩皱留仙裙折。恋恋青衫，犹染枯香，还叹鬓丝飘雪。盘心清露如铅水，又一夜、西风吹折。喜静看、匹练秋光，倒泻半湖明月。—-宋·张炎《疏影·咏荷叶》 mybatis核心,对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。 if判断（1）UserMapper.xml &lt;!-- 用户信息综合查询 #{userCustom.sex}:取出pojo包装对象中性别值 ${userCustom.username}：取出pojo包装对象中用户名称 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;com.echodemo.mybatislearning.bean.UserCustom&quot;&gt; SELECT * FROM user &lt;where&gt; &lt;if test=&quot;userCustom!=null&quot;&gt; &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt; AND user.sex=#{userCustom.sex} &lt;/if&gt; &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt; AND user.username LIKE &apos;%${userCustom.username}%&apos; &lt;/if&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 用户信息综合查询总数 parameterType：指定输入类型和findUserList一样 resultType：输出结果类型 --&gt; &lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt; SELECT count(*) FROM user &lt;where&gt; &lt;if test=&quot;userCustom!=null&quot;&gt; &lt;if test=&quot;userCustom.sex!=null and userCustom.sex != &apos;&apos; &quot;&gt; AND user.sex=#{userCustom.sex} &lt;/if&gt; &lt;if test=&quot;userCustom.username!=null and userCustom.username != &apos;&apos; &quot;&gt; AND user.username LIKE &apos;%${userCustom.username}%&apos; &lt;/if&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; （2）测试结果 a、注释掉testFindUserList()方法中的userCustom.setUsername(“张三”); //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中 userCustom.setSex(&quot;1&quot;); //userCustom.setUsername(&quot;张三&quot;); userQueryVo.setUserCustom(userCustom); 输出 DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapper matches criteria [is assignable to Object] DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapperTest matches criteria [is assignable to Object] DEBUG [main] - Opening JDBC Connection DEBUG [main] - Created connection 352359770. DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1500955a] DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE user.sex=? DEBUG [main] - ==&gt; Parameters: 1(String) DEBUG [main] - &lt;== Total: 6 [User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]] 可以看到sql语句为reparing: SELECT * FROM user WHERE user.sex=?，没有username的部分。 b、userQueryVo设为null,则userCustom为null //List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo); List&lt;UserCustom&gt; list = userMapper.findUserList(null); 输出 DEBUG [main] - ==&gt; Preparing: SELECT * FROM user DEBUG [main] - ==&gt; Parameters: DEBUG [main] - &lt;== Total: 9 [User [id=1, username=王五, sex=2, birthday=null, address=null], User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=26, username=王五, sex=null, birthday=null, address=null], User [id=27, username=王大军, sex=2, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]] 可以看到sql语句变为了SELECT * FROM user。 sql片段(重点)将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。 （1）定义sql片段 &lt;!-- 定义sql片段 id：sql片段的唯一标识 经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高 在sql片段中不要包括 where --&gt; &lt;sql id=&quot;query_user_where&quot;&gt; &lt;if test=&quot;userCustom!=null&quot;&gt; &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt; AND user.sex = #{userCustom.sex} &lt;/if&gt; &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt; AND user.username LIKE &apos;%${userCustom.username}%&apos; &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; （2）引用sql片段 &lt;!-- 用户信息综合查询 #{userCustom.sex}:取出pojo包装对象中性别值 ${userCustom.username}：取出pojo包装对象中用户名称 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;com.iot.mybatis.po.UserQueryVo&quot; resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt; SELECT * FROM user &lt;!-- where 可以自动去掉条件中的第一个and --&gt; &lt;where&gt; &lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt; &lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还要引用其它的sql片段 --&gt; &lt;/where&gt; &lt;/select&gt; foreach标签向sql传递数组或List，mybatis使用foreach解析在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，一个使用OR,一个使用IN。sql语句如下： SELECT * FROM USER WHERE id=1 OR id=10 OR id=16 SELECT * FROM USER WHERE id IN(1,10,16) （1）在输入参数类型中添加List ids传入多个id public class UserQueryVo { //传入多个id private List&lt;Integer&gt; ids; getter、setter方法 。。。 } （2）修改UserMapper.xml &lt;if test=&quot;ids!=null&quot;&gt; &lt;!-- 使用 foreach遍历传入ids collection：指定输入对象中集合属性 item：每个遍历生成的对象 open：开始遍历时拼接的串 close：结束遍历时拼接的串 separator：遍历的两个对象中需要拼接的串 --&gt; &lt;!-- 使用实现下边的sql拼接： AND (id=1 OR id=10 OR id=16) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; &lt;!-- 每个遍历需要拼接的串 --&gt; id=#{user_id} &lt;/foreach&gt; &lt;!-- 实现 “ and id IN(1,10,16)”拼接 --&gt; &lt;!-- &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;and id IN(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; 每个遍历需要拼接的串 #{user_id} &lt;/foreach&gt; --&gt; &lt;/if&gt; （3）测试代码 在testFindUserList中加入： //传入多个id List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(10); ids.add(16); //将ids通过userQueryVo传入statement中 userQueryVo.setIds(ids); 改文章转载自：mybatis学习笔记(8)-动态sql]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(6)-输入映射]]></title>
    <url>%2F2019%2F06%2F22%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)-%E8%BE%93%E5%85%A5%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[杨柳回塘，鸳鸯别浦。绿萍涨断莲舟路。断无蜂蝶慕幽香，红衣脱尽芳心苦。返照迎潮，行云带雨。依依似与骚人语。当年不肯嫁春风，无端却被秋风误。—-宋·贺铸《芳心苦·杨柳回塘》 通过parameterType指定输入参数的类型，类型可以是： 简单类型 hashmap pojo的包装类型（在实际的应用中，很多时候我们需要的查询条件都是一个综合的查询条件。比如进行连表查询时需要传入多个对象的数据） 传递pojo的包装对象（1）定义包装类型pojo package com.echodemo.mybatislearning.bean; /** * Created by Brian on 2016/2/24. */ public class UserQueryVo { //在这里包装所需要的查询条件 //用户查询条件 private UserCustom userCustom; public UserCustom getUserCustom() { return userCustom; } public void setUserCustom(UserCustom userCustom) { this.userCustom = userCustom; } //可以包装其它的查询条件，订单、商品 //.... } 其中，UserCustom类继承User： public class UserCustom extends User{ } （2）UserMapper.xml 在UserMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行复杂关联查询）。 &lt;!-- 用户信息综合查询 #{userCustom.sex}:取出pojo包装对象中性别值 ${userCustom.username}：取出pojo包装对象中用户名称 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;com.iot.mybatis.po.UserCustom&quot;&gt; SELECT * FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos; &lt;/select&gt; 注意:不要将#{userCustom.sex}中的userCustom写成UserCustom,前者指属性名(由于使用IDE提示自动补全，所以只是把类型名首字母小写了)，后者指类型名，这里是UserQueryVo类中的userCustom属性，是属性名。写错会报如下异常： org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos; ### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos; （3）UserMapper.java //用户信息综合查询 public List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception; （4）测试代码 //用户信息的综合查询 @Test public void testFindUserList() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中 userCustom.setSex(&quot;1&quot;); userCustom.setUsername(&quot;张三&quot;); userQueryVo.setUserCustom(userCustom); //调用userMapper的方法 List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo); System.out.println(list); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(7)-输出映射]]></title>
    <url>%2F2019%2F06%2F22%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)-%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[涉江玩秋水，爱此红蕖鲜。攀荷弄其珠，荡漾不成圆。佳人彩云里，欲赠隔远天。相思无因见，怅望凉风前。—-唐·李白《折荷有赠》 resultType1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 2、如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。 3、只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。 输出简单类型（1）UserMapper.xml &lt;!-- 用户信息综合查询总数 parameterType：指定输入类型和findUserList一样 resultType：输出结果类型 --&gt; &lt;select id=&quot;findUserCount&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.UserQueryVo&quot; resultType=&quot;int&quot;&gt; SELECT count(*) FROM user WHERE user.sex=#{userCustom.sex} AND user.username LIKE &apos;%${userCustom.username}%&apos; &lt;/select&gt; （2）UserMapper.java //用户信息综合查询总数 @Test public void testFindUserCount() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中 userCustom.setSex(&quot;1&quot;); userCustom.setUsername(&quot;小&quot;); userQueryVo.setUserCustom(userCustom); //调用userMapper的方法 int count = userMapper.findUserCount(userQueryVo); System.out.println(count); } 注：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。 输出pojo对象和pojo列表不管输出的pojo是单个对象还是一个列表（list中包括pojo），在UserMapper.xml中resultType指定的类型是一样的。 （1）输出单个pojo对象，方法返回值是单个对象类型 //根据id查询用户信息 public User findUserById(int id) throws Exception; （2）输出pojo对象list，方法返回值是List //根据用户名列查询用户列表 public List&lt;User&gt; findUserByName(String name) throws Exception; 生成的动态代理对象中是根据mapper方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList（返回集合对象调用 ）。 resultMapmybatis中使用resultMap完成高级输出结果映射。(一对多，多对多) resultMap使用方法（1）如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。首先定义resultMap，然后使用resultMap作为statement的输出映射类型。 &lt;!-- 定义resultMap 将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系 type：resultMap最终映射的java对象类型,可以使用别名 id：对resultMap的唯一标识 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt; &lt;!-- id表示查询结果集中唯一标识 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 （对应关系） --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- result：对普通名映射定义 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 （对应关系） --&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt; （2）使用resultMap作为statement的输出映射类型 &lt;!-- 使用resultMap进行输出映射 resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace --&gt; &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT id id_,username username_ FROM USER WHERE id=#{value} &lt;/select&gt; （3）UserMapper.java //根据id查询用户信息，使用resultMap输出 public User findUserByIdResultMap(int id) throws Exception; （4）测试代码 @Test public void testFindUserByIdResultMap() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用userMapper的方法 User user = userMapper.findUserByIdResultMap(1); System.out.println(user); } 总结1、使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 2、如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 改文章转载自：mybatis学习笔记(7)-输出映射]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(5)-配置文件]]></title>
    <url>%2F2019%2F06%2F22%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[野有蔓草，零露漙兮。有美一人，清扬婉兮。邂逅相遇，适我愿兮。野有蔓草，零露瀼瀼。有美一人，婉如清扬。邂逅相遇，与子偕臧。—-先秦·佚名《国风·郑风·野有蔓草》 SqlMapConfig.xml中配置的内容和顺序1、properties（属性） 2、settings（全局配置参数） 3、typeAliases（类型别名） 4、typeHandlers（类型处理器） 5、objectFactory（对象工厂） 6、plugins（插件） 7、environments（环境集合属性对象） &gt;environment（环境子属性对象） &gt;transactionManager（事务管理） &gt;dataSource（数据源） 8、mappers（映射器） 其中typeAliases（类型别名）和mappers（映射器）是重点。 properties(属性)将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。原因：方便对参数进行统一管理，其它xml也可以引用该db.properties。 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis?characterEncoding=utf-8&amp;amp;serverTimezone jdbc.username=root jdbc.password= 在sqlMapConfig.xml加载属性文件： &lt;properties resource=&quot;db.properties&quot;&gt; &lt;!--properties中还可以配置一些属性名和属性值 --&gt; &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt; &lt;/properties&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池,由mybatis管理--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 注意： MyBatis 将按照下面的顺序(优先级)来加载属性： 1、在properties元素体内定义的属性首先被读取。 2、然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。 3、最后读取parameterType传递的属性，它会覆盖已读取的同名属性。 建议： 1、不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。 2、在properties文件中定义属性名要有一定的特殊性，如：XXXXX.XXXXX.XXXX settings(全局参数配置)mybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载…全局参数将会影响mybatis的运行行为。具体参考官网： MyBatis-settings typeAliases(类型别名)在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。 如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。 （1）mybatis默认支持别名 MyBatis-typeAliases （2）自定义别名 1、单个别名定义 2、批量定义别名（常用） &lt;!-- 别名定义 --&gt; &lt;typeAliases&gt; &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名 --&gt; &lt;!-- &lt;typeAlias type=&quot;com.echodemo.mybatislearning.bean.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名 （首字母大写或小写都可以） --&gt; &lt;package name=&quot;com.echodemo.mybatislearning.bean&quot;/&gt; &lt;/typeAliases&gt; typeHandlers(类型处理器)mybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如： &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; select * from user where id = #{id} &lt;/select&gt; mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。 http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers mappers(映射配置)（1）通过resource加载单个映射文件： &lt;mappers&gt; &lt;!--通过resource方法一次加载一个映射文件 --&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt; &lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt; &lt;resources&gt; &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; （2）通过mapper接口加载单个mapper： &lt;!-- 通过mapper接口加载单个映射文件 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致， 且在一个目录中上边规范的前提是：使用的是mapper代理方法 --&gt; &lt;mapper class=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;/&gt; （3）目录示例： com.iot.mybatis.mapper------------------package包 |----UserMapper.java |----UserMapper.xml （4）批量加载mapper(推荐使用) &lt;mappers&gt; &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致， 且在一个目录中上边规范的前提是：使用的是mapper代理方法 --&gt; &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt; &lt;/mappers&gt; &lt;!--在pom文件中的build标签里面加入相应的路径指引--&gt; &lt;resources&gt; &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; 改文章转载自：mybatis学习笔记(5)-配置文件]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(4)-开发dao方法]]></title>
    <url>%2F2019%2F06%2F22%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)-%E5%BC%80%E5%8F%91dao%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[疏雨洗天清，枕簟凉生。井桐一叶做秋声。谁念客身轻似叶，千里飘零？梦断古台城，月淡潮平。便须携酒访新亭。不见当时王谢宅，烟草青青。—-宋·邓剡《浪淘沙·疏雨洗天清》 SqlSession使用范围（1）SqlSessionFactoryBuilder 通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建SqlSessionFactory时候，只需要new一次SqlSessionFactoryBuilder即可。 （2）SqlSessionFactory 通过SqlSessionFactory创建SqlSession，使用单例模式管理sqlSessionFactory（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory。 （3）SqlSession SqlSession是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法。如：selectOne(返回单个对象)、selectList（返回单个或多个对象）。 SqlSession是线程不安全的，在SqlSesion实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性（比如org.apache.ibatis.session.Configuration和java.sql.Connection）。SqlSession最佳应用场合在方法体内，定义成局部变量使用。 原始dao开发方法dao接口package com.echodemo.mybatislearning.dao; import com.echodemo.mybatislearning.bean.User; import java.util.List; public interface UserDao { //根据id查询用户信息 public User findUserById(int id) throws Exception; //根据用户名列查询用户列表 public List&lt;User&gt; findUserByName(String name) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception; } dao接口实现类package com.echodemo.mybatislearning.dao.Impl; import com.echodemo.mybatislearning.bean.User; import com.echodemo.mybatislearning.dao.UserDao; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import java.util.List; public class UserDaoImpl implements UserDao { // 需要向dao实现类中注入SqlSessionFactory，这里通过构造方法注入 private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory){ this.sqlSessionFactory = sqlSessionFactory; } @Override public User findUserById(int id) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id); //释放资源 sqlSession.close(); return user; } @Override public List&lt;User&gt; findUserByName(String name) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, name); // 释放资源 sqlSession.close(); return list; } @Override public void insertUser(User user) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); //执行插入操作 sqlSession.insert(&quot;test.insertUser&quot;, user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); } @Override public void deleteUser(int id) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); //执行插入操作 sqlSession.delete(&quot;test.deleteUser&quot;, id); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); } } 测试代码package com.echodemo.mybatislearning; import com.echodemo.mybatislearning.bean.User; import com.echodemo.mybatislearning.dao.Impl.UserDaoImpl; import com.echodemo.mybatislearning.dao.UserDao; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import java.io.InputStream; public class UserDaoImplTest { private SqlSessionFactory sqlSessionFactory; // 此方法是在执行testFindUserById之前执行 @Before public void setUp() throws Exception { // 创建sqlSessionFactory，mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); } @Test public void testFindUserById() throws Exception { // 创建UserDao的对象 UserDao userDao = new UserDaoImpl(sqlSessionFactory); // 调用UserDao的方法 User user = userDao.findUserById(3); System.out.println(user.toString()); } } 总结原始dao开发问题1、dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。 2、调用sqlsession方法时将statement的id硬编码了 3、调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。 mapper代理方法1、程序员只需要mapper接口（相当于dao接口） 2、程序员还需要编写mapper.xml映射文件 3、程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口 实现类代理对象。 开发规范（1）在UserMapper.xml中namespace等于mapper接口地址 &lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址 --&gt; &lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt; 1、UserMapper.java接口中的方法名和UserMapper.xml中statement的id一致 2、UserMapper.java接口中的方法输入参数类型和UserMapper.xml中statement的parameterType指定的类型一致。 3、UserMapper.java接口中的方法返回值类型和UserMapper.xml中statement的resultType指定的类型一致。 &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.iot.mybatis.po.User&quot;&gt; SELECT * FROM user WHERE id=#{value} &lt;/select&gt; //根据id查询用户信息 public User findUserById(int id) throws Exception; //总结：以上开发规范主要是对类似下边代码进行统一生成： User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id); sqlSession.insert(&quot;test.insertUser&quot;, user); 代码（1）UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt; &lt;mapper namespace=&quot;com.echodemo.mybatislearning.mapper.UserMapper&quot;&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!--需求:通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识映射文件中的sql，称为statement的id 将sql语句封装到mappedStatement对象中，所以将id称为statement的id parameterType:指定输入参数的类型 #{}标示一个占位符, #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。 resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE id=#{value} &lt;/select&gt; &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条 resultType：指定就是单条记录所映射的java对象类型 ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。 使用${}拼接sql，引起 sql注入 ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value --&gt; &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos; &lt;/select&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; &lt;!-- 将插入数据的主键返回，返回到user对象中 SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序 resultType：指定SELECT LAST_INSERT_ID()的结果类型 --&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;integer&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address}) &lt;!-- 使用mysql的uuid（）生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt; &lt;/insert&gt; &lt;!-- 删除 用户 根据id删除用户，需要输入 id值 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;integer&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;!-- 根据id更新用户 分析： 需要传入用户的id 需要传入用户的更新信息 parameterType指定user对象，包括 id和更新信息，注意：id必须存在 #{id}：从输入 user对象中获取id属性值 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;user&quot;&gt; update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id} &lt;/update&gt; &lt;/mapper&gt; （2）在SqlMapConfig.xml中加载映射文件 &lt;mappers&gt; &lt;!--通过resource方法一次加载一个映射文件 --&gt; &lt;!--&lt;mapper resource=&quot;UserMapper.xml&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致， 且在一个目录中上边规范的前提是：使用的是mapper代理方法 --&gt; &lt;package name=&quot;com.echodemo.mybatislearning.mapper&quot;/&gt; &lt;/mappers&gt; 有两种方式，每种方式都要在pom文件中的build标签里面加入相应的路径指引： &lt;resources&gt; &lt;!-- mapper中通过resource方法一次加载一个映射文件的路径依赖指引 --&gt; &lt;!--&lt;resource&gt;--&gt; &lt;!--&lt;directory&gt;src/main/java/com/echodemo/mybatislearning/mapper&lt;/directory&gt;--&gt; &lt;!--&lt;includes&gt;--&gt; &lt;!--&lt;include&gt;**/*.xml&lt;/include&gt;--&gt; &lt;!--&lt;/includes&gt;--&gt; &lt;!--&lt;/resource&gt;--&gt; &lt;!-- 批量加载mapper指定mapper接口的包名的路径依赖指引 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; （3）UserMapper.java package com.echodemo.mybatislearning.mapper; import com.echodemo.mybatislearning.bean.User; import java.util.List; public interface UserMapper { //根据id查询用户信息 public User findUserById(int id) throws Exception; //根据用户名列查询用户列表 public List&lt;User&gt; findUserByName(String name) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception; //更新用户 public void updateUser(User user)throws Exception; } （4）UserMapperTest.java package com.echodemo.mybatislearning; import com.echodemo.mybatislearning.bean.User; import com.echodemo.mybatislearning.mapper.UserMapper; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import java.io.InputStream; public class UserMapperTest { private SqlSessionFactory sqlSessionFactory; //注解Before是在执行本类所有测试方法之前先调用这个方法 @Before public void setup() throws Exception{ //创建SqlSessionFactory String resource=&quot;SqlMapConfig.xml&quot;; //将配置文件加载成流 InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂，传入mybatis配置文件的信息 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test public void testFindUserById() throws Exception{ SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用userMapper的方法 User user = userMapper.findUserById(3); System.out.println(user.getUsername()); } } 总结（1）代理对象内部调用selectOne或selectList 1、如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。 2、如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。 （2）mapper接口方法参数只能有一个是否影响系统开发 mapper接口方法参数只能有一个，系统是否不利于扩展维护?系统框架中，dao层的代码是被业务层公用的。即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。 注意：持久层方法的参数可以包装类型、map…等，service方法中建议不要使用包装类型（不利于业务层的可扩展）。 改文章转载自：mybatis学习笔记(4)-开发dao方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(3)-入门程序]]></title>
    <url>%2F2019%2F06%2F22%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[燎沉香，消溽暑。鸟雀呼晴，侵晓窥檐语。叶上初阳干宿雨、水面清圆，一一风荷举。故乡遥，何日去。家住吴门，久作长安旅。五月渔郎相忆否。小楫轻舟，梦入芙蓉浦。—-宋·周邦彦《苏幕遮·燎沉香》 工程结构（1）log4j.properties # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n （2）SqlMapConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池,由mybatis管理--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 映射文件（1）UserMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!--需求:通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识映射文件中的sql，称为statement的id 将sql语句封装到mappedStatement对象中，所以将id称为statement的id parameterType:指定输入参数的类型 #{}标示一个占位符, #{value}其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#{}中的值可以任意。 resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt; SELECT * FROM user WHERE id=#{value} &lt;/select&gt; &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条 resultType：指定就是单条记录所映射的java对象类型 ${}:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。 使用${}拼接sql，引起 sql注入 ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能使用value --&gt; &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt; SELECT * FROM user WHERE username LIKE &apos;%${value}%&apos; &lt;/select&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt; &lt;!-- 将插入数据的主键返回，返回到user对象中 SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用于自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序 resultType：指定SELECT LAST_INSERT_ID()的结果类型 --&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user (id,username,birthday,sex,address)values (#{id},#{username},#{birthday},#{sex},#{address}) &lt;!-- 使用mysql的uuid（）生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address}) --&gt; &lt;/insert&gt; &lt;!-- 删除 用户 根据id删除用户，需要输入 id值 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;!-- 根据id更新用户 分析： 需要传入用户的id 需要传入用户的更新信息 parameterType指定user对象，包括 id和更新信息，注意：id必须存在 #{id}：从输入 user对象中获取id属性值 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.echodemo.mybatislearning.bean.User&quot;&gt; update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id} &lt;/update&gt; &lt;/mapper&gt; （2）在sqlMapConfig.xml中加载User.xml &lt;!-- 加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;/mappers&gt; 程序代码（1）po类User.java package com.echodemo.mybatislearning.bean; import lombok.ToString; @ToString public class User { //属性名要和数据库表的字段对应 private int id; private String username;// 用户姓名 private String sex;// 性别 private String birthday;// 生日 private String address;// 地址 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getBirthday() { return birthday; } public void setBirthday(String birthday) { this.birthday = birthday; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } （2）测试代码 package com.echodemo.mybatislearning; import com.echodemo.mybatislearning.bean.User; import com.echodemo.mybatislearning.util.DateUtil; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.util.List; public class UserTest { @Test public void findUserByIdTest() throws IOException { // mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂，传入mybatis配置文件的信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession操作数据库 // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数 // sqlSession.selectOne结果是与映射文件中所匹配的resultType类型的对象 // selectOne查询出一条记录 User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1); System.out.println(user); // 释放资源 sqlSession.close(); } // 根据用户名称模糊查询用户列表 @Test public void findUserByNameTest() throws IOException { // mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // list中的user和映射文件中resultType所指定的类型一致 List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, &quot;小明&quot;); System.out.println(list); sqlSession.close(); } // 添加用户信息 @Test public void insertUserTest() throws IOException { // mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 插入用户对象 User user = new User(); user.setId(5); user.setUsername(&quot;王小军&quot;); user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;)); user.setSex(&quot;男&quot;); user.setAddress(&quot;河南郑州&quot;); sqlSession.insert(&quot;test.insertUser&quot;, user); // 提交事务 sqlSession.commit(); // 获取用户信息主键 System.out.println(user.getId()); // 关闭会话 sqlSession.close(); } // 根据id删除 用户信息 @Test public void deleteUserTest() throws IOException { // mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 传入id删除 用户 sqlSession.delete(&quot;test.deleteUser&quot;, 1); // 提交事务 sqlSession.commit(); // 关闭会话 sqlSession.close(); } // 更新用户信息 @Test public void updateUserTest() throws IOException { // mybatis配置文件 String resource = &quot;SqlMapConfig.xml&quot;; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 更新用户信息 User user = new User(); //必须设置id user.setId(5); user.setUsername(&quot;王大军&quot;); user.setBirthday(DateUtil.getNow(&quot;yyyy-MM-dd&quot;)); user.setSex(&quot;2&quot;); user.setAddress(&quot;河南郑州&quot;); sqlSession.update(&quot;test.updateUser&quot;, user); // 提交事务 sqlSession.commit(); // 关闭会话 sqlSession.close(); } } 改文章转载自： mybatis学习笔记(3)-入门程序一 mybatis学习笔记(3)-入门程序二]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(2)-mybatis概述]]></title>
    <url>%2F2019%2F06%2F19%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)-mybatis%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一尺深红胜曲尘，天生旧物不如新。合欢桃核终堪恨，里许元来别有人。井底点灯深烛伊，共郎长行莫围棋。玲珑骰子安红豆，入骨相思知不知。—-唐·温庭筠《新添声杨柳枝词》 mybatis 介绍（1）mybatis是一个持久层的框架，是apache下的顶级项目。 （2）mybatis托管到goolecode下，再后来托管到github(https://github.com/mybatis/mybatis-3/releases)。 （3）mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。 （4）mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）。 mybatis框架执行过程（1）配置mybatis的配置文件，SqlMapConfig.xml（名称不固定）。 （2）通过配置文件，加载mybatis运行环境（environment标签），创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式) 。 （3）通过SqlSessionFactory创建SqlSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。 （4）调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。 （5）释放资源，关闭SqlSession。 mybatis开发dao的方法（1）原始dao 的方法 a、需要程序员编写dao接口和实现类 b、需要在dao实现类中注入一个SqlSessionFactory工厂 （2）mapper代理开发方法（建议使用） 只需要程序员编写mapper接口（就是dao接口）。 程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范： a、mapper.xml中namespace就是mapper.java的类全路径。 b、mapper.xml中statement的id和mapper.java中方法名一致。 c、mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致。 d、mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。 SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。 输入映射和输出映射（1）输入映射： a、parameterType：指定输入参数类型可以简单类型、pojo、hashmap。 b、对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。 （2）输出映射： a、resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。 b、reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。 （3）高级映射： a、将关联查询的列映射到一个pojo属性中。（一对一） b、将关联查询的列映射到一个List中。（一对多） 动态sql 动态sql：（重点） if判断（掌握） where foreach sql片段（掌握） 改文章转载自：mybatis学习笔记(2)-mybatis概述]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(1)-对原生jdbc程序中的问题总结]]></title>
    <url>%2F2019%2F06%2F19%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)-%E5%AF%B9%E5%8E%9F%E7%94%9Fjdbc%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[飒飒东风细雨来，芙蓉塘外有轻雷。金蟾啮锁烧香入，玉虎牵丝汲井回。贾氏窥帘韩掾少，宓妃留枕魏王才。春心莫共花争发，一寸相思一寸灰。—-唐·李商隐《无题》 jdbc编程步骤（1）加载数据库驱动 （2）创建并获取数据库连接 （3）设置sql语句 （4）获取预处理的jdbc statement对象 （5）设置sql语句中的参数(使用preparedStatement) （6）通过statement执行sql并获取结果 （7）对sql执行结果进行解析处理 （8）释放资源(resultSet、preparedstatement、connection) 问题总结（1）数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。 设想：使用数据库连接池管理数据库连接。 （2）将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。 设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 （3）向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。 设想：将sql语句及占位符号和参数全部配置在xml中。 （4）从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。 设想：将查询的结果集，自动映射成java对象。 参考代码package com.iot.mybatis.jdbc; //import java.sql.*; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; /** * Created by Administrator on 2016/2/21. */ public class JdbcTest { public static void main(String[] args) { //数据库连接 Connection connection = null; //预编译的Statement，使用预编译的Statement提高数据库性能 PreparedStatement preparedStatement = null; //结果集 ResultSet resultSet = null; try { //加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(&quot;jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;123&quot;); //定义sql语句 ?表示占位符 String sql = &quot;select * from user where username = ?&quot;; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, &quot;王五&quot;); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next()){ System.out.println(resultSet.getString(&quot;id&quot;)+&quot; &quot;+resultSet.getString(&quot;username&quot;)); } } catch (Exception e) { e.printStackTrace(); }finally{ //释放资源 if(resultSet!=null){ try { resultSet.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(preparedStatement!=null){ try { preparedStatement.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(connection!=null){ try { connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } 改文章转载自：mybatis学习笔记(1)-对原生jdbc程序中的问题总结]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么阿里巴巴禁止把SimpleDateFormat定义为static类型]]></title>
    <url>%2F2019%2F04%2F24%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E6%8A%8ASimpleDateFormat%E5%AE%9A%E4%B9%89%E4%B8%BAstatic%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。 七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。—-辛弃疾《西江月·夜行黄沙道中》 在日常开发中，我们经常会用到时间相关类，我们有很多办法在Java代码中获取时间。但是不同的方法获取到的时间的格式都不尽相同，这时候就需要一种格式化工具，把时间显示成我们需要的格式。最常用的方法就是使用SimpleDateFormat类。这是一个看上去功能比较简单的类，但是，一旦使用不当也有可能导致很大的问题。在阿里巴巴Java开发手册中，有如下明确规定： 5.[强制]SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。 SimpleDateFormat用法SimpleDateFormat是Java提供的一个格式化和解析日期的工具类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。在Java中，可以使用SimpleDateFormat的format方法，将一个Date类型转化成String类型，并且可以指定输出格式。 // Date转String Date data = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String dataStr = sdf.format(data); System.out.println(dataStr); 以上代码，转换的结果是：2018-11-25 13:00:00，日期和时间格式由”日期和时间模式”字符串指定。如果你想要转换成其他格式，只要指定不同的时间模式就行了。 在Java中，可以使用SimpleDateFormat的parse方法，将一个String类型转化成Date类型。 // String转Data System.out.println(sdf.parse(dataStr)); 日期和时间模式表达方法在使用SimpleDateFormat的时候，需要通过字母来描述时间元素，并组装成想要的日期和时间模式。常用的时间元素和字母的对应表如下： 模式字母通常是重复的，其数量确定其精确表示。 输出不同时区的时间时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。 世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。 现今全球共分为24个时区。由于实用上常常1个国家，或1个省份同时跨着2个或更多时区，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。例如，中国幅员宽广，差不多跨5个时区，但为了使用方便简单，实际上在只用东八时区的标准时即北京时间为准。 由于不同的时区的时间是不一样的，甚至同一个国家的不同城市时间都可能不一样，所以，在Java中想要获取时间的时候，要重点关注一下时区问题。 默认情况下，如果不指明，在创建日期的时候，会使用当前计算机所在的时区作为默认时区，这也是为什么我们通过只要使用new Date()就可以获取中国的当前时间的原因。那么，如何在Java代码中获取不同时区的时间呢？SimpleDateFormat可以实现这个功能。 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); sdf.setTimeZone(TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;)); System.out.println(sdf.format(Calendar.getInstance().getTime())); 以上代码，转换的结果是： 2018-11-24 21:00:00 。既中国的时间是11月25日的13点，而美国洛杉矶时间比中国北京时间慢了16个小时（这还和冬夏令时有关系，就不详细展开了）。 如果你感兴趣，你还可以尝试打印一下美国纽约时间（America/New_York）。纽约时间是2018-11-25 00:00:00。纽约时间比中国北京时间慢了13个小时。当然，这不是显示其他时区的唯一方法，不过本文主要为了介绍SimpleDateFormat，其他方法暂不介绍了。 SimpleDateFormat线程安全性由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat： public class Main { private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); public static void main(String[] args) { simpleDateFormat.setTimeZone(TimeZone.getTimeZone(&quot;America/New_York&quot;)); System.out.println(simpleDateFormat.format(Calendar.getInstance().getTime())); } } 这种定义方式，存在很大的安全隐患。我们来看一段代码，以下代码使用线程池来执行时间输出。 /** * @author Hollis */ public class Main { /** * 定义一个全局的SimpleDateFormat */ private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); /** * 使用ThreadFactoryBuilder定义一个线程池 */ private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat(&quot;demo-pool-%d&quot;).build(); private static ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); /** * 定义一个CountDownLatch，保证所有子线程执行完之后主线程再执行 */ private static CountDownLatch countDownLatch = new CountDownLatch(100); public static void main(String[] args) { //定义一个线程安全的HashSet Set&lt;String&gt; dates = Collections.synchronizedSet(new HashSet&lt;String&gt;()); for (int i = 0; i &lt; 100; i++) { //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; { //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 String dateString = simpleDateFormat.format(calendar.getTime()); //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); }); } //阻塞，直到countDown数量为0 countDownLatch.await(); //输出去重后的时间个数 System.out.println(dates.size()); } } 以上代码，其实比较容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数（这个天数随着循环次数而变化），然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。 上面的例子我特意写的稍微复杂了一些，不过我几乎都加了注释。这里面涉及到了线程池的创建、CountDownLatch、lambda表达式、线程安全的HashSet等知识。感兴趣的朋友可以逐一了解一下。 正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。 原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。那么，接下来我们就来看下到底是为什么，以及该如何解决。 线程不安全原因通过以上代码，我们发现了在并发场景中使用SimpleDateFormat会有线程安全问题。其实，JDK文档中已经明确表明了SimpleDateFormat不应该用在多线程场景中： Date formats are not synchronized.It is recommended to create separate format instances for each thread.If multiple threads access a format concurrently, it must be synchronized externally. 那么接下来分析下为什么会出现这种问题，SimpleDateFormat底层到底是怎么实现的？我们跟一下SimpleDateFormat类中format方法的实现其实就能发现端倪。 // Called from Format after creating a FieldDelegate private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) { // Convert input date to time field list calendar.setTime(date); boolean useDateFormatSymbols = useDateFormatSymbols(); for (int i = 0; i &lt; compiledPattern.length; ) { int tag = compiledPattern[i] &gt;&gt;&gt; 8; int count = compiledPattern[i++] &amp; 0xff; if (count == 255) { count = compiledPattern[i++] &lt;&lt; 16; count |= compiledPattern[i++]; } switch (tag) { case TAG_QUOTE_ASCII_CHAR: toAppendTo.append((char)count); break; case TAG_QUOTE_CHARS: toAppendTo.append(compiledPattern, i, count); i += count; break; default: subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols); break; } } return toAppendTo; } SimpleDateFormat中的format方法在执行过程中，会使用一个成员变量calendar来保存时间。这其实就是问题的关键。由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。 假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改成了2018-12-12。这时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过之后的。 除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。所以，不要把SimpleDateFormat作为一个共享变量使用。 破解之法使用局部变量for (int i = 0; i &lt; 100; i++) { //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; { // SimpleDateFormat声明成局部变量 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 String dateString = simpleDateFormat.format(calendar.getTime()); //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); }); } SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。 加同步锁for (int i = 0; i &lt; 100; i++) { //获取当前时间 Calendar calendar = Calendar.getInstance(); int finalI = i; pool.execute(() -&gt; { //加锁 synchronized (simpleDateFormat) { //时间增加 calendar.add(Calendar.DATE, finalI); //通过simpleDateFormat把时间转换成字符串 String dateString = simpleDateFormat.format(calendar.getTime()); //把字符串放入Set中 dates.add(dateString); //countDown countDownLatch.countDown(); } }); } 通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。其实以上代码还有可以改进的地方，就是可以把锁的粒度再设置的小一点，可以只对simpleDateFormat.format这一行加锁，这样效率更高一些。 使用ThreadLocal第三种方式，就是使用 ThreadLocal。 ThreadLocal 可以确保每个线程都可以得到单独的一个 SimpleDateFormat 的对象，那么自然也就不存在竞争问题了。 /** * 使用ThreadLocal定义一个全局的SimpleDateFormat */ private static ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;() { @Override protected SimpleDateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); } }; //用法 String dateString = simpleDateFormatThreadLocal.get().format(calendar.getTime()); 当然，以上代码也有改进空间，就是，其实SimpleDateFormat的创建过程可以改为延迟加载。这里就不详细介绍了。 使用DateTimeFormatter如果是Java8应用，可以使用DateTimeFormatter代替SimpleDateFormat，这是一个线程安全的格式化工具类。就像官方文档中说的，这个类 simple beautiful strong immutable thread-safe。 //解析日期 String dateStr= &quot;2016年10月25日&quot;; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;); LocalDate date= LocalDate.parse(dateStr, formatter); //日期转换为字符串 LocalDateTime now = LocalDateTime.now(); DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 hh:mm a&quot;); String nowStr = now .format(format); System.out.println(nowStr); 总结本文介绍了SimpleDateFormat的用法，SimpleDateFormat主要可以在String和Date之间做转换，还可以将时间转换成不同时区输出。同时提到在并发场景中SimpleDateFormat是不能保证线程安全的，需要开发者自己来保证其安全性。主要的几个手段有改为局部变量、使用synchronized加锁、使用Threadlocal为每一个线程单独创建一个和使用Java8中的DateTimeFormatter类代替等。 改文章转载自：你真的会使用SimpleDateFormat吗？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Volatile关键字]]></title>
    <url>%2F2019%2F04%2F24%2FJava%E4%B8%AD%E7%9A%84Volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[东城渐觉风光好。縠皱波纹迎客棹。绿杨烟外晓寒轻，红杏枝头春意闹。浮生长恨欢娱少。肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。—-宋祁《玉楼春·春景》 Java内存模型中的可见性、原子性和有序性原子性(Atomicity)在Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。比如： i = 2; j = i; i++; i = i + 1； 上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为三步，一是读取i的值，然后再赋值给j,最后将j的值存到写回主存，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，也3步操作。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32位的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 可见性(Visibility)说到可见性，Java就是利用volatile来提供可见性的。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。 其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。 有序性（Ordering）JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段： double pi = 3.14; //A double r = 1; //B double s= pi * r * r;//C 上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。比如这样的代码: int a = 0; bool flag = false; public void write() { a = 2; //1 flag = true; //2 } public void multiply() { if (flag) { //3 int ret = a * a;//4 } } 假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。 这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了其中包含这样一条规则：volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。即如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。 volatile底层的实现机制如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能： 1、重排序时不能把后面的指令重排序到内存屏障之前的位置。 2、使得本CPU的Cache写入内存。 3、写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 volatile使用场景 状态量标记，就如上面对flag的标记：这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 单例模式的实现，典型的双重检查锁定（DCL）： class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解多线程之Java虚拟机的锁优化技术]]></title>
    <url>%2F2019%2F04%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[漠漠轻寒上小楼，晓阴无赖似穷秋。淡烟流水画屏幽。自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。—-秦观《浣溪沙·漠漠轻寒上小楼》 前情提要 1、同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。深入理解多线程之Synchronized的实现原理 2、同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得所锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。深入理解多线程之Moniter的实现原理 3、在HotSpot虚拟机中，使用oop-klass模型来表示对象。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。深入理解多线程之Java的对象模型 4、对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。深入理解多线程之Java的对象头 在深入理解多线程之Moniter的实现原理的最后，我们说过，事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。 高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。本文主要先来介绍一下自旋、锁消除以及锁粗化等技术。 这里简单说明一下，本文要介绍的这几个概念，以及后面要介绍的轻量级锁和偏向锁，其实对于使用他的开发者来说是屏蔽掉了的，也就是说，作为一个Java开发，你只需要知道你想在加锁的时候使用synchronized就可以了，具体的锁的优化是虚拟机根据竞争情况自行决定的。也就是说，在JDK 1.5 以后，我们即将介绍的这些概念，都被封装在synchronized中了。 线程状态要想把锁说清楚，一个重要的概念不得不提，那就是线程和线程的状态。锁和线程的关系是怎样的呢，举个简单的例子你就明白了。 比如，你今天要去银行办业务，你到了银行之后，要先取一个号，然后你坐在休息区等待叫号，过段时间，广播叫到你的号码之后，会告诉你去哪个柜台办理业务，这时，你拿着你手里的号码，去到对应的柜台，找相应的柜员开始办理业务。当你办理业务的时候，这个柜台和柜台后面的柜员只能为你自己服务。当你办完业务离开之后，广播再喊其他的顾客前来办理业务。 这个例子中，每个顾客是一个线程。 柜台前面的那把椅子，就是锁。 柜台后面的柜员，就是共享资源。 你发现无法直接办理业务，要取号等待的过程叫做阻塞。 当你听到叫你的号码的时候，你起身去办业务，这就是唤醒。 当你坐在椅子上开始办理业务的时候，你就获得锁。 当你办完业务离开的时候，你就释放锁。 对于线程来说，一共有五种状态，分别为：初始状态(New) 、就绪状态(Runnable) 、运行状态(Running) 、阻塞状态(Blocked) 和死亡状态(Dead) 。 自旋锁在前面的文章中，我们介绍的synchronized的实现方式中使用Monitor进行加锁，这是一种互斥锁，为了表示他对性能的影响我们称之为重量级锁。这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换需要花费很多的处理器时间。 就像去银行办业务的例子，当你来到银行，发现柜台前面都有人的时候，你需要取一个号，然后再去等待区等待，一直等待被叫号。这个过程是比较浪费时间的，那么有没有什么办法改进呢？有一种比较好的设计，那就是银行提供自动取款机，当你去银行取款的时候，你不需要取号，不需要去休息区等待叫号，你只需要找到一台取款机，排在其他人后面等待取款就行了。 之所以能这样做，是因为取款的这个过程相比较之下是比较节省时间的。如果所有人去银行都只取款，或者办理业务的时间都很短的话，那也就可以不需要取号，不需要去单独的休息区，不需要听叫号，也不需要再跑到对应的柜台了。 在程序中，Java虚拟机的开发工程师们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得。如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。 很多人在对于自旋锁的概念不清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。 对于去银行取钱的你来说，站在取款机面前等待和去休息区等待叫号有一个很大的区别：那就是如果你在休息区等待，这段时间你什么都不需要管，随意做自己的事情，等着被唤醒就行了。如果你在取款机面前等待，那么你需要时刻关注自己前面还有没有人，因为没人会唤醒你。很明显，这种直接去取款机前面排队取款的效率是比较高。 所以，自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。 由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，也就无需调用操作系统原生的线程，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。 锁消除除了自旋锁之后，JDK中还有一种锁的优化被称之为锁消除。还拿去银行取钱的例子说。 你去银行取钱，所有情况下都需要取号，并且等待吗？其实是不用的，当银行办理业务的人不多的时候，可能根本不需要取号，直接走到柜台前面办理业务就好了。能这么做的前提是，没有人和你抢着办业务。上面的这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现所做的一种优化。 在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。如以下代码： public void f() { Object hollis = new Object(); synchronized(hollis) { System.out.println(hollis); } } 代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成： public void f() { Object hollis = new Object(); System.out.println(hollis); } 这里，可能有读者会质疑了，代码是程序员自己写的，程序员难道没有能力判断要不要加锁吗？就像以上代码，完全没必要加锁，有经验的开发者一眼就能看的出来的。其实道理是这样，但是还是有可能有疏忽，比如我们经常在代码中使用StringBuffer作为局部变量，而StringBuffer中的append是线程安全的，有synchronized修饰的，这种情况开发者可能会忽略。这时候，JIT就可以帮忙优化，进行锁消除。 总之，读者只需要知道，在使用synchronized的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。 锁粗化很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。这也是很多人用同步代码块来代替同步方法的原因，因为往往他的粒度会更小一些，这其实是很有道理的。 还是我们去银行柜台办业务，最高效的方式是你坐在柜台前面的时候，只办和银行相关的事情。如果这个时候，你拿出手机，接打几个电话，问朋友要往哪个账户里面打钱，这就很浪费时间了。最好的做法肯定是提前准备好相关资料，在办理业务时直接办理就好了。 加锁也一样，把无关的准备工作放到锁外面，锁内部只处理和并发相关的内容。这样有助于提高效率。 那么，这和锁粗化有什么关系呢？可以说，大部分情况下，减小锁的粒度是很正确的做法，只有一种特殊的情况下，会发生一种叫做锁粗化的优化。 就像你去银行办业务，你为了减少每次办理业务的时间，你把要办的五个业务分成五次去办理，这反而适得其反了。因为这平白的增加了很多你重新取号、排队、被唤醒的时间。 如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当放宽加锁的范围，减少性能消耗。当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。 如以下代码： for(int i=0;i&lt;100000;i++){ synchronized(this){ do(); } 会被粗化成： synchronized(this){ for(int i=0;i&lt;100000;i++){ do(); } 这其实和我们要求的减小锁粒度并不冲突。减小锁粒度强调的是不要在银行柜台前做准备工作以及和办理业务无关的事情。而锁粗化建议的是，同一个人，要办理多个业务的时候，可以在同一个窗口一次性办完，而不是多次取号多次办理。 总结自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。 本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String那些事儿]]></title>
    <url>%2F2019%2F04%2F18%2FString%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[树绕村庄，水满陂塘。倚东风、豪兴徜徉。小园几许，收尽春光。有桃花红，李花白，菜花黄。远远围墙，隐隐茅堂。飏青旗、流水桥旁。偶然乘兴、步过东冈。正莺儿啼，燕儿舞，蝶儿忙。—-秦观《行香子·树绕村庄》 String，是Java中除了基本数据类型以外，最为重要的一个类型了。很多人会认为他比较简单。但是和String有关的面试题有很多，下面我随便找两道面试题，看看你能不能都答对： Q1：String s = new String(&quot;hollis&quot;);定义了几个对象。 Q2：如何理解String的intern方法？ 上面这两个是面试题和String相关的比较常考的，很多人一般都知道答案。 A1：若常量池中已经存在”hollis”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存在”hollis”，则先创建后引用，也就是有两个。 A2：当一个String实例调用intern()方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。 两个答案看上去没有任何问题，但是，仔细想想好像哪里不对呀。按照上面的两个面试题的回答，就是说new String会检查常量池，如果有的话就直接引用，如果不存在就要在常量池创建一个，那么还要intern干啥？难道以下代码是没有意义的吗？ String s = new String(&quot;Hollis&quot;).intern(); 如果每当我们使用new创建字符串的时候，都会到字符串池检查，然后返回。那么以下代码也应该输出结果都是true? String s1 = &quot;Hollis&quot;; String s2 = new String(&quot;Hollis&quot;); String s3 = new String(&quot;Hollis&quot;).intern(); System.out.println(s1 == s2); System.out.println(s1 == s3); 但是，以上代码输出结果为（base jdk1.8.0_73）： false true 不知道，聪明的读者看完这段代码之后，是不是有点被搞蒙了，到底是怎么回事儿？别急，且听我慢慢道来。 字面量和运行时常量池JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。 了解Class文件结构或者做过Java代码的反编译的朋友可能都知道，在java代码被javac编译之后，文件结构中是包含一部分Constant pool的。比如以下代码： public static void main(String[] args) { String s = &quot;Hollis&quot;; } 经过编译后，常量池内容如下： Constant pool: #1 = Methodref #4.#20 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #21 // Hollis #3 = Class #22 // StringDemo #4 = Class #23 // java/lang/Object ... #16 = Utf8 s .. #21 = Utf8 Hollis #22 = Utf8 StringDemo #23 = Utf8 java/lang/Object 上面的Class文件中的常量池中，比较重要的几个内容： #16 = Utf8 s #21 = Utf8 Hollis #22 = Utf8 StringDemo 上面几个常量中，s就是前面提到的符号引用，而Hollis就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。 new String创建了几个对象下面，我们可以来分析下String s = new String(“Hollis”);创建对象情况了。 这段代码中，我们可以知道的是，在编译期，符号引用s和字面量Hollis会被加入到Class文件的常量池中，然后在类加载阶段，这两个常量会进入常量池。但是，这个“进入”过程，并不会直接把所有类中定义的常量全部都加载进来，而是会做个比较，如果需要加到字符串常量池中的字符串已经存在，那么就不需要再把字符串字面量加载进来了。 说完了编译期的事儿了，该到运行期了，在运行期，new String(“Hollis”);执行到的时候，是要在Java堆中创建一个字符串对象的，而这个对象所对应的字符串字面量是保存在运行时常量池中的。但是，String s = new String(“Hollis”);对象的符号引用s是保存在Java虚拟机栈上的，他保存的是堆中刚刚创建出来的的字符串对象的引用。 所以，你也就知道以下代码输出结果为false的原因了。 String s1 = new String(&quot;Hollis&quot;); String s2 = new String(&quot;Hollis&quot;); System.out.println(s1 == s2); 因为，==比较的是s1和s2在堆中创建的对象的地址，当然不同了。但是如果使用equals，那么比较的就是字面量的内容了，那就会得到true。 在不同版本的JDK中，Java堆和字符串常量池之间的关系也是不同的，这里为了方便表述，就画成两个独立的物理区域了。具体情况请参考Java虚拟机规范。 常量池中的“对象”是在编译期就确定好了的，在类被加载的时候创建的，如果类加载时，该字符串常量在常量池中已经有了，那这一步就省略了。堆中的对象是在运行期才确定的，在代码执行到new的时候创建的。 运行时常量池的动态扩展编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是String的intern方法。 当一个String实例调用intern()方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用； intern()有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。我们再来看下开头的那个让人产生疑惑的例子： String s1 = &quot;Hollis&quot;; String s2 = new String(&quot;Hollis&quot;); String s3 = new String(&quot;Hollis&quot;).intern(); System.out.println(s1 == s2); System.out.println(s1 == s3); 你可以简单的理解为String s1 = “Hollis”;和String s3 = new String(“Hollis”).intern();做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。如下图： 对于String s3 = new String(“Hollis”).intern();，在不调intern情况，s3指向的是JVM在堆中创建的那个对象的引用的（如图中的s2）。但是当执行了intern方法时，s3将指向字符串常量池中的那个字符串常量。 由于s1和s3都是字符串常量池中的字面量的引用，所以s1==s3。但是，s2的引用是堆中的对象，所以s2!=s1。 intern的正确用法不知道，你有没有发现，在String s3 = new String(“Hollis”).intern();中，其实intern是多余的？ 因为就算不用intern，Hollis作为一个字面量也会被加载到Class文件的常量池，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到intern呢?在解释这个之前，我们先来看下以下代码： String s1 = &quot;Hollis&quot;; String s2 = &quot;Chuang&quot;; String s3 = s1 + s2; String s4 = &quot;Hollis&quot; + &quot;Chuang&quot;; 在经过反编译后，得到代码如下： String s1 = &quot;Hollis&quot;; String s2 = &quot;Chuang&quot;; String s3 = (new StringBuilder()).append(s1).append(s2).toString(); String s4 = &quot;HollisChuang&quot;; 可以发现，同样是字符串拼接，s3和s4在经过编译器编译后的实现方式并不一样。s3被转化成StringBuilder及append，而s4被直接拼接成新的字符串。如果你感兴趣，你还能发现，String s3 = s1 + s2; 经过编译之后，常量池中是有两个字符串常量的分别是 Hollis、Chuang（其实Hollis和Chuang是String s1 = “Hollis”;和String s2 = “Chuang”;定义出来的），拼接结果HollisChuang并不在常量池中。 如果代码只有String s4 = “Hollis” + “Chuang”;，那么常量池中将只有HollisChuang而没有Hollis和 Chuang。究其原因，是因为常量池要保存的是已确定的字面量值。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。 如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。那么，有了这个特性了，intern就有用武之地了。那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中。 这时候，对于那种可能经常使用的字符串，使用intern进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。如一美团点评团队的《深入解析String#intern》文中举的一个例子： static final int MAX = 1000 * 10000; static final String[] arr = new String[MAX]; public static void main(String[] args) throws Exception { Integer[] DB_DATA = new Integer[10]; Random random = new Random(10 * 10000); for (int i = 0; i &lt; DB_DATA.length; i++) { DB_DATA[i] = random.nextInt(); } for (int i = 0; i &lt; MAX; i++) { arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern(); } } 在以上代码中，我们明确的知道，会有很多重复的相同的字符串产生，但是这些字符串的值都是只有在运行期才能确定的。所以，只能我们通过intern显示的将其加入常量池，这样可以减少很多字符串的重复创建。 总结我们再回到文章开头那个疑惑：按照上面的两个面试题的回答，就是说new String也会检查常量池，如果有的话就直接引用，如果不存在就要在常量池创建一个，那么还要intern干啥？难道以下代码是没有意义的吗？ String s = new String(&quot;Hollis&quot;).intern(); new String 所谓的“如果有的话就直接引用”，指的是Java堆中创建的String对象中包含的字符串字面量直接引用字符串池中的字面量对象。也就是说，还是要在堆里面创建对象的。而intern中说的“如果有的话就直接返回其引用”，指的是会把字面量对象的引用直接返回给定义的对象。这个过程是不会在Java堆中再创建一个String对象的。 的确，以上代码的写法其实是使用intern是没什么意义的。因为字面量Hollis会作为编译期常量被加载到运行时常量池。之所以能有以上的疑惑，其实是对字符串常量池、字面量等概念没有真正理解导致的。有些问题其实就是这样，单个问题，自己都知道答案，但是多个问题综合到一起就蒙了。归根结底是知识的理解还停留在点上，没有串成面。 改文章转载自：我终于搞清楚了和String有关的那点事儿]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鲜为人知的Unsafe类]]></title>
    <url>%2F2019%2F04%2F17%2F%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84Unsafe%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。—-白居易《钱塘湖春行》 Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下： 1、内存管理，Unsafe类中存在直接操作内存的方法。 2、获取对象的实例。 3、挂起与恢复。 4、CAS操作 内存管理通过Unsafe类可以分配内存，可以释放内存；类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应。 //分配内存指定大小的内存 public native long allocateMemory(long bytes); //根据给定的内存地址address设置重新分配指定大小的内存 public native long reallocateMemory(long address, long bytes); //用于释放allocateMemory和reallocateMemory申请的内存 public native void freeMemory(long address); 除此之外，它还有下列一些操作内存的方法： //将指定对象的给定offset偏移量内存块中的所有字节设置为固定值 public native void setMemory(Object o, long offset, long bytes, byte value); //设置给定内存地址的值 public native void putAddress(long address, long x); //获取指定内存地址的值 public native long getAddress(long address); //设置指定内存的byte值 //其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同 public native byte getByte(long address); //获取指定内存的byte值 public native void putByte(long address, byte x); //操作系统的内存页大小 public native int pageSize(); //对象字段的定位,该方法返回给定field的内存地址偏移量，这个值对于给定的filed是唯一的且是固定不变的 public native long staticFieldOffset(Field field); //获取对象中offset偏移地址对应的整型field的值,支持volatile load语义 public native int getIntVolatile(Object obj, long l); //获取数组第一个元素的偏移地址 public native int arrayBaseOffset(Class class1); //获取数组的转换因子，也就是数组中元素的增量地址 public native int arrayIndexScale(Class class1); Unsafe类中有很多以BASE_OFFSET结尾的常量，比如ARRAY_INT_BASE_OFFSET，ARRAY_BYTE_BASE_OFFSET等，这些常量值是通过arrayBaseOffset方法得到的。arrayBaseOffset方法是一个本地方法，可以获取数组第一个元素的偏移地址。Unsafe类中还有很多以INDEX_SCALE结尾的常量，比如 ARRAY_INT_INDEX_SCALE ， ARRAY_BYTE_INDEX_SCALE等，这些常量值是通过arrayIndexScale方法得到的。arrayIndexScale方法也是一个本地方法，可以获取数组的转换因子，也就是数组中元素的增量地址。将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。 获取对象的实例//传入一个对象的class并创建该实例对象，但不会调用构造方法 public native Object allocateInstance(Class cls) throws InstantiationException; 挂起与恢复将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中（java.util.concurrent包中挂起操作都是在LockSupport类实现的），LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法来实现的。 public class LockSupport { public static void unpark(Thread thread) { if (thread != null) unsafe.unpark(thread); } public static void park(Object blocker) { Thread t = Thread.currentThread(); setBlocker(t, blocker); unsafe.park(false, 0L); setBlocker(t, null); } public static void parkNanos(Object blocker, long nanos) { if (nanos &gt; 0) { Thread t = Thread.currentThread(); setBlocker(t, blocker); unsafe.park(false, nanos); setBlocker(t, null); } } public static void parkUntil(Object blocker, long deadline) { Thread t = Thread.currentThread(); setBlocker(t, blocker); unsafe.park(true, deadline); setBlocker(t, null); } public static void park() { unsafe.park(false, 0L); } public static void parkNanos(long nanos) { if (nanos &gt; 0) unsafe.park(false, nanos); } public static void parkUntil(long deadline) { unsafe.park(true, deadline); } } Unsafe里的CAS操作CAS是一些CPU直接支持的指令，在Java中无锁操作CAS基于以下3个方法实现： public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x); public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x); 第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值。expected表示期望值，x表示要设置的值。 利用Unsafe类获取Unsafe实例public static Unsafe getUnsafeInstance() throws Exception{ Field unsafeStaticField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); unsafeStaticField.setAccessible(true); return (Unsafe) unsafeStaticField.get(Unsafe.class); } 通过java反射机制，我们跳过了安全检测，拿到了一个Unsafe类的实例。 修改和读取数组中的值@RequestMapping(&quot;/readandwritearray&quot;) public void readAndWriteArray() throws Exception { Unsafe unsafe = getUnsafeInstance(); int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //返回当前数组的首地址 int b = unsafe.arrayBaseOffset(int[].class); //返回当前数组一个元素占用的字节数 int s = unsafe.arrayIndexScale(int[].class); //获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，将intval写入内存 unsafe.putInt(arr, (long) b + s * 9, 1); for (int i = 0; i &lt; 10; i++) { //获取数组对象obj的起始地址，加上偏移值，得到对应元素的地址，从而获得元素的值 int v = unsafe.getInt(arr, (long) b + s * i); System.out.print(v + &quot; &quot;); } } 打印结果:1 2 3 4 5 6 7 8 9 1 ,可以看到，成功读出了数组中的值，而且最后一个值由10改为了1。 偏移值: 数组元素偏移值 = arrayBaseOffset + arrayIndexScalse * i。 修改静态变量和实例变量的值先定义一个UnsafeTest类: public class UnsafeTest { public int infield; public static int staticIntField; public static int[] arr; private UnsafeTest() { System.out.println(&quot;constructor called!&quot;); } } 修改UnsafeTest类的实例变量: @RequestMapping(&quot;/changeinstancefield&quot;) public void changeInstanceField() throws Exception { Unsafe unsafe = getUnsafeInstance(); //传入一个对象的class并创建该实例对象，但不会调用构造方法 UnsafeTest unsafeTest = (UnsafeTest)unsafe.allocateInstance(UnsafeTest.class); //获取对象某个属性的地址偏移值 long b1 = unsafe.objectFieldOffset(UnsafeTest.class.getDeclaredField(&quot;infield&quot;)); unsafe.putInt(unsafeTest, b1, 2); System.out.println(&quot;infield:&quot; + unsafeTest.infield); } 这里使用allocateInstance方法获取了一个UnsafeTest类的实例，并且没有打印“constructor called”，说明构造方法没有调用。修改实例变量与修改数组的值类似，同样要获取地址偏移值，然后调用putInt方法。 修改UnsafeTest类的静态变量: @RequestMapping(&quot;/changestaticfield&quot;) public void changeStaticField() throws Exception { Unsafe unsafe = getUnsafeInstance(); Field staticIntField = UnsafeTest.class.getDeclaredField(&quot;staticIntField&quot;); //获取静态变量所属的类在方法区的首地址。可以看到，返回的对象就是UnsafeTes.class Object o = unsafe.staticFieldBase(staticIntField); System.out.println(o == UnsafeTest.class); //获取静态变量地址偏移值 Long b4 = unsafe.staticFieldOffset(staticIntField); //因为是静态变量，传入的Object参数应为class对象 unsafe.putInt(o, b4, 10); System.out.println(&quot;staticIntField:&quot; + unsafe.getInt(UnsafeTest.class, b4)); } 打印结果： true staticIntField:10 静态变量与实例变量不同之处在于，静态变量位于方法区中，它的地址偏移值与UnsafeTest类在方法区的地址相关，与UnsafeTest类的实例无关。 调戏String.intern在jdk7中，String.intern不再拷贝string对象实例，而是保存第一次出现的对象的引用。在下面的代码中，通过Unsafe修改被引用对象s的私有属性value达到间接修改s1的效果！ @RequestMapping(&quot;/stringintern&quot;) public void stringIntern() throws Exception { String s = &quot;abc&quot;; //保存s的引用 s.intern(); //此时s1==s，地址相同 String s1 = &quot;abc&quot;; Unsafe unsafe = getUnsafeInstance(); //获取s的实例变量value Field valueInString = String.class.getDeclaredField(&quot;value&quot;); //获取value的变量偏移值 long offset = unsafe.objectFieldOffset(valueInString); //value本身是一个char[],要修改它元素的值，仍要获取baseOffset和indexScale long base = unsafe.arrayBaseOffset(char[].class); long scale = unsafe.arrayIndexScale(char[].class); //获取value char[] values = (char[]) unsafe.getObject(s, offset); //为value赋值 unsafe.putChar(values, base + scale, &apos;c&apos;); System.out.println(&quot;s:&quot; + s + &quot; s1:&quot; + s1); //将s的值改为 abc s = &quot;abc&quot;; String s2 = &quot;abc&quot;; String s3 = &quot;abc&quot;; System.out.println(&quot;s:&quot; + s + &quot; s1:&quot; + s1); System.out.println(&quot;s2:&quot; + s2 +&quot; s3:&quot; + s3); } 打印结果： s:acc s1:acc s:acc s1:acc s2:acc s3:acc 我们发现了什么？所有值为“abc”的字符串都变成了“acc”。Unsafe类果然不安全！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁的一种实现方式CAS]]></title>
    <url>%2F2019%2F04%2F17%2F%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8FCAS%2F</url>
    <content type="text"><![CDATA[怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。—-岳飞《满江红·写怀》 线程安全众所周知，Java是多线程的。但是，Java对多线程的支持其实是一把双刃剑。一旦涉及到多个线程操作共享资源的情况时，处理不好就可能产生线程安全问题。线程安全性可能是非常复杂的，在没有充足的同步的情况下，多个线程中的操作执行顺序是不可预测的。 Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性。加上复合操作的原子性，我们可以认为Java的线程安全性问题主要关注点有3个：可见性、有序性和原子性。 Java内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题。这里不再详细介绍JMM及锁的其他相关知识。但是我们要讨论一个问题，那就是锁到底是不是有利无弊的？ 锁存在的问题Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。但是悲观锁机制存在以下问题： 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。 一个线程持有锁会导致其它所有需要此锁的线程挂起。 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。 而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 与锁相比，volatile变量是一个更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile不能解决原子性问题，因此当一个变量依赖旧值时就不能使用volatile变量。因此对于同步最终还是要回到锁机制上来。 乐观锁乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 上面提到的乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。 CASCAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。 这里再强调一下，乐观锁是一种思想。CAS是这种思想的一种实现方式。 Java对CAS的支持在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。 我们以java.util.concurrent中的AtomicInteger为例，看一下在不使用锁的情况下是如何保证线程安全的。主要理解getAndIncrement方法，该方法的作用相当于 ++i 操作。 public class AtomicInteger extends Number implements java.io.Serializable { private volatile int value; public final int get() { return value; } public final int getAndIncrement() { for (;;) { int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; } } public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } } 在没有锁的机制下需要字段value要借助volatile原语，保证线程间的数据是可见的。这样在获取变量的值的时候才能直接读取。getAndIncrement采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet利用JNI来完成CPU指令的操作。从代码中我们可以发现，JAVA中的CAS操作都是通过sun.misc包下Unsafe类实现的，关于Unsafe类更详细的说明，可以查阅我的这篇文章:鲜为人知的Unsafe类 ABA问题CAS会导致“ABA问题”。 CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。 部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 CAS与对象创建另外，CAS还有一个应用，那就是在JVM创建对象的过程中。对象创建在虚拟机中是非常频繁的。即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能正在给对象A分配内存空间，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题的方案有两种，其中一种就是采用CAS配上失败重试的方式保证更新操作的原子性。 总结Java中的线程安全问题至关重要，要想保证线程安全，就需要锁机制。锁机制包含两种：乐观锁与悲观锁。悲观锁是独占锁，阻塞锁。乐观锁是非独占锁，非阻塞锁。有一种乐观锁的实现方式就是CAS ，这种算法在JDK 1.5中引入的java.util.concurrent中有广泛应用。但是值得注意的是这种算法会存在ABA问题。 改文章转载自：乐观锁的一种实现方式——CAS]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解多线程之Moniter的实现原理]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BMoniter%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[阅尽天涯离别苦，不道归来，零落花如许。花底相看无一语，绿窗春与天俱暮。待把相思灯下诉，一缕新欢，旧恨千千缕。最是人间留不住，朱颜辞镜花辞树。—-王国维《蝶恋花·阅尽天涯离别苦》 操作系统中的管程如果你在大学学习过操作系统，你可能还记得管程（monitors）在操作系统中是很重要的概念。同样Monitor在java同步机制中也有使用。 管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。 Java线程同步相关的Moniter在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。 先来举个例子，然后我们再上源码。我们可以把监视器理解为包含一个特殊的房间的建筑物，这个特殊房间同一时刻只能有一个客人（线程）。这个房间中包含了一些数据和代码。 如果一个顾客想要进入这个特殊的房间，他首先需要在走廊（Entry Set）排队等待。调度器将基于某个标准（比如 FIFO）来选择排队的客户进入房间。如果，因为某些原因，该客户暂时因为其他事情无法脱身（线程被挂起），那么他将被送到另外一间专门用来等待的房间（Wait Set），这个房间可以稍后再次进入那间特殊的房间。如上面所说，这个建筑屋中一共有三个场所。 总之，监视器是一个用来监视这些线程进入特殊的房间的。他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象，主要特点是： 对象的所有方法都被“互斥”的执行。好比一个Monitor只有一个运行“许可”，任一个线程进入任何一个方法都需要获得这个“许可”，离开时把许可归还。 通常提供singal机制：允许正持有“许可”的线程暂时放弃“许可”，等待某个谓词成真（条件变量），而条件成立后，当前进程可以“通知”正在等待这个条件变量的线程，让他可以重新去获得运行许可。 监视器的实现在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现的，其主要数据结构如下： ObjectMonitor() { _header = NULL; _count = 0; _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } 源码地址：objectMonitor.hppObjectMonitor中有几个关键属性： _owner：指向持有ObjectMonitor对象的线程 _WaitSet：存放处于wait状态的线程队列 _EntryList：存放处于等待锁block状态的线程队列 _recursions：锁的重入次数 _count：用来记录该线程获取锁的次数 当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。 若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示: ObjectMonitor类中提供了几个方法： 获得锁void ATTR ObjectMonitor::enter(TRAPS) { Thread * const Self = THREAD ; void * cur ; //通过CAS尝试把monitor的`_owner`字段设置为当前线程 cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ; //获取锁失败 if (cur == NULL) { assert (_recursions == 0 , &quot;invariant&quot;) ; assert (_owner == Self, &quot;invariant&quot;) ; // CONSIDER: set or assert OwnerIsThread == 1 return ; } // 如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。 if (cur == Self) { // TODO-FIXME: check for integer overflow! BUGID 6557169. _recursions ++ ; return ; } // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程 if (Self-&gt;is_lock_owned ((address)cur)) { assert (_recursions == 0, &quot;internal state error&quot;); _recursions = 1 ; // Commute owner from a thread-specific on-stack BasicLockObject address to // a full-fledged &quot;Thread *&quot;. _owner = Self ; OwnerIsThread = 1 ; return ; } // 省略部分代码。 // 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放 for (;;) { jt-&gt;set_suspend_equivalent(); // cleared by handle_special_suspend_equivalent_condition() // or java_suspend_self() EnterI (THREAD) ; if (!ExitSuspendEquivalent(jt)) break ; // // We have acquired the contended monitor, but while we were // waiting another thread suspended us. We don&apos;t want to enter // the monitor while suspended because that would surprise the // thread that suspended us. // _recursions = 0 ; _succ = NULL ; exit (Self) ; jt-&gt;java_suspend_self(); } 释放锁void ATTR ObjectMonitor::exit(TRAPS) { Thread * Self = THREAD ; //如果当前线程不是Monitor的所有者 if (THREAD != _owner) { if (THREAD-&gt;is_lock_owned((address) _owner)) { // // Transmute _owner from a BasicLock pointer to a Thread address. // We don&apos;t need to hold _mutex for this transition. // Non-null to Non-null is safe as long as all readers can // tolerate either flavor. assert (_recursions == 0, &quot;invariant&quot;) ; _owner = THREAD ; _recursions = 0 ; OwnerIsThread = 1 ; } else { // NOTE: we need to handle unbalanced monitor enter/exit // in native code by throwing an exception. // TODO: Throw an IllegalMonitorStateException ? TEVENT (Exit - Throw IMSX) ; assert(false, &quot;Non-balanced monitor enter/exit!&quot;); if (false) { THROW(vmSymbols::java_lang_IllegalMonitorStateException()); } return; } } // 如果_recursions次数不为0.自减 if (_recursions != 0) { _recursions--; // this is simple recursive enter TEVENT (Inflated exit - recursive) ; return ; } } //省略部分代码，根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。 除了enter和exit方法以外，objectMonitor.cpp中还有: void wait(jlong millis, bool interruptable, TRAPS); void notify(TRAPS); void notifyAll(TRAPS); 等方法。 总结上面介绍的就是HotSpot虚拟机中Moniter的的加锁以及解锁的原理。 通过这篇文章我们知道了sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。事实上，只有在JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。为什么说这种方式操作锁很重呢？ Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费处理器很多的时间，对于代码简单的同步块（如被synchronized修饰的get或set方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说synchronized是java语言中一个重量级的操纵。 所以，在JDK1.6中对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在1.4就有只不过默认的是关闭的，jdk1.6是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。后面的文章会继续介绍这几种锁以及他们之间的关系。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解多线程之Java的对象头]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[今古河山无定据。画角声中，牧马频来去。满目荒凉谁可语？西风吹老丹枫树。从前幽怨应无数。铁马金戈，青冢黄昏路。一往情深深几许？深山夕照深秋雨。—-纳兰容若《蝶恋花·出塞》 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。那么这里提到的对象头到底是什么呢？ class oopDesc { friend class VMStructs; private: volatile markOop _mark; union _metadata { wideKlassOop _klass; narrowOop _compressed_klass; } _metadata; } 上面代码中的_mark和_metadata其实就是对象头的定义。关于_metadata之前就介绍过，这里不再赘述。由于这个专题主要想介绍和JAVA并发相关的知识，所以本文展开介绍一下_mark ，即mark word。 对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 对markword的设计方式上，非常像网络协议报文头：将mark word划分为多个比特位区间，并在不同的对象状态下赋予比特位不同的含义。下图描述了在32位虚拟机上，在对象不同状态时 mark word各个比特位区间的含义。 同样，在HotSpot的源码中我们可以找到关于对象头对象的定义，会一一印证上图的描述。对应与markOop.hpp类。 enum { age_bits = 4, lock_bits = 2, biased_lock_bits = 1, max_hash_bits = BitsPerWord - age_bits - lock_bits - biased_lock_bits, hash_bits = max_hash_bits &gt; 31 ? 31 : max_hash_bits, cms_bits = LP64_ONLY(1) NOT_LP64(0), epoch_bits = 2 }; 从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记位的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。 在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。 markOop.hpp类中有关于对象状态的定义： enum { locked_value = 0, unlocked_value = 1, monitor_value = 2, marked_value = 3, biased_lock_pattern = 5 }; 简单翻译一下： locked_value(00) = 0 unlocked_value(01) = 1 monitor_value(10) = 2 marked_value(11) = 3 biased_lock_pattern(101) = 5 关于为什么要定义这么多状态，上面提到的轻量级锁、重量级锁、偏向锁以及他们之前的关系，会在下一篇文章中重点阐述，敬请期待。 该文转载自：深入理解多线程（三）—— Java的对象头]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解多线程之Java的对象模型]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BJava%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[似花还似非花，也无人惜从教坠。抛家傍路，思量却是，无情有思。萦损柔肠，困酣娇眼，欲开还闭。梦随风万里，寻郎去处，又还被、莺呼起。不恨此花飞尽，恨西园、落红难缀。晓来雨过，遗踪何在？一池萍碎。春色三分，二分尘土，一分流水。细看来，不是杨花，点点是离人泪。—-苏轼《水龙吟·次韵章质夫杨花词》 我们都知道，几乎所有的Java对象都是保存在堆内存当中（有例外，自行了解），在内存中Java对象包含三部分：对象头、实例数据和对齐填充。其中对象头是一个很关键的部分，因为对象头中包含锁状态标志、线程持有的锁等标志。这篇文章就主要从Java对象模型入手，找一找我们关心的对象头以及对象头中和锁相关的运行时数据在JVM中是如何表示的。 Java的对象模型任何一个接触过Java的人都知道，Java是一种面向对象语言。在学习Java的过程中你一定对下面两句话不陌生： 1、在面向对象的软件中，对象（Object）是某一个类（Class）的实例。 2、一切皆对象。 我们还知道，在JVM的内存结构中，对象保存在堆内存中，而我们在对对象进行操作时，其实操作的是对象的引用。那么对象本身在JVM中的结构是什么样的呢？本文的所有分析均基于HotSpot虚拟机。 oop-klass modelHotSpot是基于c++实现，而c++是一门面向对象的语言，本身是具备面向对象基本特征的，所以Java中的对象表示，最简单的做法是为每个Java类生成一个c++类与之对应。但HotSpot JVM并没有这么做，而是设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 为什么HotSpot要设计一套oop-klass model呢？答案是：HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表）。这个解释似乎可以说得通。众所周知，C++和Java都是面向对象的语言，面向对象语言有一个很重要的特性就是多态。关于多态的实现，C++和Java有着本质的区别。 多态是面向对象的最主要的特性之一，是一种方法的动态绑定，实现运行时的类型决定对象的行为。多态的表现形式是父类指针或引用指向子类对象，在这个指针上调用的方法使用子类的实现版本。多态是IOC、模板模式实现的关键。 在C++中通过虚函数表的方式实现多态，每个包含虚函数的类都具有一个虚函数表（virtual table），在这个类对象的地址空间的最靠前的位置存有指向虚函数表的指针。在虚函数表中，按照声明顺序依次排列所有的虚函数。由于C++在运行时并不维护类型信息，所以在编译时直接在子类的虚函数表中将被子类重写的方法替换掉。 在Java中，在运行时会维持类型信息以及类的继承体系。每一个类会在方法区中对应一个数据结构用于存放类的信息，可以通过Class对象访问这个数据结构。其中，类型信息具有superclass属性指示了其超类，以及这个类对应的方法表（其中只包含这个类定义的方法，不包括从超类继承来的）。而每一个在堆上创建的对象，都具有一个指向方法区类型信息数据结构的指针，通过这个指针可以确定对象的类型。 上面这段是从网上摘取过来的，说的有一定道理，但是也不全对。至于为啥，我会在后文介绍到Klass的时候细说。关于opp-klass模型的整体定义，在HotSpot的源码中可以找到。oops模块可以分成两个相对独立的部分：OOP框架和Klass框架。在oopsHierarchy.hpp里定义了oop和klass各自的体系。 oop-klass结构 oop体系： //定义了oops共同基类 typedef class oopDesc* oop; //表示一个Java类型实例 typedef class instanceOopDesc* instanceOop; //表示一个Java方法 typedef class methodOopDesc* methodOop; //表示一个Java方法中的不变信息 typedef class constMethodOopDesc* constMethodOop; //记录性能信息的数据结构 typedef class methodDataOopDesc* methodDataOop; //定义了数组OOPS的抽象基类 typedef class arrayOopDesc* arrayOop; //表示持有一个OOPS数组 typedef class objArrayOopDesc* objArrayOop; //表示容纳基本类型的数组 typedef class typeArrayOopDesc* typeArrayOop; //表示在Class文件中描述的常量池 typedef class constantPoolOopDesc* constantPoolOop; //常量池告诉缓存 typedef class constantPoolCacheOopDesc* constantPoolCacheOop; //描述一个与Java类对等的C++类 typedef class klassOopDesc* klassOop; //表示对象头 typedef class markOopDesc* markOop; 上面列出的是整个Oops模块的组成结构，其中包含多个子模块。每一个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。从上面的代码中可以看到，有一个变量opp的类型是oppDesc ，OOPS类的共同基类型为oopDesc。 在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。在HotSpot中，根据JVM内部使用的对象业务类型，具有多种oopDesc的子类。除了oppDesc类型外，opp体系中还有很多instanceOopDesc、arrayOopDesc 等类型的实例，他们都是oopDesc的子类。 这些OOPS在JVM内部有着不同的用途，例如，instanceOopDesc表示类实例，arrayOopDesc表示数组。也就是说，当我们使用new创建一个Java对象实例的时候，JVM会创建一个instanceOopDesc对象来表示这个Java对象。同理，当我们使用new创建一个Java数组实例的时候，JVM会创建一个arrayOopDesc对象来表示这个数组对象。 在HotSpot中，oopDesc类定义在oop.hpp中，instanceOopDesc定义在instanceOop.hpp中，arrayOopDesc定义在arrayOop.hpp中。简单看一下相关定义： class oopDesc { friend class VMStructs; private: volatile markOop _mark; union _metadata { wideKlassOop _klass; narrowOop _compressed_klass; } _metadata; private: // field addresses in oop void* field_base(int offset) const; jbyte* byte_field_addr(int offset) const; jchar* char_field_addr(int offset) const; jboolean* bool_field_addr(int offset) const; jint* int_field_addr(int offset) const; jshort* short_field_addr(int offset) const; jlong* long_field_addr(int offset) const; jfloat* float_field_addr(int offset) const; jdouble* double_field_addr(int offset) const; address* address_field_addr(int offset) const; } class instanceOopDesc : public oopDesc { } class arrayOopDesc : public oopDesc { } 通过上面的源码可以看到，instanceOopDesc实际上就是继承了oopDesc，并没有增加其他的数据结构，也就是说instanceOopDesc中主要包含以下几部分数据：markOop _mark和union _metadata 以及一些不同类型的 field。 HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头、实例数据和对齐填充。在虚拟机内部，一个Java对象对应一个instanceOopDesc的对象。其中对象头包含了两部分内容：_mark和_metadata，而实例数据则保存在oopDesc中定义的各种field中。 _mark文章开头我们就说过，之所以我们要写这篇文章，是因为对象头中有和锁相关的运行时数据，这些运行时数据是synchronized以及其他类型的锁实现的重要基础，而关于锁标记、GC分代等信息均保存在_mark中。因为本文主要介绍的oop-klass模型，在这里暂时不对对象头做展开，下一篇文章介绍。 _metadata前面介绍到的_metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。在深入介绍之前，就要来到oop-Klass中的另外一个主角klass了。 klassklass体系 //klassOop的一部分，用来描述语言层的类型 class Klass; //在虚拟机层面描述一个Java类 class instanceKlass; //专有instantKlass，表示java.lang.Class的Klass class instanceMirrorKlass; //专有instantKlass，表示java.lang.ref.Reference的子类的Klass class instanceRefKlass; //表示methodOop的Klass class methodKlass; //表示constMethodOop的Klass class constMethodKlass; //表示methodDataOop的Klass class methodDataKlass; //最为klass链的端点，klassKlass的Klass就是它自身 class klassKlass; //表示instanceKlass的Klass class instanceKlassKlass; //表示arrayKlass的Klass class arrayKlassKlass; //表示objArrayKlass的Klass class objArrayKlassKlass; //表示typeArrayKlass的Klass class typeArrayKlassKlass; //表示array类型的抽象基类 class arrayKlass; //表示objArrayOop的Klass class objArrayKlass; //表示typeArrayOop的Klass class typeArrayKlass; //表示constantPoolOop的Klass class constantPoolKlass; //表示constantPoolCacheOop的Klass class constantPoolCacheKlass; 和oopDesc是其他oop类型的父类一样，Klass类是其他klass类型的父类。 Klass向JVM提供两个功能： 1、实现语言层面的Java类（在Klass基类中已经实现） 2、实现Java对象的分发功能（由Klass的子类提供虚函数实现） 文章开头的时候说过：之所以设计oop-klass模型，是因为HotSopt JVM的设计者不想让每个对象中都含有一个虚函数表。 HotSopt JVM的设计者把对象一拆为二，分为klass和oop，其中oop的职能主要在于表示对象的实例数据，所以其中不含有任何虚函数。而klass为了实现虚函数多态，所以提供了虚函数表。所以，关于Java的多态，其实也有虚函数的影子在。 _metadata是一个共用体，其中_klass是普通指针，_compressed_klass是压缩类指针。这两个指针都指向instanceKlass对象，它用来描述对象的具体类型。 instanceKlassJVM在运行时，需要一种用来标识Java内部类型的机制。在HotSpot中的解决方案是：为每一个已加载的Java类创建一个instanceKlass对象，用来在JVM层表示Java类。来看下instanceKlass的内部结构： //类拥有的方法列表 objArrayOop _methods; //描述方法顺序 typeArrayOop _method_ordering; //实现的接口 objArrayOop _local_interfaces; //继承的接口 objArrayOop _transitive_interfaces; //域 typeArrayOop _fields; //常量 constantPoolOop _constants; //类加载器 oop _class_loader; //protected域 oop _protection_domain; .... 可以看到，一个类该具有的东西，这里面基本都包含了。 在JVM中，对象在内存中的基本存在形式就是oop。那么，对象所属的类，在JVM中也是一种对象，因此它们实际上也会被组织成一种oop，即klassOop。同样的，对于klassOop，也有对应的一个klass来描述，它就是klassKlass，也是klass的一个子类。klassKlass作为oop的klass链的端点。关于对象和数组的klass链大致如下图： 在这种设计下，JVM对内存的分配和回收，都可以采用统一的方式来管理。oop-klass-klassKlass关系如图： 内存存储关于一个Java对象，他的存储是怎样的，一般很多人会回答：对象存储在堆上。稍微好一点的人会回答：对象存储在堆上，对象的引用存储在栈上。今天，再给你一个更加显得牛逼的回答： 对象的实例（instantOopDesc)保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。 其实如果细追究的话，上面这句话有点故意卖弄的意思。因为我们都知道。方法区用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 所谓加载的类信息，其实不就是给每一个被加载的类都创建了一个 instantKlass对象么。 class Model { public static int a = 1; public int b; public Model(int b) { this.b = b; } } public static void main(String[] args) { int c = 10; Model modelA = new Model(2); Model modelB = new Model(3); } 存储结构如下： 从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。 总结每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码的编译与反编译那些事儿]]></title>
    <url>%2F2019%2F04%2F14%2FJava%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[槛菊愁烟兰泣露，罗幕轻寒，燕子双飞去。明月不谙离恨苦，斜光到晓穿朱户。昨夜西风凋碧树，独上高楼，望尽天涯路。欲寄彩笺兼尺素，山长水阔知何处？—-晏殊《蝶恋花·槛菊愁烟兰泣露》 编程语言在介绍编译和反编译之前，我们先来简单介绍下编程语言（Programming Language）。编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。 机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。但是，汇编语言用起来同样比较复杂，后面，就衍生出了Java、C、C++等高级语言。 什么是编译上面提到语言有两种，一种低级语言，一种高级语言。可以这样简单的理解：低级语言是计算机认识的语言、高级语言是程序员认识的语言。那么如何从高级语言转换成低级语言呢？这个过程其实就是编译。 C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条a=b+1;语句要翻译成三条汇编或机器指令，这个过程称为编译（Compile），由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用C语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用C语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。 将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。 现在我们知道了什么是编译，也知道了什么是编译器。不同的语言都有自己的编译器，Java语言中负责编译的编译器是一个命令：javac javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。 当我们写完一个HelloWorld.java文件后，我们可以使用javac HelloWorld.java命令来生成HelloWorld.class文件，这个class类型的文件是JVM可以识别的文件。通常我们认为这个过程叫做Java语言的编译。其实，class文件仍然不是机器能够识别的语言，因为机器只能识别机器语言，还需要JVM再将这种class文件类型字节码转换成机器可以识别的机器语言。 什么是反编译反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。 有了反编译工具，我们可以做很多事情，最主要的功能就是有了反编译工具，我们就能读得懂Java编译器生成的字节码。如果你想问读懂字节码有啥用，那么我可以很负责任的告诉你，好处大大的。比如一些原理性文章的分析，都是通过反编译工具得到反编译后的代码得到的。 Java反编译工具本文主要介绍3个Java的反编译工具：javap、jad和cfr javapjavap是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。javap和其他两个反编译工具最大的区别是他生成的文件并不是java文件，也不像其他两个工具生成代码那样更容易理解。拿一段简单的代码举例，如我们想分析Java 7中的switch是如何支持String的，我们先有以下可以编译通过的源代码： public class switchDemoString { public static void main(String[] args) { String str = &quot;world&quot;; switch (str) { case &quot;hello&quot;: System.out.println(&quot;hello&quot;); break; case &quot;world&quot;: System.out.println(&quot;world&quot;); break; default: break; } } } 执行以下两个命令： javac switchDemoString.java javap -c switchDemoString.class 生成代码如下： public class com.hollis.suguar.switchDemoString { public com.hollis.suguar.switchDemoString(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String world 2: astore_1 3: aload_1 4: astore_2 5: iconst_m1 6: istore_3 7: aload_2 8: invokevirtual #3 // Method java/lang/String.hashCode:()I 11: lookupswitch { // 2 99162322: 36 113318802: 50 default: 61 } 36: aload_2 37: ldc #4 // String hello 39: invokevirtual #5 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 42: ifeq 61 45: iconst_0 46: istore_3 47: goto 61 50: aload_2 51: ldc #2 // String world 53: invokevirtual #5 // Method java/lang/String.equals:(Ljava/lang/Object;)Z 56: ifeq 61 59: iconst_1 60: istore_3 61: iload_3 62: lookupswitch { // 2 0: 88 1: 99 default: 110 } 88: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 91: ldc #4 // String hello 93: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 96: goto 110 99: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 102: ldc #2 // String world 104: invokevirtual #7 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 107: goto 110 110: return } 我个人的理解，javap并没有将字节码反编译成java文件，而是生成了一种我们可以看得懂的字节码。其实javap生成的文件仍然是字节码，只是程序员可以稍微看得懂一些。如果你对字节码有所掌握，还是可以看得懂以上的代码的。其实就是把String转成hashcode，然后进行比较。 个人认为，一般情况下我们会用到javap命令的时候不多，一般只有在真的需要看字节码的时候才会用到。但是字节码中间暴露的东西是最全的，你肯定有机会用到，比如在分析synchronized的原理的时候就有用到javap。通过javap生成的字节码，我们发现synchronized底层依赖了ACC_SYNCHRONIZED标记和monitorenter、monitorexit两个指令来实现同步。 jadjad是一个比较不错的反编译工具，只要下载一个执行工具，就可以实现对class文件的反编译了。还是上面的源代码，使用jad反编译后内容如下： 命令：jad switchDemoString.class public class switchDemoString { public switchDemoString() { } public static void main(String args[]) { String str = &quot;world&quot;; String s; switch((s = str).hashCode()) { default: break; case 99162322: if(s.equals(&quot;hello&quot;)) System.out.println(&quot;hello&quot;); break; case 113318802: if(s.equals(&quot;world&quot;)) System.out.println(&quot;world&quot;); break; } } } 看，这个代码你肯定看的懂，因为这不就是标准的java的源代码么。这个就很清楚的可以看到原来字符串的switch是通过equals()和hashCode()方法来实现的。但是，jad已经很久不更新了，在对Java7生成的字节码进行反编译时，偶尔会出现不支持的问题，在对Java 8的lambda表达式反编译时就彻底失败。 CFRjad很好用，但是无奈的是很久没更新了，所以只能用一款新的工具替代他，CFR是一个不错的选择，像我现在所使用的2018版本的intelliJ IDEA默认的反编译器是Fernflower，如果我用它打开class文件，会得到它自动帮我反编译的结果，该结果和CFR反编译器得到的结果基本上是一致的。相比jad来说，它们的语法可能会稍微复杂一些，但是好在他可以work。如，我们使用cfr对刚刚的代码进行反编译。执行一下命令： java -jar cfr_0_125.jar switchDemoString.class --decodestringswitch false 得到以下代码： public class switchDemoString { public static void main(String[] arrstring) { String string; String string2 = string = &quot;world&quot;; int n = -1; switch (string2.hashCode()) { case 99162322: { if (!string2.equals(&quot;hello&quot;)) break; n = 0; break; } case 113318802: { if (!string2.equals(&quot;world&quot;)) break; n = 1; } } switch (n) { case 0: { System.out.println(&quot;hello&quot;); break; } case 1: { System.out.println(&quot;world&quot;); break; } } } } 通过这段代码也能得到字符串的switch是通过equals()和hashCode()方法来实现的结论。相比Jad来说，CFR有很多参数，还是刚刚的代码，如果我们使用以下命令，输出结果就会不同： java -jar cfr_0_125.jar switchDemoString.class public class switchDemoString { public static void main(String[] arrstring) { String string; switch (string = &quot;world&quot;) { case &quot;hello&quot;: { System.out.println(&quot;hello&quot;); break; } case &quot;world&quot;: { System.out.println(&quot;world&quot;); break; } } } } 所以–decodestringswitch表示对于switch支持string的细节进行解码。类似的还有–decodeenumswitch、–decodefinally、–decodelambdas等。在我的关于语法糖的文章中，我使用–decodelambdas对lambda表达式进行了反编译。 源码： public static void main(String... args) { List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;); strList.forEach( s -&gt; { System.out.println(s); } ); } java -jar cfr_0_125.jar lambdaDemo.class –decodelambdas false反编译后代码： public static /* varargs */ void main(String ... args) { ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;); strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)()); } private static /* synthetic */ void lambda$main$0(String s) { System.out.println(s); } CFR还有很多其他参数，均用于不同场景，读者可以使用java -jar cfr_0_125.jar –help进行了解。这里不逐一介绍了。 如何防止反编译由于我们有工具可以对Class文件进行反编译，所以，对开发人员来说，如何保护Java程序就变成了一个非常重要的挑战。但是，魔高一尺、道高一丈。当然有对应的技术可以应对反编译咯。但是，这里还是要说明一点，和网络安全的防护一样，无论做出多少努力，其实都只是提高攻击者的成本而已。无法彻底防治。 典型的应对策略有以下几种： *隔离Java程序 *让用户接触不到你的Class文件 *对Class文件进行加密 *提到破解难度 *代码混淆 *将代码转换成功能上等价，但是难于阅读和理解的形式 该文转载自：Java代码的编译与反编译那些事儿]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机是如何执行线程同步的]]></title>
    <url>%2F2019%2F04%2F14%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草！墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。—-苏轼《蝶恋花·春景》 了解Java语言的人都知道，Java代码要想被JVM执行，需要被转换成由字节码组成的class文件。本文主要来分析下Java虚拟机是如何在字节码层面上执行线程同步的。这里是原文的地址：Java虚拟机是如何执行线程同步的 线程和共享数据Java编程语言的优点之一是它在语言层面上对多线程的支持。这种支持大部分集中在协调多个线程对共享数据的访问上。JVM的内存结构主要包含以下几个重要的区域：栈、堆、方法区等。 在Java虚拟中，每个线程独享一块栈内存，其中包括局部变量、线程调用的每个方法的参数和返回值。其他线程无法读取到该栈内存块中的数据。栈中的数据仅限于基本类型和对象引用。所以，在JVM中，栈上是无法保存真实的对象的，只能保存对象的引用。真正的对象要保存在堆中。 在JVM中，堆内存是所有线程共享的。堆中只包含对象，没有其他东西。所以，堆上也无法保存基本类型和对象引用。堆和栈分工明确。但是，对象的引用其实也是对象的一部分。这里值得一提的是，数组是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。因为在Java中，数组是对象。 除了栈和堆，还有一部分数据可能保存在JVM中的方法区中，比如类的静态变量。方法区和栈类似，其中只包含基本类型和对象应用。和栈不同的是，方法区中的静态变量可以被所有线程访问到。 对象和类的锁如前文提到，JVM中有两块内存区域可以被所有线程共享： 1、堆，上面存放着所有对象 2、方法区，上面存放着静态变量 那么，如果有多个线程想要同时访问同一个对象或者静态变量，就需要被管控，否则可能出现不可预期的结果。 为了协调多个线程之间的共享数据访问，虚拟机给每个对象和类都分配了一个锁。这个锁就像一个特权，在同一时刻，只有一个线程可以“拥有”这个类或者对象。如果一个线程想要获得某个类或者对象的锁，需要询问虚拟机。当一个线程向虚拟机申请某个类或者对象的锁之后，也许很快或者也许很慢虚拟机可以把锁分配给这个线程，同时这个线程也许永远也无法获得锁。当线程不再需要锁的时候，他再把锁还给虚拟机。这时虚拟机就可以再把锁分配给其他申请锁的线程。 类锁其实通过对象锁实现的。因为当虚拟机加载一个类的时候，会为这个类实例化一个java.lang.Class 对象，当你锁住一个类的时候，其实锁住的是其对应的Class 对象。 监视器（Monitors）监视器和锁同时被JVM使用（我理解作者的意思应该是想说锁其实是通过监视器实现的。），监视器主要功能是监控一段代码，确保在同一时间只有一个线程在执行。 每个监视器都与一个对象相关联。当线程执行到监视器监视下的代码块中的第一条指令时，线程必须获取对被引用对象的锁定。在线程获取锁之前，他是无法执行这段代码的，一旦获得锁，线程便可以进入“被保护”的代码开始执行。当线程离开代码块的时候，无论如何离开，都会释放所关联对象的锁。 多次加锁同一个线程可以对同一个对象进行多次加锁。每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。 同步在Java中，当有多个线程都必须要对同一个共享数据进行访问时，有一种协调方式叫做同步。Java语言提供了两种内置方式来使线程同步的访问数据：同步代码块和同步方法。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解多线程之Synchronized的实现原理]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BSynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[伫倚危楼风细细，望极春愁，黯黯生天际。草色烟光残照里，无言谁会凭阑意。拟把疏狂图一醉，对酒当歌，强乐还无味。衣带渐宽终不悔，为伊消得人憔悴。—-柳永《蝶恋花·伫倚危楼风细细》 在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）。在了解synchronized的实现原理之前，我们先来看看synchronized关键字的三种应用方式。 synchronized的三种应用方式1、修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。 2、修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。 3、修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 没有加synchronized关键字的情况public class SynchronizedTest { public void method1(){ System.out.println(&quot;Method 1 start&quot;); try { System.out.println(&quot;Method 1 execute&quot;); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 1 end&quot;); } public void method2(){ System.out.println(&quot;Method 2 start&quot;); try { System.out.println(&quot;Method 2 execute&quot;); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) { final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() { @Override public void run() { test.method1(); } }).start(); new Thread(new Runnable() { @Override public void run() { test.method2(); } }).start(); } } 执行结果如下，线程1先执行，但由于线程1在中途sleep了3秒钟时间，所以导致了线程2先执行完成。 Method 1 start Method 1 execute Method 2 start Method 2 execute Method 2 end Method 1 end synchronized作用于实例方法所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法。 public class SynchronizedTest { public synchronized void method1(){ System.out.println(&quot;Method 1 start&quot;); try { System.out.println(&quot;Method 1 execute&quot;); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 1 end&quot;); } public synchronized void method2(){ System.out.println(&quot;Method 2 start&quot;); try { System.out.println(&quot;Method 2 execute&quot;); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) { final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() { @Override public void run() { test.method1(); } }).start(); new Thread(new Runnable() { @Override public void run() { test.method2(); } }).start(); } } 执行结果如下，跟代码段一比较，可以很明显的看出，线程2需要等待线程1的method1执行完成才能开始执行method2方法。 Method 1 start Method 1 execute Method 1 end Method 2 start Method 2 execute Method 2 end synchronized作用于静态方法当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 public class SynchronizedTest { public static synchronized void method1(){ System.out.println(&quot;Method 1 start&quot;); try { System.out.println(&quot;Method 1 execute&quot;); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 1 end&quot;); } public static synchronized void method2(){ System.out.println(&quot;Method 2 start&quot;); try { System.out.println(&quot;Method 2 execute&quot;); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) { final SynchronizedTest test = new SynchronizedTest(); final SynchronizedTest test2 = new SynchronizedTest(); new Thread(new Runnable() { @Override public void run() { test.method1(); } }).start(); new Thread(new Runnable() { @Override public void run() { test2.method2(); } }).start(); } } 执行结果如下，对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使test和test2属于不同的对象，但是它们都属于SynchronizedTest类的实例，所以也只能顺序的执行method1和method2，不能并发执行。 Method 1 start Method 1 execute Method 1 end Method 2 start Method 2 execute Method 2 end synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了。 public class SynchronizedTest { public void method1(){ System.out.println(&quot;Method 1 start&quot;); try { synchronized (this) { System.out.println(&quot;Method 1 execute&quot;); Thread.sleep(3000); } } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 1 end&quot;); } public void method2(){ System.out.println(&quot;Method 2 start&quot;); try { synchronized (this) { System.out.println(&quot;Method 2 execute&quot;); Thread.sleep(1000); } } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;Method 2 end&quot;); } public static void main(String[] args) { final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() { @Override public void run() { test.method1(); } }).start(); new Thread(new Runnable() { @Override public void run() { test.method2(); } }).start(); } } 执行结果如下，虽然线程1和线程2都进入了对应的方法开始执行，但是线程2在进入同步块之前，需要等待线程1中同步块执行完成。 Method 1 start Method 1 execute Method 2 start Method 1 end Method 2 execute Method 2 end Synchronized的实现原理Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法并不是由monitorenter和monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED 标志来隐式实现的。 反编译我们先来看一下下面这段synchronized同步方法和同步代码块两种使用形式的代码： public class SynchronizedTest { public synchronized void doSth(){ System.out.println(&quot;Hello World&quot;); } public void doSth1(){ synchronized (SynchronizedTest.class){ System.out.println(&quot;Hello World&quot;); } } } 使用javap来反编译以上代码，结果如下（部分无用信息过滤掉了）： public synchronized void doSth(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return public void doSth1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: ldc #5 // class com/hollis/SynchronizedTest 2: dup 3: astore_1 4: monitorenter 5: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 8: ldc #3 // String Hello World 10: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 13: aload_1 14: monitorexit 15: goto 23 18: astore_2 19: aload_1 20: monitorexit 21: aload_2 22: athrow 23: return 反编译后，我们可以看到Java编译器为我们生成的字节码。在对于doSth和doSth1的处理上稍有不同。也就是说。JVM对于同步方法和同步代码块的处理方式不同。 对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步。 对于同步代码块，JVM采用monitorenter、monitorexit两个指令来实现同步。关于这部分内容，在JVM规范中也可以找到相关的描述。 同步方法The Java® Virtual Machine Specification中有关于方法级同步的介绍： Method-level synchronization is performed implicitly, as part of method invocation and return. A synchronized method is distinguished in the run-time constant pool’s method_info structure by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions. When invoking a method for which ACC_SYNCHRONIZED is set, the executing thread enters a monitor, invokes the method itself, and exits the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may enter it. If an exception is thrown during invocation of the synchronized method and the synchronized method does not handle the exception, the monitor for the method is automatically exited before the exception is rethrown out of the synchronized method. 主要说的是： 方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。 同步代码块同步代码块使用monitorenter和monitorexit两个指令实现。 The Java® Virtual Machine Specification 中有关于这两个指令的介绍： monitorenter Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows: If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership. monitorexit The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. 大致内容如下： 可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。 总结同步方法通过ACC_SYNCHRONIZED关键字隐式的对方法进行加锁。当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法。 同步代码块通过monitorenter和monitorexit执行来进行加锁。当线程执行到monitorenter的时候要先获得所锁，才能执行后面的方法。当线程执行到monitorexit的时候则要释放锁。 每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁。即可重入锁。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2019%2F04%2F13%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[君不见，黄河之水天上来，奔流到海不复回。君不见，高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。—-李白《将进酒》 为什么要有内存模型在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型（Memory Model），然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。 CPU和缓存一致性我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。 可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。那么，程序的执行过程就变成了： 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。那么，在有了多级缓存之后，程序的执行就变成了： 当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。 单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。下图为一个CPU双核的缓存结构。 随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。 单线程。cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。 单核CPU，多线程。进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。 在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。 处理器优化和指令重排上面提到在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。 可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。 并发编程的问题前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。 这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性： 1、原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。 2、可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 3、有序性即程序执行的顺序按照代码的先后顺序执行。 有没有发现，缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。 什么是内存模型前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。 所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。 为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。 什么是Java内存模型前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。 我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。 本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。 所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。 Java内存模型的实现了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。 在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。 本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。 原子性在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。这两个字节码，在Java中对应的关键字就是synchronized。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。 可见性Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同， 有序性在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。 好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构、Java内存模型和Java对象模型]]></title>
    <url>%2F2019%2F04%2F13%2FJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8CJava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[休对故人思故国，且将新火试新茶，诗酒趁年华。—-苏轼《望江南》 JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： 以上是JVM规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。根据JVM规范，JVM把内存划分成了这几个区域（其中，方法区和堆是所有线程共享的）： 1.方法区（Method Area） 2.堆区（Heap） 3.虚拟机栈（JVM Stack） 4.本地方法栈（Native Method Stack） 5.PC寄存器（The PC Register） 方法区（Method Area）方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。方法区是全局共享的，在一定条件下也会被GC（Garbage Collection）。当方法区超过它允许的大小时，就会抛出OutOfMemory：PermGen Space异常。 在Hotspot虚拟机中，这块区域对应持久代（Permanent Generation），一般来说，方法区上执行GC的情况很少，因此方法区被称为持久代的原因之一，但这并不代表方法区上完全没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在方法区上进行GC，条件相当苛刻而且困难。 如图中所示，运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。 堆区（Heap）堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。 Java虚拟机栈（JVM Stack）虚拟机栈占用的是操作系统内存，每个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Statck Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，栈帧入栈，当方法调用结束时，栈帧出栈。 局部变量表中存储着和方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此他有个特点：内存空间可以在编译期间就确定，运行时不再改变。 虚拟机栈定义了两种异常类型：StackOverFlowError(栈溢出)和OutOfMemoryError（内存溢出）。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StackOverFlowError；不过大多数虚拟机都允许动态扩展虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足时，抛出OutOfMemoryError。 本地方法栈（Native Method Stack）本地方法栈用于支持native方法的执行，存储了每个native方法的执行状态。本地方法栈和虚拟机栈他们的运行机制一致，唯一的区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。 PC寄存器（The PC Register）PC寄存器（The PC Register）是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，程序猿无法操作它，它的作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变PC寄存器（程序计数器）的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。 每个PC寄存器只能记录一个线程的行号，因此它是线程私有的。如果程序当前正在执行的是一个java方法，则PC寄存器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则寄存器的值为空，此内存区是唯一不会抛出OutOfMemoryError的区域。 Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿。在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型（Java Memory Model）简称JMM。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，它描述了一组规则或规范，这个规范定义了一个线程在对共享变量进行写入时对另一个线程是可见的。 简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。下面是JMM抽象示意图： Java对象模型我们都知道Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。这个关于Java对象自身的存储模型称之为Java对象模型。 在HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的instanceKlass。下面是一个简单的Java对象的OOP-Klass模型，即Java对象模型。 从上图中可以看到，在方法区的instantKlass中有一个int a=1的数据存储。在堆内存中的两个对象的oop中，分别维护着int b=3,int b=2的实例数据。和oopDesc一样，instantKlass也维护着一些fields，用来保存类中定义的类数据，比如int a=1。 总结最后，我们再来区分下JVM内存结构、 Java内存模型 以及Java对象模型这三个概念：JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。Java对象模型和Java对象在虚拟机中的表现形式有关。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中碰到的问题]]></title>
    <url>%2F2019%2F04%2F13%2FMySQL%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我把天空和大地打扫地干干净净，归还一个陌不相识的人。—-海子《黎明》 在使用group by时碰到的问题(1)选择列表中的列无效，因为该列没有包含在聚合函数或者group by子句中。 select id,name,count(0) as cx from student group by id order by cx desc 其中name会无效，因为该列没有包含在聚合函数或者group by子句当中。也就是说：在select需要查询语句中选中的字段，必须出现在group by子句中。我们还需注意的是：group by和order by一起使用时，order by要在group by的后面。 (2)每个 group by 表达式必须至少包含一个不是外部引用的列。 select count(0)，nothing from student group by nothing having name=&apos;echodemo&apos; 出错的原因是因为group by语句所跟的内容一般是数据表中的字段或者数据表的表达式，因为上边的句子中在group by后边使用的是数据表中不存在的字段且也不是数据表的表达式，为外部实例，所以才会报上变得错误。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁与悲观锁]]></title>
    <url>%2F2019%2F04%2F13%2F%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[死亡不是真的逝去，遗忘才是永恒的消亡。—-李·昂克里奇《寻梦环游记》 数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。而乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 其实无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。乐观锁和悲观锁的概念不仅仅是关系型数据库系统所具有的，像memcache、hibernate、tair等都有类似的概念。 针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 悲观锁在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据） 在数据库中，悲观锁的流程如下：在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0。 //0.开始事务 begin;/begin work;/start transaction; (三者选一就可以) //1.查询出商品信息 select status from t_goods where id=1 for update; //2.根据商品信息生成订单 insert into t_orders (id,goods_id) values (null,1); //3.修改商品status为2 update t_goods set status=2; //4.提交事务 commit;/commit work; 上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。 乐观锁在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。 使用版本号实现乐观锁使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 //1.查询出商品信息 select (status,status,version) from t_goods where id=#{id} //2.根据商品信息生成订单 insert into t_orders (id,goods_id) values (null,1); //3.修改商品status为2 update t_goods set status=2,version=version+1 where id=#{id} and version=#{version}; 优点与不足乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的读锁和写锁]]></title>
    <url>%2F2019%2F04%2F13%2FMySQL%E4%B8%AD%E7%9A%84%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81%2F</url>
    <content type="text"><![CDATA[即使明天早上，枪口和血淋淋的太阳，让我交出自由、青春和笔，我也绝不会交出这个夜晚。—-北岛《履历》 本文提到的读锁和写锁都是MySQL数据库的MyISAM引擎支持的表级锁。而对于行级锁的共享读锁和互斥写锁请阅读MySQL中的共享锁与排他锁。其实共享锁指的就是读锁！互斥锁、排他锁、独占锁值得都是写锁。 重点知识回顾MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB存储引擎采用的是页面锁(page-level locking)，但也支持表级锁;InnoDB存储引擎既支持行级锁(row-level locking)，也支持表级锁，但默认情况下是采用行级锁。 表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高，并发度最低。 行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低，并发度也最高。 页面锁:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁之间，并发度一般。 MyISAM表锁MyISAM 存储引擎只支持表锁，MySQL 的表级锁有两种模式:表共享读锁(Table Read Lock)和表独占写锁(Table Write Lock)。 对于读操作，可以增加读锁，一旦数据表被加上读锁，其他请求可以对该表再次增加读锁，但是不能增加写锁。（当一个请求在读数据时，其他请求也可以读，但是不能写，因为一旦另外一个线程写了数据，就会导致当前线程读取到的数据不是最新的了。这就是不可重复读现象） 对于写操作，可以增加写锁，一旦数据表被加上写锁，其他请求无法在对该表增加读锁和写锁。（当一个请求在写数据时，其他请求不能执行任何操作，因为在当前事务提交之前，其他的请求无法看到本次修改的内容。这有可能产生脏读、不可重复读和幻读） 读锁和写锁都是阻塞锁。如果t1对数据表增加了写锁，这时t2请求对数据表增加写锁，t2并不会直接返回，而是会一直处于阻塞状态，直到t1释放了对表的锁，这时t2便有可能加锁成功，获取到结果。 表锁的加锁/解锁方式MyISAM 在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行更新操作 (UPDATE、DELETE、INSERT 等)前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。如果用户想要显示的加锁可以使用以下命令： 锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…] 解锁表：UNLOCK TABLES 在用 LOCK TABLES 给表显式加表锁时,必须同时取得所有涉及到表的锁。在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表;如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。 //对表test_table增加读锁： LOCK TABLES test_table READ UNLOCK test_table //对表test_table增加写锁： LOCK TABLES test_table WRITE UNLOCK test_table 当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错! 比如如下SQL语句： select a.first_name,b.first_name, from actor a,actor b where a.first_name = b.first_name; 该Sql语句中，actor表以别名的方式出现了两次，分别是a,b，这时如果要在该Sql执行之前加锁就要使用以下Sql: lock table actor as a read,actor as b read; 并发插入上文提到过 MyISAM 表的读和写是串行的,但这是就总体而言的。在一定条件下,MyISAM表也支持查询和插入操作的并发进行。 MyISAM存储引擎有一个系统变量concurrent_insert,专门用以控制其并发插入的行为,其值分别可以为0、1或2。 1、当concurrent_insert设置为0时,不允许并发插入。 2、当concurrent_insert设置为1时,如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时,另一个进程从表尾插入记录。这也是MySQL的默认设置。 3、当concurrent_insert设置为2时,无论MyISAM表中有没有空洞,都允许在表尾并发插入记录。可以利用MyISAM存储引擎的并发插入特性,来解决应用中对同一表查询和插入的锁争用。 MyISAM的锁调度前面讲过,MyISAM 存储引擎的读锁和写锁是互斥的,读写操作是串行的。那么,一个进程请求某个MyISAM 表的读锁,同时另一个进程也请求同一表的写锁,MySQL 如何处理呢? 答案是写进程先获得锁。 不仅如此,即使读请求先到锁等待队列,写请求后到,写锁也会插到读锁请求之前!这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因,因为,大量的更新操作会造成查询操作很难获得读锁,从而可能永远阻塞。这种情况有时可能会变得非常糟糕!不过幸好我们可以通过 一些设置来调节 MyISAM 的调度行为。 1、通过指定启动参数low-priority-updates,使MyISAM引擎默认给予读请求以优先的权利。 2、通过执行命令SET LOWPRIORITYUPDATES=1,使该连接发出的更新请求优先级降低。 3、通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性,降低该语句的优先级。 另外,MySQL也提供了一种折中的办法来调节读写冲突,即给系统参数max_write_lock_count 设置一个合适的值,当一个表的读锁达到这个值后,MySQL就暂时将写请求的优先级降低, 给读进程一定获得锁的机会。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的共享锁与排他锁]]></title>
    <url>%2F2019%2F04%2F13%2FMySQL%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E4%BB%96%E9%94%81%2F</url>
    <content type="text"><![CDATA[从别后，忆相逢，几回魂梦与君同。—-晏几道《鹧鸪天》 在MySQL中的行级锁,表级锁,页级锁中介绍过，行级锁是Mysql中锁定粒度最细的一种锁，行级锁能大大减少数据库操作的冲突。行级锁分为共享锁和排他锁两种，本文将详细介绍共享锁及排他锁的概念、使用方式及注意事项等。 共享锁(Share Lock)共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。 SELECT ... LOCK IN SHARE MODE; 在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。 排他锁（eXclusive Lock）排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。 SELECT ... FOR UPDATE; 在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。 意向锁InnoDB还有两个表锁： 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。 注：意向锁是InnoDB自动加的，不需要用户干预。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql中的行级锁、表级锁、页级锁]]></title>
    <url>%2F2019%2F04%2F13%2FMysql%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%2F</url>
    <content type="text"><![CDATA[我的建议是：出发吧。给你的宇宙套上马鞍，看它会变成什么样？—-《瑞克和莫蒂》 在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。 行级锁行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。 特点:开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 表级锁表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点:开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁表级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁.表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 MySQL常用存储引擎的锁机制MyISAM和MEMORY采用表级锁(table-level locking)。 BDB采用页面锁(page-level locking)或表级锁，默认为页面锁。 InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。 Innodb中的行锁与表锁前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？ InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。 行级锁与死锁MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。 在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。 当两个事务同时执行，一个锁住了主键索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。 有多种方法可以避免死锁，这里只介绍常见的三种: 1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的读现象浅析]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E7%8E%B0%E8%B1%A1%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[别怕美好的一切会消失，咱们先来让它存在。—-王小波《爱你就像爱生命》 “读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。 脏读脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据,那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 不可重复读不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。 幻读幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。 幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。 解决方案要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Limit的用法]]></title>
    <url>%2F2019%2F04%2F13%2FLimit%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[春天来得很慢，春天才有浪漫。 —-deca joins《夜间独白》 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。 SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis中的事件处理]]></title>
    <url>%2F2019%2F04%2F05%2FRedis%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件： 文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字（Socket）操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。 时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。 注：TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）。 文件事件文件事件处理器文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器；当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。下图是Redis线程模型： 文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。 （1）文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。 （2）I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。如果你不太清楚IO多路复用程序可以阅读我的这篇博客：Redis中的IO多路复用 （3）文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。 （4）事件处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。 时间事件时间事件分为以下两类： 定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次; 周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。 时间事件主要由以下三个属性组成： id：服务器为时间事件创建的全局唯一ID（标识号）。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大; when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间; timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。 一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值： 如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达; 如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。(现在的Redis主要使用这个)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Redis]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%88%9D%E8%AF%86Redis%2F</url>
    <content type="text"><![CDATA[你身体里的每一粒原子都来自一颗爆炸了的恒星。形成你左手的原子和形成你右手的原子也许来自不同的恒星。这是我所知的物理学中最富有诗意的事情：你们都是星辰。—-劳伦斯·克劳斯《一颗原子的时空之旅》 1，盛赞RedisRedis（REmote Dictionary Server）的前身是一个叫做LLOOGG的网站，在2008年，Redis的作者在开发该网站时，需要实现一个高性能的队列功能，最开始是使用MySQL来实现的， 但后来发现无论如何优化SQL语句都无法使网站的性能提高上去，他决定做一个专属于LLOOGG的数据库 。 Redis是一种基于键值对（key-value）的NoSQL数据库。NoSQL(NoSQL = Not Only SQL )。是对不同于传统的关系型数据库的数据库管理系统的统称。高可扩展性，分布式计算，低成本，架构的灵活性等特性。 国外的Twitter、 Instagram、Stack Overflow、GitHub，国内像新浪微博、阿里巴巴、腾讯、百度、搜狐、优酷土豆、美团、小米、唯品会等公司都是 Redis的使用者。 2,Redis特性1、速度快 2、基于键值对的数据结构服务器 3、丰富的功能 4、简单稳定 5、客户端语言多 6、持久化 7、主从复制 8、高可用和分布式 （1）速度快 Redis的所有数据都是存放在内存当中。它是完全基于内存，其绝大部分请求是纯粹的内存操作。 Redis使用了单线程架构。避免了不必要的上下文切换和竞争条件，从而不存在多进程或者多线程切换导致的CPU消耗问题，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 采用了非阻塞I/O多路复用机制。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，此时程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流。阻塞式I/O如果要接收更多的连接，就必须创建更多的线程。在I/O复用模式下大量的连接统统都可以过来直接注册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。这就是I/O复用与传统的阻塞式I/O最大的不同。也正是I/O复用的精髓所在。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）。具体的关于I/O多路复用可以查看我的这篇文章：I/O多路复用 Redis是用C语言实现的。一般来说C语言实现的程序“距离”操作系统更近，执行速度相对会更快。 （2）基于键值对的数据结构服务器 与很多键值对数据库不同的是，Redis中的值不仅可以是字符串，而且还可以是具体的数据结构，Redis它主要提供了5种数据结构：字符串（String）、哈希（Hash)、列表（List）、集合（Set）、有序集合（Sorted Set），同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种神奇的“数据结构”，并且随着 LBS（Location Based Service，基于位置服务）的不断发展，Redis3.2版本中加入有关GEO（地理信息定位）的功能，在这些数据结构的帮助下，不仅提高了开发的效率，而且适用于更多的应用场景。 （3）丰富的功能 1、提供了键过期功能，可以用来实现缓存。 2、提供了发布订阅功能，可以用来实现消息系统。 3、支持Lua脚本功能，可以利用Lua创造出新的Redis命令。 4、提供了简单的事务功能，能在一定程度上保证事务特性。 5、提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到 Redis，减少了网络的开销。 （4）简单稳定 Redis的源码很少，早期版本的代码只有2万行左右，3.0版本以后由于添加了集群特性，代码增至5万行左右，也就意味着普通的开发和运维人员完全可以“吃透”它。 Redis使用单线程模型，这样不仅使得Redis服务端处理模型变得简单，而且也使得客户端开发变得简单。 Redis不需要依赖于操作系统中的类库（例如Memcache需要依赖 libevent这样的系统类库），Redis自己实现了事件处理的相关功能。 （5）客户端语言多 Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入到 Redis，几乎涵盖了主流的编程语言，例如Java、PHP、 Python、C、C++、Nodejs等。 （6）持久化 我们都知道的是：将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失。Redis提供了两种持久化方式用来将内存的数据保存到硬盘：RDB和 AOF。 RDB(Redis DataBase)是在某个时间点将数据（Database中的key-value的二进制形式数据）写入一个临时的rdb文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。它是通过配置Redis在n秒内如果超过m个key被修改就执行一次RDB操作，这中持久化的方式也叫做snapshots。RDB是间隔一段时间进行持久化，如果在持久化之间发生故障，会发生数据的丢失，所以这种方式更适合数据要求不严谨的时候。 AOF(Append Only File)把数据的每一条修改命令都追加到aof文件。该“日志文件”保存了历史所有的操作过程，虽然可以保证数据的不易丢失，但是这样也造成了其文件势必会比rdb文件大很多，且aof文件中存储的是命令，导致其恢复的速度变慢。 （7）主从复制 Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。 （8）高可用和分布式 Redis从2.8版本正式提供了高可用实现Redis Sentinel，它能够保证Redis 节点的故障发现和故障自动转移。Redis从3.0版本正式提供了分布式实现 Redis Cluster，它是Redis真正的分布式实现，提供了高可用、读写和容量的扩展性。 3，Redis使用场景 （1）缓存 Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。 （2）排行榜系统 Redis提供了列表和有序集合数据结构。 （3）计数器应用 传统关系型数据库如果并发量很大，为了保证数据的实时性，对其性能是一种很大的挑战。Redis天然支持计数功能而且计数的性能也非常好。 （4）社交网络 由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存点赞，推送，下拉刷新等类型的数据，而Redis提供的数据结构可以相对比较容易地实现这些功能。 （5）消息队列系统 Redis提供了发布订阅功能和阻塞队列的功能。 （6）Redis不适合的场景 不适合存储大规模的数据和冷数据。 4，安装Redis （1）在Linux上安装Redis $ wget http://download.redis.io/releases/redis-3.0.7.tar.gz $ tar xzf redis-3.0.7.tar.gz $ ln -s redis-3.0.7 redis $ cd redis $ make $ make install 1、下载Redis指定版本的源码压缩包到当前目录。 2、解压缩Redis源码压缩包。 3、建立一个redis目录的软连接，指向redis-3.0.7。这是为了不把redis目录固定在指定版本上，有利于Redis未来版本升级， 是安装软件的一种好习惯。 4、进入redis目录。 5、编译（编译之前确保操作系统已经安装gcc）。 6、安装。将Redis的相关运行文 件放到/usr/local/bin/下，这样就可以在任意目录下执行Redis的命令。 （2）在Windows上安装Redis 5，启动、操作、关闭Redis 启动Redis服务 （1）默认配置 $ redis-server （2）运行启动 $ redis-server --configKey1 configValue1 --configKey2 configValue2 （3）配置文件启动 $ redis-server /opt/redis/redis.conf Redis命令行客户端 （1）交互式方式 $ redis-cli -h 127.0.0.1 -p 6379 $ 127.0.0.1:6379&gt; set hello world $ OK $ 127.0.0.1:6379&gt; get hello $ &quot;world&quot; （2）命令方式 $ redis-cli -h 127.0.0.1 -p 6379 get hello $ &quot;world&quot; 注：如果没有-h参数，那么默认连接127.0.0.1；如 果没有-p，那么默认6379端口，也就是说如果-h和-p都没写就是连接 127.0.0.1：6379这个Redis实例。 停止Redis服务 Redis提供了shutdown命令来停止Redis服务，如果要停掉127.0.0.1上 6379端口上的Redis服务： $ redis-cli shutdown]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis中的I/O多路复用]]></title>
    <url>%2F2019%2F04%2F05%2FRedis%E4%B8%AD%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[人真正活过的那段生命仅仅是一小部分。其余的部分不能算是生命，仅仅是时间而已。—-伊坂幸太郎《死神的精确度》 在谈I/O多路复用机制之前，我们先来讲讲阻塞I/O和非阻塞I/O。 1、阻塞I/O我们常用的IO操作（比如read和write）都是阻塞I/O，也就是说当你调用read时，如果没有收到数据的返回，那么线程或者进程就会被挂起，直到收到数据。阻塞的意思，就是一直等着。阻塞I/O就是等着数据返回，进行读写操作。通过应用的函数进行调用，但是内核一直没有返回，就一直等着。应用的函数长时间处于等待数据返回的状态，我们就称之为阻塞I/O。 2、非阻塞I/O非阻塞IO是通过fcntl（POSIX）或ioctl（Unix）设为非阻塞模式。此时，当你调用read时，如果有数据收到，就返回数据；如果没有数据收到，就立刻返回一个错误。这样的话就不存在线程的阻塞了，但是你还是要不断的轮询来读取或写入。相当于你去查看有没有数据，告诉你没有，过一会再来吧！应用过一会再来问，有没有数据？没有数据，会有一个返回。但是依旧很不好。应用必须得过一会来一下，问问内核有木有数据啊。 3、I/O多路复用这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路复用是指使用一个线程来检查多个Socket的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。什么意思呢？就是派一个代表，同时监听多个文件描述符是否有数据到来。等着等着，如果有数据，就告诉某某你的数据来啦！赶紧来处理吧。 我们先来看一张JDK的基于I/O多路复用技术的NIO实现的图片，如下： 从图片中我们可以看到，很多的网络连接都向Selector进行注册，Selector会对已经向它注册了的网络连接进行轮询监控，一旦发现某个网络连接有了数据的返回，便通过SelectKey通知相应的Channel。从而达到多路复用的目的。 Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换。下面是redis线程模型，如图所示： 我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。更详细的关于redis中的事件处理请参见我的这篇文章：Redis中的事件处理]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONField注解]]></title>
    <url>%2F2019%2F03%2F07%2F2019-03-7-JSONField%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、JSONField介绍 package com.alibaba.fastjson.annotation; public @interface JSONField { // 配置序列化和反序列化的顺序，1.1.42版本之后才⽀持 int ordinal() default 0; // 指定字段的名称 String name() default &quot;&quot;; // 指定字段的格式，对⽇期格式有⽤ String format() default &quot;&quot;; // 是否序列化 boolean serialize() default true; // 是否反序列化 boolean deserialize() default true; } 若属性是私有的，必须有set*方法。否则无法反序列化。2、JSONField配置方式 （1）配置在getter/setter⽅法上。 public class A { private int id; @JSONField(name=&quot;ID&quot;) public int getId() {return id;} @JSONField(name=&quot;ID&quot;) public void setId(int value) {this.id = id;} } （2）配置在属性上 public class A { @JSONField(name=&quot;ID&quot;) private int id; public int getId() {return id;} public void setId(int value) {this.id = id;} } （3）使⽤format配置⽇期格式化 public class A { // 配置date序列化和反序列使⽤yyyyMMdd日期格式 @JSONField(format=&quot;yyyyMMdd&quot;) public Date date; } （4）使⽤serialize/deserialize指定字段不序列化 public class A { @JSONField(serialize=false) public Date date; } （5）使⽤ordinal指定字段的顺序 public static class VO { @JSONField(ordinal = 3) private int f0; @JSONField(ordinal = 2) private int f1; @JSONField(ordinal = 1) private int f2; } 缺省fastjson序列化一个java bean，是根据fieldName的字母序进⾏序列的你可以通过ordinal指定字段的顺序。这个特性需要1.1.42以上版本。（6）使用serializeUsing制定属性的序列化类 在fastjson 1.2.16版本之后，JSONField⽀持新的定制化配置serializeUsing，可以单独对某一个类的某个属性定制序列化。 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField; import com.alibaba.fastjson.serializer.JSONSerializer; import com.alibaba.fastjson.serializer.ObjectSerializer; import java.io.IOException; import java.lang.reflect.Type; public class MyTest { public static class A { @JSONField(serializeUsing = AValueSerializer.class) public int value; } public static class AValueSerializer implements ObjectSerializer { @Override public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException { Integer value = (Integer) object; String text = value + &quot;元&quot;; serializer.write(text); } } public static void main(String[] args) { A obj = new A(); obj.value = 100; String json = JSON.toJSONString(obj); System.out.println(json); } } （7）JSONField jsonDirect 在fastjson-1.2.12版本中，JSONField⽀持⼀个新的配置项jsonDirect，它的作⽤是：当你有⼀个字段是字符串类型，⾥⾯是json格式数据，你希望直接输出，⽽不是经过转义之后再输出。 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField; import com.alibaba.fastjson.serializer.JSONSerializer; import com.alibaba.fastjson.serializer.ObjectSerializer; import java.io.IOException; import java.lang.reflect.Type; public class MyTest { public static void main(String[] args) { B b = new B(); b.id = 9999; b.value = &quot;{}&quot;; String json = JSON.toJSONString(b); System.out.println(json); } public static class B{ public int id; @JSONField(jsonDirect = true) public String value; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器错误码]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E9%94%99%E8%AF%AF%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1、1XX100（继续）：请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换。 2、2XX200（成功）：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 203（非授权信息）：服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）：服务器成功处理了请求，但没有返回任何内容。 205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 206（部分内容）：服务器成功处理了部分 GET 请求。 3、3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305（使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4、4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。 404（未找到）：服务器找不到请求的网页。 405（方法禁用）：禁用请求中指定的方法。 406（不接受）：无法使用请求的内容特性响应请求的网页。 407（需要代理授权）：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408（请求超时）：服务器等候请求时发生超时。 409（冲突）：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410（已删除）：如果请求的资源已永久删除，服务器就会返回此响应。 411（需要有效长度）：服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件）：服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大）：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长）：请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型）：请求的格式不受请求页面的支持。 416（请求范围不符合要求）：如果页面无法提供请求的范围，则服务器会返回此状态代码。 417（未满足期望值）：服务器未满足”期望”请求标头字段的要求。 5、5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误）：服务器遇到错误，无法完成请求。 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关）：服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504（网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《房思琪的初恋乐园》摘句]]></title>
    <url>%2F2019%2F02%2F16%2F%E3%80%8A%E6%88%BF%E6%80%9D%E7%90%AA%E7%9A%84%E5%88%9D%E6%81%8B%E4%B9%90%E5%9B%AD%E3%80%8B%E6%91%98%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1、刚刚在饭桌上，思琪用面包涂奶油的口气对妈妈说：“我们的家教好像什么都有，就是没有性教育。”妈妈诧异地看着她，回答：“什么性教育？性教育是给那些需要性的人。所谓教育不就是这样吗？”思琪一时间明白了，在这个故事中父母将永远缺席，他们旷课了，却自以为是还没开学。 2、他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。罪恶感是古老而血统纯正的牧羊犬。 3、思琪在家一面整理行李，一面用一种天真的口吻对妈妈说：“听说学校有个同学跟老师在一起。”“谁？”“不认识。”“这么小年纪就这么骚。”思琪不说话了。她一瞬间决定从此一辈子不说话了。她脸上挂着天真的表情把桌上的点心。 4、思琪的声音像一盘冷掉的菜肴，她说：“怡婷，我早已不是我自己了，那是我对自己的乡愁。” 5、整个中学生涯，她拒绝过许多中学生，一些高中生，几个大学生。她每次都说这一句“对不起，我真的没办法喜欢你”，一面说一面感觉木木的脸皮下有火烧上来。 其实是我配不上你们。我是馊掉的橙子汁和浓汤，我是爬满虫卵的玫瑰和百合，我是一个灯火流丽的都市里明明存在却没有人看得到也没有人需要的北极星。 6、为什么这个世界是这个样子？为什么所谓教养就是受苦的人该闭嘴？为什么打人的人上电视上广告广告牌？姐姐，我好失望，但我不是对你失望，这个世界，或是生活、命运，或叫它神，或无论叫它什么，它好差劲，我现在读小说，如果读到赏善罚恶的好结局，我就会哭，我宁愿大家承认人间有一些痛苦是不能和解的，我最讨厌人说经过痛苦才成为更好的人，我好希望大家承认有些痛苦是毁灭的，我讨厌大团圆的抒情传统，讨厌王子跟公主在一起，正面思考是多么媚俗！可是姐姐，你知道我更恨什么吗？我宁愿我是一个媚俗的人，我宁愿无知，也不想要看过世界的背面。 7、其实我第一次想到死的时候就已经死了。人生如衣物，如此容易被剥夺。 8、我要等等我灵魂的双胞胎，她被你丢弃在十三岁，也被我遗忘在十三岁，我要躺在那里等她，等她赶上我，我要跟她在一起。抱住他的小腿。 9、怡婷，你才十八岁，你有选择，你可以假装世界上没有人以强暴小女孩为乐；假装从没有小女孩被强暴；假装思琪从不存在；假装你从未跟另一个人共享奶嘴、钢琴，从未有另一个人与你有一模一样的胃口和思绪，你可以过一个资产阶级和平安逸的日子；假装世界上没有精神上的癌；假装世界上没有一个地方有铁栏杆，栏杆背后人人精神癌到了末期；你可以假装世界上只有马卡龙、手冲咖啡和进口文具。但是你也可以选择经历所有思琪曾经感受过的痛楚，学习所有她为了抵御这些痛楚付出的努力，从你们出生相处的时光，到你从日记里读来的时光。你要替思琪上大学，念研究所，谈恋爱，结婚，生小孩，也许会被退学，也许会离婚，也许会死胎。但是，思琪连那种最庸俗、呆钝、刻板的人生都没有办法经历。你懂吗？你要经历并牢牢记住她所有的思想、思绪、感情、感觉，记忆与幻想、她的爱、讨厌、恐惧、失重、荒芜、柔情和欲望，你要紧紧拥抱着思琪的痛苦，你可以变成思琪，然后，替她活下去，连思琪的份一起好好地活下去。 10、忍耐不是美德，把忍耐当成美德是这个伪善的世界维持它扭曲的秩序的方式，生气才是美德。11、我怕消费任何一个房思琪。我不愿伤害她们。不愿猎奇。不愿煽情。我每天写八个小时，写的过程中痛苦不堪，泪流满面。写完以后再看，最可怕的就是：我所写的、最可怕的事，竟然是真实发生过的事。而我能做的只有写。女孩子被伤害了。女孩子在读者读到这段对话的当下也正在被伤害。而恶人还高高挂在招牌上。我恨透了自己只会写字。” 感：“任何关于性的暴力都是‘社会性’的，或许应该这么说，任何关于性的暴力，都不是由施暴者独立完成的，而是由整个社会协助施暴者完成。”李国华和钱一维固然是直接的施暴者，但无论是补习班官方、小孩的家长，甚至是班主任都帮他降低女孩的戒心。其中更重要的是那些无形的“社会”：“他发现社会对性的禁忌感太方便了，强暴一个女生，全世界都觉得是她自己的错，连她都觉得是自己的错。罪恶感又会把她赶回他身边。”包括思琪的至亲怡婷和父母，都对性有着万水千山的阻隔和禁忌。此书不仅在文学创作的手法上独具特色，更为重要的是反映了社会广泛存在的性观念问题。实在是无法想象作者是在什么样的精神斗争中完成了该作品。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《不止代码》摘句(二)]]></title>
    <url>%2F2019%2F02%2F16%2F%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[什么是架构？在我看来软件架构就是将人员、技术等资源组织起来以解决业务问题，支撑业务增长的一种活动。可能比较抽象，我想我们可以从架构师的一些具体工作任务来理解这句话含义： 1、组织业务：架构师通过探索和研究业务领域的知识，构建自身看待业务的”世界观”。他会基于这种认识拆分业务生命周期，确立业务边界，构建出了一套解决特定业务问题的领域模型，并且确认模型之间、领域之间的关系与协作方式，完成了对业务领域内的要素的组织工作。 2、组织技术：为了能在计算机世界中运作人类社会的业务模型，架构师需要选用计算机世界中合适的框架、中间件、编程语言、网络协议等技术工具依据之前设计方案组织起来形成一套软件系统方案，在我看来软件系统就像是一种技术组织，即技术组件、技术手段依据某种逻辑被组织起来了，这些技术工具被确定了职责，有了明确分工，并以实现业务功能为目标集合在了一起。比如 RPC 框架或消息队列被用于内部系统之间的通信服务就如同信使一般，而数据库则负责记录结果，它更像是一名书记员。 3、组织人员：为了能够实现利用软件系统解决业务问题的目标，架构师还需要关注软件系统的构建过程，他以实现软件系统为号召，从公司组织中聚集一批软件工程师，并将这些人员按不同工种、不同职责、不同系统进行组织，确定这些人员之间的协作方式，并关注这个组织系统是否运作良好比如沟通是否顺畅、产出是否达到要求、能否按时间完成等。 4、组织全局，对外输出：架构师的首要目标是解决业务问题，推动业务增长。所以他非常关心软件的运行状况。因为只有在软件系统运行起来后，才能对外提供服务，才能在用户访问的过程中，解决业务问题。架构师需要关注运行过程中产生的数据比如业务成功率，系统运行资源占用数据、用户反馈信息、业务增长情况等，这些信息将会帮助架构师制定下一步架构目标和方向。所以软件架构不仅仅只是选用什么框架、选用什么技术组件这么简单。它贯穿了对人的组织、对技术的组织、对业务的组织，并将这三种组织以解决业务问题这一目标有机的结合在了一起。 很多面试的候选人在被问及他所开发的系统采用什么架构的问题时，只会罗列出一些技术组件、技术框架等技术要素，这样看来其根本没有理清架构的深层含义。也有一些架构师只专注对底层技术的研究，以为打造一个卓越的系统是非常牛逼的事情，可是他忽略了软件系统的价值是以解决业务问题的能力、支撑业务增长的能力为衡量标准，所以最后生产出了很多对组织，对业务没有帮助的系统。 架构目标需要适应业务的发展架构的目标就是为了支撑业务增长，就是提升软件系统的服务能力。可是话虽说如此，但真实却要做很多取舍。比如对初创团队而言，其产品是否解决业务问题这一设想还没得到确认，就立即去构造一个高性能、高可用的分布式系统，这样的架构目标远超出业务发展的需求，最后的结果就是浪费大量人力物力，却得不到任何起色。架构师需要审时度势，仔细衡量正确性、大规模、可用性三者的关系，比如今年业务蓬勃发展日均订单 300 万，基于对未来的可能预测，明年可能有 3000 万的订单，那么架构师应该要着重考虑大规模和可用性。而且每一点提升的程度，也需要架构师衡量把握，比如可用性要达到 2 个 9 还是 3 个 9。回顾自己以往的工作很多时候就是因为没有确立架构目标导致浪费了组织很多资源，比如在之前的创业团队中，由于本人有一定的代码洁癖，经常会花费很多时间和同事计较代码质量，这样本可以更快上线的功能却需要被延迟，当时过度追求正确性的行为是与创业团队快速验证想法的业务需求不匹配的。 另外一点比较深刻的案例则是在本人担任一个技术团队负责人的时候，在一次述职报告的时候，leader 问我对接下来团队工作有什么计划？我当时说了一堆什么改进代码质量，每天晨会，任务透明化，建立迭代机制等等，然后就被各种批驳一通。当时团队基本以外包人员为主，人员水平较差，开发出来的金融系统也是千疮百孔而这条业务线最重要的业务价值则是按计划实现潜在投资方的需求，争取拉到投资。所以不久 leader 就召集测试架构的相关人员与我这边一同梳理对核心功能的测试工作，将研发、测试、上线的流程自动化。 当时并不理解这样做核心价值是什么。但回过头来看这样的工作方式恰好符合了业务发展的需求，即确保系统是符合设计需求的，保证系统达到可接受的正确性，为后续能过快速前进打下基础，最重要的是为企业降低了构建成本。所以程序员想要工作出业绩，必须认清楚系统背后的业务价值，按价值去梳理工作优先级，而不是像我一般过度纠结细节，追求技术理想化。 从价值出发－找寻学习与工作的新思路迷茫能引发思考，架构则塑造了视野，而价值则是我们之所以存活，之所以工作的逻辑起点。基于这样一种价值思维，对我们的学习和工作又可以有哪些改启示呢？明确自身的业务相关主体：找出你工作的协作关系网内的业务方和客户方，这样你就可以从客户方中找到离你最近的业务价值点，从你的业务方中挖掘更多的资源。甚至你可以按这个思路顺着网络向上或向下挖掘价值链条，整合更多的上下游资源以实现更大的价值。 向前一步，为更大的价值负责：不要因为自己是开发人员就不去关注软件运维，不要因为只是测试就不关注软件开发，因为你关注的越多你越能看清全局的价值目标。如果只关注一亩三分地，那么注定这辈子只能困守在这一亩三分地里，成为一名流水线上焦虑至死的码农。试着转变思维，从架构师的角度思考价值问题，看看能否将技术贯穿到业务、到用户、到最终的价值去。之前我的朋友说过要把产品经理踢到运营位置去，把程序员踢到产品经理位置去，这样才是正确做事方式。这句话也是类似的意思，向前一步才能懂得怎么做的更好。 像架构师一样思考，用价值找寻重心：人的迷茫是因为找不到重心，而价值的意义在于引导我们思考做哪些事情才能实现价值，先做哪些事情会比后做哪些事情更能创造收益。像架构师那样全局性思考，把遇到问题进行拆分，把学习到的事物串联起来，努力构成完整的价值链条。学会连接，构建体系：前几天看到一篇文章对今日头条的产品形态极尽批判之词，指责它的智能算法将人类封死在自己的喜好之中，将人类社会进一步碎片化。这似乎很有道理，有趣的是互联网将我们连接至广袤的世界，却也把我们封闭在独属于自己的小世界里。依旧是我的那位朋友，他说他的最大价值在于连接，将不同的人连接在一起，有趣的事情可能就会即将发生。或许算法的天性就是顺从与迎合，但人最终想理解这个世界还是需要依靠自身的行动与不同人之间建立联系，这也是一种摆脱流水线限制的有效方式。另外，我们自身也是某种事物连接的产物，比如架构师，他是业务、技术、管理连接在一起的一种产物。所以我们应当树立自身的知识体系以吸收融合新知识，将孤立的概念连接起来，形成自身的价值链条。比如这篇文章将我从事技术开发经验、与对架构的理解以及自身过往经历结合起来，这也是一种内在的体系梳理。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《不止代码》摘句(一)]]></title>
    <url>%2F2019%2F02%2F16%2F%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[第一阶段：大学毕业3到5年● 基础的 Java 知识：你会开始看《Java 编程思想》、《Effective Java》。 ● 高质量代码进阶知识：你会开始看《重构：改善既有代码的设计》、《代码大全》、《编程珠玑》。 ● 常用的主流框架：比如 SSH 相关的《Spring 实战》、《Spring Boot 实战》、《Hibernate 实战 ( 第 2 版 )》。当然，这些书已经不够了，你会通过 Google、Baidu 大量地浏览在线的资源：Apache 官网、Spring 官网、Hibernate 官网。你会去 StackOverflow 问问题或找答案。 ● 系统设计与算法知识：《系统分析与设计方法》、《设计模式》、《需求分析与系统设计》、《面向对象分析与设计》、《UML 用户指南》、《算法导论》 ● 其他知识：比如数据库调优、缓存框架、NoSQL 数据库、日志框架等等 在这5年间，快速地完成这些基础知识的学习，并能在项目中快速地学以致用。不仅自身能获得比较高的成就感，而且实际的用人的单位、猎头也会非常喜欢这类熟练工。 从大部分人的实际发展轨迹看，这个阶段发展快的人和正常发展速度的人，差别还不是很大。比如，发展非常快的人，从毕业就入职阿里的 P5 到P7（注：阿里内部职称评级），可能三年就可以做到。发展速度正常的人，可能需要 5-6 年也可以到 P7。也就是说，这个阶段正常发展速度的同学也仅仅比发展速度快的人慢 2-3 年而已。 这 2 到 3 年的差距，是可以通过有针对性的学习、重大项目的历练等完成这些知识的学习。无非是，有的同学会严格要求自己，有严格的学习计划；有的同学赶早参加了一些重点的、痛苦的项目得到了锻炼。只要是做技术的，其实迟早都会经历过，都会成长起来。 第二阶段：大学毕业 5 到 10 年很多本科同学，特别是研究生同学。在毕业 10 年后，就已经到了 34、35 岁左右了。也是前段时间网上广泛讨论的所谓 34+ 岁现象。其实，年龄并不是问题的真正原因。真正的原因还是在于自身“竞争力”是否符合这个年龄所应该具备的。到了这个年龄的人，往往已经不是“个人贡献者”了，而是“团队贡献者”。团队贡献者可能是带团队的 TL，也可能是个架构师，在技术决策上具有团队影响力和话语权。 那么，为什么这些人能管理团队或者有影响力呢？从公司的经营视角看，一个管理团队的人，他必须为业务的成功负责。说个大白话，一个 TL 管了 N 个人，他至少要能保证大家输出所产生的价值，至少要高于这个团队的工资、奖金、五险一金、OPEX、CAPEX 等等吧。这个 TL 为了大家输出得有价值，他是不是需要能： ● 能对所负责领域的业务特点、发展趋势、友商竞争分析有很好的洞察？能知道这个业务领域的客户是谁？他们的需求是什么？他们的痛点是什么？所以，这个 TL 应该需要学习《咨询的奥秘》、《探索需求》、《系统化思维导论》。对于技术型的 TL，还应该了解《成为技术领导者：掌握全面解决问题的方法》。 ● 服务于特定领域的客户，我们需要能了解我们的客户企业架构、业务知识。要了解清楚规划的产品、服务，什么才是客户所需要的。那么，从理论上，我们是否应该学习一些 TOGAF、NGOSS、ITIL 等业务理论以及业务知识？ ● 作为 TL， 是否有必要能将自己对于市场的洞察转换成业务规划，并能向自己的老板（或者投资人）说清楚、讲明白？并争取到老板的同意，包括资金、人力资源等。对于，能否把事情讲明白，我们可能需要学习《金字塔原理》，并能非常清晰、有逻辑性地进行表达与沟通。当然，有些业务发展的事不一定特别有逻辑，是需要摸索、尝试，那么你是否能将一个不确定的领域说服老板并获得支持，我们又需要什么？《博弈论》、《影响力》等。 ● 获得老板支持后，就需要开始带着兄弟们干活了。作为带头人，你看我们是否需要能将业务趋势、客户痛点进行业务建模好让团队的 PD、技术都能理解？在做业务进一步深入分析，可能就需要学习《领域驱动设计 : 软件核心复杂性应对之道》、《实现领域驱动设计》、《企业应用架构模式》、《恰如其分的软件架构》等等。 ● 做完业务设计后，开始要带着团队做技术方案设计、接口设计以及编码实现等。这个过程，TL 又需要具备软件项目管理的能力。无论是《PMBOK 指南》，还是《敏捷软件开发》、《人月神话》、《程序开发心理学》，相信总归还是会有点帮助的。 ● 对于一些有国际化要求的，还需要再学习英语吧！ ● 嗯，还需要有个好的身体，还需要经常锻炼，学习科学的健身吧（说起来自己脸红）。至少我明白了一个道理，以前我都是跟自己说，等这段时间过了，闲下来去锻炼一下。其实，我发现，越是忙的时候，越需要锻炼身体！ ● 另外，在这 10 年内，比较关键的是——你还经历过什么有挑战的业务、技术、产品、平台等方面的成功与失败经验？在这些经历里，你可能会遇到这些困难与挑战：团队磨合的挑战、技术方案上的争执、平台优先 or 业务优先的博弈、低落的团队氛围、个人的低谷等等。这些困难与挑战，你是退缩了？还是有成长？在带团队时，再次面临这些挑战时，这时你是否有解或者有勇气了？ 发现没有？毕业 10 年后，作为一个团队贡献者，你可能需要具备这些能力，并且还远远不止。而且，更可悲的时，当毕业 10 年后，突然发现自己不具备这个能力时（比如晋升失败时发现了），这些能力GAP就不再是 2 到 3 年就能追得上的了。我见过一些有准备的同学，他们给自己的目标是在毕业第 7 年就要具备这些能力，他有严格的学习计划、实践计划、甚至是冒险的创业经历。当他到第 10 年这个点时，这些高阶技能很可能已经有 3 年的实践经验了。如果我们没有做好准备，10 年后，如何和这批人竞争？这些软、硬知识，从十年这个时间刻度倒排，学习计划、实践计划的执行还是很紧张的。所以，从现在开始给自己制定一个严格的学习计划、严格执行，多实践吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequestBody注解]]></title>
    <url>%2F2019%2F02%2F11%2FRequestBody%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)。 2、GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 3、在后端的同一个接收方法里，@RequestBody 与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 4、当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、数组、集合、对象等等(即:当@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。 5、如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值)，如果没有xxx名的话，那么请求会出错，报400。如果参数前不写@RequestParam(xxx)的话，那么前端可以有也可以没有对应的xxx名字，如果有xxx名的话，那么就会自动匹配；没有的话，请求也能正确发送。 6、如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求: (1)后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时,会根据json字符串中的key来匹配对应实体类的属性,如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性,这一条会在本节末尾详细分析。 (2)json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””,如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。json字符串中，如果value为null的话，后端对应收到的就是null。 (3)如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中;要么写value时，必须有值，null 或””都行。千万不能有类似”stature”:,这样的写法。 7、举例说明 (1)创建User类： package com.aspire.entity; /** * 用户实体类模型 * * @author JustryDeng * @date 2018年7月6日 上午1:55:59 */ @Data public class User { private String name; private Integer age; private String gender; private String motto; @Override public String toString() { return age + &quot;岁&quot; + gender + &quot;人[&quot; + name + &quot;]的座右铭居然是: &quot; + motto + &quot;!!!&quot;; } } 注：@Data注解请见Lombok(2)创建Team类： package com.aspire.entity; import java.util.List; /** * 小组测试实体类模型 * * @author JustryDeng * @date 2018年7月8日 下午11:23:51 */ @Data public class Team { private Integer id; private String teamName; private List&lt;String&gt; honors; private List&lt;User&gt; teamMembers; /** * 重写toString * * @see java.lang.Object#toString() */ @Override public String toString() { // 遍历出小组所获荣耀 StringBuffer sbHonors = new StringBuffer(&quot;荣耀start----\n&quot;); for (String honor : honors) { sbHonors.append(honor); sbHonors.append(&quot;\n&quot;); } sbHonors.append(&quot;荣耀end----\n&quot;); // 遍历出小组成员 StringBuffer sbMembers = new StringBuffer(&quot;成员start----\n&quot;); for (User user : teamMembers) { sbMembers.append(user.toString()); sbMembers.append(&quot;\n&quot;); } sbMembers.append(&quot;成员end----\n&quot;); return &quot;小组id:&quot; + id + &quot;\n&quot; + &quot;小组名字:&quot; + teamName + &quot;\n&quot; + &quot;小组所获荣誉:&quot; + sbHonors + &quot;\n&quot; + &quot;小组成员:&quot; + sbMembers; } } (3)@RequestBody直接以String接收前端传过来的json数据: @RequestMapping(&quot;mytest0&quot;) public String myTestController0(@RequestBody String jsonString) { System.out.println(jsonString); return jsonString; } (4)@RequestBody以简单对象接收前端传过来的json数据(SpringMVC会智能的将符合要求的数据装配进该User对象中): @RequestMapping(&quot;mytest1&quot;) public String myTestController1(@RequestBody User user) { System.out.println(user.toString()); return user.toString(); } (5)以较复杂的Team对象接收前端传过来的json数据 (SpringMVC会智能的将符合要求的数据装配进该Teamr对象中): @RequestMapping(&quot;mytest2&quot;) public String myTestController2(@RequestBody Team team) { System.out.println(team.toString()); return team.toString(); } (6)@RequestBody与简单的@RequestParam()同时使用: @RequestMapping(&quot;mytest3&quot;) public String myTestController3(@RequestBody User user, @RequestParam(&quot;token&quot;) String token) { System.out.println(user.toString()); System.out.println(token); return token + &quot;&gt;&gt;&gt;&quot; + user.toString(); } (7)@RequestBody与复杂的@RequestParam()同时使用: @RequestMapping(&quot;mytest5&quot;) public String myTestController5(@RequestBody User user, @RequestParam(&quot;arrays&quot;) List&lt;String&gt; arrays) { System.out.println(user.toString()); StringBuffer sb = new StringBuffer(); for (String array : arrays) { sb.append(array); sb.append(&quot; &quot;); System.out.println(array); } return sb.toString() + user.toString(); } (8)@RequestBody接收请求体中的json数据;不加注解接收URL中的数据并组装为对象: @RequestMapping(&quot;mytest4&quot;) public String myTestController4(@RequestBody User user1, User user2) { System.out.println(user1.toString()); System.out.println(user2.toString()); return user2.toString() + &quot;\n&quot; + user1.toString(); } 注：该文章转载自@RequestBody的使用]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System进程占用80端口]]></title>
    <url>%2F2019%2F02%2F11%2FSystem%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A880%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[80端口是为HTTP（HyperText Transport Protocol)即超文本传输协议开放的，主要用于WWW（World Wide Web）即万维网传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入“:80”了。 8080、8001等端口其实本质上没什么区别，而且它们本身无实际意义，只是用于代理服务器端口来代理服务，如tomcat、nginx、IIS等。大部分服务提供方都默认使用8080端口用于WWW代理服务，因此经常会发现8080端口被占用的情况。但我们可以通过修改配置文件来解决端口占用问题，如改成8001等。 1、在windows的cmd窗口中输入：netstat -ano|findstr “80”。查看80端口占用对应的PID。再使用：tasklist发现是System进程占用了80端口。接下来不管是在任务管理器中找到System进程后，选中，结束进程，还是直接在窗口中输入：taskkill /pid (pid号) -f。发现都无法解决。原来System进程它是Windows页面内存管理进程，拥有0级优先权，没有它系统无法启动。 也就是说，System进程是无法关闭的，如果你强行结束system进程树会直接导致蓝屏。 2、后来发现是SqlServer的Reporting Service占用了这个端口，在任务管理器中停止该服务即可成功解除System进程对80端口的占用问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok]]></title>
    <url>%2F2019%2F02%2F01%2FLombok%2F</url>
    <content type="text"><![CDATA[Lombok项目是一个Java库，它能够自动嵌入到你的IDE编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有val特性等。它基本上支持所有主流的 IDE 开发工具及编译构建工具。比如Eclipse、IDEA、Myeclipse等等。 在IDEA中安装该插件，首先去下载好和你的IDEA版本匹配的包，打开Settings，点击plugins，选择Install plugin from disk导入下载好的包导入即可。（在 IDEA 中安装 Lombok 插件，这样在使用 Lombok 的时候就不会编译报错。）最后要在Maven 的依赖配置中引入lombok依赖。 1、添加 @Getter 和 @Setter 注解用在 Java Bean 类上面，无需生成 get/ set 方法，会自动生成所有的 get/ set 方法及一个默认的构造方法。 2、@ToString使用在类上，默认生成所有非静态字段以下面的格式输出。 3、@NoArgsConstructor用在类上，用来生成一个默认的无参构造方法。 4、@RequiredArgsConstructor用在类上，使用类中所有带有 @NonNull 注解和 final 类型的字段生成对应的构造方法。 5、@AllArgsConstructor用在类上，生成一个所有参数的构造方法，默认不提供无参构造方法。 6、@Data用在类上，等同于下面这几个注解合集。 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 7、@Value用在类上，等同于下面这几个注解合集。 @Getter @FieldDefaults(makeFinal=true, level=AccessLevel.PRIVATE) @AllArgsConstructor @ToString @EqualsAndHashCode 8、@NonNull用在属性上，用于字段的非空检查，如果传入到 set 方法中的值为空，则抛出空指针异常，该注解也会生成一个默认的构造方法。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>杂说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F01%2F30%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、查看当前在线用户 [root@jaja ~]# w 2、查看Linux版本 [root@jaja ~]# lsb_release -a 3、查看进程树 [root@jaja docker]# pstree -p 4、使用ZMODEM进行文件传输 从Windows上传至Linux：[root@jaja docker]# rz 从Linux下载至Windows：[root@jaja docker]# sz 5、查看内存使用情况 [root@jaja docker]# free -m 6、查看磁盘剩余空间 [root@jaja docker]# df -h 7、查看Linux内核版本 [root@jaja docker]# uname -r]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2F2019%2F01%2F20%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、查看所有的容器 [root@jaja docker]# docker ps -a 2、查看正在运行的容器 [root@jaja docker]# docker ps 3、启动已终止的容器 [root@jaja docker]# docker start (container id) 4、终止已启动的容器 [root@jaja docker]# docker stop (container id) 5、重启容器 [root@jaja docker]# docker restart (container id) 6、进入容器交互式环境 [root@jaja docker]# docker exec -it (container id) /bin/bash 7、退出容器交互式环境 [root@jaja docker]# exit 或者使用快捷键 Ctrl + D 8、导出容器 [root@jaja docker]# docker export (container id) &gt; (filename).tar 9、导入容器 [root@jaja docker]# cat (filename).tar | docker import - (image name):(tag) 10、查看当前宿主机上的镜像列表 [root@jaja docker]# docker image ls 或者 docker images 11、删除处于终止状态的容器 (1)直接终止容器：[root@jaja docker]# docker rm (container id) (2)如果正在运行则要先终止：[root@jaja docker]# docker stop (container id) 12、删除所有处于终止状态的容器 [root@jaja docker]# docker container prune 13、打印容器的标准输出 [root@jaja docker]# docker logs 14、删除镜像(在删除镜像之前需要先停止容器，再删除容器) [root@jaja docker]# docker rmi (image id)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[醒来]]></title>
    <url>%2F2019%2F01%2F20%2F%E9%86%92%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[来呀，将我从一场忧伤的梦中惊醒 把我的沉睡赶走 这该死的虚无 昨夜的大雨 无尽的黑夜 喧嚣的逼仄]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 买卖股票的最佳时机 II]]></title>
    <url>%2F2019%2F01%2F19%2FLeetCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 题目代码：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装配Bean之通过XML装配Bean]]></title>
    <url>%2F2019%2F01%2F12%2F%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[1、创建XML配置规范在使用XML为Spring装配bean之前，需要创建一个新的配置规范。在使用JavaConfig的时候，这意味着要创建一个带有@Configuration注解的类，而在XML配置中，这意味着要创建一个XML文件，并且要以beans元素为根。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- ... --&gt; &lt;/beans&gt; 2、声明一个简单的bean要在基于XML的Spring配置中声明一个bean，我们要使用spring-beans模式中的另外一个元素：bean。bean元素类似于JavaConfig中的@Bean注解。我们可以按照如下的方式声明CompactDisc bean： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.SgtPeppers&quot; /&gt; 当Spring发现这个bean元素时，它将会调用SgtPeppers的默认构造器来创建bean。 3、借助构造器注入初始化的bean(1)构造器注入bean的引用1)使用constructor-arg元素： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt; &lt;constructor-arg ref=&quot;compactDisc&quot;/&gt; &lt;/bean&gt; 2)使用Spring3.0所引入的c-命名空间： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:cd-ref=&quot;compactDisc&quot;/&gt; 属性名以c:开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后”-ref”，告诉Spring正在装配的是一个bean的引用。 在这里它直接引用构造器参数的名称即上面的”cd”，如果参数的名称修改了，此处的配置也要进行修改，因此可以使用参数在整个参数列表中的位置来替代： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot;/&gt; 如果只有一个构造器参数则可以使用下面的方案： &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot;/&gt; 注：使用c-命名空间需要先在XML的顶部声明其模式：xmlns:c=&quot;http://www.springframework.org/schema/c&quot; (2)将字面量注入到构造器中package soundsystem; public class BlankDisc implements CompactDisc { private String title; private String artist; public BlankDisc(String title, String artist) { this.title = title; this.artist = artist; } } 1) 使用constructor-arg元素： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt; &lt;constructor-arg value=&quot;The Beatles&quot;/&gt; &lt;/bean&gt; 2)使用c-命名空间： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; c:_artist=&quot;The Beatles&quot;/&gt; 或 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_0=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; c:_1=&quot;The Beatles&quot;/&gt; 如果只有一个构造器参数： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot; c:_=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt; (3)装配集合package soundsystem; import java.util.List; import soundsystem.CompactDisc; public class BlankDisc implements CompactDisc { private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc(String title, String artist, List&lt;String&gt; tracks) { this.title = title; this.artist = artist; this.tracks = tracks; } } 1)使用list元素将其声明为一个列表(目前，使用c-命名空间的属性无法实现装配集合的功能)。 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt; &lt;constructor-arg value=&quot;The Beatles&quot;/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;one&lt;/value&gt; &lt;value&gt;two&lt;/value&gt; &lt;value&gt;three&lt;/value&gt; ... &lt;value&gt;n&lt;/value&gt; &lt;/list&gt; &lt;constructor-arg/&gt; &lt;/bean&gt; 或 &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;/&gt; &lt;constructor-arg value=&quot;The Beatles&quot;/&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;value&gt;one&lt;/value&gt; &lt;value&gt;two&lt;/value&gt; &lt;value&gt;three&lt;/value&gt; ... &lt;value&gt;n&lt;/value&gt; &lt;/set&gt; &lt;constructor-arg/&gt; &lt;/bean&gt; 2)使用ref元素替代value,从而实现bean引用列表的装配。 假设现在有一个Discography类,它的构造器如下： public Discography(String artist, List&lt;CompactDisc cds) { ... } 那么可以以如下的方式配置它的bean： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;constructor-arg value=&quot;The Beatles&quot;/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean=&quot;sgtPeppers&quot;/&gt; &lt;ref bean=&quot;whiteAlbum&quot;/&gt; ... &lt;ref bean=&quot;revolver&quot;/&gt; &lt;/list&gt; &lt;constructor-arg/&gt; &lt;/bean&gt; (4)设置属性(1)setter方法注入bean的引用： package soundsystem; import soundsystem.CompactDisc; import soundsystem.MediaPalyer; import org.springframework.beans.factory.annotation.Autowired; public class CDPlayer implements MediaPalyer { private CompactDisc compactDisc; @Autowired public void setCompactDisc(CompactDisc compactDisc) { this.compactDisc = compactDisc; } } 在这之前都是通过构造器来进行注入的，没有使用属性的setter方法，现在我们来看一下如何使用spring XML实现属性的注入。property元素为属性的setter方法所提供的功能与constructor-arg元素为构造器所提供的功能是一样的。 &lt;bean id=&quot;cdPlayer&quot; class=&quot;soundsystem.CDPlayer&quot;&gt; &lt;property name=&quot;compactDisc&quot; ref=&quot;compaceDisc&quot; /&gt; &lt;/bean&gt; (2)setter方法将字面量注入到属性中： package soundsystem; import java.util.List; import soundsystem.CompactDisc; public class BlankDisc implements CompactDisc { private String title; private String artist; private List&lt;String&gt; tracks; public void setTitle(String title) { this.title = title; } public void setArtist(String artist) { this.artist = artist; } public void setTracks(List&lt;String&gt; tracks) { this.tracks = tracks; } } 这里和先前的constructor-arg装配tracks是完全一样的： &lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.BlankDisc&quot;&gt; &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot; /&gt; &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt; &lt;property name=&quot;tracks&quot;&gt; &lt;list&gt; &lt;value&gt;one&lt;/value&gt; &lt;value&gt;two&lt;/value&gt; &lt;value&gt;three&lt;/value&gt; ... &lt;value&gt;n&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装配Bean之通过Java代码装配Bean]]></title>
    <url>%2F2019%2F01%2F12%2F%E8%A3%85%E9%85%8DBean%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[尽管在很多应用场景下通过组件扫描和自动装配来实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如：你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。此时，你必须采取显式装配的方式，在进行显式配置的时候，有两种可选的方案：Java和XML。下面主要是学习如何使用Java来进行配置。在读这篇文章之前，建议先阅读我的上一篇文章装配bean之自动化装配Bean 1、创建配置类@Configuration public class CDPlayerConfig{ ... } 创建 JavaConfig 的关键在于为其添加@Configuration注解，此外，该类应该包含在Spring应用上下文中创建bean的细节。 2、声明简单的bean(1)要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解，下面的代码声明了CompactDisc bean: @Bean public CompactDisc sgtPeppers(){ return new SgtPeppers(); } @Bean注解会告诉Spring这个方法会返回一个对象，该对象需要注册为Spring应用上下文中的bean，方法体中包含了最终产生bean实例的逻辑。 (2)默认情况下，bean的ID与带有@Bean注解的方法名是一样的。如果你想为其设置一个不同的名字的话，你可以重命名该方法，或者通过name属性指定一个不同的名字。如下： @Bean(name=&quot;lonelyHeartsClubBand&quot;) public CompactDisc sgtPeppers(){ return new SgtPeppers(); } 3、借助JavaConfig注入(1)我们前面所声明的CompactDisc bean是非常简单的，其自身没有其他的依赖。现在，我们需要声明CDPlayer bean，它依赖于CompactDisc，在JavaConfig中要像下面那样将它们装配到一起： @Bean public CDPlayer cdPlayer(){ return new CDPlayer(sgtPeppers()); } 看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此，在默认情况下，Spring中的bean都是单例的，因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。即对sgtPeppers()方法的调用返回的是Spring本身在调用sgtPeppers()时所创建的CompactDisc bean。 (2)可以看到，通过方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式： @Bean public CDPlyer cdPlayer(CompactDisc compactDisc) { return new CDPlayer(compactDisc); } 通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装配Bean之自动化装配Bean]]></title>
    <url>%2F2019%2F01%2F12%2F%E8%A3%85%E9%85%8Dbean%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[Spring从两个角度来实现自动化装配： (1)组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的 bean。 (2)自动装配(autowiring)：Spring自动满足 bean 之间的依赖。 1、创建可被发现的Bean(1)创建一个接口CompactDisc： package soundsystem; public interface CompactDisc{ void play(); } (2)创建带有@Component注解的CompactDisc接口的一个实现类： package soundsystem; import org.springframework.stereotype.Component; @Component public class SgtPeppers implements CompactDisc{ private String title = &quot;Sgt, Pepper&apos;s Lonely Hearts Club Band&quot;; private String artist = &quot;The Beatles&quot;; public void play(){ System.out.println(&quot;Playing &quot; + title + &quot; By &quot; + artist); } } 注：@Component注解表明，该类会作为组件类，并告知Spring要为这个类创建bean。不过，组件的扫描默认是不启动的，需要显式地对Spring进行配置，从而命令它去寻找带有@Component注解的类，并为其创建bean。(3)创建配置类: package soundsystem; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan public class CDPlayerConfig{ ... } 注：@ComponentScan注解能够在Spring当中启动组件扫描，它会默认扫描与配置类相同的包以及这个包下的所有子包，查找带有@Component注解的类。如此一来，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。(4)当然我们也可以使用XML配置的方式来启动组件扫描： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;soundsystem&quot;/&gt; &lt;/beans&gt; (5)Junit测试： package soundsystem; import org.junit.Test; import static org.junit.Assert.*; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; @RunWith(SpringJunit4ClassRunner.class) @ContextConfiguration(classes = CDPlayerConfig.class) public class CDPlayerTest { @Autowired private CompactDisc cd; @Test public void cdShuldNotBeNull(){ assertNotNull(cd); } } 注：a、SpringJUnit4ClassRunner用于在测试开始的时候自动创建Spring的应用上下文。b、@ContextConfiguration注解会告诉它需要在CDPlayerConfig中加载配置。由于CDPlayerConfig类当中包含了@ComponentScan注解、SgtPeppers当中包含了@Component注解，因此最终的应用上下文就会包含CompactDisc的bean。c、@Autowired注解用于将CompactDisc的bean注入到测试代码当中。2、为组件扫描的bean命名(1)Spring上下文中所有的bean都会给定一个ID，若直接使用 @Component 注解来声明一个 bean，其bean 的名字默认为类名首字母小写。例如，如上 SgtPeppers 类的默认 bean 名称为 sgtPeppers。当然我们可以在 @Component 注解中说明此 bean 的名称。 @Component(&quot;lonelyHeartClub&quot;) public class SgtPeppers implements CompactDisc{ ... } 也可以使用另外一种为bean命名的方式： @Named(&quot;lonelyHeartClub&quot;) public class SgtPeppers implements CompactDisc{ ... } 注：@Named是Java依赖注入规范(Java Dependency Injection)中所提供的为bean设置ID的注解。Spring支持将@Named作为@Component注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。然由于@Named其本身并无法表明它是干什么的，因此人们常常会选择使用@Component注解来命名。3、设置组件扫描的基础包在之前的案列中，我们没有为 @ComponentScan注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件。但是有个原因会促使我们要明确的设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。 (1)为了指定不同的包，只需要在 @ComponentScan的value属性中指明包的名称: @Configuration @ComponentScan(&quot;soundsystem&quot;) public class CDPlayerConfig{ ... } (2)如果你想更加明确的表名你所设置的是基础包，那么你可以通过basePackages属性进行配置: @Configuration @ComponentScan(basePackages=&quot;soundsystem&quot;) public class CDPlayerConfig{ ... } (3)如果你想扫描多个包，只需要将basePackages属性的值设置为要扫描包的一个数组即可: @Configuration @ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;}) public class CDPlayerConfig{ ... } (4)在上面的例子当中，basePackages属性的值是一个String类型的数组，这样配置没有问题，但却是类型不安全的，如果要重构代码的话，这些包的名字可能会被修改，从而导致包扫描出现错误，除了将包设置为简单的String类型之外，@ComponentScan 还提供了另一种方法，那就是将其指定为要扫描包中所含的类或接口。 @Configuration @ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class}) public class CDPlayerConfig{ ... } 注：你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。4、通过为bean添加注解实现自动装配在你的应用程序当中，如果所有的对象都是独立的，彼此之间没有任何的依赖，就像ShtPeppers的bean一样，那么你所需要的可能就是组件的扫描而已。但是很多对象会依赖其他的对象才能完成任务。如此一来，我们就需要有一种方法将组件扫描得到的bean和它们的依赖装配在一起。这就涉及到Spring的自动装配。自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean，这里借助@Autowired注解来声明自动装配。 (1)以下示例的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean的时候，会通过这个构造器进行实例化并传入一个CompactDisc类型的 bean。@Autowired 注解可以用在类的任何方法上。 @Component public class CDPlayer implements MediaPlayer{ private CompactDisc cd; @Autowired public CDPlayer(CompacrDisc cd){ this.cd = cd; } public void play(){ cd.play(); } } (2)不管是构造器、Setter 方法还是其他方法，Spring 都会尝试满足方法参数上所声明的依赖，假如有且仅有一个bean依赖需求的话，那么这个bean就会被装填进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false： @Autowired(required=false) public CDPlayer(CompactDisc cd){ this.cd = cd; } 注：但是，把required属性设置为false时，需要谨慎对待。如果你的代码中没有进行null检查的话，这个处于未装配状态的属性可能会出现NullPointerException。(3)如果有多个bean都能满足依赖关系的话，Spring也将会抛出一个异常，表明没有明确指定要选择那个bean进行装配。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot开发中遇到的几个问题]]></title>
    <url>%2F2018%2F11%2F30%2FSpringBoot%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、java.net.MalformedURLException: no protocol 异常 在通过 IP 地址及端口号调用远程方法，进行测试的时候，报出如上的异常。原因是没有指定 http 协议，在 URL 前面加上http://即可解决此异常。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中的FastJson]]></title>
    <url>%2F2018%2F11%2F29%2FSpringBoot%E4%B8%AD%E7%9A%84FastJson%2F</url>
    <content type="text"><![CDATA[1、依赖&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.37&lt;/version&gt; &lt;/dependency&gt; 2、导入包和主要的方法1、导入包 import com.alibaba.fastjson.JSON; 2、将JSONObject转化为String String jsonStr = JSONObject.toJsonString(jsonObject); 3、将String转化为JSONObject JSONObject jsonObject = JSONObject.parseObject(jsonStr); 4、将String转化为JSONArray JSONArray jsonArray = JSONArray.parseArray(jsonStr); 5、将JSONArray转化为JSONObject JSONObject jsonObject = new JOSNObject(); for (int i; i &lt; jsonArray.length(); i++) { jsonObject = jsonArray.getJSONObject[i]; } 6、将JSONObject转化为JOSNArray JSONArray jsonObject = JSONObject.get(&quot;key&quot;); 7、将List转JSONArray JSONArray jsonArray = JSONArray.parseArray(JSON.toJSONString(list))； 8、将JSONArray转化为List List&lt;EventColAttr&gt; list = JSONObject.parseArray(jsonArray.toJSONString(), EventColAttr.class);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Log4j]]></title>
    <url>%2F2018%2F11%2F20%2FSpringBoot%E6%95%B4%E5%90%88Log4j%2F</url>
    <content type="text"><![CDATA[1、依赖&lt;!-- spring boot start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除自带的logback依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- springboot-log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、Log4j配置文件(建立在和application文件同级的目录下)# Log4j配置 log4j.rootCategory=INFO,stdout #控制台输出 log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd-HH-mm} [%t] [%c] [%p] - %m%n 注：该文件里的stdout全部替换成CONSOLE也是没有问题的。当然你也可以在文件中配置file,error,debug等其他的日志信息。 3、使用Log4jimport org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author EchoDemo * @ClassName cn.aduu.web.HelloController * @Description */ @RestController public class HelloController{ private static final Logger logger = LoggerFactory.getLogger(HelloController.class); @RequestMapping(&quot;hello&quot;) public String hello() throws JsonProcessingException { logger.info(&quot;Hello World！&quot;); return &quot;hello world&quot;; } } 注：启动之后在浏览器访问就好了。 4、日志打印效果十一月 20, 2018 10:42:10 下午 org.apache.catalina.core.ApplicationContext log 2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization started 信息: Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos; 2018-11-20-22-42 [http-nio-8080-exec-1] [org.springframework.web.servlet.DispatcherServlet] [INFO] - FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 23 ms 2018-11-20-22-42 [http-nio-8080-exec-1] [com.echodemo.girl.web.UserController] [INFO] - Hello World!]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MyBatis]]></title>
    <url>%2F2018%2F11%2F20%2FSpringBoot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[CSDN学习链接 1、无配置文件注解版 (1)@MapperScan(“com.echodemo.girl.mapper”)这里是包名。 (2)注意到以下两个SQL语句，insert当中没有user.username是因为当它只有一个对象作为参数传递时本身进行了处理，而update当中，有两个参数传递进来，此时需要@Param的协助，并且需要以user.username的形式把值传给SQL语句当中。而单个的id则直接传递。 @Insert(&quot;INSERT INTO tb_user(username, age, ctm) VALUES(#{username}, #{age}, now())&quot;) int add(User user); @Update(&quot;UPDATE tb_user SET username = #{user.username}, age = #{user.age} WHERE id = #{id}&quot;) int update(@Param(&quot;id&quot;) Integer id, @Param(&quot;user&quot;) User user); 自己敲的GitHub代码链接 2、配置文件注解版 (1)在userMapper.xml文件当中，resultMap部分，里面的jdbcType类型都需要大写，当时INTEGER只有首字母大写了，然后找bug找了好久。 (2)在UserMapper当中要加上@Repository注解，不然在UserServiceImpl.java文件中会提示bean不存在。 自己敲的GitHub代码链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《了不起的盖茨比》]]></title>
    <url>%2F2018%2F11%2F17%2F%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%E7%9B%96%E8%8C%A8%E6%AF%94%E3%80%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“我其实觉得，盖茨比本人并不相信会有电话来，他也已经不在乎了。如果真是如此，他一定是觉得已经失去了往日那个温暖的世界，为一个梦想空守了太久，付出了太高的代价；他一定是透过可怕的树叶仰望到一片陌生的天空；他一定感到毛骨悚然，当他发现玫瑰是多么丑恶，而阳光照在刚刚露头的小草上又是多么残忍。这是一个新世界，物质的世界，没有真实可言，可怜的鬼魂呼吸着空气一般的梦想，四处飘荡……就像那个灰蒙蒙的怪人穿过杂乱的树林悄悄向他走来一样。”可以这样说：盖茨比梦想、希望和肉体的覆灭是黛西和汤姆两个人共同的杰作，当然也因为他的纯真和勇敢。但归根究底他是被残酷的社会现实活生生地扼杀的，过去是这样，现在在依然是这样。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洪水猛兽]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%B4%AA%E6%B0%B4%E7%8C%9B%E5%85%BD%2F</url>
    <content type="text"><![CDATA[我已经老了 在那汹涌的时光之河中逆流而上的 是我焦急的等待和对幸福的憧憬 那些孤独、失眠并痛苦着的夜晚 我是多么渴望 有一天能够在某个幽静的花园里 在黄色的落叶铺满整个季节的时候 坐在一棵干枯杏树下的长凳上 再为你读一首浪漫动情的诗篇 因为只有这样 才能缓解我无法避免地从思念的村庄路过时的情绪 而你并不知道我始终身陷囹圄、画地为牢 在无穷无尽的深渊里甘为囚徒、难以自拔 染上了名为爱情的霍乱 注：此诗因读《霍乱时期的爱情》有感而写]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合JdbcTemplate]]></title>
    <url>%2F2018%2F11%2F14%2FSpringBoot%E6%95%B4%E5%90%88JdbcTemplate%2F</url>
    <content type="text"><![CDATA[CSDN学习链接 下面是这篇博客当中一些需要注意的问题： 1、在yml文件当中，注意空格问题。 2、在UserDaoImpl.java文件当中，类需要加上@Repository注解。 3、在UserServiceimpl.java文件当中，类需要加上@Service注解。 4、在UserController.java文件当中，类需要加上@RestController注解。 5、JsonResult实体类需要生成get和set方法。 *另外，自己的项目里面的controller路径有所改变。 自己敲的GitHub代码链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中Controller的使用]]></title>
    <url>%2F2018%2F11%2F05%2FSpringBoot%E4%B8%ADController%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、Controller方法和类的注解 其中@RequestMapping可以给整个Controller类设置注解。还可以通过如下的设置让不同的链接参数来进行访问： @RequestMapping(value = {&quot;hello&quot;, &quot;hi&quot;}, method = RequestMethod.GET) public String say(){ return &quot;Hello SpringBoot!&quot;; } 当然为了让代码更加得简洁，可以使用@GetMapping(value = “/hello”)和@PostMapping(value = “/hello”)来替代@RequestMapping(value = “/hello”, method = RequestMethod.GET)和@RequestMapping(value = “/hello”, method = RequestMethod.POST)的。 2、Controller当中的参数传递 （1）@PathVariable @RequestMapping(value = &quot;/hello/{id}&quot;,method = RequestMethod.GET) public String say(@PathVariable(&quot;id&quot;) Integer id){ return &quot;id: &quot; + id; } （2）@RequestParam(可以设置默认值) @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) public String say(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) Integer id){ return &quot;id: &quot; + id; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的第一个入门程序]]></title>
    <url>%2F2018%2F11%2F05%2FSpringBoot%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、在intellij idea2018上创建一个maven项目(在这里我使用的是apache-maven-3.3.9以及1.8版本的JDK) 2、打开main里面的GirlApplication文件，在同一个包下面新建一个HelloController.java文件并创建一个方法。 3、在GirlApplication.java文件中启动该项目。成功之后在浏览器当中输入127.0.0.1:8080/hello。 4、项目属性配置(创建配置文件和配置文件属性类) （1）生产、测试环境以及主配置文件内容 //测试环境内容 server: port: 8080 girl: cupSize: B age: 18 //生产环境内容 server: port: 8081 girl: cupSize: F age: 18 //调用配置文件的主配置文件内容 spring: profiles: active: prod （2）创建配置文件属性类 package com.echodemo.girl; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; //获取前缀是girl的配置，注入配置需要加Component注解 @Component @ConfigurationProperties(prefix = &quot;girl&quot;) public class GirlProperties { private String cupSize; private Integer age; public String getCupSize() { return cupSize; } public void setCupSize(String cupSize) { this.cupSize = cupSize; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } （3）HelloController文件内容 package com.echodemo.girl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { /* //通过注解的方式获取配置文件值(Value注解太low了) @Value(&quot;${server.cupSize}&quot;) private String cupSize; @Value(&quot;${server.age}&quot;) private Integer age;*/ //通过创建配置文件属性类来获取配置文件中的值 @Autowired private GirlProperties girlProperties; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) public String say(){ return girlProperties.getCupSize(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《假性亲密关系》摘句(二)]]></title>
    <url>%2F2018%2F10%2F06%2F%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、我应该找我喜欢的还是喜欢我的？应该找有感觉的还是条件好的？在感情中我们很容易把注意力放在对外寻找上，却忽略了困惑往往来源于自我。如果你不了解自己的情感需要，便很难在感情中得到满足。了解自己的情感需要，从更长远的角度来说也是了解自己的成长需要，知道自己为什么活着，这一生想要得到什么、实现什么。 2、关系要获得成长，首先是处在关系中的人要成长。比如，有的女人婚后成了全职太太，将个人成长的停滞归咎于操持家庭，和先生在阅历和思想上逐渐脱节，渐行渐远。又比如，有的男性一直保持着学生时期的心态，沉迷于游戏和其他娱乐活动，拒绝面对自己的成长，也不愿认真思考未来。 3、我们不知道自己想要什么，是因为有太多担心和顾虑，眼前的问题阻碍了我们看清自己的方向。 4、怎样知道你对一件事情有激情？你每天早上醒来和晚上临睡前都会忍不住去想、去做的，就是让你充满激情的事情。如果连开始一件事情都缺少决断力，那么之后一旦遇到困难或者冲突，必然会很快选择放弃。所以，如果你已经发现自己的激情所在，想要去做一件事情，那么现在就开始！ 5、你可以试试把自己关在一个空房间里，5分钟，10分钟，半小时。不带手机，不看电脑，你可以观察自己在寂寞时会有什么反应，会做什么，这样可以很好地帮助你了解自己。 6、喜欢把工作忙、圈子小、性格内向、不善交际这些说辞挂在嘴边的人并没有想过，他们提出的每一点理由都只是一种暂时的状态，而非不可改变的现实。那些成功者与你起点相同，但最终获得成功，这才是你和他们的本质区别。 7、走出自卑，是一条重新审视自己的生活、重新定义自我价值、重新设计自我行为的漫长之路。走出自卑，需要你对客观现实和自我认知有强烈的渴望，这样才能够打破长久以来的自我偏见；走出自卑，意味着要学会忍耐自卑带来的不适感，将更多精力放在优化自己的实际行为上。 8、愤怒的表达是本能，对愤怒带来的伤害的修复比表达更为重要，但是许多人都把更多注意力放在了调整和弱化表达上面。（压抑自己的情绪）如果我们懂得如何在伤害产生后修复关系，表达我们的歉意、关怀和爱，那么伤害反而成了拉近关系和建立信任的机会。使用回避、沉默、逃避、疏远以及终止关系来表达愤怒。其结果就是，情绪得不到合理表达，引发更深层的抑郁，同时也失去了建立信任感和亲密关系的机会，在人际关系中越发感到被孤立。 9、“想要”和“需要”关于是否足够了解自己的情感需求这个话题，我会用一个简单的问题来测试：“你为什么要恋爱、结婚？”对此，我得到的常见答案是：自己到了一定年纪应该稳定下来了，家里人也比较着急，看到周围的同事、朋友也都结婚了，所以就结婚了。在我看来，这就是不了解自己情感需求的表现，因为这里给出的是一个人想要却未必需要的东西。关于人的想要和需要，我们要进行一下区分。你可以将这两者的关系理解为路径和目标，我们通过得到想要的东西，来满足根本的需要。想要的东西往往是某些具体的事物，而需要很多时候则是主观的体验和感受。比如，我想要很多钱，因为有了钱别人就会尊重我，所以我需要的其实是尊重；我想要先生对我很专一，这会让我感觉他很重视我，所以我需要的是重视；我想要很多漂亮的衣服和包，因为我打扮漂亮了，别人才会认可我，所以我需要的是认可。当一个人告诉我她走进一段感情是因为年龄、家人和社会压力时，她的真正需要可能是自信、安全感、归属感，以及被认可、被尊重、被接纳等。更进一步说，一个人得到了想要的东西，是否就一定能满足自己的需要？很多人在这两者的关系认知上存在着很大的偏差。比如走入婚姻，需要的是被别人认可和尊重，但是满足了家人和社会的期望，就一定能被别人认可和尊重吗？ 如果无法区分想要和需要，便会把生命浪费在肤浅的、想要的事物上。而人只有当需要被满足时，才会感到发自内心的满意。 10、划分人生阶段将自己的人生划分为8个阶段，这个数字没有特定的含义，只是一个结构上的要求。每个阶段用一个重要的事件或者时间节点来界定。第一个阶段从出生开始，最后一个阶段一直持续到当下。 罗列重要事件从每个阶段里找出10件对你影响重大的事件，这个数字也仅是一个结构上的要求而已。这些事件应该对你的情感、性格、生活轨迹、人际关系产生过比较大的影响。我建议你关注这样一些事件：让你的生活轨迹发生变化的转折点，重大的失败或意外，重要的决定，对情感造成较大冲击的事件，记忆深刻的事件。另外这些事件多半与他人有关，我建议你重点关注你的父母或者其他亲近的人。罗列这80件事情本身就是个挑战，有的需要努力回忆，有的需要去询问他人。你可以先定义好一个阶段，去搜罗事件，进行分析，然后再进入下一个阶段。 分析事件每一个事件下面，你都需要回答以下几个问题： （1）这件事给你带来了哪些认知和想法上的变化？ （2）这件事给你带来了哪些情感上的冲击或者影响？ （3）这件事和现在的你有什么关系？换句话说，这件事如何塑造了今天的你？ 内容上没有太多要求，每个人都有权利以自己喜欢的方式写一部自己的个人史。唯一需要你坚持的是8个阶段，总共80件事情，每件事情3个问题，这样写出来的东西才能足够细化。每个问题你可以随便回答，或者详细地描述。要花多少时间，要写多少，由你自己决定。你的收获完成这份“作业”可能需要花费很多时间，多到远远超出你的预期。写的过程中你可能会哭、会笑、会感慨。你可能需要他人帮助你回忆某些事。我介绍身边的一些人尝试过这种方法，包括我的长辈。我没有看他们写的东西（你最好不给别人看，这样才能保证内容最真实）。但是大家给我的反馈一致：做这样一件事对自己有太多益处。这个练习是我大学时期的一位心理学教授布置的期末论文题目。当时的我花费两个月的时间，写下一万多字。它开启了我对自我认知的探寻之路，是我到目前为止做过的最重要的几件事情之一。最终的效果因人而异。但对我来说，写作的过程已让我受益匪浅，一边写一边思考，看清了很多以往忽略或者误解的问题。写完之后，整个人有一种“觉醒”的感觉，它带来的思考，也会持续影响自己。同时，你会更理解自己，会看到所处的环境对自己的影响，而不再把所有事情都归因于自己或者身边的人。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《假性亲密关系》摘句(一)]]></title>
    <url>%2F2018%2F10%2F06%2F%E3%80%8A%E5%81%87%E6%80%A7%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、在亲密关系中，很多人往往会在尚未完全理解对方时就开始批判或反驳。这种方式看似能够说服伴侣，让对方在压力之下顺从你的意愿，可是却会让对方害怕在你面前畅所欲言。结果就是你以为你很了解对方，其实他内心还有许多保留的秘密。专注的聆听和不带批判性的回应，信任感会得到加强。 2、在深入了解双方的想法时，例如聊到和前任的关系或者异性朋友这类比较敏感的话题时，建议你平和而又诚恳地邀请对方表达，让对方感到安全：“我知道这个话题对你来说可能比较敏感，或许你可以试着说说看，我很想了解你，也向你保证，我不会在没有完全理解你的时候给你贴标签或者批判你。” 3、矛盾冲突永远存在，但是高质量的关系可以保障亲密关系中的满意度更持久。很多人在亲密关系中所犯的错误就是为了争论对错、分出输赢、掌握控制权，宁可牺牲亲密关系，因为我们往往习惯了以强制的方式使对方接受。 4、你可能习惯了不说话，在人群里永远保持沉默，有着很强的戒备心理，对异性充满恐惧。你可能有很多情结、障碍、缺点，但你必须要走出自己熟悉的舒适区，做以前没做过的事情。浪漫的事情，都多少带些不寻常甚至是冒险。在恐惧、焦虑、不确定的时候，你习惯了逃避，那么，多半也会错过那些美好奇妙的邂逅。 5、许多人总要求对方要与自己有精神共鸣、有生活情趣、要浪漫、要体贴入微。要求别人之前先看看自己，你是个爱读书、爱思考的人吗？你的生活是不是充满了各种趣味？你是否有自己独特的手艺和爱好可以用来营造浪漫？你是否习惯于帮助他人和奉献自我？长久积累的品质才能产生魅力，而平庸和平淡的你，拿什么吸引心仪的人，拿什么让亲密关系保鲜？ 6、我极力推荐大家去看看《摩登家庭》，此剧一个重要的看点就是学习剧中人物在处理家庭关系时如何用积极的、有建设性的语言沟通彼此的感受。 7、我希望用文字鼓励那些心有所向的人，不要因为可能被拒绝就患得患失，不要因为希望渺茫就放弃。感情不能用得失、成败来衡量，因为感情中的失败其实是一种提示，是在告诉你且行且珍惜，你完全没必要和失败过不去。 8、我真心希望每一个恋爱中的人，都不要只顾着享受对方带给你的感动和温暖，要多想想自己可以为他做些什么。在你感到最幸福、最满足的时候，记得问问自己：他是否和我一样幸福？ 9、任何形式的失败，其实都是生活在提示我们：你的方法不对，需要调整。拒绝分手或者离婚，找各种理由说服自己死扛，本质就是拒绝承认错误。当你忽视生活给你的提示时，获得的只能是更多更激烈和强硬的提示，直到你被彻底打垮。 10、每当你和伴侣之间出现矛盾的时候，你需要先思考以下两个问题：对方怎么改变能够让你感到满意？如果有人要让你做出这样的改变，激励你的最好方式是什么？]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《自控力》摘句]]></title>
    <url>%2F2018%2F09%2F08%2F%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E6%91%98%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1、提高自控力的最有效途径在于，弄清自己如何失控、为何失控。 2、在做每一个作业时，试着带上观察者的眼光，没有偏见、保持好奇心，就像一名通过显微镜作观察的科学家一样，期待发现有趣且有用的东西。 3、从每章挑选一个策略，选和你的挑战最相关的一个，而不是一次尝试10种策略。 4、人脑像一个求知欲很强的学生，对经验有着超乎大家想象的反应。如果你每天都让大脑学数学，它就会越来越擅长数学。如果你让它忧虑，它就会越来越忧虑。如果你让它专注，它就会越来越专注。 5、如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。 6、人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。 7、如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做。 8、如果我们想增强自控力，就要考虑如何支撑住最疲惫的自己，而不是指望最理想的自己突然出现来拯救生活。 9、自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。 10、道德许可：当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。 11、只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。 12、当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？·你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？·你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？ 13、我们都倾向于相信自我怀疑和自我批评，但这并不会让我们离目标更近。实际上，我们可以尝试从良师益友的角度来看待问题。他们都信任你、想要你变得更好、愿意在你失意的时候鼓励你，你也可以这么做。 14、你是否在推迟重要的变化或任务，等待自控力更强的未来的自己出现？你是不是乐观地让自己承担过多的责任，最后却被不可能的任务打倒了？你今天有没有不去做什么事，因为明天你会更想去做那件事？ 15、这一周，仔细观察你是否在模仿别人的行为，尤其是和你的意志力挑战有关的行为。同样放纵自己的行为是不是维持关系的社会黏合剂？当看到周围的人在做同样的事时，你会不会变本加厉地去做这件事？ 16、如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。你有没有告诉过自己，你的意志力挑战不是什么大事，因为它是社会规范？你是否意识到，自己认识的所有人都有同样的习惯？如果是这样，你可能会质疑这种看法。质疑它的最好方法就是找到一群人，他们正在做你渴望做到的事。找到一个新的“群体”并加入进去。这个“群体”可能是一个支援小组、一个班级、一个本地俱乐部、一个网络社区，甚至是一份支持你实现目标的杂志。置身于和你共享承诺与目标的人们当中，会让你觉得自己的目标才是社会规范。 17、你是否想忘记某些东西？如果是，请检验一下讽刺性反弹理论。压抑有用吗？试图忘记某些东西是否让它回来时变得更强烈？（没错，你要让“监控”来监控它自己。） 18、是什么让你的多巴胺神经元不停燃烧？你知道什么会刺激你的多巴胺分泌？食物？酒精？购物？Facebook？还是其他东西？这一周，试着观察是什么吸引了你的注意力。是什么给了你奖励的承诺，强迫你去寻求满足感？是什么让你像巴甫洛夫的狗一样垂涎欲滴，或是像奥尔兹和米尔纳的小白鼠一样欲罢不能？ 19、谁在控制你的多巴胺神经元？让我们来观察一下，零售商和营销人员究竟是如何刺激奖励承诺的。把逛商店或看广告当做一种游戏。你闻到了什么？看到了什么？听到了什么？当你知道这些暗示都是经过精心设计，专门要诱惑你上钩的时候，你就能看清它们到底是什么，也就能成功抵御它们了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故乡]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%85%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完最新一期的《朗读者》，在黑暗的楼道里一步一步往下走，思绪仍然还在节目里，满怀的惆怅与沉默。到底什么是故乡？白岩松的故乡是呼伦贝尔大草原上傍晚的落日和马头琴声；贾樟柯的故乡是同学和朋友的专程看望和问询；郑愁予的故乡是始终心系的祖国；还有一个人的故乡是他十年来力排众议在艰难的环境和地形下修筑的几十公里的山路。。。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫一辆Hello共享单车，在幽暗的路上漫无目的地游荡。想起考研未果的日子，我知道，那时候选择找工作而不是二战，是因为自己在逃避，害怕再一次的失败，不知道自己的退路在哪。如今来到偌大的城市里，繁华是你。刚来的日子里满心欢喜，为自己能够来到这座城市而庆幸，把冥冥中的注定看作美好的开始。但此刻自己的内心是茫然的，故乡对我而言意味着什么，一个人需要怎样的经历和过去才能够看清？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;立在公交站台旁的我，用手机写着这段文字的时候，抬头望着夜空中笼罩在云里的月，顿下来，目光又顺着车流望向灯火斑斓的远方，好像知道了点什么，转身往回走去。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐诗人]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%9F%B3%E4%B9%90%E8%AF%97%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨晚心血来潮，熬夜看完最近一期的《中国好声音》。以前这个节目对自己而言哪里有这么大的魔性，仅仅是因为有他的存在。李健对待生活的态度和方式，一直都是自己所仰慕和追寻的。在他的音乐里，诗意的词，动听的曲，美的无与伦比。台上的他，于言谈举止之间无时无刻不透露着温文儒雅的气质。近来知晓他与其妻子的爱情，从两小无猜的年纪到同是清华的学子，彼此之间缘深缘浅，自是懂得，这一切都是最好的安排。据说在李健的每一张专辑里都有一首歌是写给孟小蓓的，他对她说：和你在一起的日子才叫时光。他爱咖啡，也爱清茶，更爱读书，这也是他随口而出的词句里文化深厚的原因。他的音乐如诗，爱情如诗，更是把生活过成了一首诗。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[萤火虫]]></title>
    <url>%2F2018%2F08%2F18%2F%E8%90%A4%E7%81%AB%E8%99%AB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“蛋黄蛋白吃光了，用清水把鸭蛋里面洗净，晚上捉了萤火虫来，装在蛋壳里，空头的地方糊一层薄罗。萤火虫在鸭蛋壳里一闪一闪地亮，好看极了！”――《生活，是很好玩的》汪曾祺 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种做法，想想都是美的。以前小时候在故乡，秋天的夜晚，带着随意的瓶子跑到屋子外面去捕萤火虫，满天的星光下，是我们奔跑的身影和不尽的欢笑。那时候小，把一只又一只的萤火虫都塞进瓶中，第二天一大早起来，见到的就是它们的躯体，自己伤心极了，便下定决心不再捕捉，只是远观这些闪烁着的精灵就足够了。如今年岁见长，到远离故乡的城市里读书，再到现在的新入职场，一切都变得遥远。大概现在已经有好几年没有见到过萤火虫了。一方面是人类发展导致的环境恶化，另一方面是自己在这样的时节里和故乡难以靠近。昨天七夕，不禁想起唐代诗人杜牧那首《秋夕》“银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星”，给此时的自己又增添了一份美好。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis中的XML配置]]></title>
    <url>%2F2018%2F08%2F16%2FMyBatis%E4%B8%AD%E7%9A%84XML%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1、properties这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。首先在同级目录下新建一个db.properties文件。 &lt;!-- db.properties文件 --&gt; driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8 username=root password=root &lt;!-- properties配置 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt; &lt;!-- 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值，如下所示： --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;!-- 1、在properties元素体内指定的属性首先被读取。 2、然后根据properties元素中的resource属性读取类路径下属性文件或根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性。 3、最后读取作为方法参数(parameterType)传递的属性，并覆盖已读取的同名属性。 4、通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。 --&gt; 2、Setting它们会修改MyBatis在运行时的行为方式，ibatis的全局配置参数，包括很多的性能参数(最大线程数、最大等待时间等)，通过调用这些性能参数使用ibatis达到高性能的运行。MyBatis运行时调整全局参数，相当于软件运行时的参数。(需要小心配置，配置参数会影响MyBatis的执行) 3、typeAlias&lt;!-- 1、类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 2、自定义别名:alias别名；type类型。如果指定包中所有类都有别名，使用类名作为别名(大小写不敏感)。 --&gt; &lt;typeAliases&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;com.entity.User&quot;/&gt; &lt;package name=&quot;com.entity&quot;/&gt; &lt;/typeAliases&gt; 4、environmentsMyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。 &lt;!-- 可以接受环境配置的两个方法签名 --&gt; SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties); &lt;!-- 如果忽略了环境参数，那么默认环境将会被加载 --&gt; SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties); &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 在MyBatis中有两种类型的事务管理器： 1、JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 2、MANAGED这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 --&gt; &lt;transactionManager type=&quot;MANAGED&quot;&gt; &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt; &lt;/transactionManager&gt; 5、mappers这些配置会告诉了 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了 &lt;!-- 使用相对于类路径的资源引用 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;!-- 使用完全限定资源定位符（URL） --&gt; &lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;!-- 使用映射器接口实现类的完全限定类名 --&gt; &lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; &lt;/mappers&gt; &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt; &lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt; &lt;/mappers&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis第一个入门程序]]></title>
    <url>%2F2018%2F08%2F15%2FMyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 2、写一个mybatis的入门程序 (1)在Myeclipse上新建一个Java项目。首先导入jar包，在该项目下新建一个lib目录，将下列的jar包导入到lib目录下。 (2)在该项目下创建一个与src同级的source folder，取名为config。在这其中存放xml配置文件。 1)sqlMapConfig.xml(名字是自行定义的):其中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。如下所示：这里要注意DOCTYPE首部最好是在mybatis文档当中复制粘贴，不要自己手打。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- 全局配置文件 --&gt; &lt;configuration&gt; &lt;!-- 环境变量 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;!-- 以下的数据库以及密码需要配置自己的 --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- mappers元素则是包含一组mapper映射器(这些mapper的XML文件包含了SQL代码和映射定义信息) --&gt; &lt;mapper resource=&quot;Usermapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2)Usermapper.xml(和上面的配置文件中的mappers当中的mapper是一一对应的):这个配置文件主要用于进行SQL的配置。同时记得在数据库当中创建users表，且添加数据。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- mapper.xml(配置SQL) --&gt; &lt;!-- namespace命名空间，为了对SQL语句进行隔离，方便管理 mapper开发dao方式，有特殊的作用。 --&gt; &lt;mapper namespace=&quot;mappertest&quot;&gt; &lt;!-- mapper.xml文件配置的SQL语句，执行每一个SQL，都将封装为mapperStatement对象。 mapper.xml以statement为单位管理SQL语句 。 --&gt; &lt;!-- ID唯一标识Statement --&gt; &lt;!-- parameterType：输入参数类型，通过#{}，#{}中名称任意 --&gt; &lt;!-- resultType：输出结果的类型，返回单条或者多条记录，指明类型 --&gt; &lt;!-- #{}表示占位符，如果参数给出String，自动添加&apos;&apos;；${value}表示SQL语句拼接，不会自动添加&apos;&apos;。 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.entity.User&quot;&gt; select * from users where id=#{id} &lt;/select&gt; &lt;select id=&quot;findUserByName&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt; select * from users where username=#{username} &lt;/select&gt; &lt;select id=&quot;findUserByName1&quot; parameterType=&quot;string&quot; resultType=&quot;com.entity.User&quot;&gt; select * from users where username like &apos;%${value}%&apos; &lt;/select&gt; &lt;!-- 添加用户,传参时将大括号中填写的是属性名 --&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.entity.User&quot;&gt; &lt;!-- order设置是取SQL语句执行之前还是之后的值 。 resultType：返回类型。 keyProperty：将主键设置到属性。 last_insert_id()：获得刚插入的记录自动编号的值。 --&gt; &lt;selectKey order=&quot;AFTER&quot; resultType=&quot;int&quot; keyProperty=&quot;id&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into users(username,age) values(#{username},#{age}) &lt;/insert&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from users where id=#{id} &lt;/delete&gt; &lt;!-- 修改用户 ，用户的ID一定需要有值--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.entity.User&quot;&gt; update users set username=#{username},age=#{age} where id=#{id} &lt;/update&gt; &lt;/mapper&gt; (3)创建一个com.entity包，在此包下新建User.java文件。 package com.entity; public class User { private int id; private String username; private int age; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User(){ super(); } public User(String username, int age) { super(); this.username = username; this.age = age; } public User(int id, String username, int age) { super(); this.id = id; this.username = username; this.age = age; } @Override public String toString() { return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, age=&quot; + age + &quot;]&quot;; } } (4)最后创建一个com.test包，创建一个APPTest.java文件，用于junit测试(记得导入junit的jar包)。 package com.test; import java.io.IOException; import java.io.InputStream; import java.util.List; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import com.entity.User; public class AppTest { SqlSessionFactory sqlSessionFactory = null; @Before public void Init() throws IOException{ InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test public void testSelectUser() {//查找数据 SqlSession sqlSession = sqlSessionFactory.openSession(); //第一个参数是Statement的id,第二个参数是SQL语句中所需要的值。 /*User user = (User)sqlSession.selectOne(&quot;findUserById&quot;, 2); System.out.println(user.toString());*/ //List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName&quot;, &quot;EchoDemo&quot;); List&lt;User&gt; list = sqlSession.selectList(&quot;findUserByName1&quot;, &quot;Echo&quot;); for(User user:list){ System.out.println(user.toString()); } sqlSession.close(); } @Test public void testInsertUser(){//插入数据 SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(&quot;落叶物语&quot;,24); sqlSession.insert(&quot;addUser&quot;, user); sqlSession.commit();//提交 sqlSession.close(); System.out.println(&quot;当前插入用户的ID:&quot; + user.getId()); } @Test public void testDeleteUser(){//删除数据 SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.delete(&quot;deleteUser&quot;,2); sqlSession.commit(); sqlSession.close(); } @Test public void testUpdateUser(){//更新数据 SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(3,&quot;紫苏半夏&quot;,22); sqlSession.update(&quot;updateUser&quot;, user); sqlSession.commit(); sqlSession.close(); } } 1)每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。 2)SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了。因此SqlSessionFactoryBuilder实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在以保证所有的XML解析资源开放给更重要的事情。 3)SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次，多次重建SqlSessionFactory被视为一种代码“坏味道（bad smell）”。因此SqlSessionFactory的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 4)每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将SqlSession实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理作用域中，比如Servlet架构中的HttpSession。如果你现在正在使用一种Web框架，要考虑SqlSession放在一个和HTTP请求对象相似的作用域中。换句话说，每次收到的HTTP请求，就可以打开一个SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到finally块中以确保每次都能执行关闭。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML]]></title>
    <url>%2F2018%2F08%2F07%2FJava%E4%B8%AD%E7%9A%84XML%2F</url>
    <content type="text"><![CDATA[1、XML定义(1)XML指可扩展标记语言(Extensible Markup Language)，适合Web传输，类似HTML，不同的是它的设计宗旨是传输数据，而非显示数据。 (2)XML提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。XML标签没有被预定义，开发者根据需要自行定义标签。XML被设计为具有自我描述性，是W3C的推荐标准。 2、XML文档结构(1)XML声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; (2)XML根元素定义：XML文档的树形结构要求必须有一个根元素。根元素的起始标记要放在所有其他元素起始标记之前，根元素的结束标记放在其他元素的结束标记之后。 (3)XML元素：元素的基本结构由开始标记，数据内容，结束标记组成。 3、XML语法规则(1)所有XML元素都须有关闭标签。 (2)XML标签对大小写敏感。 (3)XML必须正确地嵌套。 (4)XML文档必须有根元素。 (5)XML的属性以名值对方式组成，值须加引号。 (6)XML可编写注释。 (7)在XML中，空格会被保留，文档中的空格不会被删节。 4、举例说明&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;bookstore&gt; &lt;book bookno=&quot;001&quot;&gt; &lt;title&gt;Java语言编程&lt;/title&gt; &lt;author&gt;张三&lt;/author&gt; &lt;price&gt;80&lt;/price&gt; &lt;/book&gt; . . . &lt;/bookstore&gt; 5、XML SAX解析器(1)SAX(Simple API For XML)是一个公共的基于事件的XML文档解析标准，能够通过一个简单的、快速的方法来对XML文档进行处理，和DOM相比它所占用的系统资源更少。 (2)SAX既是一个接口，也是一个软件包。作为接口，SAX是事件驱动型XML解析的一个标准接口，对文档进行顺序扫描，当扫描到文档(document)开始、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。 6、SAX解析器API(1)事件类型，大多数的SAX会产生以下类型的事件： 1)在文档的开始时和结束时触发文档处理事件。 2)在文档内每一XML元素接受解析的前后触发元素事件。 3)任何的元数据通常由单独的事件处理。 (2)举例说明 &lt;doc&gt; &lt;para&gt;Hello,iotek!&lt;/para&gt; &lt;doc&gt; 其解析过程为： 1)start document; 2)start element:doc; 3)start element.para; 4)characters:Hello,iotek!; 5)end element:para; 6)end element:doc; 7)end document; (3)解析步骤 1)创建事件处理程序(即编写ContentHandler的实现类，一般继承自DefaultHandler类，采用adapter模式) 2)创建SAX解析器 3)将事件处理程序分配到解析器。 4)对文档进行解析，将每个事件发送至事件处理程序。 (4)常用接口：ContentHandler接口 1)ContentHandler是Java类包中一个特殊的SAX接口。该接口封装了一些对事件处理的方法，当XML解析器开始解析XML输入文档时，他会遇到某些特殊的事件，比如文档的开头和结束、元素开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法(回调方法)来响应该事件。 2)ContentHandler接口常用方法： void startDocument();//文档解析开始的处理。 void endDocument();//文档解析结束的处理。 void startElement(String uri,String localName,String qName,Attributes atts);//ElementNode开始的处理。 void endElement(String uri,String localName,String qName);//ElementNode结束的处理。 void character(char[] ch,int start,int length);//具体在某一节点中的处理。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中反射与Annotation]]></title>
    <url>%2F2018%2F08%2F06%2FJava%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%8EAnnotation%2F</url>
    <content type="text"><![CDATA[1、MetaAnnotation概念(1)MetaAnnotation也称为元Annotation，也是一种Annotation，可以对其他的Annotation进行注释。 (2)Java5.0提供了一些标准的MetaAnnotation： 1)@Retention 2)@Target 3)@Documented 4)@Inherited (3)@Retention:控制被Retention注释的Annotation信息的保留时间长短。 @Retention(SOURCE/CLASS/RUNTIME) public/default @interface Annotation名称{...} a、SOURCE:Annotation信息在编译阶段被丢弃，仅保留在java源文件中。 b、CLASS(默认):Annotation信息在编译阶段被保留，保留到class文件中，但是运行阶段不存在。 c、RUNTIME:Annotation信息一直保存到运行阶段，直到退出虚拟机才被丢弃。 以上三个值是java.lang.annotation.RetentionPolicy这个类所提供的枚举值。 (4)@Target:表示一个Annotation的使用范围。 @Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD,...}) public/defalut @interface Annotation名字{...} a、TYPE:只能在类或接口或枚举上使用。 b、METHOD:在方法中使用。 c、FIELD:在成员变量使用。 d、PARAMETER:在参数上使用。 e、CONSTRUCTOR:在构造中使用。 f、LOCAL_VARIABLE:在局部变量上使用。 g、ANNOTATION_TYPE:只能在Annotation中使用。 h、PACKAGE:只能在包中使用。 (5)@Documented:想要在使用者制作JavaDoc文件的同时，也一并将Annotation的讯息加入至API文件中。 @Documented public/default @interface Annotation名称{...} (4)@Inherited:表示一个Annotation是否允许被其子类继承下来。 @Inherited public/default @inherited Annotation名称{...} 2、反射与Annotation(1)一个Annotation真正起作用，必须结合反射机制，在java.lang.reflect反射包中提供AccessibleObject类来对Annotation进行操作，最常用的方法如下： public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass);//判断是否使用时指定的Annotation。 public Annotation[] getAnnotation();//得到全部的Annotation。 注：无反射，不注解。 3、举例说明package com.iotek.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.lang.reflect.Method; public class ReflectAnnotationDemo { public static void main(String[] args) throws Exception { Class&lt;?&gt; classType = Class.forName(&quot;com.iotek.annotation.AnnotationTest&quot;); boolean flag = classType.isAnnotationPresent(Description.class); if(flag){ Description description = classType.getAnnotation(Description.class); System.out.println(&quot;AnnotationTest&apos;s description--&gt;&quot; + description.value()); Method[] methods = classType.getDeclaredMethods(); for(Method method:methods){ if(method.isAnnotationPresent(Author.class)){ Author author = method.getAnnotation(Author.class); System.out.println(&quot;AnnotationTest&apos;s author--&gt;&quot; + author.name() + &quot; from &quot;+author.group()); } } } } } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Documented @interface Author{ String name(); String group(); } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @interface Description{ String value(); } @Description(&quot;这是一个用于测试的类&quot;) class AnnotationTest{ @Author(name=&quot;EchoDemo&quot;,group=&quot;com.iotek&quot;) public void test(){ System.out.println(&quot;test over!&quot;); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Annotation]]></title>
    <url>%2F2018%2F08%2F06%2FJava%E4%B8%ADAnnotation%2F</url>
    <content type="text"><![CDATA[1、Annotation简介(1)Annotation是Java5开始引入的新特性。中文名称一般叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据与程序元素(类、方法、成员变量等)进行关联。更通俗的意思就是为程序的元素(类、方法、成员变量)加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类、构造方法、方法、成员变量、参数及本地变量的声明语句中。按照运行机制划分包括源码注解、编译时注解和运行时注解；按照来源来划分的话包括JDK注解、第三方注解和自定义注解。 (2)Annotation的原理 1)Annotation其实是一种接口。通过Java反射机制中的相关API来访问annotation信息。相关类(框架或工具的类)根据这些信息来决定如何使用该程序元素或者改变他们的行为。Annotation是不会影响程序代码的执行的，无论Annotation怎么变化，代码都始终如一地执行。 2)Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。Annotation的工具统称APT(Annotation Processing Tool)。 2、常见的标准Annotation(也称之为JDK注解，它们属于编译时注解)(1)@Override:@Override就是用来指定方法重写的，他可以强调一个子类必须要覆盖父类的方法。 (2)@Deprecated:@deprecated用于表示某个程序元素(类、方法等)已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。 (3)@SuppressWarning：@SuppressWarning指示被Annotation标识的程序元素(以及在该程序元素中的所有子元素)取消显示指定的编译器警告。 (4)举例说明 1)@Override:可以防止方法名写错。 package com.iotek.annotation; public class OVerrideDemo { public static void main(String[] args) { Apple apple = new Apple(); apple.info(); } } class Fruit{ public void info(){ System.out.println(&quot;描述水果的信息！&quot;); } } class Apple extends Fruit{ @Override public void info() { System.out.println(&quot;我是苹果！&quot;); } } 2)@Deprecated:提示程序员不推荐使用 package com.iotek.annotation; public class DeprecatedDemo { public static void main(String[] args) { Person person = new Person(); person.showInfo(); } } class Person{ @Deprecated public void showInfo(){ System.out.println(&quot;hello person!&quot;); } } 3)@Suppresswarning:去除警告信息 package com.iotek.annotation; public class SuppresswarningDemo { public static void main(String[] args) { } } class Container&lt;T&gt;{ private Object[] obj = null; public Container(){ obj = new Object[10]; } @SuppressWarnings(&quot;unchecked&quot;) public T[] toArray(){ return (T[])obj; } } 3、自定义Annotation(1)语法 访问修饰符 @interface Annotation名称{ 返回类型 method() [默认值]; } 1)Annotation类型的方法必须声明为无参数、无异常抛出的。这些方法定义了Annotation的成员：方法名成为了成员名，而方法返回值成为了成员的类型。方法的返回类型必须要为基本数据类型、String类型、Class类型、枚举类型、Annotation类型或者由前面类型之一作为元素的一维数组。 2)方法的后面可以使用default和一个默认数值来声明成员的默认值来声明成员的默认值，null不能作为成员的默认值。在定义Annotation型态时，不能继承其他的Annotation型态或是接口。 (2)举例说明 package com.iotek.annotation; //可以修饰类 @MyAnnotation1 public class MyAnnotation { //可以修饰方法 @MyAnnotation1 @MyAnnotation3 public static void main(String[] args) { //可以修饰成员变量，可以有多个注解 @MyAnnotation1 @MyAnnotation2(name=&quot;zhangsan&quot;) @MyAnnotation3(&quot;haha&quot;) @MyAnnotation4(sex=&quot;男&quot;,age=10) @MyAnnotation5({&quot;haah&quot;,&quot;hehe&quot;,&quot;ee&quot;}) @MyAnnotation6(color=Color.RED) int number = 10; } } @interface MyAnnotation1{ } @interface MyAnnotation2{ String name(); } @interface MyAnnotation3{//value和默认值 String value() default &quot;lisi&quot;;//只有为value时才可以省略&quot;value=&quot;，有默认值时可以不给值。 } @interface MyAnnotation4{//两个元素 String sex(); int age(); } @interface MyAnnotation5{//数组 String[] value(); } enum Color{ RED,BLUE,YELLOW; } @interface MyAnnotation6{//枚举类型 Color color(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中URL类的使用]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E4%B8%ADURL%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、URL概念URL(Uniform Resource Locator)统一资源定位符，它表示Internet上某一资源的地址。通过URL我们可以访问Internet上的各种网络资源，浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源。它由五个部分组成： &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#&lt;引用&gt; 2、URL编程(1)为了表示URL，java.net包中实现了类URL。我们可以通过下面的构造方法来初始化一个URL对象： URL(String url);//URL代表了一个绝对地址，URL对象直接指向这个资源。 URL(URL baseURL,String relativeURL);//其中baseURL代表绝对地址，realtiveURL代表相对地址。 URL(String protocol,String host,String file);//protocol代表通信协议，host代表主机名，file代表文件名。 URL(String protocol,String host,int port,String file); (2)获取URL对象的属性： getFile();//获得URL指定资源的完整文件名。 getHost();//返回主机名。 getPath();//返回指定资源的文件目录和文件名。 getPort();//返回端口号。 getProtocol();//返回表示URL中协议的字符串对象。 getRef();//返回URL的HTML文档标记，即#号标记。 getUserInfo();//返回用户信息。 (3)URL有两种方法可以用来访问Internet上的资源： 1)使用URL的openConnection()方法创建一个URLConnection类对象。再通过URLConnection对象获取相应的输入流和输出流。 2)利用URL类的openStream()方法。openStream()方法与指定的URL建立连接并返回InputStream类的对象。 3、举例说明package com.iotek.url; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.URL; import java.net.URLConnection; public class URLDemo { public static void main(String[] args) throws IOException { DownloadUtil.download(&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot;, &quot;baidu.jpg&quot;, &quot;f:\\test&quot;); System.out.println(&quot;下载结束！&quot;); } } class DownloadUtil{ public static void download(String urlString,String fileName,String savePath) throws IOException{ URL url = new URL(urlString); /*URLConnection conn = url.openConnection(); InputStream inputStream = conn.getInputStream();*/ InputStream inputStream = url.openStream(); byte[] buff = new byte[1024*1024]; int len = 0; File file = new File(savePath); if(!file.exists()){ file.mkdirs(); } OutputStream outputStream = new FileOutputStream(file.getAbsolutePath()+&quot;\\&quot;+fileName); while((len = inputStream.read(buff))!=-1){ outputStream.write(buff, 0, len); } inputStream.close(); outputStream.close(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中基于UDP协议的Socket编程]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E4%B8%AD%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、创建发送端(1)建立DatagramSocket对象。该端点建立，系统会随机分配一个端口。如果不想随机配置，可以手动指定。 (2)将数据进行packet包的封装，必须要指定目的地地址和端口。 (3)通过socket服务的send()方法将该包发出。 (4)将socket关闭。 2、创建接收端(1)建立DatagramSocket对象。要监听一个端口。 (2)通过socket的receive方法将数据存入数据包中。 (3)通过数据包dp的方法getData()、getAddress()、getPort()等方法获取包中的指定信息。 (4)将socket关闭。 3、举例说明(1)接收端： package com.iotek.tcpsocket; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; public class UDPDemo2 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(8000); byte[] buff = new byte[100]; DatagramPacket packet = new DatagramPacket(buff, 100); socket.receive(packet);//接收传来的数据包 System.out.println(new String(buff,0,packet.getLength())); String string = &quot;Me too!&quot;; DatagramPacket packet2 = new DatagramPacket(string.getBytes(), string.length(),packet.getAddress(),packet.getPort()); socket.send(packet2); socket.close(); } } (2)发送端： package com.iotek.tcpsocket; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; public class UDPDemo1 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(); String string = &quot;I Love You!&quot;; //将数据进行封装，封装到数据包当中 DatagramPacket packet = new DatagramPacket(string.getBytes(), string.length(),InetAddress.getByName(&quot;localhost&quot;),8000); socket.send(packet);//发送 byte[] buff = new byte[100]; DatagramPacket packet2 = new DatagramPacket(buff, 100); socket.receive(packet2); System.out.println(new String(buff,0,packet2.getLength())); socket.close(); } } (3)为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。 //编译 javac -d . UDP*.java //开启接收端 java com.iotek.tcpsocket.UDPDemo2 //开启发送端，这里另外开启一个窗口 java com.iotek.tcpsocket.UDPDemo1]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中基于TCP协议的Socket编程]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E4%B8%AD%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、Socket概述(1)所谓socket通常也称作“套接字”，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过“套接字”向网络发出请求或者应答网络请求。它是连接运行在网络上的两个程序间的双向通讯的端点。 (2)网络通讯其实指的就是socket间的通讯。通讯的两端都有socket，数据在两个socket之间通过IO来进行传输。 (3)使用socket进行网络通信的过程 1)服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求。 2)客户程序根据服务器程序所在的主机名和端口号发出连接请求。 3)如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。 4)客户和服务器通过读、写套接字进行通讯。 2、基于TCP协议的socket编程(1)创建TCP服务端步骤： 1)创建一个ServerSocket对象 2)调用accept()方法接受客户端请求 3)从socket中获取IO流 4)对IO流进行读写操作，完成与客户端的交互。 5)关闭IO流和Socket (2)创建TCP客户端步骤： 1)创建一个Socket对象 2)从Socket中获取IO流 3)对IO流进行读写操作，完成与服务端的交互 4)关闭IO流和Socket 注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。 (3)举例说明 1)服务器端 package com.iotek.tcpsocket; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.ServerSocket; import java.net.Socket; public class TCPServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(8888);//创建一个ServerSocket对象 Socket socket = serverSocket.accept();//调用accept()方法来接受客户端的请求 System.out.println(socket.getInetAddress().getHostAddress() + &quot;has connected!&quot;); //获取socket对象的输入输出流 BufferedReader bReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true); String line = null; while((line = bReader.readLine())!=null){//读取客户端传过来的数据 if(line.equals(&quot;over&quot;)){ break; } System.out.println(line); /*bWriter.write(line.toUpperCase());//把转换成大写的字符串传给客户端 bWriter.newLine();//换行，这样客户端才能知道输入什么时候结束的 bWriter.flush();*/ pWriter.println(line.toUpperCase()); } //bWriter.close(); pWriter.close(); bReader.close(); socket.close(); System.out.println(socket.getInetAddress().getHostAddress() + &quot;has disconnected!&quot;); } } 2)客户端 package com.iotek.tcpsocket; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.Socket; public class TCPClient { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;,8888); BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in)); //BufferedWriter bWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); PrintWriter pWriter = new PrintWriter(socket.getOutputStream(),true); BufferedReader bw = new BufferedReader(new InputStreamReader(socket.getInputStream())); while(true){ String line = bReader.readLine();//获取键盘所输入的字符串 /*bWriter.write(line); bWriter.newLine();//换行，这样服务端才能识别一行的结束 bWriter.flush();*/ pWriter.println(line); if(line.equals(&quot;over&quot;)){ break; } System.out.println(bw.readLine());//获取服务端传来的大写字符串 } bReader.close(); bw.close(); //bWriter.close(); pWriter.close(); socket.close(); } } 为了更直观地理解服务器端和客户端的交互过程，我们将两个文件拷贝到f盘当中。使用下列命令进行编译和执行。 //编译 javac -d . *.java //开启服务器 java com.iotek.tcpsocket.TCPServer //开启客户端，这里另外开启一个窗口 java com.iotek.tcpsocket.TCPClient]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中网络编程基础知识和通讯要素]]></title>
    <url>%2F2018%2F08%2F05%2FJava%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E9%80%9A%E8%AE%AF%E8%A6%81%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1、网络基础知识(1)计算机网络 计算机网络，就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互联成一个规模大、功能性强的网络系统，从而使众多的计算机可以方便地互相传递信息，共享硬件、软件、数据信息等资源。 (2)网络体系结构 网络体系结构定义计算机设备和其他设备如何连接在一起以形成一个允许用户共享信息和资源的通信系统。国际标准化组织ISO于1978年提出“开放系统互连参考模型”，即著名的OSI(Open System Interconnection)模型。OSI模型保证了各类设备生产厂家的产品兼容性。该模型把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 (3)TCP/IP协议 TCP/IP协议是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络接口层、网络层、传输层和应用层。 2、网络通信要素(1)网络编程的目的 网络编程的目的就是指直接或者间接地通过网络协议与其他计算机进行通讯。网络编程中有两个主要问题，一个是如何准确的定位网络上一台或者多台主机，另一个就是找到主机后如何可靠高效的进行数据传输。 (2)IP地址 网络中每台主机都必须有一个唯一的IP地址，因特网上的IP地址具有全球唯一性。对应的类-InetAddress。 (3)端口号 端口号用来表示该计算机上的应用程序，代表此应用程序逻辑地址。端口号使用一个16位的数字来表示，它的范围是0~65535,1024以下的端口号保留给预定义的服务。例如：http使用80端口。 (4)协议 为计算机网络中进行数据交互而建立的规则、标准或约定的集合。 TCP是一种面向连接的保证可靠传输的协议。 UDP是一种无连接的且不可靠的传输协议。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的RandomAccessFile]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E4%B8%AD%E7%9A%84RandomAccessFile%2F</url>
    <content type="text"><![CDATA[1、RandomAccessFile(随机访问文件)支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件指针。 2、输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，随着对字节的写入而前移此文件指针。 3、写入该隐含数组末尾之后的输出操作导致该数组扩展。该文件指针可以通过getFilePointer方法读取，通过seek方法设置该文件指针的位置。 4、RandomAccessFile举例 package com.iotek.otherio; import java.io.IOException; import java.io.RandomAccessFile; import java.util.Scanner; public class RandomAccessFileDemo { public static void main(String[] args) throws IOException { Person[] persons = {new Person(&quot;chenhao&quot;,90), new Person(&quot;justin&quot;,30),new Person(&quot;bush&quot;,80), new Person(&quot;lisi&quot;,20)}; RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;f:\\test\\3.txt&quot;, &quot;rw&quot;); /*for(int i=0;i&lt;persons.length;i++){//写入数据到RandomAccessFile这个对象中 randomAccessFile.writeChars(persons[i].getName()); randomAccessFile.writeInt(persons[i].getAge()); }*/ //读取指定位置上的Person对象 Scanner scanner = new Scanner(System.in); System.out.println(&quot;读取第几个Person对象数据&quot;); int num = scanner.nextInt(); //使用seek方法来操作存取位置 randomAccessFile.seek((num-1)*Person.size()); Person person = new Person(); person.setName(readName(randomAccessFile)); person.setAge(randomAccessFile.readInt()); System.out.println(&quot;姓名:&quot;+person.getName()); System.out.println(&quot;年龄:&quot;+person.getAge()); randomAccessFile.close(); } private static String readName(RandomAccessFile randomAccessFile) throws IOException{ char[] name = new char[15]; for(int i=0;i&lt;name.length;i++){ name[i] = randomAccessFile.readChar(); } return new String(name).replace(&apos;\u0000&apos;, &apos; &apos;); } } class Person{ private String name; private int age; public Person(){ } public Person(String name, int age) { StringBuilder builder = null; if(name!=null){ builder = new StringBuilder(name); }else{ builder = new StringBuilder(15); } builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos; this.name = builder.toString(); this.age = age; } public String getName() { return name; } public void setName(String name) { StringBuilder builder = null; if(name!=null){ builder = new StringBuilder(name); }else{ builder = new StringBuilder(15); } builder.setLength(15);//固定长度为15个，占了30个字节大小，不足时会自动补&apos;\u0000&apos; this.name = builder.toString(); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //每个对象所占的字节数 public static int size(){ return 34; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中其他的IO流]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E4%B8%AD%E5%85%B6%E4%BB%96%E7%9A%84IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1、ObjectInputStream和ObjectOutputStreamObjectInputStream和ObjectOutputStream分别与FileInputStream和FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。我们把对象以某种特定的编码格式写入称之为“序列化”。把写入的编码格式内容还原成对象称之为“反序列化”。被序列化的对象必须实现Serializable接口。 package com.iotek.otherio; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class ObjectInputOutputDemo { public static void main(String[] args) throws IOException { /*Student student = new Student(&quot;zhangsan&quot;, 30); FileOutputStream fos = new FileOutputStream(&quot;f:\\test\\1.txt&quot;); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fos); objectOutputStream.writeObject(student);//把对象序列化到指定的文件输出流中 objectOutputStream.close();//释放资源*/ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;f:\\test\\1.txt&quot;)); try { Student student = (Student)objectInputStream.readObject(); System.out.println(student); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } class Student implements Serializable{//需要实现Serializable接口 private static final long serialVersionUID = 1L; private String name; private int age; public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } } 2、InputStreamReader和OutputStreamWriter转换流是指将字节流与字符流之间进行转换。转换流的出现方便了对文件的读写，它在字符流与字节流之间架起了一座桥梁，使原本毫无关联的两种操作能够进行转化，提高了程序的灵活性。字节流中的数据都是字符时，转化成字符流操作更高效。如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式的参数，而FileReader与FileWriter是默认编码的文本文件。 package com.iotek.otherio; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; public class InputStreamWriterReaderDemo { public static void main(String[] args) throws IOException { /*OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;f:\\test\\2.txt&quot;), &quot;utf-8&quot;); BufferedWriter bw = new BufferedWriter(osw); bw.write(&quot;您好&quot;); bw.close();*/ /*BufferedReader br = new BufferedReader(new FileReader(&quot;f:\\test\\2.txt&quot;)); String line = null; while((line = br.readLine())!=null){ System.out.println(line); } br.close();*/ BufferedReader bReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;f:\\test\\2.txt&quot;),&quot;utf-8&quot;)); String line = null; while((line = bReader.readLine())!=null){ System.out.println(line); } bReader.close(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的字符流]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1、Reader和Writer抽象类字节流提供处理任何类型输入输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。字符流层次结构的顶层是Reader和Writer抽象类，它们的顶层仍然是字节流。Reader是定义Java的流式字符输入模式的抽象类。Reader抽象类中的方法和InputStream类似。Writer是定义Java的流式字符输出模式的抽象类。该类的方法都返回void值并在出错条件下抛IOException异常。Writer抽象类中的方法和OutputStream类似。 2、FileReader和FileWriterFileReader类表示可以读取文件内容的Reader类，构造方法有： FileReader(String filePath) FileReader(File fileObj) FileWriter表示可以写文件的Writer类，构造方法有： FileWriter(String filePath) FileWriter(String filePath,boolean append) FileWriter(File fileObj) 3、FileReader和FileWriter举例package com.iotek.readerwriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class FileReaderWriterDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;); char[] buffer = new char[100]; FileWriter fWriter = new FileWriter(&quot;f:\\test\\hh.txt&quot;); int len = 0;//实际读到的字符个数 while((len = fr.read(buffer))!=-1){ fWriter.write(buffer,0,len); } fr.close(); fWriter.close(); } } 4、BufferedReader和BufferedWriterBufferedReader通过缓冲区提高输入性能。BufferedWriter则通过缓冲区提高输出性能。类似于BufferedInputStream和BufferedOutputStream。分别都具有两个构造方法： BufferedReader(Reader inputStream) BufferedReader(Reader inputStream,int bufSize) BufferedWriter(Writer ouputStream) BufferedWriter(Writer outputStream,int bufSize) 5、BufferedReader和BufferedWriter举例package com.iotek.readerwriter; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class BufferedReaderWriterDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;f:\\hehe\\hehe.txt&quot;); FileWriter fw = new FileWriter(&quot;f:\\test\\hh.txt&quot;); BufferedReader bReader = new BufferedReader(fr); BufferedWriter bWriter = new BufferedWriter(fw); String line = null; while((line=bReader.readLine())!=null){ System.out.println(line); bWriter.write(line);//写入一行 bWriter.newLine();//换行 //bWriter.flush();//不使用close()方法时需要使用此方法 } bReader.close(); bWriter.close(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中使用字节流复制一个文件夹]]></title>
    <url>%2F2018%2F08%2F04%2FJava%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[1、案例介绍使用字节流复制一个文件夹中的所有内容到指定的文件夹中。 2、案例设计使用递归算法，使用字节缓冲区来提高程序效率。 3、案例实现：package com.iotek.file; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class CopyFileDemo { public static void main(String[] args) throws IOException { CopyUtil.copyDir(new File(&quot;f:\\haha&quot;), new File(&quot;f:\\ee&quot;)); } } class CopyUtil{ public static void copyDir(File src,File dst) throws IOException{ dst.mkdirs();//相比于mkdir()会创建路径中本不存在的文件夹 if(src!=null){ File[] files = src.listFiles();//遍历原文件夹中的文件或目录 if(files!=null){ for(File f:files){ if(f.isFile()){//复制文件 FileInputStream fis = new FileInputStream(f); FileOutputStream fos = new FileOutputStream(dst.getAbsolutePath() + &quot;\\&quot; + f.getName()); byte[] buffer = new byte[1024*1024]; int len = 0;//保存读到的字节个数 while((len = fis.read(buffer))!=-1){ fos.write(buffer,0,len); } fis.close(); fos.close(); }else { copyDir(f, new File(dst.getAbsolutePath()+&quot;\\&quot;+dst.getName())); } } } } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门(二)]]></title>
    <url>%2F2018%2F08%2F02%2FGit%E5%85%A5%E9%97%A8(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、比较分支//查看test分支和master之间的差别 $ git diff master test //查看当前的工作目录与另外一个分支的差别，查看与test分支的区别 $ git diff test //你也以加上路径限定符，来只比较某一个文件或目录 $ git diff test file1 //--stat 参数可以统计一下有哪些文件被改动，有多少行被改动 $ git diff test --stat 2、分布式的工作流程(1)分布式的工作流程 你目前的项目在gitproject目录下，这是我们的git仓库(repository)，假设另一个用户也想与你协作开发。他的工作目录也在这台机器上。首先，我们假设另一个用户也用相同的用户登录，只是工作在不同的目录下开发代码，实际工作中不太可能发生，大部分情况都是多个用户，这个假设只是为了让实验简化。 //克隆git仓库，建了一个新的叫&quot;myrepo&quot;的目录，这个目录里包含了一份gitproject仓库的克隆 $ git clone gitproject myrepo //查看 $ ls -l myrepo 在 myrepo 做了一些修改并且提交： $ cd myrepo //添加新的文件newfile $ echo &quot;newcontent&quot; &gt; newfile //提交修改 $ git add newfile $ git commit -m &quot;add newfile&quot; myrepo修改完成后，可以在仓库gitproject中把myrepo的修改给拉(pull)下来，合并这份修改到gitproject的git仓库。git pull命令执行两个操作: 它从远程分支(remote branch)抓取修改git fetch的内容，然后把它合并git merge进当前的分支。如果gitproject在myrepo修改文件内容的同时也做了修改的话，可能需要手工去修复冲突。 $ cd gitproject $ git pull myrepo master $ ls gitproject里可以用git fetch 来执行git pull前半部分的工作，但是这条命令并不会把抓下来的修改合并到当前分支里： $ git fetch myrepo 获取后，我们可以通过git log查看远程分支做的所有修改，由于我们已经合并了所有修改，所以不会有任何输出： $ git log -p master..myrepo/master 当检查完修改后，gitproject可以把修改合并到它的主分支中： $ git merge myrepo/master 如果我们在myrepo目录下执行git pull。myrepo会从克隆的位置拉取代码并更新本地仓库，就是把gitproject上的修改同步到本地: //进入到gitproject $ cd gitproject //添加一行内容到newfile $ echo &quot;gitproject: new line&quot; &gt;&gt; newfile //提交修改 $ git commit -a -m &apos;add newline to newfile&apos; //进入myrepo目录 $ cd myrepo //同步gitproject的所有修改 $ git pull 因为myrepo是从gitproject仓库克隆的，那么他就不需要指定gitproject仓库的地址。因为Git把gitproject仓库的地址存储到myrepo的配置文件中，这个地址就是在git pull时默认使用的远程仓库: $ git config --get remote.origin.url (2)公共git仓库 开发过程中，通常大家都会使用一个公共的仓库，并clone到自己的开发环境中，完成一个阶段的代码后可以告诉目标仓库的维护者来pull自己的代码。如果你和维护者都在同一台机器上有帐号，那么你们可以互相从对方的仓库目录里直接拉所作的修改，git命令里的仓库地址也可以是本地的某个目录名： $ git clone /path/to/repository $ git pull /path/to/other/repository //也可以是一个ssh地址： $ git clone ssh://yourhost/~you/repository (3)将修改推到一个公共仓库 通过http或是git协议，其它维护者可以通过远程访问的方式抓取(fetch)你最近的修改，但是他们 没有写权限。如何将本地私有仓库的最近修改主动上传到公共仓库中呢？最简单的办法就是用git push命令，推送本地的修改到远程Git仓库，执行下面的命令: $ git push ssh://yourserver.com/~you/proj.git master:master 或者: $ git push ssh://yourserver.com/~you/proj.git master 如果推送(push)结果不是快速向前fast forward，可能会报像错。常是因为没有使用git pull获取远端仓库的最新更新，在本地修改的同时，远端仓库已经变化了（其他协作者提交了代码），此时应该先使用git pull合并最新的修改后再执行git push： $ git pull $ git push ssh://yourserver.com/~you/proj.git master 3、git标签(1)轻量级标签 我们可以用 git tag不带任何参数创建一个标签(tag)指定某个提交(commit): //进入到gitproject目录 $ cd gitproject //查看git提交记录 $ git log //选择其中一个记录标志位stable-1的标签，注意需要将后面的8c315325替换成仓库下的真实提交内，commit的名称很长，通常我们只需要写前面8位即可 $ git tag stable-1 8c315325 //查看当前所有tag $ git tag 这样，我们可以用stable-1作为提交8c315325的代称。前面这样创建的是一个“轻量级标签”。如果你想为一个tag添加注释，或是为它添加一个签名, 那么我们就需要创建一个 “标签对象”。git tag中使用-a， -s 或是 -u三个参数中任意一个，都会创建一个标签对象，并且需要一个标签消息(tag message)来为tag添加注释。 如果没有-m 或是 -F这些参数，命令执行时会启动一个编辑器来让用户输入标签消息。当这样的一条命令执行后，一个新的对象被添加到Git对象库中，并且标签引用就指向了一个标签对象，而不是指向一个提交，这就是与轻量级标签的区别。 下面是一个创建标签对象的例子: $ git tag -a stable-2 8c315325 -m &quot;stable 2&quot; (2)签名的标签 签名标签可以让提交和标签更加完整可信。如果你配有GPG key，那么你就很容易创建签名的标签。首先你要在你的 .git/config 或 ~/.gitconfig 里配好key。 下面是示例: [user] signingkey = &lt;gpg-key-id&gt; 你也可以用命令行来配置: $ git config (--global) user.signingkey &lt;gpg-key-id&gt; 现在你可以在创建标签的时候使用-s 参数来创建“签名的标签”： $ git tag -s stable-1 1b2e1d63ff 如果没有在配置文件中配GPG key,你可以用-u参数直接指定。 $ git tag -u &lt;gpg-key-id&gt; stable-1 1b2e1d63ff]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的装饰模式]]></title>
    <url>%2F2018%2F08%2F01%2FJava%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、装饰模式的概念装饰模式以对客户透明地方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不创造更多子类的情况下，将对象的功能加以扩展。 2、装饰模式中的角色(1)抽象构建(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。如：InputStream。 (2)具体构件(Concrete Component)角色：定义一个将要接收附加责任的类。如：FileInputStream。 (3)装饰(Decorator)角色：持有一个构件对象的实例，并定义一个与抽象构建接口一致的接口。如：FilterInputStream。 (4)具体装饰(Concrete Decorator)角色：负责给构件对象“贴上”附加的责任。如：BufferedInputStream、DataInputStream。 3、举例说明(1)抽象构建角色 package com.iotek.decorator; public interface Component { void doThingA(); } (2)具体构件角色 package com.iotek.decorator; public class ConcreteComponent implements Component { @Override public void doThingA() { System.out.println(&quot;do A thing.&quot;); } } (3)装饰角色 package com.iotek.decorator; public class Decorator implements Component { private Component component = null; public Decorator(Component component) { this.component = component; } @Override public void doThingA() { component.doThingA();//调用被装饰对象的方法 } } (4)具体装饰角色1 package com.iotek.decorator; public class ConcreteDecorator1 extends Decorator { public ConcreteDecorator1(Component component) { super(component); } public void doThingA(){//调用被包装类的方法 super.doThingA(); doThingB(); } //扩展的方法 private void doThingB(){ System.out.println(&quot;do B thing.&quot;); } } (5)具体装饰角色2 package com.iotek.decorator; public class ConcreteDecorator2 extends Decorator { public ConcreteDecorator2(Component component) { super(component); } public void doThingA(){//调用被包装类的方法 super.doThingA(); doThingC(); } //扩展的方法 private void doThingC(){ System.out.println(&quot;do C thing.&quot;); } } (6)测试类 package com.iotek.decorator; public class Test { public static void main(String[] args) { ConcreteComponent concreteComponent = new ConcreteComponent(); //concreteComponent.doThingA(); ConcreteDecorator1 cd1 = new ConcreteDecorator1(concreteComponent); //cd1.doThingA(); ConcreteDecorator2 cd2 = new ConcreteDecorator2(cd1); cd2.doThingA(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1023 组个最小数]]></title>
    <url>%2F2018%2F08%2F01%2FPAT-B1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。现给定数字，请编写程序输出能够组成的最小的数。 输入格式：每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。 输出格式：在一行中输出能够组成的最小的数。 输入样例： 2 2 0 0 0 3 0 0 1 0 输出样例： 10015558 题目代码： #include&lt;iostream&gt; using namespace std; int main() { int a[10]; int t = 0; for (int i = 0;i &lt; 10;i++) { cin &gt;&gt; a[i]; } for (int i = 1;i &lt; 10;i++) {//查找第一个不包括零在内的个数不为零的数并输出一个 if (a[i] != 0) { cout &lt;&lt; i; t = i; break; } } for (int i = 0;i &lt; a[0];i++) { cout &lt;&lt; 0; } for (int i = 0;i &lt; a[t] - 1;i++) { cout &lt;&lt; t; } for (int i = t + 1;i &lt; 10;i++) { for (int j = 0;j &lt; a[i];j++) { cout &lt;&lt; i; } } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的过滤流]]></title>
    <url>%2F2018%2F08%2F01%2FJava%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1、过滤流介绍(1)过滤流(Filtered Stream)仅仅是为底层透明地提供扩展功能的输入流(输出流)的包装。这些流一般由普通类的方法(即过滤流的一个父类)访问。 (2)过滤字节流FilterInputStream和FilterOutputStream，它们不是抽象类，它们提供的方法和InputStream和OutputStream类的方法相同。构造方法有： FilterOutputStream(OutputStream os); FilterInputstream(InputStream is); 常用的过滤流有BufferedInputStream和BufferedOutputStream(带缓冲区)，需要使用已经存在的节点流(直接操作设备的流)来构造，FileInputStream就是节点流，而BufferedInputStream包装了FileInputStream。提供带缓冲的读写，提高了读写的效率。DataInputStream和DataOutputStream(对基本数据类型进行读写操作)。数据输入输出流允许应用程序读写基本Java数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取。读写顺序要保持一致。 2、过滤流举例说明(1)BufferedInputStream和BufferedOutputStream package com.iotek.inputoutputstream; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class BufferedInputOutputStreamDemo { public static void main(String[] args) { try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。 FileUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;)); } catch (IOException e) { e.printStackTrace(); } } } class FileUtil{ public static void copyFile(File src,File dst) throws IOException{ FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(dst); BufferedInputStream bis = new BufferedInputStream(fileInputStream); BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream); long time1 = System.currentTimeMillis(); int data = 0; while((data = bis.read())!=-1){//从缓冲区里面读，而不是直接从输入流里面读。 bos.write(data);//先写到缓冲区，当缓冲区满的时候再一次性写到输出流里面去。 } bis.close(); bos.close(); long time2 = System.currentTimeMillis(); System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;); } } (2)DataInputStream和DataOutputStream package com.iotek.inputoutputstream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class DataInputOutputStream { public static void main(String[] args) throws IOException { /*String name = &quot;zhangsan&quot;; int age = 10; boolean flag = true; char set = &apos;男&apos;; double money = 100.56; DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;f:\\test\\b.txt&quot;)); dos.writeUTF(name); dos.writeInt(age); dos.writeBoolean(flag); dos.writeChar(set); dos.writeDouble(money); dos.close();*/ DataInputStream dis = new DataInputStream(new FileInputStream(&quot;f:\\test\\b.txt&quot;)); //读的顺序必须和写的顺序一致 System.out.println(dis.readUTF()); System.out.println(dis.readInt()); System.out.println(dis.readBoolean()); System.out.println(dis.readChar()); System.out.println(dis.readDouble()); dis.close(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的输入输出流]]></title>
    <url>%2F2018%2F07%2F31%2FJava%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1、流的概念和分类(1)流的概念 流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件、内存或是网络连接。同理，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据就好像在这其中“流动”一样。 (2)流的分类 a、流按其流向分为“输入流”和“输出流”。 b、流按数据传输单位分为“字节流”和“字符流”。“字节流”用来读写8位二进制的字节，“字符流”用来读写16位二进制字符。 c、流按功能分为“节点流”和“过滤流”。“节点流”用于直接操作目标设备的流，例如：磁盘或一块内存区域。“过滤流”是对一个已存在的流的链接和封装，通过对数据进行处理，为程序提供功能强大、灵活的读写功能。 2、InputStream和Outputstream抽象类字节流类用于向字节流读写8位二进制的字节。一般的，字节流类主要用于读写诸如图像或声音等的二进制数据。字节流类以InputStream和OutputStream为顶层类。他们都是抽象类。InputStream中定义的方法有： public abstract int read();//从输入流中读取数据的下一个字节 public int read(byte[] b);//从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中 public int read(byte[] b ,int off ,int len);//将输入流中最多len个数据字节读入byte数组 public long skip(long n);//跳过或者丢弃此输入流中数据的n个字节 public int available();//返回从该输入流中可以读取的字节数的估计值，而不会被下一次调用此输入流的方法阻塞 public void close();//关闭输入流并释放与该流关联的所有系统资源 OutputStream抽象类所有方法返回void值，在出错情况下抛IOException异常。需要定义OutputStream子类的应用,OutputStream必须至少提供一个写入一个字节输出的方法。OutputStream中定义的方法： public abstract void write(int b);//将指定的字节写入此输出流。 public void write(byte[] b);//将b.length个字节从指定的byte数组写入此输出流 public void write(byte[] ,int off ,int len);//从指定的字节数组写入len个字节，从偏移off开始输出到此输出流。 public void flush();//刷新此输出流并强制任何缓冲的输出字节被写出。 public void close();//关闭输出流并释放与该流关联的所有系统资源 3、FileInputStream和FileOutputStream(它们分别是InputStream和OutputStream类的子类)(1)每个抽象类都有多个具体的子类，这些子类对不同的外设进行处理，例如磁盘文件，网络连接，甚至是内存缓冲区。FileInputStream类表示能从文件读取字节的InputStream类。其常用的构造方法有：FileInputStream(String filepath);FileInputStream(File fileObj);FileOutputStream类表示能向文件写入字节的OutputStream类。其常用的构造方法有：FileOutputStream(String filepath);FileOutputStream(File fileObj);FileOutputStream(String filePath,boolean append); (2)举例说明 package com.iotek.inputoutputstream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileInputStreamOutputStreamDemo { public static void main(String[] args) { try {//这里不管是读取文件，还是写入文件，都应该是文件，而不是文件夹。 FileCopyUtil.copyFile(new File(&quot;G:\\bookmarks_5_8_18.html&quot;), new File(&quot;F:\\test\\test.html&quot;)); } catch (IOException e) { e.printStackTrace(); } } } class FileCopyUtil{ public static void copyFile(File src,File dst) throws IOException{ FileInputStream fileInputStream = new FileInputStream(src); FileOutputStream fileOutputStream = new FileOutputStream(dst); long time1 = System.currentTimeMillis(); /*int data = -1; while((data = fileInputStream.read())!=-1){ fileOutputStream.write(data); }*/ byte[] buf = new byte[1024*1024];//创建一个1M大小的缓冲区，用来存放输入流中的字节数据 int len = 0;//用来保存实际读到的字节数 while((len = fileInputStream.read(buf))!=-1){ fileOutputStream.write(buf, 0, len);//使用缓冲区对文件的进行读写操作会大大提高读写的速度 } fileOutputStream.close(); fileInputStream.close(); long time2 = System.currentTimeMillis(); System.out.println(&quot;复制完成，一共花费：&quot; + (time2-time1) + &quot;毫秒&quot;); } } 4、ByteArrayInputStream和ByteArrayOutputStream(1)ByteArrayInputStream是把字节数组当成源的输入流，其内部包含一个内部缓冲区，且调用close()方法关闭ByteArrayInputStream无效。它有两个构造方法，每个都需要一个字节数组提供数据源：ByteArrayInputStream(byte array[]);ByteArrayInputStream(byte array[],int start,int numBytes);ByteArrayOutputStream是把字节数组当作目标的输出流，它也有两个构造方法：ByteArrayInputStream();ByteArrayOutputStream(int numBytes); (2)举例说明 package com.iotek.inputoutputstream; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileOutputStream; import java.io.IOException; public class ByteArrayInputOutputStream { public static void main(String[] args) throws IOException { /*String string = &quot;Hello,shanghai!&quot;; ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(string.getBytes()); int data = -1; while((data=byteArrayInputStream.read())!=-1){ System.out.print((char)data); } byteArrayInputStream.close();//这里的关闭时无效的，因为没有调用操作系统底层的函数。*/ ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byteArrayOutputStream.write(97); byteArrayOutputStream.write(65); byteArrayOutputStream.write(&quot;hello,world!&quot;.getBytes()); byte[] buff = byteArrayOutputStream.toByteArray(); for(byte b:buff){ System.out.print((char)b); } FileOutputStream fileOutputStream = new FileOutputStream(&quot;f:\\test\\a.txt&quot;,true);//true表示可以追加 byteArrayOutputStream.writeTo(fileOutputStream);//把ByteArrayOutputStream内部缓冲区中的数据写到对应的文件输出流中 byteArrayOutputStream.close();//这里的关闭同上 } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim入门]]></title>
    <url>%2F2018%2F07%2F31%2FVim%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、Vim的模式介绍(1)普通模式(Normal mode):在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。 (2)插入模式(Insert mode):在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。 (3)可视模式(Visual mode):这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。 (4)选择模式(Select mode):这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 (5)命令行模式(Command line mode):在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 (6)Ex模式(Ex mode):这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。这其中我们常用到就是普通模式、插入模式和命令行模式。 vim启动进入普通模式，处于插入模式或命令行模式时只需要按Esc或者Ctrl+[(这在vim课程环境中不管用)即可进入普通模式。普通模式中按i（插入）或a（附加）键都可以进入插入模式，普通模式中按:进入命令行模式。命令行模式中输入wq回车后保存并退出vim。 2、Vim常用命令(1)移动 1)h 左移一个字符； 2)l 右移一个字符； 3)j 下移一行； 4)k 上移一行； 5)w 移动到下一个单词； 6)b 移动到上一个单词； (2)插入 1)i 在当前光标处进行编辑； 2)I 在当前行首插入； 3)a 在光标后插入； 4)A 在当前行末插入； 5)o 在下面新建一行插入； 6)O 在上面新建一行插入； (3)保存 1):wq 保存并退出； 2):w 保存修改； 3):q 退出； 4):saveas newfilename 另存为； 5):q! 强制退出，不保存； 6):wq! 强制保存并退出； (4)删除 1)x 删除游标所在的字符 2)X 删除游标所在前一个字符 3)dd 删除整行 4)dw 删除一个单词（不适用中文） 5)d$或D 删除至行尾 6)d^ 删除至行首 7)dG 删除到文档结尾处 8)d1G 删至文档首部]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中IO框架之File]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%ADIO%E6%A1%86%E6%9E%B6%E4%B9%8BFile%2F</url>
    <content type="text"><![CDATA[1、I/O框架介绍I/O(Input/Output)是计算机输入/输出的接口。Java的核心库java.io提供了全方面的I/O接口，包括：文件系统的操作，文件读写，标准设备输出等等。 2、File类及使用(1)一个File类的对象，表示了磁盘上的文件或者目录。File类提供了与平台无关的方法来对磁盘上的文件或者目录进行操作。File类直接处理文件和文件系统。比如删除文件，获取文件长度大小等信息。File类没有提供方法从文件读取或者向文件存储信息。其构造方法有：File(String directoryPath);File(String directoryPath,String filename);File(File dirObj,String filename); (2)File定义了获取File对象标准属性的方法： public String getName();获取文件或目录的名字 public String getParent();获取父目录的路径字符串 public File getParentFile();获取父目录的File对象 public String getAbsolutePath();获取文件或目录的绝对路径 public boolean exists();判断文件或目录是否存在 public String[] list();获得目录里面的文件名和目录名。 public boolean isDirectory();判断是否是目录 public boolean isFile();判断是否是文件 public long length();获取文件的大小 public boolean delete();删除目录或者文件夹 public boolean mkdir();创建文件夹 ...... 3、IO方法举例package com.iotek.file; import java.io.File; import java.io.FileFilter; import java.io.FilenameFilter; import java.io.IOException; public class FileDemo { public static void main(String[] args) { File file = new File(&quot;f:\\hehe&quot;); System.out.println(file.getAbsolutePath());//获得绝对路径 System.out.println(file.getParent());//获得父目录的路径字符串 System.out.println(file.isDirectory());//判断是否为目录 System.out.println(file.isFile());//判断是否为文件 System.out.println(file.exists());//判断是否存在 System.out.println(file.length());//获取长度 File myFile = new File(&quot;f:\\hehe&quot;); System.out.println(myFile.mkdir());//新建一个目录 File myFile1 = new File(&quot;f:/hehe/hehe.txt&quot;); try { System.out.println(myFile1.createNewFile());//新建一个文件 } catch (IOException e) { e.printStackTrace(); } /*String[] filesStrings = file.list();//获取当前目录下的所有文件名和目录名 for(String f:filesStrings){ System.out.println(f); }*/ /*String[] filesString = myFile.list(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名 } }); for(String f:filesString){ System.out.println(f); }*/ /*File[] files = myFile.listFiles(); for(File f:files){ System.out.println(f.getName() + &quot;--&quot; + f.length());//打印文件或目录的名字和大小 }*/ /*File[] filesString = myFile.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(&quot;.gif&quot;);//查找gif后缀的文件，打印文件名 } }); for(File f:filesString){ System.out.println(f.getName() + &quot;--&quot; + f.length()); }*/ File[] files = myFile.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { return pathname.getName().endsWith(&quot;.gif&quot;); } }); for(File f:files){ System.out.println(f.getName() + &quot;--&quot; + f.length()); } } } 4、案例(1)案例说明：给定一个目录要求按层次显示目录结构信息，文件名后面加上*或者\来表示文件夹。 (2)案例分析：使用递归算法，使用File类中的ListFile方法来遍历文件夹，使用List集合。 (3)案例实现 package com.iotek.file; import java.io.File; import java.util.ArrayList; import java.util.List; public class IteratorDirDemo { public static void main(String[] args) { IteratorUtil.IteratorDir(new File(&quot;f:/git&quot;)); } } class IteratorUtil{ private static int level = 0; public static void IteratorDir(File file){ if(null!=file){ /* * 找到递归的出口，如果是文件或者是空文件夹就触碰到边界 */ if(file.isFile()||file.listFiles().length==0){ return; }else{ File[] files = file.listFiles(); files = sortFiles(files); for(File f:files){ StringBuilder sBuilder = new StringBuilder(); sBuilder.append(getTab(level)); sBuilder.append(f.getName()); if(!f.isFile()){ sBuilder.append(&quot;\\&quot;); } System.out.println(sBuilder.toString()); if(f.isDirectory()){//如果是文件夹，进入目录遍历，层级自增1 level++; IteratorDir(f); level--;//目录自减1，返回上一级目录 } } } } } private static File[] sortFiles(File[] files) {//对File类型的数组进行先目录后文件的排列 List&lt;File&gt; fList = new ArrayList&lt;File&gt;(); for(File f:files){//先存放文件夹 if(f.isDirectory()){ fList.add(f); } } for(File f:files){//再存放文件 if(f.isFile()){ fList.add(f); } } return fList.toArray(new File[fList.size()]);//把集合中的元素转化成指定大小的和指定类型的数组 } private static String getTab(int level) {//根据层级数来得到制表符的个数 StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;level;i++){ stringBuilder.append(&quot;\t&quot;); } return stringBuilder.toString(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的单例模式]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文链接:设计模式（二）——单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式。它一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。单例模式有以下两个优点。 （1）在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。 （2）避免对资源的多重占用（比如写文件操作）。 实现方式我们知道，一个类的对象的产生是由类构造函数来完成的。如果一个类对外提供了public的构造方法，那么外界就可以任意创建该类的对象。所以，如果想限制对象的产生，一个办法就是将构造函数变为私有的(至少是受保护的)，使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。 1、饿汉式所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个SimpleSingleton的实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。同时，由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。 //code public class Singleton { //在类内部实例化一个实例 private static Singleton instance = new Singleton(); //私有的构造函数,外部无法访问 private Singleton() { } //对外提供获取实例的静态方法 public static Singleton getInstance() { return instance; } } //test public class SingletonClient { public static void main(String[] args) { SimpleSingleton simpleSingleton1 = SimpleSingleton.getInstance(); SimpleSingleton simpleSingleton2 = SimpleSingleton.getInstance(); System.out.println(simpleSingleton1==simpleSingleton2); } } //result true 2、饿汉模式的变种它其实和饿汉式是一样的，都是在类被加载的时候实例化一个对象。 public class Singleton2 { //在类内部定义 private static Singleton2 instance; static { //实例化该实例 instance = new Singleton2(); } //私有的构造函数,外部无法访问 private Singleton2() { } //对外提供获取实例的静态方法 public static Singleton2 getInstance() { return instance; } } 饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。 3、静态内部类式这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比饿汉式更加合理。 public class StaticInnerClassSingleton { //在静态内部类中初始化实例对象 private static class SingletonHolder { private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); } //私有的构造方法 private StaticInnerClassSingleton() { } //对外提供获取实例的静态方法 public static final StaticInnerClassSingleton getInstance() { return SingletonHolder.INSTANCE; } } 4、懒汉式所谓懒汉式，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。 public class Singleton { //定义实例 private static Singleton instance; //私有构造方法 private Singleton(){} //对外提供获取实例的静态方法 public static Singleton getInstance() { //在对象被使用的时候才实例化 if (instance == null) { instance = new Singleton(); } return instance; } } 但这种懒汉式单例其实还存在一个线程安全问题。就是在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。 5、线程安全的懒汉式针对线程不安全的懒汉式的单例，其实解决方式很简单，就是给创建对象的方法加锁： public class SynchronizedSingleton { //定义实例 private static SynchronizedSingleton instance; //私有构造方法 private SynchronizedSingleton(){} //对外提供获取实例的静态方法,对该方法加锁 public static synchronized SynchronizedSingleton getInstance() { //在对象被使用的时候才实例化 if (instance == null) { instance = new SynchronizedSingleton(); } return instance; } } 这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。） 6、双重校验锁为了解决上面锁的范围太大的问题。我们只要缩小锁的范围就可以了。那么如何缩小锁的范围呢？相比于同步方法，同步代码块的加锁范围更小。通过使用同步代码块的方式减小了锁的范围。这样可以大大提高效率。（对于已经存在singleton的情况，无须同步，直接return）。 public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 但是，事情这的有这么容易吗？上面的代码看上去好像是没有任何问题。实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但是，该代码还存在隐患。隐患的原因主要和Java内存模型（JMM）有关。考虑下面的事件序列： (1)线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。 (2)由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。 (3)线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。 在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。不过这里提供两种替代方案，volatile关键字和final关键字来保证多个线程可以正确处理单件实例。 7、使用volatile关键字使用volatile关键字这种双重校验锁的方式用的比较广泛，他解决了前面提到的所有问题。但是，即使是这种看上去完美无缺的方式也可能存在问题，那就是遇到序列化的时候。 public class VolatileSingleton { private static volatile VolatileSingleton singleton; private VolatileSingleton() { } public static VolatileSingleton getSingleton() { if (singleton == null) { synchronized (VolatileSingleton.class) { if (singleton == null) { singleton = new VolatileSingleton(); } } } return singleton; } } 8、使用final关键字class FinalWrapper&lt;T&gt; { public final T value; public FinalWrapper(T value) { this.value = value; } } public class FinalSingleton { private FinalWrapper&lt;FinalSingleton&gt; helperWrapper = null; public FinalSingleton getHelper() { FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper; if (wrapper == null) { synchronized (this) { if (helperWrapper == null) { helperWrapper = new FinalWrapper&lt;FinalSingleton&gt;(new FinalSingleton()); } wrapper = helperWrapper; } } return wrapper.value; } } 9、枚举式这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象（下面会介绍），可谓是很坚强的壁垒啊。不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过，但是不代表他不好。 public enum Singleton { INSTANCE; public void Singleton() { } } 序列化可以破坏单例。要想防止序列化对单例的破坏，只要在Singleton类中定义readResolve就可以解决该问题： package com.hollis; import java.io.Serializable; /** * Created by hollis on 16/2/5. * 使用双重校验锁方式实现单例 */ public class Singleton implements Serializable{ private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } private Object readResolve() { return singleton; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的线程通信]]></title>
    <url>%2F2018%2F07%2F28%2FJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1、线程通信相关方法Java提供了三个重要的方法巧妙地解决线程间的通信问题。这三个方法分别是：wait()、notify()和notifyAll()。 (1)调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。 (2)调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的进程，并使该线程退出等待队列，进入可运行态。 (3)调用notifyAll()方法可以使所有正在等待队列中共享同一资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。 2、举例package com.iotek.synchronize; import java.util.LinkedList; public class ProductorConsumerDemo { public static void main(String[] args) { Basket basket = new Basket(); Productor productor = new Productor(basket); Consumer consumer = new Consumer(basket); productor.start(); consumer .start(); } } class Apple{//苹果类 private int id; public Apple(int id){ this.id = id; } @Override public String toString() { return &quot;Apple:&quot; + (id+1); } } class Basket{//篮子类 private LinkedList&lt;Apple&gt; basket = new LinkedList&lt;Apple&gt;(); public synchronized void pushApple(){//放四轮苹果 for(int i=0;i&lt;20;i++){ Apple apple = new Apple(i); push(apple); } } public synchronized void popApple(){//取四轮苹果 for(int i=0;i&lt;20;i++){ pop(); } } private void push(Apple apple){//向篮子放苹果，当存放了五个苹果就等待并通知消费者来取苹果。 if(basket.size()==5){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); }//等待并释放当前对象的锁 } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } basket.addFirst(apple);//每隔500毫秒放一个苹果进篮子里面 System.out.println(&quot;存放&quot;+apple.toString()); notify();//通知消费者来消费 } private void pop(){//向篮子取苹果，当篮子当中苹果数为零的时候，就等待并通知生产者来生产。 if(basket.size()==0){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); }//等待并释放当前对象的锁 } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } Apple apple = basket.removeFirst();//每隔500毫秒从篮子里面取一个苹果 System.out.println(&quot;吃掉&quot;+apple.toString()); notify();//通知生产者来生产 } } class Productor extends Thread{//生产者 private Basket basket = null; public Productor(Basket basket) { super(); this.basket = basket; } @Override public void run(){ basket.pushApple(); } } class Consumer extends Thread{//消费者 private Basket basket = null; public Consumer(Basket basket) { super(); this.basket = basket; } @Override public void run(){ basket.popApple(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程编程]]></title>
    <url>%2F2018%2F07%2F28%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、线程同步线程同步是为了防止多个线程访问一个数据对象时，对数据造成破坏。它是保证多线程安全访问竞争资源的一种手段。 (1)同步和锁：Java中的每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例(this实例)有关的锁；当程序运行到synchronized同步代码块时，自动获得锁定对象的锁。一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放锁。这也意味着任何其他线程都不能进入synchronized方法或者代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或者代码块。 (2)对于同步，一般而言在Java中需要完成两个操作：把竞争访问的资源表示为private；同步那些访问资源的代码，使用synchronized关键字修饰方法或者代码块。当synchronized方法执行完或者发生异常时会自动释放锁。 2、举例(1)案例介绍 某银行账号上有500元存款，一个人拿着存折去取钱，同时另一个人拿着银行卡去ATM机上取钱，各自取钱400元。要求取钱的过程中不能出现资源竞争：比如400元被取出两次、银行卡的账目不能小于0等。 (2)案例实现 package com.iotek.synchronize; public class BankDemo { public static void main(String[] args) { Bank bank1 = new Bank(); BankThread bankThread = new BankThread(bank1); bankThread.start();//柜台取钱 BankThread bankThread2 = new BankThread(bank1); bankThread2.start();//ATM机取钱 } } class Bank{ private int money = 500; private Object object = new Object();//锁这个对象也可以实现，因为任何对象都只有一个锁。 /*取钱的方法，返回取钱的数目 当一个线程去调用同步方法的时候，这个线程就调用了当前对象的锁。其他线程则等待*/ public int getMoney(int number) throws InterruptedException{ synchronized(this){ if(number &lt; 0) return -1; else if(money &lt; 0) return -2; else if(number - money &gt;0) return -3; else{ Thread.sleep(1000); money-=number; System.out.println(&quot;账户余额：&quot; + money); } return number; } } } class BankThread extends Thread{ private Bank bank = null; public BankThread(Bank bank){ this.bank = bank; } @Override public void run(){ try { System.out.println(&quot;取钱：&quot;+bank.getMoney(400)); } catch (InterruptedException e) { e.printStackTrace(); } } } 3、同步产生死锁(1)同步产生死锁的原因：当一个线程已经获取了对象1的锁，同时又想获取对象二的锁。而此时另一个线程当前已经持有了对象二的锁，而又想获取对象一的锁。这中相互等待对方释放锁的过程，会导致“死锁”。 (2)死锁举例 package com.iotek.synchronize; public class DieThreadDemo { public static void main(String[] args) throws InterruptedException { Example example = new Example(); DieThread thread1 = new DieThread(example); thread1.start(); DieThread1 thread2 = new DieThread1(example); thread2.start(); } } class Example{ private Object obj1 = new Object(); private Object obj2 = new Object(); public void method1() throws InterruptedException{//先占用对象1，再请求对象2. synchronized (obj1) { Thread.sleep(1000); synchronized (obj2) { System.out.println(&quot;method1&quot;); } } } public void method2() throws InterruptedException{//先占用对象2，再请求对象1. synchronized (obj2) { Thread.sleep(1000); synchronized (obj1) { System.out.println(&quot;method2&quot;); } } } } class DieThread extends Thread{//死亡进程1 private Example example = null; public DieThread(Example example) { super(); this.example = example; } @Override public void run(){ try { example.method1(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } class DieThread1 extends Thread{//死亡进程2 private Example example = null; public DieThread1(Example example) { super(); this.example = example; } @Override public void run(){ try { example.method2(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的生命周期]]></title>
    <url>%2F2018%2F07%2F28%2FJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[与人的生老病死一样，线程也同样要经历新建、就绪、运行、阻塞和死亡五种不同的状态。这五种状态都可以通过Thread类中的方法进行控制。 (1)新建状态(New Thread)：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。线程处于创建状态时，可通过Thread类的方法来设置线程各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。 (2)就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。 (3)运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占用CPU并转为运行状态。此时，系统真正执行线程的run()方法。可以通过Thread类的isAlive()方法来判断线程是否处于就绪状态：当线程处于就绪/运行状态时，isAlive()方法返回true；否则的话，线程可能处于阻塞状态也可能是处于停止状态。 (4)阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞状态。包括以下原因： a、当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集(Blocked Pool)内，等待超时而自动苏醒。 b、当多个线程试图进入某个同步区域(synchronized)时，没能进入该同步区域的线程会被置入锁定集(Lock Pool)，直到获得该同步区域的锁，进入就绪状态。 c、当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集(Wait Pool)中，直到执行了该对象的notify()方法，wait()/notify()方法的执行要求线程首先获取到该对象的锁。 (5)死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。 (6)终止线程的三种方法 a、使用退出标志，使线程正常退出，也就是run()方法完成后线程终止，推荐使用。 b、使用stop()方法强行终止线程(这个方法不推荐使用，因为stop()和suspend()、resume()一样，也可能发生不可预料的后果)。 c、使用interrupt()方法中断线程。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的线程模型]]></title>
    <url>%2F2018%2F07%2F28%2FJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1、概念了解(1)程序是安装在磁盘上的一段指令集合，它是静态的概念。 (2)进程是运行中的程序，是动态的概念。每个进程有独立的资源空间。 (3)线程是轻量级的进程，是程序执行流的最小单位，是程序中一个单一的顺序控制流程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。 (4)多线程是在单个程序中可以同时运行多个不同的线程执行不同的任务。一个进程可以包含一个或者多个线程。一个程序实现多个代码同时交替运行就需要产生多个线程。线程本身不拥有系统资源，与同属一个进程的其他线程共享所在进程所拥有的资源。同一进程中的多个线程之间可以并发执行。CPU会随机抽出时间，让我们的程序一会做这件事，一会做另外一件事情。多线程的目的在于，最大限度地利用CPU资源，当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源。从根本上说，这就是多线程编程的最终目的。 (5)Java运行系统在很多方面依赖于线程，所有的类库设计都考虑到多线程。Java是纯面向对象语言，Java的线程模型也是面向对象的。 (6)创建线程的方式有两种：第一，通过继承Thread类创建线程，普通Java类如继承自Thread类，就成为一个线程类，并可通过该类的start方法来启动线程，执行线程代码。Thread子类可直接实例化，但在子类中必须覆盖run方法才能真正运行线程的代码。第二，通过实现Runnable接口创建线程，实现Runnable接口的类必须借助Thread类才能创建线程(本质上还是通过继承Thread来实现)。通过Runnable接口创建线程分为两步：创建实现Runnable接口的类的实例；创建一个Thread类对象，将第一步实例化得到的Runnable对象作为参数传入Thread类的构造方法。最后通过Thread类的start方法启动线程。 2、举例说明(1)举例一：通过继承Thread类创建线程 package com.iotek.threadtest; public class HelloThreadDemo { public static void main(String[] args) { HelloThread h1HelloThread = new HelloThread(&quot;A&quot;); //h1HelloThread.setName(&quot;线程1&quot;);//自定义线程名字 h1HelloThread.start();//启动线程就会调用run方法 HelloThread h2HelloThread = new HelloThread(&quot;B&quot;); //h1HelloThread.setName(&quot;线程2&quot;); h2HelloThread.start(); } } class HelloThread extends Thread{ public HelloThread(String name) { super(name); } @Override public void run(){ for(int i = 0 ;i &lt; 5 ;i++){ System.out.println(this.getName() + &quot;:&quot; + i); } } } (2)举例二：通过实现Runnable接口创建线程 package com.iotek.threadtest; public class HelloRunnableDemo { public static void main(String[] args) { HelloRunnable helloRunnable = new HelloRunnable(); Thread thread = new Thread(helloRunnable,&quot;A&quot;); thread.start(); Thread thread2 = new Thread(helloRunnable,&quot;B&quot;); thread2.start(); } } /** * Runnable接口优于Thread的地方 * 1、避免单继承的局限，一个类可以实现多个接口，但只能继承一个类。 * 2、适合资源的共享。 * @author 紫苏半夏 * */ class HelloRunnable implements Runnable{ @Override public void run() { for(int i = 0 ;i &lt; 5 ;i++){ System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); } } } (3)举例三：Runnable接口适合资源的共享 package com.iotek.threadtest; public class SharedDataThreadDemo { public static void main(String[] args) { /*TicketThread ticketThread1 = new TicketThread(&quot;一号窗口&quot;); ticketThread1.start(); TicketThread ticketThread2 = new TicketThread(&quot;二号窗口&quot;); ticketThread2.start();*/ TicketRunnable ticketRunnable = new TicketRunnable(); Thread thread = new Thread(ticketRunnable, &quot;一号窗口&quot;); thread.start(); Thread thread1 = new Thread(ticketRunnable, &quot;一号窗口&quot;); thread1.start(); } } /*class TicketThread extends Thread{ private int ticket = 5; public TicketThread(String name){ super(name); } @Override public void run(){ while (true) { System.out.println(this.getName() + &quot;:&quot; + (ticket--)); if(ticket &lt; 1){ break; } } } }*/ class TicketRunnable implements Runnable{ private int ticket = 5; @Override public void run(){ while (true) { System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (ticket--)); if(ticket &lt; 1){ break; } } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射API(二)]]></title>
    <url>%2F2018%2F07%2F26%2FJava%E5%8F%8D%E5%B0%84API(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、案例介绍Student类，有属性id，name，age，对应的get、set方法和构造方法，现产生一个Student对象。通过反射复制此Student对象。 2、案例设计通过反射机制来获取类的属性和方法。通过反射来生成对象，并通过反射来调用其set方法来对属性进行赋值以达到复制对象的目的。最后对复制成功的对象信息进行打印。 3、方案实施(1)创建Student类。 (2)创建一个Student对象。 (3)获取Student对象所属类型的Class对象。 (4)通过调用class.newInstance方法来构建一个目标对象。 (5)获取class对象中的get和set方法。 (6)调用源对象的get方法获取属性值。 (7)调用目标对象的set方法来设置属性值。 (8)打印目标对象的数据。 4、案例实现package com.iotek.reflect; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import javax.activation.FileDataSource; import org.omg.CORBA.portable.ValueBase; public class ReflectionExampleDemo { public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{ Student student = new Student(1, &quot;EchoDemo&quot;, 22); Student student2 = (Student) ObjectCopyUtil.copyObj(student); System.out.println(&quot;复制对象成功&quot;); System.out.println(student2.toString()); } } /** * 这是一个拷贝对象的工具类，内部提供了一个拷贝对象的方法，接收源对象。 * @author 紫苏半夏 * */ class ObjectCopyUtil{ public static Object copyObj(Object obj) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{ //获取student对象所对应类型的Class对象(也就是Student类所对应的对象) Class&lt;?&gt; classType = obj.getClass(); //通过class对象的newInstance方法来构建一个目标对象 Object objCopy = classType.newInstance(); //获取Class对象的get和set方法 for(Field field : classType.getDeclaredFields()){ /*//得到属性所对应的get和set方法 String getMethodName = &quot;get&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1); String setMethodName = &quot;set&quot;+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1); //调用源对象的get方法获取属性值 Method getMethod = classType.getDeclaredMethod(getMethodName, new Class[]{}); Object value = getMethod.invoke(obj, new Object[]{}); //调用源对象的set方法给属性赋值 Method setMethod = classType.getDeclaredMethod(setMethodName, new Class[]{field.getType()}); setMethod.invoke(obj, new Object[]{value});*/ //直接获取源对象的值 field.setAccessible(true); Object value = field.get(obj); field.set(objCopy, value); } return objCopy; } } //声明一个学生类 class Student{ private int id; private String name; private int age; public Student(){ } public Student(int id, String name, int age) { super(); this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射API(一)]]></title>
    <url>%2F2018%2F07%2F24%2FJava%E5%8F%8D%E5%B0%84API(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、Java.lang.reflect库Class类和java.lang.reflect类库一起对反射的概念进行支持。在java.lang包下：Class:表示一个正在运行的Java应用程序中的类和接口，是Reflection的起源。在java.lang.reflect包下：Field类：代表类的成员变量(也称之为类的属性)；Method类：代表类的方法；Constructor类：代表类的构造方法；Array类：提供动态创建数组，以及访问数组的元素的静态方法。 2、通过反射实例化对象(1)平常情况我们通过new Object来生成一个类的实例，但有时候我们没法直接new，只能通过反射动态生成。 (2)实例化无参构造函数的对象，两种方式： Class.newInstace(); Class.getConstructor(new Class[]{}).newInstance(new Object[]{}); (3)实例化带参构造函数的对象 Class.getConstructor(Class&lt;?&gt;...parameterTypes).newInstance(Object...initargs); 3、通过反射获取并调用方法(1)获得当前类以及超类的public Method Method[] arrMethods=classType.getMethods(); (2)获得当前类申明的所有Method Method[] arrMethods=classTyep.getDeclaredMethods(); (3)获得当前类以及超类指定的public Method Method method=classType.getMethod(String name,Class&lt;?&gt;...parameterTypes); (4)获得当前类申明的指定的Method Method method=classType.getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes); (5)通过反射动态运行指定Method Object obj=method.invoke(Object obj,Object...args); 4、通过反射获取并调用属性(1)获得当前类以及超类的public Field Field[] arrFields=classType.getFields(); (2)获得当前类申明的所有Field Field[] arrFields=classType.getDeclaredFields(); (3)获得当前类以及超类指定的public Field Field field=classType.getField(String name); (4)获得当前类申明的指定的Field Field field=classType.getDeclaredField(String name); (5)通过反射动态设定Field的值 field.set(Object obj,Object value); (6)通过反射动态获取Field的值 Object obj=field.get(Object obj); 5、举例package com.iotek.reflect; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ReflectionAPIDemo { public static void main(String[] args) throws Exception{ /** * 只要用到反射，先获得Class对象。没有方法能够获得当前类的超类的private方法和属性， * 你必须通过getSuperclass()找到超类以后再去尝试获得。通常情况下，即使是当前类， * private属性或者方法也是不能访问的，你需要设置压制权限setAccessible(true)来 * 取得private的访问权。但这样的话，就破坏了面向对象的规则，所以除非万不得已，尽量少用。 */ //获取Emploee这个类所关联的class对象 Class&lt;?&gt; classType=Class.forName(&quot;com.iotek.reflect.Emploee&quot;); //通过反射机制来构造一个Emploee的实例对象(默认调用无参的构造方法) Emploee emploee=(Emploee)classType.newInstance(); //调用指定的构造方法来实例化对象 Constructor&lt;?&gt; constructor=classType.getConstructor(new Class[]{}); Emploee emploee2=(Emploee)constructor.newInstance(new Object[]{}); System.out.println(emploee); System.out.println(emploee2); //调用指定的构造方法来实例化对象(调用带参数的构造方法) Constructor&lt;?&gt; constructor1=classType.getConstructor(new Class[]{String.class,int.class}); Emploee emploee3=(Emploee)constructor1.newInstance(new Object[]{&quot;zhangsan&quot;,30}); System.out.println(emploee3); //获取class对象指定的方法，包括私有的 Method method=classType.getDeclaredMethod(&quot;toString&quot;, new Class[]{}); System.out.println(method.getName()); //方法的调用 String desc=(String) method.invoke(emploee, new Object[]{}); System.out.println(desc); //获取class对象指定的所有方法，包括私有的(私有的是默认不能被访问的) Method[] methods = classType.getDeclaredMethods(); for(Method method2 : methods){ method2.setAccessible(true);//私有的可以访问了 System.out.println(method2.getName()+&quot;--&gt;&quot;+method2.getModifiers()); } //获取Class对象所指定的属性，包括私有的(私有的默认是不能被访问的) Field field = classType.getDeclaredField(&quot;nameString&quot;); field.setAccessible(true);//可访问了 field.set(emploee, &quot;李四&quot;); System.out.println(field.get(emploee)); } } class Emploee{ private String nameString; private int age; public Emploee(){ System.out.println(&quot;无参构造法方法&quot;); } public Emploee(String nameString, int age) { super(); this.nameString = nameString; this.age = age; } public String getNameString() { return nameString; } public void setNameString(String nameString) { this.nameString = nameString; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Emploee [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;]&quot;; } } 6、使用反射机制来创建一维数组和二维数组package com.iotek.reflect; import java.lang.reflect.Array; public class ReflectionArrayDemo { public static void main(String[] args) throws ClassNotFoundException { //创建一个一维数组(String) Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;); Object obj = Array.newInstance(classType,5); Array.set(obj, 3, &quot;abc&quot;); System.out.println(Array.get(obj, 3)); //创建二维数组(3行3列) int[] dimens={3,3}; Object obj1 = Array.newInstance(int.class, dimens); Object obj2 = Array.get(obj1, 2);//获取第三行(它是一个一维数组) Array.setInt(obj2, 2, 5);//给指定位置赋值 int[][] obj3 = (int[][])obj1; System.out.println(obj3[2][2]); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的反射]]></title>
    <url>%2F2018%2F07%2F23%2FJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[1、反射概述(1)反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。 (2)JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。包括其访问修饰符、父类、实现的接口、属性和方法的所有信息，并可在运行时创建对象、修改属性(包括私有的)、调用方法(包括私有的)。 2、反射机制(1)直接创建对象不就行了吗？为什么要用反射机制？这里涉及动态和静态的概念。 静态编译：在编译时确定类型，绑定对象，如：Student stu=new Student(&quot;zhangsan&quot;,30); 动态编译：在运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现类多态的应用，用以降低类之间的耦合性。Class.forName(&quot;com.mysql.Driver.class&quot;).newInstance(); (2)优缺点 优点：反射机制可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中 缺点：反射机制对性能有影响，使用反射机制基本上是一种解释操作，这类操作总是慢于直接执行的相同操作。 (3)功能 a、在运行时判断任意一个对象所属的类。 b、在运行时构造任意一个类的对象。 c、在运行时判断任意一个类所具有的成员变量和方法。 d、在运行时调用任意一个对象的方法。 3、Class对象Class对象是Reflection故事的起源。要想操纵类中的属性和方法，都必须从获取Class对象开始。 (1)类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译一个新类，就会产生与之对应的一个Class对象。 (2)Class类没有公共构造方法。Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的方法自动构造的，因此不能显示地声明一个Class对象。 (3)获取Class对象的方式 (4)举例 package com.iotek.classtype; public class ClassDemo { public static void main(String[] args) { //通过对象名.getClass() Employee employee=new Employee(&quot;zhangsan&quot;, 30); Class&lt;?&gt; classTypeClass=employee.getClass();//问号代表可以接收任意类型的Class对象 System.out.println(classTypeClass.getName());//获取Class对象的名字 System.out.println(classTypeClass.getSuperclass().getName());//获取父类的Class对象的名字 //类名.class Class&lt;?&gt; classTypeClass2=Employee.class; System.out.println(classTypeClass2.getName());//获取Class对象的名字 System.out.println(classTypeClass2.getSuperclass().getName());//获取父类的Class对象的名字 //使用Class.forName() try { Class&lt;?&gt; classTypeClass3=Class.forName(&quot;com.iotek.classtype.Employee&quot;); System.out.println(classTypeClass3.getName());//获取Class对象的名字 System.out.println(classTypeClass3.getSuperclass().getName());//获取父类的Class对象的名字 } catch (Exception e) { e.printStackTrace(); } //获取基本数据类型的Class对象(基本数据类型没有父类) Class&lt;?&gt; classTypeClass4=int.class; System.out.println(classTypeClass4.getName());//获取Class对象的名字 //通过基本数据类型的包装类来获取对应的基本数据类型所对应的Class对象 Class&lt;?&gt; classTypeClass5=Double.TYPE; System.out.println(classTypeClass5.getName());//获取Class对象的名字 //获取基本数据类型的包装类的Class对象 Class&lt;?&gt; classTypeClass6=Double.class; System.out.println(classTypeClass6.getName());//获取Class对象的名字 System.out.println(classTypeClass6.getSuperclass().getName());//获取父类的Class对象的名字 } } class Employee{ private String nameString; private int age; public Employee(String nameString, int age) { super(); this.nameString = nameString; this.age = age; } public String getNameString() { return nameString; } public void setNameString(String nameString) { this.nameString = nameString; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的观察者模式和Swing]]></title>
    <url>%2F2018%2F07%2F23%2FJava%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8CSwing%2F</url>
    <content type="text"><![CDATA[1、观察者模式定义对象间的一种一对多的依赖关系。当一方的对象改变状态时，所有的依赖者都会得到通知并被自动更新。也称之为依赖(Dependents)、发布-订阅(Publish-Subscribe)模式。 2、观察者模式意图将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性而使得各个类紧密耦合，导致可重用性的降低。观察者模式是使得任意数目的观察者不必知道彼此的存在，且主题发生变化时都可以得到主题的通知，而同步改变状态。是一种松散耦合，具有更好的可重用性。 3、观察者模式组成 a、主题(Subject)：知道它的观察者(观察者必须实现特定接口)，可以有任意多观察者。提供注册和注销观察者的接口。 b、观察者(Observer)：为那些在主题发生变化时需要获得通知的对象定义一个更新(update)接口。 c、ConcreteSubject(具体主题)：保持实际状态数据，当状态发生变化时通知各观察者。 d、ConcreteObserver(具体观察者)：维持一个指向具体主题对象的引用。 4、观察者模式示例(1)男朋友接口 package com.iotek.observer; public interface IBoyFriend { void update(String msg);//更新信息 } (2)女生接口 package com.iotek.observer; public interface IGirl { void attachBoyFriend(IBoyFriend boyFriend);//注册一个男朋友 void deleteBoyFriend(IBoyFriend boyFriend);//删除一个男朋友 void notifyBoyFriend();//通知所有男朋友 } (3)女生实现类 package com.iotek.observer; import java.util.ArrayList; import java.util.List; public class PrettyGirl implements IGirl { private List&lt;IBoyFriend&gt; boyList=new ArrayList&lt;IBoyFriend&gt;(); private String msg=&quot;我生病了&quot;; @Override public void attachBoyFriend(IBoyFriend boyFriend) { boyList.add(boyFriend); } @Override public void deleteBoyFriend(IBoyFriend boyFriend) { if(boyList.size()&gt;0){ boyList.remove(boyFriend); } } @Override public void notifyBoyFriend() { for(int i=0;i&lt;boyList.size();i++){ IBoyFriend boyFriend=boyList.get(i); boyFriend.update(msg); } } } (4)三个男朋友实现类 package com.iotek.observer; public class LiBoyFriend implements IBoyFriend { @Override public void update(String msg) { if(msg.equals(&quot;我生病了&quot;)){ System.out.println(&quot;我现在没空&quot;); } } } package com.iotek.observer; public class WangBoyFriend implements IBoyFriend { @Override public void update(String msg) { if(msg.equals(&quot;我生病了&quot;)){ System.out.println(&quot;和我无关，我不认识你！&quot;); } } } package com.iotek.observer; public class ZhangBoyFriend implements IBoyFriend { @Override public void update(String msg) { if(msg.equals(&quot;我生病了&quot;)){ System.out.println(&quot;我马上过来&quot;); } } } (5)测试类 package com.iotek.observer; public class Test { public static void main(String[] args) { //实例化三个男朋友 ZhangBoyFriend zhnagBoyFriend=new ZhangBoyFriend(); LiBoyFriend liBoyFriend=new LiBoyFriend(); WangBoyFriend wangBoyFriend=new WangBoyFriend(); //实例化女生类，并且添加三个男朋友，删除一个男朋友 PrettyGirl girl=new PrettyGirl(); girl.attachBoyFriend(wangBoyFriend); girl.attachBoyFriend(zhnagBoyFriend); girl.attachBoyFriend(liBoyFriend); girl.deleteBoyFriend(wangBoyFriend); //女生发出信息 girl.notifyBoyFriend(); } } 5、Swing介绍(1)Java1.2引入称为Swing的新的GUI组件库。它是一个用于开发Java应用程序用户界面的开发工具包。 (2)Swing控件是用纯Java语言编写而成的，不依赖于本地操作系统的GUI，Swing控件可以跨平台运行。独立于本地平台的Swing控件被称为轻量级控件，而依赖于本地的AWT控件被称为重量级控件。 (3)它以抽象窗口工具包(AWT)为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。 (4)工具包中所有的包都是以Swing作为名称，例如：javax.swing，javax.swing.event。 6、Swing框架 7、开发Swing图形界面主要步骤导入Swing包--&gt;设置顶层容器--&gt;设置按钮和标签等Swing组件--&gt;将组件添加至容器中--&gt;处理事件。 8、简单示例package com.iotek.observer; import javax.swing.JFrame; import javax.swing.JLabel; public class SwingTest { public static void main(String[] args) { JFrame frame=new JFrame(&quot;Hello Swing&quot;);//设置一个顶级容器 JLabel label=new JLabel(&quot;你好，Swing&quot;);//创建一个Swing组件 frame.getContentPane().add(label);//将组件添加到容器内容窗格 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//单击关闭按钮时可以关闭窗口 frame.setSize(300,200); frame.setVisible(true); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的AWT事件处理]]></title>
    <url>%2F2018%2F07%2F22%2FJava%E4%B8%AD%E7%9A%84AWT%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、AWT事件处理基本概念AWT事件的处理过程中，主要涉及三类对象。 (1)Event(事件)：用户对组件的一个操作，称之为一个事件，以类的形式出现，例如，键盘操作对应的事件类是KeyEvent。其实例在该事件发生时由系统自动产生。每一种事件都对应专门的监听者。 (2)Event Source(事件源)：事件发生的场所，通常就是各个组件，例如按钮Button。事件源自己不处理事件，而是把在其自身所有可能发生的事件委托给事件监听器来处理。 (3)Event Monitor(事件监听器)：接收事件对象并对其进行处理的类的对象，通常其中某个成员方法对事件进行相应的处理。 2、事件AWT的相关事件继承于java.awt.AWTEvent类，这些事件分为两大类：低级事件和高级事件。 (1)低级事件是指基于组件和容器的事件，当一个组件发生事件，如鼠标进入、点击、拖放或组件的窗口开关等时，触发了组件事件。如：组件事件、容器事件、窗口事件、焦点事件、键盘事件、鼠标事件。 (2)高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类。比如，按下按钮和在TextField中按Enter键会触发ActionEvent事件，滑动滚动条会触发AdjustmentEvent事件，选中项目列表的某一条会触发ItemEvent事件。 3、事件监听器事件监听器通常是一个类，该类必须实现与该事件类型相对应的接口。对应的接口被称之为事件监听器接口。事件监听器接口类的名称与事件类的名称相对应，例如：MouseEvent事件类的监听器接口名为MouseListener。 4、事件适配器类Java语言为一些事件监听提供了适配器(Adapter)。我们可以通过继承事件对应的Adapter类，重写所需要的方法，无关的方法则不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序代码。java.awt.event包中定义的事件适配器类包括以下7个：MouseAdapter(鼠标适配器)、MouseMotionAdapter(鼠标运动适配器)、KeyAdapter(键盘适配器)、WindowAdapter(窗口适配器)、ComponentAdapter(组件适配器)、ComtainerAdapter(容器适配器)、FocusAdapter(焦点适配器)。 5、示例package com.iotek.awt; import java.awt.BorderLayout; import java.awt.Button; import java.awt.CardLayout; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Label; import java.awt.Panel; import java.awt.TextField; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.event.MouseMotionAdapter; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ListenerDemo { public static void main(String[] args) { MyFrame7 frame7=new MyFrame7(&quot;Listener&quot;); } } class MyFrame7 extends Frame{ private Panel card_panel=null; private Panel ctrol_panel=null; private CardLayout cardLayout=null; private FlowLayout flowLayout=null; private Label lb_1,lb_2,lb_3,lb_4; private TextField tf_contentField; private Button btn_1,btn_2,btn_3,btn_4; public MyFrame7(String title){ super(title); init(); registerListener(); } /* * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。 * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。 */ public void init(){ //创建两个面板容器 card_panel=new Panel(); ctrol_panel=new Panel(); //创建两个布局管理器 cardLayout=new CardLayout(); flowLayout=new FlowLayout(); //给面板容器设定指定的布局管理器 card_panel.setLayout(cardLayout); ctrol_panel.setLayout(flowLayout); //声明创建四个标签控件和一个文本框控件。 lb_1=new Label(&quot;First Page&quot;,Label.CENTER); lb_2=new Label(&quot;Second Page&quot;,Label.CENTER); tf_contentField=new TextField();//编辑文本框 lb_3=new Label(&quot;Third Page&quot;,Label.CENTER); lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER); //构建四个按钮对象 btn_1=new Button(&quot;First&quot;); btn_2=new Button(&quot;Second&quot;); btn_3=new Button(&quot;Third&quot;); btn_4=new Button(&quot;Forth&quot;); //把按钮添加到控制面板 ctrol_panel.add(btn_1); ctrol_panel.add(btn_2); ctrol_panel.add(btn_3); ctrol_panel.add(btn_4); //把四个标签控件和一个文本框控件添加到card_panel容器中。 card_panel.add(lb_1); card_panel.add(lb_2); card_panel.add(tf_contentField); card_panel.add(lb_3); card_panel.add(lb_4); this.add(card_panel,BorderLayout.CENTER); this.add(ctrol_panel,BorderLayout.SOUTH); this.setSize(400, 300); this.setVisible(true); } private void registerListener(){ /* * 产生一个事件监听器对象，给四个按钮注册同一个事件监听器。 */ BtnListener btnListener=new BtnListener(); btn_1.addActionListener(btnListener); btn_2.addActionListener(btnListener); btn_3.addActionListener(btnListener); btn_4.addActionListener(btnListener); lb_1.addMouseMotionListener(new MouseMotionAdapter() { @Override public void mouseMoved(MouseEvent e) { lb_1.setText(e.getX()+&quot;:&quot;+e.getY()); } }); lb_2.addMouseListener(new MouseAdapter() { @Override public void mouseExited(MouseEvent e) { System.out.println(&quot;鼠标移出&quot;); } @Override public void mouseEntered(MouseEvent e) { System.out.println(&quot;鼠标移入&quot;); } }); tf_contentField.addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { System.out.println(e.getKeyChar()); } }); this.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } class BtnListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { /*System.out.println(e.getActionCommand()); System.out.println(e.getSource());*/ Object object=e.getSource();//获得当前点击的事件源 if(object==btn_1){ cardLayout.first(card_panel);//获得第一张 }else if(object==btn_2){ cardLayout.previous(card_panel);//获得前一张 }else if(object==btn_3){ cardLayout.next(card_panel);//获得下一张 }else{ cardLayout.last(card_panel);//获得最后一张 } } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的布局管理器]]></title>
    <url>%2F2018%2F07%2F22%2FJava%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定的。在AWT中为我们提供了以下五种布局管理器。FlowLayout布局管理器、BorderLayout边界布局管理器、GridLayout网格布局管理器、CardLayout卡片布局管理器、GridBagLayout网格包布局管理器。 2、容器中组件的布局通常由布局管理器控制。每个Container(比如一个Panel或一个Frame)都有一个与它相关的缺省布局管理器，Panel容器默认是FlowLayout，Frame容器默认是BorderLayout，我们可以通过调用setLayout()来改变布局管理器。 3、我们可以通过设置空布局管理器，来控制组件的大小和位置。可以调用setLayout(null)。在设置空布局管理器之后，必须对所有的组件调用setLocation()，setSize()或者setBounds()，将它们定位在容器中。 4、FlowLayout布局管理器：流程布局通常用于布置面板中的按钮。 它可以水平排列按钮，直到不再有按钮在同一行上。 线对齐由align属性确定。 可能的值是：LEFT、RIGHT、CENTER、LEADING、TRAILING。 package com.iotek.awt; import java.awt.Button; import java.awt.Color; import java.awt.FlowLayout; import java.awt.Frame; public class FlowLayoutDemo { public static void main(String[] args) { MyFrame3 frame3=new MyFrame3(&quot;FlowLayout&quot;); frame3.init(); } } class MyFrame3 extends Frame{ public MyFrame3(String title){ super(title); } public void init(){ //FlowLayout layout=new FlowLayout();//构造一个新的 FlowLayout中心对齐和默认的5单位水平和垂直间隙。 //FlowLayout layout=new FlowLayout(FlowLayout.LEFT);//构造一个新的 FlowLayout左对齐和默认的5单位水平和垂直间隙。 FlowLayout layout=new FlowLayout(FlowLayout.RIGHT,50,50);//构造一个新的 FlowLayout右对齐和默认的5单位水平和垂直间隙均为50。 this.setLayout(layout); this.setBackground(Color.cyan); this.add(new Button(&quot;btn1&quot;));//添加按钮 this.add(new Button(&quot;btn2&quot;)); this.add(new Button(&quot;btn3&quot;)); this.add(new Button(&quot;btn4&quot;)); this.add(new Button(&quot;btn5&quot;)); this.add(new Button(&quot;btn6&quot;)); this.add(new Button(&quot;btn7&quot;)); this.add(new Button(&quot;btn8&quot;)); this.setSize(300, 200); this.setVisible(true); } } 5、BorderLayout布局管理器：边界布局设置了一个容器，安排和调整其组件，以适应五个区域：北，南，东，西和中心。 每个区域可以含有不超过一个部件，并且通过相应的常数确定： NORTH ， SOUTH ， EAST ， WEST和CENTER 。 package com.iotek.awt; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Color; import java.awt.FlowLayout; import java.awt.Frame; public class BorderLayoutDemo { public static void main(String[] args) { MyFrame4 frame4=new MyFrame4(&quot;BorderLayout&quot;); frame4.init(); } } class MyFrame4 extends Frame{ public MyFrame4(String title){ super(title); } public void init(){ this.setBackground(Color.cyan); this.add(new Button(&quot;btn1&quot;),BorderLayout.EAST);//添加按钮在东边 this.add(new Button(&quot;btn2&quot;),BorderLayout.WEST); this.add(new Button(&quot;btn3&quot;),BorderLayout.NORTH); this.add(new Button(&quot;btn4&quot;),BorderLayout.SOUTH); this.add(new Button(&quot;btn5&quot;),BorderLayout.CENTER); this.setSize(300, 200); this.setVisible(true); } } 6、GridLayout布局管理器：它将一个容器的组件放在矩形网格中。 容器被分成等大小的矩形，并且每个矩形中放置一个组件。当行数和列数都被设置为非零值时，无论是通过构造函数还是setRows和setColumns方法，都会忽略指定的列数。而是从指定的行数和布局中的组件总数确定列的数量。因此，例如，如果已经指定了三行和两列，并且将九个组件添加到布局，则它们将显示为三列三列。仅当行数设置为零时，才指定列数影响布局。 package com.iotek.awt; import java.awt.Button; import java.awt.Color; import java.awt.Frame; import java.awt.GridLayout; public class GridLayoutDemo { public static void main(String[] args) { MyFrame5 frame5=new MyFrame5(&quot;GridLayout&quot;); frame5.init(); } } class MyFrame5 extends Frame{ public MyFrame5(String title){ super(title); } public void init(){ //GridLayout gridLayout=new GridLayout();//在单个行中创建一个每个组件的默认值为一列的网格布局。 //GridLayout gridLayout=new GridLayout(3,2);//创建具有指定行数和列数的网格布局。 GridLayout gridLayout=new GridLayout(3,2,10,10);//创建具有指定行数和列数的网格布局，且指定水平和垂直间隔。 this.setLayout(gridLayout); this.setBackground(Color.cyan); this.add(new Button(&quot;btn1&quot;)); this.add(new Button(&quot;btn2&quot;)); this.add(new Button(&quot;btn3&quot;)); this.add(new Button(&quot;btn4&quot;)); this.add(new Button(&quot;btn5&quot;)); this.add(new Button(&quot;btn6&quot;)); this.add(new Button(&quot;btn7&quot;)); this.setSize(300, 200); this.setVisible(true); } } 7、 CardLayout布局管理器：它将容器中的每个组件视为一张卡。 一次只能看到一张卡片，容器就是一堆卡片。添加到CardLayout对象的第一个组件是首次显示容器时的可见组件。卡片的顺序由容器自己的组件对象的内部顺序决定。CardLayout定义了一组允许应用程序顺序翻转这些卡片或显示指定卡片的方法。 addLayoutComponent(java.awt.Component, java.lang.Object)方法可用于将字符串标识符与给定卡相关联，以便快速随机访问。 package com.iotek.awt; import java.awt.BorderLayout; import java.awt.Button; import java.awt.CardLayout; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Label; import java.awt.Panel; import java.awt.TextField; public class CardLayoutDemo { public static void main(String[] args) { MyFrame6 frame6=new MyFrame6(&quot;CardLayout&quot;); frame6.init(); } } class MyFrame6 extends Frame{ private Panel card_panel=null; private Panel ctrol_panel=null; private CardLayout cardLayout=null; private FlowLayout flowLayout=null; private Label lb_1,lb_2,lb_3,lb_4; private TextField tf_contentField; private Button btn_1,btn_2,btn_3,btn_4; public MyFrame6(String title){ super(title); } /* * 在一个窗口当中设置两个面板，上面的面板设置成CardLayout布局管理器，下面的面板设置成FlowLayout布局管理器。 * 由于Frame默认是BorderLayout布局管理器，将上面的面板放进窗体的Center位置，下面的面板放在South位置。 */ public void init(){ //创建两个面板容器 card_panel=new Panel(); ctrol_panel=new Panel(); //创建两个布局管理器 cardLayout=new CardLayout(); flowLayout=new FlowLayout(); //给面板容器设定指定的布局管理器 card_panel.setLayout(cardLayout); ctrol_panel.setLayout(flowLayout); //声明创建四个标签控件和一个文本框控件。 lb_1=new Label(&quot;First Page&quot;,Label.CENTER); lb_2=new Label(&quot;Second Page&quot;,Label.CENTER); tf_contentField=new TextField();//编辑文本框 lb_3=new Label(&quot;Third Page&quot;,Label.CENTER); lb_4=new Label(&quot;Forth Page&quot;,Label.CENTER); //构建四个按钮对象 btn_1=new Button(&quot;First&quot;); btn_2=new Button(&quot;Second&quot;); btn_3=new Button(&quot;Third&quot;); btn_4=new Button(&quot;Forth&quot;); //把按钮添加到控制面板 ctrol_panel.add(btn_1); ctrol_panel.add(btn_2); ctrol_panel.add(btn_3); ctrol_panel.add(btn_4); //把四个标签控件和一个文本框控件添加到card_panel容器中。 card_panel.add(lb_1); card_panel.add(lb_2); card_panel.add(tf_contentField); card_panel.add(lb_3); card_panel.add(lb_4); this.add(card_panel,BorderLayout.CENTER); this.add(ctrol_panel,BorderLayout.SOUTH); this.setSize(400, 300); this.setVisible(true); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的AWT框架和容器]]></title>
    <url>%2F2018%2F07%2F22%2FJava%E4%B8%AD%E7%9A%84AWT%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、GUI概述(1)GUI(Graphical User Interface)图形化用户界面。用户和程序之间可以通过GUI能方便友好地进行交互。在Java语言中，JFC(Java Foundation Classed)是开发GUI的API集，它主要包括以下几个部分： a、AWT(抽象窗口工具包)：Java开发用户界面最初的工具包，是建立JFC的主要基础。 b、Swing组件：建立在AWT之上，新的，功能更强大的图形组件包。 c、JAVA2D：实现高质量的二维图形。 ...... 2、AWT框架(1)在java.awt包中包含了一个完整的类集以支持GUI程序的设计。awt所提供的控件一般称之为重量级控件，因为awt主要依靠本地方法(操作系统所提供的图形库)来实现其功能，基于此Java为了实现一次编译到处运行的概念，awt就不得不通过牺牲功能来实现(取各个操作系统的交集)。其中的类及相互关系可以用下图来描述。 (2)Component类是最核心的类，它是构成Java图形用户界面的基础，大部分组件都是有该类派生出来的。Component类主要由基本组件和容器(Container)组件组成。容器组件组要分为Window容器和Panel容器。 (3)Frame容器 a、Window是能独立存在的容器，它有一个子类Frame，它是一个带有标题和缩放角的窗口。 b、Frame有一个构造方法Frame(String title)。 c、你可以通过add()方法，在Frame容器中加入其它的组件。 d、Frame容器有默认的布局管理器。 e、Frame被创建后，是不可见的。 f、示例 package com.iotek.awt; import java.awt.Color; import java.awt.Frame; public class FrameDemo1 { public static void main(String[] args) { MyFrame1 myFrame1=new MyFrame1(&quot;标题&quot;); myFrame1.init(); } } class MyFrame1 extends Frame{ public MyFrame1(String title){ super(title); } public void init(){ //this.setSize(300,300);//设置窗体的宽和高 this.setBounds(100, 100, 300, 300);//移动并调整此组件的大小。 this.setBackground(Color.GREEN);//给窗体设置背景颜色 this.setVisible(true);//设置窗体可见 } } (4)Panel容器 a、Panel只能存在于其它的容器(Window或者其子类)中才能显示出来。 b、通过Panel的默认构造方法Panel()可以创建一个Panel。 c、示例 package com.iotek.awt; import java.awt.Button; import java.awt.Color; import java.awt.Frame; import java.awt.Panel; public class FrameDemo2 { public static void main(String[] args) { MyFrame2 myFrame2=new MyFrame2(&quot;我的窗体&quot;); myFrame2.init(); } } class MyFrame2 extends Frame{ public MyFrame2(String title){ super(title); } public void init(){ this.setSize(300, 300); this.setBackground(Color.GREEN); this.setLayout(null);//去掉窗体的默认布局管理器 Panel panel=new Panel(); panel.setLayout(null);//去掉panel容器的默认布局管理器 panel.setBackground(Color.blue); panel.setBounds(0, 0, 200, 200);//移动并调整此组件的大小。 Button btn1=new Button(&quot;clickMe&quot;); btn1.setBounds(0, 0, 100, 100); btn1.setBackground(Color.red); panel.add(btn1);//添加按钮到面板中 this.add(panel);//把panel加到窗体中 this.setVisible(true);//让窗体显示 } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨中漫步]]></title>
    <url>%2F2018%2F07%2F22%2F%E9%9B%A8%E4%B8%AD%E6%BC%AB%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下着小雨的清晨，去楼下吃一碗汤粉，和着鲜红的辣酱，调至自己喜欢的口味，把汤都喝完。在幽深的小巷子里面一个人缓慢地走着，两旁是高大的法国梧桐。想起当年的蒋中正因为宋美龄的一句话，便在六朝古都的金陵广种法国梧桐。或许这是政治手段的表现手法，亦或许这只是传言、是虚假的。但此刻的我宁愿相信他对她的渴慕是真实的，是带着恋人之间的浪漫的。树叶上汇聚的雨点滴落在伞上，发出清脆的轻响，日光暗淡幽然，小巷仍然向前延伸。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Collections]]></title>
    <url>%2F2018%2F07%2F21%2FJava%E4%B8%AD%E7%9A%84Collections%2F</url>
    <content type="text"><![CDATA[1、Collections类及常用API(1)Collections类集工具类，定义了若干用于类集和映射(Map)的算法，这些算法被定义为静态方法。 (2)常用方法：public static void sort(List list);public static int binarySearch(List list,T key);public static void reverse(List&lt;?&gt; list);public static void shuffle(List&lt;?&gt; list);public static vodi swap(List&lt;?&gt; list,int i,int j);public static void fill(List&lt;? super T&gt; list,T obj); (3)举例 package com.iotech.set; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CollectionsDemo1 { public static void main(String[] args) { List&lt;String&gt; nList=new ArrayList&lt;String&gt;(); nList.add(&quot;chenhao&quot;); nList.add(&quot;zhangsan&quot;); nList.add(&quot;lisi&quot;); nList.add(&quot;wangwu&quot;); nList.add(&quot;rose&quot;); nList.add(&quot;mary&quot;); System.out.println(&quot;操作前&quot;); for(String s:nList){ System.out.print(s+&quot; &quot;); } System.out.println(); System.out.println(&quot;交换顺序后&quot;); Collections.swap(nList, 1, 2); for(String s:nList){ System.out.print(s+&quot; &quot;); } System.out.println(); System.out.println(&quot;自然排序后&quot;); Collections.sort(nList); for(String s:nList){ System.out.print(s+&quot; &quot;); } System.out.println(); System.out.println(&quot;打乱顺序后&quot;); Collections.shuffle(nList); for(String s:nList){ System.out.print(s+&quot; &quot;); } System.out.println(); System.out.println(&quot;填充后&quot;); Collections.fill(nList, &quot;chenhao&quot;); for(String s:nList){ System.out.print(s+&quot; &quot;); } } } 2、对ArrayList容器中的内容进行排序(1)案例介绍 ArrayList中存储了多个person对象，(此对象包含，名字，年龄，ID)要求按年龄从小到大排序，年龄相等的话再按名字的大小来排序输出。 (2)案例设计 使用ArrayList来存储Person对象，使用Collections类所提供的静态sort方法来按要求对ArrayList进行排序，最终输出排好序的结果信息。(这里需要重写Comparator方法。) (3)代码实现 package com.iotech.set; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; public class CollectionsDemo2 { public static void main(String[] args) { ArrayList&lt;Person&gt; nList=new ArrayList&lt;Person&gt;(); nList.add(new Person(&quot;zhangsan&quot;, 17, 0)); nList.add(new Person(&quot;lisi&quot;, 18, 1)); nList.add(new Person(&quot;xiaohong&quot;, 19, 2)); nList.add(new Person(&quot;chenhao&quot;, 20, 3)); nList.add(new Person(&quot;mary&quot;, 17, 4)); Collections.sort(nList,new Comparator&lt;Person&gt;(){//匿名内部类 @Override public int compare(Person o1, Person o2) { int x=o1.getAge()-o2.getAge(); if(x&gt;0) return 1; else if(x&lt;0) return -1; else{ return o1.getNameString().compareTo(o2.getNameString()); } } }); for(Person person:nList){ System.out.println(person.toString()); } } } class Person{ private String nameString; private int age; private int id; public Person(String nameString, int age, int id) { super(); this.nameString = nameString; this.age = age; this.id = id; } public String getNameString() { return nameString; } public void setNameString(String nameString) { this.nameString = nameString; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return &quot;Person [nameString=&quot; + nameString + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &quot;]&quot;; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Set]]></title>
    <url>%2F2018%2F07%2F20%2FJava%E4%B8%AD%E7%9A%84Set%2F</url>
    <content type="text"><![CDATA[1、Set容器的特点Set容器是一个不包含重复元素的Collection，并且最多包含一个null元素，它和List容器相反，Set容器不能保证其元素的顺序。最常用的两个Set接口的实现类是HashSet和TreeSet。 2、HashSet及常用API(1)HashSet扩展AbstractSet并实现Set接口，HashSet使用散列表(又称之为哈希表)进行存储。(HashSet底层实际上维护了一个HashMap，只是我们操作的是HashMap的key，而HashMap底层维护了哈希表) (2)构造方法：HashSet();HashSet(Collection c);HashSet(int capacity);HashSet(int capacity,float fillRatio)。 (3)HashSet没有定义任何超过它的父类和接口提供的其他方法，散列集合没有确保其元素的顺序，因为散列处理通常不参与排序。 (4)举例 package com.iotech.set; import java.util.HashSet; public class HashSetDemo1 { public static void main(String[] args) { /*HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;(); hashSet.add(&quot;zhangsan&quot;); hashSet.add(&quot;lisi&quot;); hashSet.add(&quot;jay&quot;); hashSet.add(&quot;jack&quot;); System.out.println(hashSet.add(&quot;jay&quot;)); System.out.println(hashSet);*/ HashSet&lt;Student&gt; hashSet=new HashSet&lt;Student&gt;(); System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20))); System.out.println(hashSet.add(new Student(&quot;李四&quot;, 30))); System.out.println(hashSet.add(new Student(&quot;张三&quot;, 20))); System.out.println(hashSet.size()); } } class Student{ private String name; private int age; public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } 3、TreeSet及常用API(1)TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储，访问和检索很快。在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择。(事实上，TreeSet的底层就是TreeMap实现的，只是我们操作的是TreeMap的Key) (2)构造方法：TreeSet();TreeSet(Collection c);TreeSet(Comparator comp);TreeSet(SortedSet ss)。 (3)举例 package com.iotech.set; import java.util.Iterator; import java.util.TreeSet; public class TreeSetDemo1 { public static void main(String[] args) { TreeSet&lt;Person&gt; treeSet=new TreeSet&lt;Person&gt;(); treeSet.add(new Person(&quot;chenhao&quot;, 30)); treeSet.add(new Person(&quot;lisi&quot;, 20)); treeSet.add(new Person(&quot;wangwu&quot;, 10)); treeSet.add(new Person(&quot;rose&quot;, 40)); Iterator&lt;Person&gt; iterator=treeSet.iterator(); while(iterator.hasNext()){ Person person=iterator.next(); System.out.println(person.getName()+&quot;--&gt;&quot;+person.getAge()); } } } class Person implements Comparable&lt;Person&gt;{ private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public int compareTo(Person o) { int x=this.age-o.age; if(x&gt;0) return 1; else if(x&lt;0) return -1; return 0; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Map]]></title>
    <url>%2F2018%2F07%2F20%2FJava%E4%B8%AD%E7%9A%84Map%2F</url>
    <content type="text"><![CDATA[1、Map接口详解(1)映射(map)是一个存储键/值对的对象。给定一个键，可以查询到它的值，键和值都是对象。 (2)键必须是唯一的，值可以重复。 (3)有些映射可以接收null键和null值，而有的不能。 (4)Map接口定义的方法：int size();boolean isEmpty();boolean containsKey(Object key);boolean containsValue(Object value);V get(Object key);V put(K key,V value);V remove(Object key);Collection values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();返回包含的映射关系的Set视图，Map接口定义的entrySet()方法返回包含映射项Entry的集合(Set)，集合中元素是Map.Entry类型。 (5)Map.Entry接口代表映射项(键-值对)类型，是Map的嵌套类型(是Map的内部类)。 (6)Map.Entry接口定义的方法：K getKey();V getValue();V setValue(V value)。 2、HashMap及常用API(1)HashMap类是基于哈希表的map接口的实现，并允许使用null键和null值。 (2)构造方法：HashMap();HashMap(Map m);HashMap(int capacity);HashMap(int capacity,float fillRatio)。 (3)HashMap实现并扩展AbstractMap，本身并没有增加任何新的方法。 (4)散列映射不保证它的元素的顺序，元素加入散列映射的顺序并不一定是它们被迭代读出的顺序。 (5)HashMap常用方法举例 package com.iotech.map; import java.util.Collection; import java.util.HashMap; import java.util.Map.Entry; import java.util.Set; public class HashMapDemo1 { public static void main(String[] args) { //HashMap&lt;String,String&gt; hashmap=new HashMap&lt;String, String&gt;();//构造一个空的 HashMap ，默认初始容量（16）和默认负载系数（0.75）。 HashMap&lt;String,String&gt; hashmap=new HashMap&lt;String, String&gt;(1);//构造一个空的 HashMap具有指定的初始容量和默认负载因子（0.75）。 hashmap.put(&quot;jay&quot;, &quot;张三&quot;); hashmap.put(&quot;jay&quot;, &quot;李四&quot;); hashmap.put(&quot;rose&quot;, &quot;玫瑰&quot;); hashmap.put(&quot;Mary&quot;, &quot;小红&quot;); System.out.println(hashmap); //获取map中的所有键 /*Set&lt;String&gt; keysSet=hashmap.keySet(); for(String name:keysSet){ System.out.println(name); }*/ //获取map中的所有值 Collection&lt;String&gt; values=hashmap.values(); for(String value:values){ System.out.println(value); } //得到key的同时得到key所对应的值 Set&lt;String&gt; keysSet=hashmap.keySet(); for(String name:keysSet){ System.out.println(name+&quot;--&gt;&quot;+hashmap.get(name)); } System.out.println(hashmap.size()); System.out.println(hashmap.isEmpty()); //当我们调用put(key,value)方法的时候，首先会把key和value封装到Entry这个静态内部类对象中。 //把Entry对象再添加到数组中，所以我们想获取map中的所有键值对，我们只要获取数组中的所有Entry对象， //接下来调用Entry对象中的getkey()和getvalue()方法就能获取键值对。 Set&lt;Entry&lt;String,String&gt;&gt; entrySet=hashmap.entrySet(); for(Entry&lt;String, String&gt; entry:entrySet){ System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue()); } /* * hashmap调用默认构造方法会产生一个底层长度为16的Entry数组 * int hash=hash(key.hashCode()); * 首先调用key的hashCode方法来得到一个整数(哈希码)，把哈希码作为参数传到hash函数中来进行运算(散列运算) * 得到一个整型(散列值)。hashCode()方法能够提高哈希表的性能。 * int i=indexFor(hash,table.length); * 把散列值和数组的长度来进行运算，最终得到entry对象存放到数组的位置(下标)。 * * hashmap内部的结构是一个数组链表结构。因为不同的key有可能算出来是相同的散列值，根据散列值计算出存放数组 * 的下标会冲突。 */ } } 3、哈希码的产生和使用(1)hashCode的常规协定：在Java应用程序执行期间，在对同一对象多次调用hashCode方法时，必须一致地返回相同的整数，前提是将对象进行equals比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 (2)如果根据equals(Object)方法，两个对象是相等的那么这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。(这里的equals方法是指Object类中没有被子类重写过的equals方法)。 (3)如果根据equals(java.lang.Object)方法，两个对象不相等，那么对这两个对象中的任一对象上调用hashCode方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。 (4)举例 package com.iotech.map; import java.util.HashMap; import java.util.Map; public class HashCodeDemo2 { public static void main(String[] args) { Map&lt;Student, String&gt; map=new HashMap&lt;Student, String&gt;(); map.put(new Student(&quot;jay&quot;, 20), &quot;张三&quot;); map.put(new Student(&quot;lisi&quot;, 30), &quot;李四&quot;); map.put(new Student(&quot;rose&quot;, 20), &quot;玫瑰&quot;); map.put(new Student(&quot;lisi&quot;, 30), &quot;陈豪&quot;); /*要满足student键值相等，首先需要hashCode相等，另外还需要key的equals方法相等。所以需要重写 hashCode()和equals()方法。*/ System.out.println(map); System.out.println(map.size()); } } class Student{ private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public Student(String name, int age) { super(); this.name = name; this.age = age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } 4、TreeMap及常用API(1)TreeMap类通过使用红黑树实现Map接口。 (2)TreeMap提供按排序顺序存储键/值对的有效手段，同时允许快速检索。 (3)TreeMap不像散列映射，树映射保证它的元素按关键字升序排序。 (4)TreeMap的构造方法：TreeMap();TreeMap(Comparator comp);TreeMap(Map m);TreeMap(SortedMap sm)。 (5)TreeMap实现SortedMap并且扩展AbstractMap，它本身没有定义其他的方法。 (6)举例一 package com.iotech.map; import java.util.Set; import java.util.TreeMap; import java.util.Map.Entry; public class TreeMapDemo1 { public static void main(String[] args) { TreeMap&lt;String,String&gt; treeMap=new TreeMap&lt;String, String&gt;(); treeMap.put(&quot;jack&quot;, &quot;zhangsan&quot;); treeMap.put(&quot;mary&quot;, &quot;xiaohong&quot;); treeMap.put(&quot;rose&quot;, &quot;xiaozhang&quot;); treeMap.put(&quot;free&quot;, &quot;xiaoming&quot;); treeMap.put(&quot;rose&quot;, &quot;chenhao&quot;); //TreeMap是按照键来进行排序的，而String实现了comparable接口，所以是没有问题的。 System.out.println(treeMap); Set&lt;Entry&lt;String, String&gt;&gt; entrySet=treeMap.entrySet(); for(Entry&lt;String, String&gt; entry:entrySet){ System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue()); } } } (7)举例二 package com.iotech.map; import java.util.Comparator; import java.util.TreeMap; public class TreeMapDemo2 { public static void main(String[] args) { TreeMap&lt;Person,String&gt; treeMap=new TreeMap&lt;Person,String&gt;(new Comparator&lt;Person&gt;() { @Override public int compare(Person o1, Person o2) { int x=o1.getAge()-o2.getAge(); if(x&gt;0) return 1; else if(x&lt;0) return -1; return 0; } }); treeMap.put(new Person(&quot;zhangsan&quot;, 30), &quot;张三&quot;); treeMap.put(new Person(&quot;lisi&quot;, 31), &quot;李四&quot;); treeMap.put(new Person(&quot;rose&quot;, 32), &quot;玫瑰&quot;); treeMap.put(new Person(&quot;zhangsan&quot;, 33), &quot;张三&quot;); //这里的Person作为TreeMap中的键，也是需要进行排序的，所以Person类也需要继承Comparable接口， //因此也需要重写CompareTo()方法。 System.out.println(treeMap); } } class Person/* implements Comparable&lt;Person&gt;*/{ private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } /*@Override public int compareTo(Person o) { int x=this.age-o.getAge(); if(x&gt;0){ return 1; }else if(x&lt;0){ return -1; } return 0; }*/ } 5、Comparator和Comparable接口TreeMap的key存储引用数据类型，需要满足一定条件，要么引用类型实现Comparable接口，要么为该TreeMap容器提供实现Comparator接口的比较器对象。对应上面例二的两种实现方式。 6、案例讲解(1)给定一个字符数组，数组中内容有重复，现要求打印输出各个字符串出现的次数。 (2)使用HashMap来设计，HashMap的key可以用来保存字符串，value用来保存字符串所对应的次数，从HashMap中获取不存在的key所对应的值为null。 (3)代码实现 package com.iotech.map; import java.util.HashMap; import java.util.Map.Entry; import java.util.Set; public class HashMapTest { public static void main(String[] args) { String[] string={&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;,&quot;jack&quot;,&quot;zhangsan&quot;,&quot;zhangsan&quot;,&quot;wangwu&quot;}; HashMap&lt;String,Integer&gt; hashMap=new HashMap&lt;String,Integer&gt;(); for(int i=0;i&lt;string.length;i++){ if(null==hashMap.get(string[i])){ hashMap.put(string[i], 1); }else{ hashMap.put(string[i], hashMap.get(string[i])+1); } } Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet=hashMap.entrySet(); for(Entry&lt;String,Integer&gt; entry:entrySet){ System.out.println(entry.getKey()+&quot;--&gt;&quot;+entry.getValue()); } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的迭代模式举例]]></title>
    <url>%2F2018%2F07%2F19%2FJava%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%BC%8F%E4%B8%BE%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1、案例介绍提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。自定义容器和迭代器。 2、案例设计迭代器角色(Iterator)、具体迭代器角色(Concrete Iterator)、容器角色(Container)、具体容器角色(Concrete Container)。 定义具体的迭代器角色(我们可以取名为MyIterator)用来实现迭代器角色接口(如Iterator接口，在使用当中，其主要包含hasNext()方法和next()方法)。对于容器角色和具体的容器角色，可以比较直观地把List看作是容器角色，而把ArrayList看作是具体容器角色。 3、具体实现(1)迭代器角色 package com.iotech.myiterator; public interface Iterator&lt;T&gt; { public boolean hasNext();//判断是否有下一个元素 public T next();//获取下一个元素的内容 } (2)容器角色 package com.iotech.myiterator; public interface List&lt;T&gt; { public void add(T obj);//给具体的容器添加元素 public T get(int index);//获取指定位置上的元素 public int size();//获得容器中的元素个数 public Iterator&lt;T&gt; iterator();//得到具体的迭代器对象 } (3)具体的迭代器角色 package com.iotech.myiterator; public class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; { private List list=null; private int index=0;//访问到容器中元素的当前下标 //创建一个迭代器对象的时候接收要被迭代的具体的容器对象 public MyIterator(List&lt;T&gt; list){ this.list=list; } //判断是否有下一个元素 @Override public boolean hasNext() { return index&lt;list.size(); } //取出下一个元素 @SuppressWarnings(&quot;unchecked&quot;) @Override public T next() { return (T) list.get(index++); } } (4)具体的容器角色 package com.iotech.myiterator; public class ArrayList&lt;T&gt; implements List&lt;T&gt; { private Object[] obj=null;//声明一个Object类型的数组(泛型是不能声明泛型数组的) private int index;//数组的下标 private int size;//记录数组中元素的个数 public ArrayList(){ obj=new Object[10]; index=0; size=0; } @Override public void add(T obj) { this.obj[index++]=obj;//把数据存放到数组中 size++;//元素个数加1 } @SuppressWarnings(&quot;unchecked&quot;) @Override public T get(int index) { return (T) this.obj[index]; } @Override public int size() { return size; } @Override public Iterator&lt;T&gt; iterator() { return new MyIterator&lt;T&gt;(this); } } (5)测试类 package com.iotech.myiterator; public class Test { public static void main(String[] args) { List&lt;String&gt; nameList=new ArrayList&lt;String&gt;(); nameList.add(&quot;zhangsan&quot;); nameList.add(&quot;lisi&quot;); nameList.add(&quot;wangwu&quot;); nameList.add(&quot;chenhao&quot;); Iterator&lt;String&gt; iterator=nameList.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的List]]></title>
    <url>%2F2018%2F07%2F18%2FJava%E4%B8%AD%E7%9A%84List%2F</url>
    <content type="text"><![CDATA[1、List容器特点List容器是有序的collection(也称之为序列)，此接口的用户可以对List容器中每个元素的插入位置进行精准地控制。用户可以根据元素的整数索引(在列表中的位置)访问元素，并搜索列表中的元素。List容器允许插入重复的值，包括null。 2、ArrayList(动态数组)及常用API(1)ArrayList类扩展了AbstractList并实现了List接口。 (2)支持可随需增长的动态数组。(以1.5倍的倍率进行扩容) (3)ArrayList构造方法。ArrayList();ArrayList(Collection c);ArrayList(int capacity); (4)除继承的方法之外，ArrayList常用方法。E get(int index)方法：返回此列表中指定位置上的元素；int intdexOf(Object o)：返回此列表中首次出现的指定元素的索引，或如果此列表不含该元素，则返回-1。 (5)ArrayList的常用方法举例 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ArrayListDemo1 { public static void main(String[] args) { /* * 当我们调用无参构造方法来构造一个ArrayList对象的时候，它会在内部分配一个初始大小为10的一个Object类型数组。 * * 当添加的数据容量超过数组大小的时候，会产生一个新的数组，新的数组的大小是原来数组大小的1.5倍。接着把原数组 * 中的数据拷贝到新的数组中。 */ List&lt;String&gt; nList=new ArrayList&lt;String&gt;(); nList.add(&quot;chenhao&quot;);//添加元素 nList.add(&quot;lisi&quot;); nList.add(&quot;lisi&quot;); nList.add(&quot;wangwu&quot;); nList.add(1, &quot;jay&quot;);//在指定的位置添加元素 nList.add(&quot;jack&quot;); nList.set(0, &quot;chengang&quot;);//修改指定位置的元素值 System.out.println(&quot;使用迭代器对象来进行统一的遍历&quot;); Iterator&lt;String&gt; iterator=nList.iterator(); while (iterator.hasNext()) { String name = iterator.next(); System.out.println(name); } System.out.println(&quot;使用增强for循环进行遍历&quot;); for(String name:nList){ System.out.println(name); } System.out.println(&quot;********************************&quot;); System.out.println(nList.indexOf(&quot;lisi&quot;));//查找指定元素的位置 System.out.println(nList.remove(&quot;lisi&quot;));//删除元素 System.out.println(nList.remove(0));//删除某个位置的元素 System.out.println(nList.size());//动态数组的大小 System.out.println(nList.contains(&quot;chenhao&quot;));//是否包含某个元素 System.out.println(nList.get(1));//获取指定位置的元素值 System.out.println(nList.isEmpty());//判断动态数组是否为空 nList.clear();//清空动态数组 System.out.println(nList.isEmpty()); System.out.println(&quot;********************************&quot;); } } (6)ArrayList方法的重载举例 import java.util.ArrayList; import java.util.List; public class ArrayListDemo2 { public static void main(String[] args) { List&lt;Student&gt; stuList=new ArrayList&lt;Student&gt;();//以学生类对象作为泛型的具体化 Student stu1=new Student(&quot;zhangsan&quot;, 10); Student stu2=new Student(&quot;lisi&quot;, 20); Student stu3=new Student(&quot;jack&quot;, 30); Student stu4=new Student(&quot;mandy&quot;, 10); Student stu5=new Student(&quot;mary&quot;, 20); stuList.add(stu1); stuList.add(stu2); stuList.add(stu3); stuList.add(stu4); stuList.add(stu5); Student stu6=new Student(&quot;mary&quot;, 20); //可以通过按住Ctrl键再点击相应的方法名来查看方法的具体实现。从而搞清楚下列方法在修改equals方法之后的变化。 System.out.println(stuList.indexOf(stu6)); System.out.println(stuList.contains(stu6)); System.out.println(stuList.remove(stu6)); System.out.println(stuList.indexOf(stu5)); System.out.println(stuList.size()); } } class Student{//学生类 private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Student(String name, int age) { super(); this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object obj) {//重写equals方法，只要姓名和年龄一致则是相同的对象。 if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } 3、LinkedList及常用API(1)LinkedList类扩展AbstractSequentialList并实现List接口。 (2)LinkedList提供了一个链表数据结构。(其中含有Node对象，并且有前引用和后引用) (3)LinkedList有两个构造方法：LinkedList();LinkedList(Collection c); (4)除了继承的方法之外，LinkedList类还定义了一些有用的方法用于操作和访问容器中的数据。void addFirst(E e);void addLast(E e);E removeFirst();E removeLast(); (5)由于Deque接口扩展了Queue接口，成为双端队列，而LinkedList继承了Deque接口。所以它可以提供add、poll先进先出队列的操作，以及其他堆栈和双端队列操作。 (6)LinkedList常用方法举例 import java.util.Iterator; import java.util.LinkedList; public class LinkedListDemo1 { public static void main(String[] args) { /* * LinkedList内部封装的是双向的链表数据结构，每个节点是一个Node对象，Node对象中封装的是你要 * 添加的元素，还有一个指向上一个Node对象的引用和下一个Node对象的引用。 * * 不同的容器有不同的数据结构，不同的数据结构操作起来的性能是不一样的。链表数据结构做插入、删除 * 的效率较高，但查询的效率比较低。数组结构做查询的时候效率高，因为可以通过下标直接找到元素，但 * 插入和删除效率比较低，因为要做移位操作。 */ LinkedList&lt;String&gt; sList=new LinkedList&lt;String&gt;(); sList.add(&quot;zhangsan&quot;);//添加 sList.add(&quot;lisi&quot;); sList.add(&quot;wangwu&quot;); sList.add(&quot;rose&quot;); sList.add(&quot;mary&quot;); sList.add(&quot;jack&quot;); sList.addFirst(&quot;chenhao&quot;);//添加至开头 sList.addLast(&quot;mandy&quot;);//添加至末尾 /*Iterator&lt;String&gt; iterator=sList.iterator(); while (iterator.hasNext()) { String name = iterator.next(); System.out.println(name); }*/ /*for(String name:sList){ System.out.println(name); }*/ for(Iterator&lt;String&gt; iterator=sList.iterator();iterator.hasNext();){ String name=iterator.next(); System.out.println(name); } System.out.println(sList.removeFirst());//为空时返回异常 System.out.println(sList.size()); sList.clear(); System.out.println(sList.pollFirst());//为空时返回null } } (7)使用LinkedList来实现栈和队列的功能 import java.util.Iterator; import java.util.LinkedList; public class LinkedListDemo2 { public static void main(String[] args) { /*Mystack&lt;String&gt; mystack=new Mystack&lt;String&gt;(); mystack.push(&quot;zhangsan&quot;); mystack.push(&quot;lisi&quot;); mystack.push(&quot;wangwu&quot;); mystack.push(&quot;zhaoliu&quot;); mystack.pop(); mystack.pop(); Iterator&lt;String&gt; iterator = mystack.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }*/ MyQueue&lt;Integer&gt; myQueue=new MyQueue&lt;Integer&gt;(); myQueue.push(1); myQueue.push(2); myQueue.push(3); myQueue.push(4); myQueue.push(5); myQueue.pop(); myQueue.pop(); Iterator&lt;Integer&gt; iterator=myQueue.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } class Mystack&lt;T&gt;{//使用LinkedList来模拟栈的数据结构 private LinkedList&lt;T&gt; data=null; public Mystack(){ data=new LinkedList&lt;T&gt;(); } //压栈的方法 public void push(T obj){ data.addFirst(obj); } //出栈的方法 public T pop(){ return data.removeFirst(); } public Iterator&lt;T&gt; iterator(){ return data.iterator(); } } class MyQueue&lt;T&gt;{//使用LinkedList来模拟队列的数据结构 private LinkedList&lt;T&gt; data=null; public MyQueue(){ data=new LinkedList&lt;T&gt;(); } //入队 public void push(T obj){ data.addLast(obj); } //出队 public T pop(){ return data.removeFirst(); } public Iterator&lt;T&gt; iterator(){ return data.iterator(); } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的集合]]></title>
    <url>%2F2018%2F07%2F18%2FJava%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1、集合框架：它是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口与类。集合框架包含了各种各样的容器，每一种容器都可以存放数据并且提供了操作容器当中数据的相关方法。 2、集合框架中不同的集合类有各自不同的数据结构，所以在使用中要根据应用的性能要求来选择不同的集合类。 3、集合类存放在java.util包中，今后进行程序编程时将大量使用集合类和相关接口。其中包括Iterable:迭代器接口；Collection：类集接口；List：列表接口；Set：数据集接口；Queue：队列；Map：键值对组合映射表。 (1)Iterable接口 实现该接口允许对象成为“foreach”语句的目标，即该集合对象允许迭代。类集接口Collection是Iterable的子接口，所以所有类集对象可以迭代访问，而映射Map不行。(Map并没有实现Iterable接口) Iteratoriterator():功能：返回一个在一组T类型的元素上进行迭代的迭代器对象。迭代器是实现了Iterator/ListIterator接口的类的对象，可以通过遍历类集，访问操作其中的每个元素。ListIterator继承了父接口Iterator，允许双向遍历集合，并可以修改和删除元素。 (2)Collection接口 int size();boolean isEmpty();boolean contains(Object o);Iterator iterator;Object[] toArray();boolean add(E e);boolean remove(Object o);void clear()。等等 (3)List、Set、Map接口 List接口扩展了Collection，有序且可重复；Set接口扩展了Collection，无序且不可重复；Map是一个存储关键字/值对的对象。映射不是Collection的子接口，所以它本身不能使用迭代器来进行遍历。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[礼仪培训笔记]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%A4%BC%E4%BB%AA%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、什么是礼仪？礼仪=礼节+原则=心理+形式 二、简析服务礼仪1、顾客永远是对的（把面子留给客人，放弃自我，自主揽错） 2、永远不要辩解，服务中禁止使用推卸责任的语言。 3、注重首因效应、末轮效应。比如：缩短客人的等待时间。 4、在职场当中得体比漂亮更重要。包括面部，发型，举止，服饰，谈吐。如：不能穿短衬打领带，衬衣只买领围的大小。 三、学会用眼睛说话1、目光注视方式（PAC规律） 2、目光注视区域（三角定律） 3、目光注视时间规律（3~5秒） 4、目光注视的距离 四、人际沟通“六到”1、脑到：先三思，后言行。 2、眼到：专注，诚恳，体现尊重。 3、耳到：诚心聆听，不打岔。 4、口到：不吝啬鼓励、善意、赞美的语言。 5、心到：从他人角度理解，换位思考。 6、脚到：主动接近，距离合适。 五、其他1、服务距离：0.5~1.5米；展示距离：1~3米；引导距离：在客户左前方1~1.5米；待命距离：3米以外。 2、鞠躬距离控制：脚前方2米是15度；脚前方1.5米是30度；脚前方1.0米是45度。 3、在职场以职称论高低，在社交场合以女士为尊者，在家庭以年龄为长。 4、握手需要把握力度，距离。在不同的场合都是尊者先伸手握手。自我介绍在握手之前，且尊者后进行自我介绍。尊者有优先了解别人的权利。 5、名片：先客后主，先低后高，尊者优先收名片。尊者有优先了解别人的权利。 6、先肯定全部，再否认局部。注：上班提前半小时，开会提前10分钟，由你来准备会议提前半小时。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廊下听雨]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%BB%8A%E4%B8%8B%E5%90%AC%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小暑时节，雨一直下，且大，完全没有减弱的痕迹。坐在廊下听雨，淅淅沥沥的。树叶上浸润着雨水，轻轻地晃动着。天空一片灰濛，背后是望不到尽头的远方。仿佛时间于此刻定格，又好像自己回到了久远的过去，似曾相识里神情甚是淡然。起身取来《平凡的世界》，自己明日即将远行。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[童年的暑假]]></title>
    <url>%2F2018%2F07%2F05%2F%E7%AB%A5%E5%B9%B4%E7%9A%84%E6%9A%91%E5%81%87%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;坐在夏天的院子里，吹着独属于清晨凉爽的风，高大的板栗树的叶子随风舞动着，新生的狗崽们自由地玩闹着，不远处也时而传来清脆悦耳的鸟鸣。此刻正在阅读的我，不由得想起童年的暑假。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信对于每一位拥有暑假的孩子来说，那都是一段令我们魂牵梦萦的时光。因为年少的我们还没能意识到知识的重要性，对于“求知”一词也就无从谈起。但我们拥有对世界的好奇心，对于某些物质的渴求。而我在那个时期的暑假是伴随着辛劳、收获与懵懂无知的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暑假刚至，便是西瓜的盛世。那时村里几乎每家每户都种西瓜（现在也一如既往，就算是没有种瓜的人家也总有瓜纷至沓来），人们在下午太阳的热辣褪去之后，拉着双轮车就往瓜地里走去。在大片的瓜地里寻找最大的西瓜，学着大人的模样在瓜的身上轻轻敲打来辨别是否可以采摘，还有搬着一个个又大又圆的西瓜走在田埂上是我的乐趣。第二天一大早，在天还未亮的时候，人们就拉着满车的西瓜往集市上赶。而我就在家中用菜刀切开自己早就精挑细选好的西瓜的头部，用调羹挖开又红又甜的瓜瓤，享受夏天清爽而又甜蜜的味道。当然也不能忘却杏子和李子给过的酸甜可口。寻觅，爬树，摇晃，然后找一泓清泉，于阴凉之地，蝉鸣的聒噪声中大饱口福是在所难免的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等到享乐的时节一过，就迎来了第一季的农忙。趁着昨夜的凉气还未完全消散，趁着火热的太阳还未升起，家家户户收拾好工具就早早地去往金黄的稻田，开始一天的劳作。早上是一天当中最佳的劳作时间，人们往往会在两至三个小时之后才会回到家中，由妇女准备饭食，其他人则负责将收割回来的稻谷搬运到楼顶或者院子里摊开晾晒。短暂而又简短的早餐过后，一天中的重要时段上午便接踵而至，这时的太阳已经普照大地。左手握稻秆，右手持镰刀，挥汗如雨下，人们顶着烈日在田地里弯腰劳作着，将一捧又一捧连着稻秆的稻穗，搭成稻谷架（以便打谷这一工序）。偶尔吹来一阵凉爽的风（有时就连风也是热的），抬起头，田野里各处响起脚踏打谷机的运作声，天上是澄澈的蓝天和白云。中场休息是我的最爱，不仅有家中甘甜的井水，还有从来都不缺的可口的西瓜，以此来解渴和补充糖分。忙到中午时分，回到家，午餐过后，小睡，便又开始了下午的忙碌。在睡意昏沉中走进烈日的暴晒里，整个人顿时就清醒了。动作重复，直至夕阳西下，此时需要派人先行回家收好早上和上午晾晒的稻谷。说到收稻谷这件事，农忙期间作为小孩子的我既渴望天空下雨又不愿天空下雨，真真是让心里纠结又矛盾。当然，除了收割稻子之外，还需要为晚稻做准备。一般是收割完一块地之后，便要犁地抛秧。抛秧这件事比割稻子有趣，自从有了育秧盘，抛秧就比插秧轻松多了。当大人们在认认真真地有间隔和规律地抛秧时，我手中的秧苗呢，可以从天而降，也可以在水田里组成各式各样的形状（此情此景，总是想起王维的“漠漠水田飞白鹭”），甚至用抛出的秧苗将他们给围起来。农忙时节一般需要持续将近一个月左右，这个月是人类与大地深切交流的日子。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;农忙过后的我就要与家中的黄牛常伴左右了。这是农耕文明里必不可少的物种，也是世世代代的农民不可缺少的战友。同样是早起，和小伙伴们赶着牛群有时往山里走，有时走向荒废的田野。清晨只是个插曲，下午才是重点。虽然烈日当头照，但我们躲在树的阴凉里，玩着各种属于我们的游戏，享受属于我们的快乐时光。童年的暑假便是在这样的日子里慢慢度过，直至开学第一课。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今的故乡，农耕的机械化时代早已如约而至，曾经面朝黄土背朝天的农人们依然即将步入收获的季节。暑假只是我童年的一个缩影，于我而言，童年是一个物质相对匮乏的时期，更谈不上阅读这一有着一定条件的事物了。或许这是现在的我对阅读和文字饱有热爱之心的缘由。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自由与人生]]></title>
    <url>%2F2018%2F07%2F01%2F%E8%87%AA%E7%94%B1%E4%B8%8E%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[那些以自由为人生终极目的的人是不会真正拥有自由的，因为他们时常为自由所奴役。相反，我认为人生才是自由的目的。换言之，我们是 要“自由的人生”，而不是“人生的自由”。――熊培云 当我看到这句话的时候，才恍然意识到在这之前，自己的思想里追求的就是“人生的自由”，而非“自由的人生”。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[豆瓣入门单反购买文章推荐]]></title>
    <url>%2F2018%2F06%2F14%2F%E8%B1%86%E7%93%A3%E5%85%A5%E9%97%A8%E5%8D%95%E5%8F%8D%E8%B4%AD%E4%B9%B0%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[1、单反购机指南 2、微单购机指南 3、索尼微单购机指南]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[昨夜同门云集推杯又换盏]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%98%A8%E5%A4%9C%E5%90%8C%E9%97%A8%E4%BA%91%E9%9B%86%E6%8E%A8%E6%9D%AF%E5%8F%88%E6%8D%A2%E7%9B%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有一些文字需要留给渐行渐远的昨日，那我想此时写下应是恰如其分的。从时光的长河里回溯，逆流而上，我将在哪个渡口停留呢？想了很多，试着写下，但却觉得文字的表述在此刻显得如此地苍白无力。貌似无法承载情感的洪流，犹如昨日的暴雨落地，地面的流水浩浩汤汤，奔涌而去，却仍然没有停止的迹象。或许过后回望，会像雨过天晴之后晨梦亭里的独坐、鸟儿与青蛙的鸣唱、不远处飘来的荷香还有洗净的天空那样云淡而风轻。但最为珍贵的仍是属于当下的自己，当下的我们。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《非暴力沟通》摘句]]></title>
    <url>%2F2018%2F06%2F04%2F%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E6%91%98%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1、非暴力生活的一个关键就是：感激生活的赐予，而不贪心。 2、非暴力沟通提醒我们专注于彼此的观察、感受、需要和请求。它鼓励倾听，培育尊重与爱，使我们情意相通，乐于互助。 3、非暴力沟通四要素。首先：留意发生的事情，说出人们所做的事情，清楚地表达观察结果，而不判断或评估。其次：表达感受。然后：说出哪些需要导致那样的感受，诚实地表达自己。最后：提出具体的请求。 4、暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方。 5、我这样做，因为我想……陈述观察……我（感到）……因为我…… 6、我们大多数的人使用的语言倾向于评判、比较、命令和指责，而不是鼓励我们倾听彼此的感受和需要。 7、道德评判就是其中的一种，它将不符合我们价值观的人看作是不道德的或邪恶的。进行比较也是一种评判，它会蒙蔽对人对己的爱意。异化的沟通方式还淡化了我们对自己的思想、情感和行为的责任意识。此外，强人所难也会造成心灵的隔阂。 8、如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。 9、真诚待人比委曲求全更为可贵。如果别人感到不安，我们可以认真地倾听，但无须责备自己。 10、我们提出的请求越具体越好。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。使用抽象的语言还会使我们无法深入了解自己。请求他人采取具体的行动将揭示我们的动机。 11、如果我们只是表达自己的感受，别人可能就不清楚我们想要什么。 12、由于我们所要表达的意思与别人的理解有可能不一致，有时，我们需要请求他人的反馈。特别是在集体讨论中发言时，我们需要清楚地表明自己的期待。否则，讨论可能只是在浪费大家的时间。 13、在我们的文化中，直接谈论一个人的感受是很少见的。重要的是，我已经不再把他的话看作是对我的攻击，而注意体会他的感受和需要。 14、为了倾听他人，我们需要先放下已有的想法和判断，全心全意地体会对方。倾听他人有助于对他人的理解和接纳。 15、听到不中听的话时，我们有四种选择：1.责备自己；2.指责他人；3.体会自己的感受和需要；4.体会他人的感受和需要。 16、如果你希望自己在生气的时候也能运用非暴力沟通，我建议你做以下的练习。在前面，我们已经提到，我们生气是因为我们的想法——我们认为人们“应该”或“不应该”做什么，我们还给人贴上各种标签，并说长论短。请留意我们头脑中“我不喜欢抽烟的人……”之类的想法。然后，问自己：“我不喜欢他们……，是因为我什么样的需要没有得到满足？”通过这样的方式，我们就把注意力放在了尚未得到满足的需要，而不是考虑他人有什么过错。 17、在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。表达愤怒的四个步骤是：（1）停下来，除了呼吸，什么都别做；（2）想一想是什么想法使我们生气了；（3）体会自己的需要；（4）表达感受和尚未满足的需要。有时，在第3步和第4步之间，我们需要先倾听他人。在得到倾听和理解之后，他们也就可以静下心来体会我们的感受和需要。 18、在使用惩罚性的强制力时，我们认为某些人是邪恶的，为了让他们悔改，必须给他们一点颜色看看。此时，我们希望痛苦能让他们：（1）意识到自己的过错；（2）感到懊悔；（3）改变行为。然而，在实际生活中，惩罚往往加强了对方的敌意和抵触心理，使双方的关系更加疏远。 19、个人的成长是通过与他人的坦诚交流来实现的——在交流中，彼此能够自由地表达内心的软弱。 20、非暴力沟通表达感激的方式包含三个部分：1.对方做了什么事情使我们的生活得到了改善；2.我们有哪些需要得到了满足；3.我们的心情怎么样？ 21、诚实地表达自己，而不批评、指责（1）观察我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：“当我（看、听、想到我看到的/听到的） ……”（2）感受对于这些行为，我有什么样的感受（情感而非思想）：“我感到……”（3）需要什么样的需要或价值（而非偏好或某种具体的行为）导致我那样的感受：“因为我需要／看重……”（4）请求清楚地请求（而非命令）那些能丰富我生命的具体行为：“你是否愿意……？” 22、关切地倾听他人，而不解读为批评或指责（1）观察你所观察（看、听、回忆、想）到的有助于（或无助于）你的福祉的具体行为：“当你（看、听、想到你看到的/听到的） ……”（2）感受对于这些行为，你有什么样的感受（是情感而非思想）：“你感到……吗？”（3）需要什么样的需要或价值（而非偏好或某种具体的行为）导致你那样的感受：“因为你需要／看重……”（4）请求关切地倾听那些能丰富你生命的具体请求，而不解读为命令：“所以，你想……”]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS制图]]></title>
    <url>%2F2018%2F06%2F03%2FPS%E5%88%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1、一寸照的尺寸为：宽度2.5厘米，高度3.5厘米，分辨率设为300，选择CMYK颜色。将图片拖入新建的空白图片当中，快捷键Ctrl+T进行自由变换(如果此时看不到控点，可以通过Ctrl+减号快捷键来进行缩小)。如果需要变换背景色，则使用快速选择工具选择空白区域。然后按住Alt键来添加图层蒙版。此时可以删除背景图层，选中蒙版来对图层蒙版进行调节。接下来新建一个图层，下拉到带有蒙版的图层的下方，再进行颜色填充即可。如果此时还需要对服装进行变换，那么就将做好选区的衣服图片拖入图中进行变换。之后还可以建立矩形选区，通过Ctrl+T快捷键，然后通过移动来消除譬如T恤这种色块。最后保存为jpg格式。 如果需要将一寸照片打印多张在一张国际标准纸张上面。那么可以新建一个文件，选择国际标准纸张，选择CMYK模式，然后将刚才的jpg文件移动到新建的纸张里面。可以通过Ctrl+R快捷键调出标尺，然后拖出两条分别距离左顶点一厘米的参考线，回车之后。双击图层，打开图层样式，勾选描边，像素设置为5像素，位置选择内部，颜色选择白色，点击确定。然后在移动工具下按住Alt键来拖拽图片进行复制。当复制出两个之后，在图层工作区上选择两个图层继续按住Alt键来复制，这样以此类推，就可以不需要一张一张复制，而是以2的幂次方递增了。在复制出一整行图片之后，可以在图层的缩览图当中选择最小的样式，之后选择所有的图层，使用Ctrl+E将他们全部合并为一个图层。此时用之前的复制方法就可以很快地对图片进行复制，直到基本铺满整个国际标准纸张。 2、制作全景图片：在文件菜单中选择脚本，将脚本载入堆栈，然后选择文件夹，打开。选择所有的图层，选择移动工具，在移动工具菜单栏的最右边选择自动对齐图层，常规情况下选择自动即可，点击确定。接下来继续选中这些图层，在编辑菜单中选择自动混合图层，选择全景图，点击确定。然后再对图片进行裁剪。自动回合图层还可以用于堆叠混合。 3、服装操控变形：打开图像，在编辑菜单栏中选择操控变形选项。在图片中打上图钉之后即可进行变形，图钉深度可以将图钉在前面和后面进行切换。 4、内容识别比例：打开图片，使用套索工具对需要进行放大或者是缩小的部分进行大致地选取，然后右击鼠标进行存储选区，接下来Ctrl+D取消选区。在编辑菜单当中，选择内容识别比例，在保护项当中选取刚才存储的选区。如果选取的是人物，还可以勾选，保护项后面的保护肤色选项。 5、图层复制：按住Alt键直接拖拽来复制图层。在图层面板中将图层移动到新建图层按钮上。也可以通过快捷键Ctrl+J来复制图层。 选区复制：按住Alt键来对选区进行拖拽即可，这样复制出来的是在同一个图层。如果是通过快捷键Ctrl+J来复制选区的话，就是新建出了一个只包含选区内容的图层。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS抠图]]></title>
    <url>%2F2018%2F05%2F31%2FPS%E6%8A%A0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1、调整边缘抠图：先使用快速选择工具做出选区，然后通过调整边缘(选择并遮住)来调整。先选择黑底，然后根据需要来调整半径，平滑，羽化(对比度)，移动边缘等命令。之后新建带有图层蒙版的图层。 2、当打开一张已经抠好的图片，并且此时没有设置蒙版，那么为了节省时间可以使用图层下拉菜单中的修边选项中的各个命令来处理图片的边缘。 3、钢笔工具抠图：选择钢笔工具，选择路径选项，建立锚点直到闭合选区。添加矢量蒙版，选择减去顶层形状来，通过新建锚点来再建一条路径(此时需要选中蒙版来操作)，直到闭合路径。新建图层，添加背景。之后可以对图片中局部镂空的地方，继续选择减去顶层形状来做精细的路径抠图(依然需要选中蒙版才能进行操作)。在这之后，我们还可以选择路径选择工具和直接选择工具对路径进行再调整。 4、蒙版抠图：通过蒙版来进行粗抠图，可以产生不一样的效果，使用椭圆选区大致地选出需要抠取的部分，在选择下拉菜单当中选择修改中的羽化，建立蒙版。将其拖入其他的图片当中进行变换即可。 融合两张图片：可以先将一张图片拖入另一张图片，然后对拖入的图片创建蒙版。选中蒙版，使用黑白渐变工具(这里注意前景色和背景色)，然后进行渐变调节，即可将两张图片融合在一起。如果是有倒影的情况，可以选中图层，然后进行复制，右击进行垂直翻转，同时选择正片叠底，再降低它的不透明度即可。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS基础知识(杂)]]></title>
    <url>%2F2018%2F05%2F30%2FPS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E6%9D%82)%2F</url>
    <content type="text"><![CDATA[1、分辨率和图片的用途是相关的。常用分辨率设置：洗印照片：300或以上；杂志、名片等印刷物：300；海报高清写真：96~200；网络图片、网页界面：72；大型喷绘：25~50。总像素值=像素宽度X像素高度=文档宽度X文档高度X分辨率的平方 2、常用快捷键： (1)打开首选项：Ctrl+K (2)缩放图片：Alt+鼠标滚轮 (3)新建时复位：按住Alt不松 (4)打开文件：双击工作区 (5)新建图层：Alt+创建图层 (6)创建图层副本：Alt+拖拽至指定位置或者Ctrl+J (7)抓手工具：按住空格键不松 (8)放大工具：空格+Ctrl (9)缩小工具：空格+Alt (10)快速填充前景色:Alt+delete (11)快速填充背景色:Ctrl+delete 3、移动图层位置不变：在拖拽至另一个文件时，先按住Shift再松鼠标(前提是两个图像大小一样)。如果两个图像大小不一样的话，按上面操作会跑到正中央；如果图像中有选区，则跑到选区的正中央。在移动工具状态下，按住Ctrl键就可以自动选择图层。在非移动工具状态下，按住Ctrl键可以切换到移动工具状态。Shift键加方向键可以微调。 4、选区时按住Shift键，选框变成正方形。按住Alt键从中心点建立选区。Ctrl+D取消选区，Ctrl+Shift+D恢复之前的选区 5、套索工具按住Alt键可以在套索工具和多边形套索工具之间切换。磁性套索工具按住Alt键可以在磁性套索工具和多边形套索工具之间切换。delete键可以用于取消套索的上一个锚点。 6、按住Alt键，点击鼠标右键左右移动，改变画笔大小。上下移动改变画笔硬度。 7、虽然修复画笔工具和仿制图章工具共享仿制源，但是修复画笔工具不同于仿制图章工具。修复画笔工具更智能，它能够尽可能地和周围的环境进行融合。 8、通道的概念类似于图层的概念，只不过通道是从另一个角度(图像的色彩或透明度)来诠释图像的构成。 Alpha通道就是记录透明度信息的特殊层，在Alpha通道当中，黑色代表着透明，白色代表拥有颜色信息，不透明。说白了，通道当中的颜色代表的是当前通道的颜色强度(黑白灰)，而不是颜色本身。Alpha通道是一个选区加工厂。不管是通道还是图层，都可以通过按住Ctrl键，点击相应的通道或者是图层来建立相应的选区。 9、图层蒙版可以隐藏和显示图层上的部分区域，按住Alt键点击添加图层蒙版，隐藏的是选区的部分。按住Alt键点击建立好的图层蒙版，图层蒙版此时处于编辑状态之下，对应的是一个临时的Alpha通道。快速蒙版方便查看。 10、锁定透明像素：禁止对透明区域进行操作。快速建组：Ctrl+G。一个组合一个图层同时选中，Ctrl+G也可以再建组。取消分组：Ctrl+Shift+G。Ctrl+E向下合并图层，Ctrl+Alt+E向下合并并且保留向下合并的图层。创建图层剪贴蒙版，图层只能在下方图层内显示。 11、色相：颜色的品相。通过改变色相环上色彩的角度(一共360度)可以进行变色。从红色到蓝色需要逆时针旋转120度，就把色相的值变换为-120。从红色到绿色需要顺时针旋转120，就把色相的值变换为120。 饱和度：是指色彩的鲜艳程度，其实就是加入中性灰的程度。当饱和度降到最低的时候，图像显示的是灰色，灰色是没有色相的。灰色的红绿蓝RGB值是相等的，只要RGB值是相等的，那么只可能是黑、白、灰三种颜色。 明度：就是发光量，加入额外的白光。 RGB模式：光的三基色，它是发光色。 CMYK模式：印刷色彩模式。青色(Cyan)，品红色(Magenta)，黄色(Yellow)，黑色(Black)。代表印刷用的四种油墨，它是反光色。CMYK通道里面，黑色代表100%浓度的油墨。 12、色阶：是表示图像亮度强弱的指数标准，表现了一副图的明暗关系，它和颜色无关。通过色阶编辑框可以看出图片整体的明暗分布。移动X轴上的最左边的黑色滑块，如果从0移动到70，黑场的数值变大，画面变暗(仅是黑场部分发生了变化，而灰场和白场没有)，它是把亮度级别为70以下的像素，都合并为最低的0。调节黑场，就是合并暗部的颜色，对亮部暂无影响。如果是移动X轴最右边的白色滑块，从255移动到180的话，和黑色滑块的原理是一样的，再180到255这个亮度级别的像素，都合并成为255级别。 13、曲线命令：Ctrl+M。曲线直方图的X轴上的黑色滑块和白色滑块的功能和色阶上的对应滑块功能相似。所不同的是，它们是对整个图片的明暗度进行整体的变暗和变亮。而不仅仅是对移动滑块区域的像素进行调整。但对于复杂的图片来说，色阶、曲线等最好都去使用调整图层，这样可以针对图片的某个图层进行调整。 14、色彩平衡不同于色相的改变。保持明度，可以保证调整后的颜色发光总量不变。 15、使用钢笔工具时按住Shift键，可以根据角度来创建水平，垂直和45度的线段。在相应的路径点击回车，图像上的路径会被隐藏。黑色的路径选择工具是选择整体的，而白色的路径选择工具是选择单个的锚点的，按住Ctrl键可以在两者之间进行转换。按住Alt键，可以调节单个的控杆。Ctrl+enter将路径变成选区。文字可以依附路径的形状输入。 16、调节行距，字距。Alt+上下左右箭头就可以。在视图的显示当中有网格。视图当中的标尺可以在标尺的区域通过单击右键来修改单位，也可以从左上角的方块拉出十字交叉线来改变原点的位置，双击方块可以恢复到原状态。视图中可以新建参考线，也可以从标尺当中拖拽出参考线，按住Alt键来单击左键可以将水平和垂直的参考线进行转换，将参考线拉回标尺区域即可删除参考线。视图中的显示额外内容(Ctrl+H)，可以将隐藏参考线，网格以及选区。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 从排序数组中删除重复项]]></title>
    <url>%2F2018%2F05%2F18%2FLeetCode-%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) { print(nums[i]); } 题目代码： class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.size()==0) return 0; else if(nums.size()==1) return 1; int i=1,k=1; int len=nums.size(); while(k&lt;len){ if(nums[k-1]!=nums[k]){ nums[i++]=nums[k]; } k++; } nums.erase(nums.begin()+i,nums.end()); return i; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 旋转字符串]]></title>
    <url>%2F2018%2F05%2F18%2FLintCode-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串和一个偏移量，根据偏移量旋转字符串(从左向右旋转) 样例：对于字符串 &quot;abcdefg&quot;. offset=0 =&gt; &quot;abcdefg&quot; offset=1 =&gt; &quot;gabcdef&quot; offset=2 =&gt; &quot;fgabcde&quot; offset=3 =&gt; &quot;efgabcd&quot; 挑战：在数组上原地旋转，使用O(1)的额外空间 分析：注意offset为0和str长度为0的情况，还有offset大于str的长度的情况。 题目代码： class Solution { public: /** * @param str: An array of char * @param offset: An integer * @return: nothing */ void rotateString(string &amp;str, int offset) { // write your code here if(str.size()==0) return; if(offset==0) return; int offs=offset%str.size(); reverse(str.begin(),str.end()); reverse(str.begin(),str.begin()+offs); reverse(str.begin()+offs,str.end()); } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买包子]]></title>
    <url>%2F2018%2F05%2F18%2F%E4%B9%B0%E5%8C%85%E5%AD%90%2F</url>
    <content type="text"><![CDATA[早上去九食堂买包子。 我：“一个梅菜和一个扣肉。” 对方：“梅菜和扣肉是同一种，同学。” 等到付款的时候，点开支付宝。 对方：“你这是收钱，不是付款，同学。” 心里想：“是不是起早了，人也变傻了？”]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在清晨的光里，校园中的枣树，梨树，桃树，柚子树，桔子树，杨梅树，紫叶李，还有枇杷树的果实均已挂满枝头，一派夏季欣欣向荣的景象。从莺飞草长的三月搭建博客至今，日志的数量在不知不觉间已经破百。那些无形的似水流年就在与键盘的敲击中悄悄地溜走，犹如匆匆而去的大学时光，此刻也即将消耗殆尽。怀着对诗词、书卷和生活的热爱，还有一入程序员之路深似海的决心（但写字不能成为路人）。日志当然也是要继续写下去的！记录时间的流逝，也记录自己来时的路。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 合并排序数组 II]]></title>
    <url>%2F2018%2F05%2F17%2FLintCode-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II%2F</url>
    <content type="text"><![CDATA[合并两个排序的整数数组A和B变成一个新的数组。 样例：给出A=[1,2,3,4]，B=[2,4,5,6]，返回 [1,2,2,3,4,4,5,6] 挑战：你能否优化你的算法，如果其中一个数组很大而另一个数组很小？ 题目代码： class Solution { public: /** * @param A: sorted integer array A * @param B: sorted integer array B * @return: A new sorted integer array */ vector&lt;int&gt; mergeSortedArray(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { // write your code here int a=A.size(); int b=B.size(); int c=a+b; vector&lt;int&gt; C(c); int i=0,j=0,k=0; while(i&lt;a&amp;&amp;j&lt;b){ if(A[i]&lt;=B[j]){ C[k++]=A[i++]; }else{ C[k++]=B[j++]; } } while(i&lt;a) C[k++]=A[i++]; while(j&lt;b) C[k++]=B[j++]; return C; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 第k大元素]]></title>
    <url>%2F2018%2F05%2F17%2FLintCode-%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在数组中找到第k大的元素，你可以交换数组中的元素的位置。 样例：给出数组 [9,3,2,4,8]，第三大的元素是 4 给出数组 [1,2,3,4,5]，第一大的元素是 5，第二大的元素是 4，第三大的元素是 3，以此类推 挑战：要求时间复杂度为O(n)，空间复杂度为O(1) 题目代码： class Solution { public: /* * @param n: An integer * @param nums: An array * @return: the Kth largest element */ int kthLargestElement(int n, vector&lt;int&gt; &amp;nums) { // write your code here int i=nums.size(); sort(nums.begin(),nums.end()); return nums[i-n]; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 丑数 II]]></title>
    <url>%2F2018%2F05%2F15%2FLintCode-%E4%B8%91%E6%95%B0II%2F</url>
    <content type="text"><![CDATA[设计一个算法，找出只含素因子2，3，5 的第 n 小的数。 符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12… 我们可以认为1也是一个丑数 样例：如果n = 9， 返回 10 挑战：要求时间复杂度为O(nlogn)或者O(n) 方法一：如果采用遍历的方式，无法完全通过，会造成超时。 class Solution { public: /** * @param n: An integer * @return: the nth prime number as description. */ long long nthUglyNumber(int n) { // write your code here int count = 0; int i = 0; while(count &lt; n) { m++; int number = i; while(number % 2 == 0) number = number / 2; while(number % 3 == 0) number = number / 3; while(number % 5 == 0) number = number / 5; if(number == 1) { count++; } } return i; } }; 方法二：是从1开始构造丑数，然后依次计数。 class Solution { public: /* * @param n an integer * @return the nth prime number as description. */ int nthUglyNumber(int n) { // write your code here int count = 1;//统计丑数 vector&lt;int&gt; ugly(n,0);//保存丑数 ugly[0] = 1;//第一个丑数 vector&lt;int&gt; idx(3,0); while(count &lt; n) { int a = 2 * ugly[idx[0]]; int b = 3 * ugly[idx[1]]; int c = 5 * ugly[idx[2]]; int temp = min(min(a, b), c); if(temp == a) ++idx[0]; if(temp == b) ++idx[1]; if(temp == c) ++idx[2]; ugly[count] = temp; ++count; } return ugly[n-1]; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不孝有三，无后为大？]]></title>
    <url>%2F2018%2F05%2F14%2F%E4%B8%8D%E5%AD%9D%E6%9C%89%E4%B8%89%EF%BC%8C%E6%97%A0%E5%90%8E%E4%B8%BA%E5%A4%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“不孝有三，无后为大”这八字言语基本上作为炎黄子孙的一员都曾有所耳闻。此语出自《孟子离娄上》：“不孝有三，无后为大。舜不告而娶，为无后也。君子以为犹告也。” &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的观点认为：无后就是指没有后代，更准确地来说是没有子嗣的意思。然而孟子在《离娄章句下》中说：“世俗所谓不孝者五：惰其四支，不顾父母之养，一不孝也；博弈好饮酒，不顾父母之养，二不孝也；好货财，私妻子，不顾父母之养，三不孝也；从耳目之欲，以为父母戮，四不孝也；好勇斗狠，以危父母，五不孝也。”如果说“无后”是指没有后代的话，那么这里的五不孝中肯定有一条是“无后”，但是五不孝中没有一条提及“没有后代”。另外，再来看“不孝有三，无后为大”的后文，说的是：舜不告而娶，为无后也。舜没有告知父母就擅自娶妻，为无后也。这里的“为”字可以表承接关系“就是”的意思，也可以表目的“为了”的意思。然而不管哪一种说法，都与传统的意思不符。第一，取了妻子怎么能说就是没有后代呢，恰恰相反，娶妻就是为了能够繁衍后代；第二，取了妻子又怎么能说是为了没有后代呢。这些都明显和上文“舜不告而娶”的意思不衔接，跨度未免太大些了。最后孟子还说到：君子认为应该把娶妻这件事情告诉父母，这和没有子嗣又有何关系呢？话说像亚圣这种高智慧生物，怎么会犯如此低级的逻辑错误呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果采用第二种观点，“无后”指没有尽到后辈的责任也就都能够说的通了。首先，孟子的五不孝讲的都是后辈未尽之责，同时在古文当中使用具体的数字时常常是虚指而并非实指，用三来代五也完全说的过去。例如：飞流直下三千尺。三人行，必有我师焉。军书十二卷，卷卷有爷名。等都是虚指。其次，下文的舜不告而娶，就是没有尽到后辈的责任和君子认为应该把娶妻这件事情告诉父母的意思也都衔接得恰到好处。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《生活教会你》摘句]]></title>
    <url>%2F2018%2F05%2F13%2F%E3%80%8A%E7%94%9F%E6%B4%BB%E6%95%99%E4%BC%9A%E4%BD%A0%E3%80%8B%E6%91%98%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[在读完读完本书的第一章之后，我想：这真是一本好书，如此多的发人深省的话语，着实让人钦佩。这不是心灵鸡汤，而是自己内心也十分认可的观点。但随着章节的推移，内容虽然不像前面那么让我着迷，但丝毫没有影响我在豆瓣为它打上四星的评分。 1、对儿童教育而言，最重要的是让孩子拥有好奇心、兴趣、想象力以及对生活的探索精神。 2、我们在家和学校接受教育，最重要的是，我们从生活本身接受教育。学习应当贯穿我们的一生。生命总是在不断变动，要么前进，要么后退。只有当一个人在不断成长时，生活才会有趣；换句话说，只有当我们仍对生活怀有兴趣时，才能取得成长。 3、杜威的这种进步主义教育并不试图将孩子引向他不愿去的地方。孩子不会被逼着遵守什么准则，除非他自己乐意去做或认为值得去做。 4、从长远来看，有价值的并非是一个人读了什么书，而是独立思考并吸收了什么东西，是通过阅读激发的那些想法和感觉。正是你自己的想法，独立思考得出的那些想法，使你成为一个有意思的人。 5、通过别人来激发自己的兴趣—在我看来，这是效率最高、最有收获的教育方法之一。你要做的只是去寻找这个兴趣点。这会让每段经历都成为一种挑战，并使人永葆好奇—好奇心是一个人最宝贵的品质之一。 6、每个孩子的“为什么”都应得到尊重，得到用心的回答。如果你不知道问题的答案（实际情况通常如此），那就带着孩子一起寻找答案。 7、当我逐渐真正观察起周围的事物，试着去理解它们时，生活中的每件事情都变得更加有趣，也更有价值。这就像以三维视角去看一张二维的照片，看待问题有了更多的深度。 8、好在，每当我们与恐惧作战时，哪怕当时认为它不可战胜，哪怕在过程中受尽折磨，只要经受住痛苦，克服了恐惧，你会发现获得了更大的自由。一个人只要经受住一次这种考验，就可以经受住任何事情。每一次与恐惧的正面对决都会让我们收获力量、勇气与自信。 9、放下自我。如果你能放下自我，不去想是否给别人留下好印象，不去管人们怎么看你，反过来替别人着想，你就不会再感到胆怯和恐惧。恐惧在很大程度上是由于缺乏了解。我们不知道在新环境会发生什么，也不知道自己能否应对。越早知道会发生什么，就能越早从恐惧中解脱出来。 10、“我做不到。”这种话说来容易。实际上，你会发现其实自己做得到。尝试去做某件事情不仅能让自己摆脱恐惧的束缚，还能锻炼承受能力，并从成就感中获得自由。 11、我自己一般有三种办法：第一，保持内心平静，以使工作时不受周围环境影响；第二，专注在手头的事情上；第三，建立起生活规律，分配好时间，提前计划每件事情，同时又留有余地以备不患。除此之外，还有一点也很重要：那就是保持身体健康，保证有充沛的精力可用。 12、一个人只有愿意接受自身存在不足这一残酷事实，愿意做出调整去适应它，才算得上真正的成熟。成熟的一个重要部分，就是不仅接受自己的缺点，也接纳你所爱之人的缺点，并尽可能地帮助他们避免出错。 13、“对自己和身边的人诚实以待；在生活和工作中竭尽全力；拥有爱别人的能力。”实际上，获得快乐还有一个条件，当时我不知为何落了这条：那就是感到自己是一个有用的人。 14、对大部分人来说，渴望被他人需要的愿望比自己意识到的还要强烈。人们常说一个人需要表现自我，但是一般来说，表现自我带来的满足感不如满足他人带来的满足感多。 15、我们总以为每个人都想得到自由，但事实并非如此。对很多人来说，放弃自由，让别人指导自己，让别人给自己做决定，比为自己和自己的决定负责要快乐得多。他们不想自己动脑，也不想自己做主。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 统计数字]]></title>
    <url>%2F2018%2F05%2F13%2FLintCode-%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[计算数字k在0到n中的出现的次数，k可能是0~9的一个值 样例：例如n=12，k=1，在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]，我们发现1出现了5次 (1, 10, 11, 12) 分析：基本就是遍历了，不过要注意的就是0要特别处理。还有在遍历之后的数值处理需要交给临时变量，而不是用遍历数本身。 class Solution { public: /* * @param : An integer * @param : An integer * @return: An integer denote the count of digit k in 1..n */ int digitCounts(int k, int n) { // write your code here int count=0; if(k==0) count++; for(int i=k;i&lt;=n;i++){ int temp=i; while(temp){ if(temp%10==k) count++; temp/=10; } } return count; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 尾部的零]]></title>
    <url>%2F2018%2F05%2F12%2FLintCode-%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[设计一个算法，计算出n阶乘中尾部零的个数 样例：11! = 39916800，因此应该返回 2 挑战：O(logN)的时间复杂度 分析：此题如果采用先求出数的阶乘，再来计算求出的结果的0的个数的话，一方面时间的复杂度太高，另一方面平时的数据类型难以存储如此大的数，需要使用大整数来进行存储。因此需要另辟蹊径，从数学的角度来看待此问题。0的个数即代表的是10的个数，而10=2*5。很明显的是：在阶乘当中5所存在的个数必定是多于2的个数的。因此，我们可以说找到了多少个5就找到了多少个10,。使用100作为例子，从1~100之间会有多少个能够被5整除的数呢？通过数学归纳法可以发现是(100/5=20)个，此时是不是就结束了呢？再来看一下1~100之中的25,50,75,100这4个数，当他们同时都除以5以后发现依次是5,10,15,20，也就是说在进行一次除以5的操作之后他们之间其实还存在着5，而此次需要求取5的个数的区间刚好是上次除以5操作后的数。由此可见，这其实是应该存在于一个循环当中的，跳出循环的条件是n非零即可。 题目代码： class Solution { public: /* * @param n: A long integer * @return: An integer, denote the number of trailing zeros in n! */ long long trailingZeros(long long n) { // write your code here, try to do it without arithmetic operators. long long sum=0; while(n){ sum+=n/5; n/=5; } return sum; } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode A + B 问题]]></title>
    <url>%2F2018%2F05%2F12%2FLintCode-(A%20%2B%20B%20%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。 你不需要从输入流读入数据，只需要根据aplusb的两个参数a和b，计算他们的和并返回就行。 注意：a和b都是32位整数 样例：如果 a=1 并且 b=2，返回3 分析：对于这道题以我浅薄的知识真的是没想出来(发现这是一道简单题，瞬间受到一万点伤害)，这种接近于底层的东西，感觉自己在这方面太匮乏了。题目要求不能使用算术运算符号，基本上就能想到是通过二进制的位运算进行解答。但是想了半天也没什么头绪，只能默默地搜一下了。发现还是这篇文章讲得最靠谱了。lintcode刷题A+B问题位运算 然后突然想起自己的左移和右移有点淡忘了，就复习一下。移位包括逻辑移位和算术移位。逻辑移位是指移出去的位丢弃，空缺位用0来填充；算术移位是指移出去的位丢弃，空缺位用符号位来填充。当然对于无符号数来说，不管是左移还是右移都是逻辑移位；而对于有符号数而言，如果是左移则仍然是逻辑移位，但如果是右移则属于算术移位。 题目代码：比起oj里面的lintcode答案，还是比较喜欢上条链接里大佬写的代码，嘻嘻！ class Solution { public: /** * @param a: An integer * @param b: An integer * @return: The sum of a and b */ int aplusb(int a, int b) { // write your code here if(a==0) return b; if(b==0) return a; int x1=(a&amp;b)&lt;&lt;1; int x2=a^b; return aplusb(x1,x2); } };]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.六鱼》(典故)]]></title>
    <url>%2F2018%2F05%2F06%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E5%85%AD%E9%B1%BC%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、浩然驴：唐孟浩然曾在灞水之滨踏雪寻梅，并说：“我的诗思在风雪中、驴背上。” 2、分金齐鲍叔：齐管仲穷困时与鲍叔共做生意，分利时总给自己分得多。鲍叔也不认为管仲贪，知道这是他贫穷的缘故。 3、奉璧蔺相如：战国时，赵国得和氏璧，秦国要以十五城换赵璧。赵蔺相如奉璧使秦，见秦无诚意，以大智大勇与强秦对抗，终不辱使命，完璧归赵。 4、掷地金声孙绰赋：晋人孙绰作《天台山赋》，他的友人范荣期赞美其赋，说：“你试把它掷地，当作金石声响。” 5、回文锦字窦滔书：前秦苏蕙为秦州刺史窦滔妻，窦滔为安南将军，抛却苏蕙携宠妾而去。苏蕙悲恨，用彩锦织成《回文璇玑图诗》以赠滔。滔颇受感动，于是夫妻和好如初。 、6、未遇殷宗，胥靡困傅岩之筑：殷高宗梦得贤臣，后来按梦中人的相貌在傅岩找到了傅说(yue)。傅说未遇高宗时，仅是一个操杵筑土的奴隶。胥靡：奴隶。筑：筑土之杵。 7、既逢周后，太公舍渭水之渔：殷末，姜太公只在渭水之滨垂钓闲居，遇周文王，得以重用。周后：指周文王。舍：离去。 8、六朝：吴建都于建业(今南京城)，后历东晋、宋、齐、梁、陈，各朝均设都于此，号为“六朝”。 9、天禄：传说中的长角怪兽，汉代有阁名为“天禄阁”。刘向曾在此阁校书(整理书籍)。 10、石渠：据古史记载，汉初萧何曾建“石渠阁”收藏各国图书典籍，后来汉武帝以石渠作为国家收藏秘籍之处。 11、千字策：唐代科举考试重于诗赋，至宋代，开始侧重于“策试之制”，即要求考生就国家政治、军事大政发表议论，每篇文章以千字为限，称为“千字策”。 12、八行书：语见唐代诗人孟浩然诗：“家书寄八行。”此典原出马融寄窦尚书，内有两纸八行文字，故后人以“八行书”言其简赅。 13、有若对相如：有若：孔子的弟子。相如：战国时人蔺相如，另一解为指东汉时著名文学家司马相如。 14、爱见人长，共服宣尼休假盖：假盖：语见《孔子家语》。言某日孔子正待出门而天降阵雨，孔子的门人对孔子言，某人家里有雨伞，可以向此人借用。孔子回答说：此人为人，缺点就在于比较计较财物的得失。我听说与人交往，应当注意人家的长处，回避人家的短处，这样才能长久。我并不是不知道他家有伞，而怕的是他若不肯借，正暴露出他的短处呀！ 15、恐彰已吝，谁知阮裕竟焚车：晋代人阮裕，字思旷，有一辆好车。凡是有人求借，他无不借给。有一次，有人葬其母亲，欲向阮裕借车而又不敢开口。阮裕闻后叹息道：“我有这么一辆好车，却让人家不敢来向我借，这车拿来还有什么用呢？”于是，便焚烧了此车。 16、]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暮春游龙腾湖]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%9A%AE%E6%98%A5%E6%B8%B8%E9%BE%99%E8%85%BE%E6%B9%96%2F</url>
    <content type="text"><![CDATA[暮春游龙腾湖紫苏半夏忽见林中颜色盛，暗惊尘外岁时流。微风袅袅拂杨柳，细雨霏霏泛白鸥。四载韶华弹指过，三春好景转头休。不知何日能重返，惟有此辰怜此洲。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.五微》(典故)]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E4%BA%94%E5%BE%AE%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、周臻大定一戎衣：周兴师伐商，终于安定天下。臻(zhen)：达到大定，天下安定。 2、虎节：古时候使节所持的虎型信物。 3、白简：古时候御史如果要向皇帝弹劾官员，一般使用白色竹简书写。 4、朱衣：古代官服颜色。唐时四、五品官员穿的是红色的官服，因此称为朱衣。《欧阳公诗》中有：“文章自古无凭据，唯愿朱衣一点头。” 5、尨也吠：《诗经·召南·野有死靡》，原文为：“无感我帨兮，无使尨也吠。”（不要揭动我的围裙呀，不要让你的猎狗叫起来。）尨（音máng），多毛狗。 6、燕于飞：语出《诗经.燕燕》：“燕燕于飞，差池其羽。”借燕子双飞，比喻女子出嫁。 7、出使振威冯奉世：西汉冯奉世曾出使西域，遇上莎车国杀了汉朝使者，他便劝说西域诸国，发兵大破莎车，杀莎车王，威名远扬，得到西域各国敬重。 8、治民异等尹翁归：汉代尹翁归曾先后为东海、右扶风守令，他治民有方，赏善刑奸，除盗罢税，政绩卓然。 9、燕我弟兄，载咏棣棠韡韡：出自《诗经》中的《常（棠）棣》，原文为：“常棣之华，鄂不韡韡，凡今之人，莫如兄弟。”（棠棣树开的花呀，外观不是明艳照人吗？所有现在的人呀，没有人能赶上亲兄弟。）据说这是周公为宴饮兄弟而作的诗。燕，通“宴”。载，发语词，无义。棣棠，树木名，即郁李，也写作棠棣、唐棣。文中将“棠棣”写成“棣棠”，是因为服从对仗平仄的要求而改的。韡韡（音wěi），光艳茂盛的样子。 10、命伊将帅，为歌杨柳依依：《诗经.采薇》中有：“昔我往矣，杨柳依依，今我来思，雨雪霏霏。”这首诗是用来描写出征战士艰苦的生活。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立夏]]></title>
    <url>%2F2018%2F05%2F05%2F%E7%AB%8B%E5%A4%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚结束了于自己而言的一段旅程。立夏时节，早起，奔赴图书馆。昨夜有雨，地面湿漉，焕发着生机与活力的植被上布满了晶莹的水珠。门还未开，来到湖边的石椅上独坐，背单词。空气清新，雾气弥漫，晨光柔和，适合摄影的光线和境地。清脆的鸟鸣不断，偶尔会有鱼儿跃出水面，打破水面的平静，想起杜甫的那句“细雨鱼儿出，微风燕子斜”。上午在图书馆自习，写毕业的论文。倦了就去长廊里休憩，在长廊里听程璧的《你们》，吹凉爽的风，看楼下的景。今日的风稍大很特别，吹得整个人都倍感放松和惬意，这或许是春夏之交的礼赠。楼下已经有人开始拍摄毕业照，穿着一致的服装，为大学四年的相遇和时光留下最后一点珍贵的记忆。长廊的另一头望见的是晨梦亭、荷塘、郁郁葱葱的树木之中的小道还有很难觉察到的的小溪。想必此时的荷叶已经开始酝酿它的繁华时期了，山坡上的那棵桑树还有桑葚挂在枝头吗？这一载睡莲的长势会不会向迅猛方向发展从而占领更多的领地？想着在离去之前是一定要再去见它们一面的，与它们作别也与自己作别。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.四支》(典故)]]></title>
    <url>%2F2018%2F05%2F01%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E5%9B%9B%E6%94%AF%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、四目颉：指仓颉，传说是他始创汉字。仓颉为神圣，有四只眼睛。 2、一足夔：夔为舜时乐正。舜曾说：“一夔足矣。”意思是说夔具有真才，有他一个人担当乐正就足够了。后来人们误解了这话，以为夔异于常人，只长了一只脚。孔子也向鲁哀公解释说：足是“足够”之足，不是“手足”之足。乐(yue)正：是古代在宫廷中负责管理音乐的官名。 3、智伯恩深，国土吞变形之炭：春秋战国之交，豫让受智伯恩遇。后来智伯被赵襄子等杀死，豫让便漆身为癫，吞炭为哑，变其形容，伺机行刺赵襄子以报智伯仇，不遂，被执自杀。 4、羊公德大，邑人竖堕泪之碑：晋武帝时，羊祜镇守荆州，极得民心，死后葬岘山。百姓常记他的德行，见到他的墓碑每每落泪。时称堕泪碑。 5、去妇因探邻舍枣：汉朝人王吉的妻子摘了邻居家的几个枣，王吉就把她休回了娘家。 6、出妻为种后园葵：春秋时期公仪休为鲁国相，有一天在家中吃到葵菜，又见妻子在纺织，曰：“欲夺园夫红女之利乎？”为了不与园夫和织女争利，于是怒而拔去葵菜，并休妻出门。 7、青眼：正视。晋阮籍不拘礼教，对凡俗之士，常用白眼斜看，唯有嵇康携琴来到时，阮籍大喜，常用青眼看他。 8、白眉：三国蜀马良，字季常，眉间有白毛。兄弟五人都有才名，又都有一个“常”字为字。时谚说：“马氏五常，白眉最良。” 9、海棠春睡早：杨贵妃睡醒，唐明皇笑问道：“海棠春睡未足耶？” 10、张骏曾为槐树赋：晋西平公张骏据梁州，种柳树不活，独酒泉西北角有槐树生长，因而他就写了《槐树赋》。 11、杜陵不做海棠诗：杜甫诗集中没有咏海棠的诗，或以为杜甫母名海棠，因此避讳而不写海棠诗。 12、晋士奇特，可比一斑之豹：晋王献之少时，看到他父亲的门生赌博，时见胜负，就说：“南风不竟(意谓力量不强)。”门生们轻视他这个小孩子，反而说：“这个小儿不过是透过管子看豹，只能见到一点花斑而已。” 13、唐儒博识，堪为五总之龟：唐殷践猷知识渊博，贺知章称他为“五总龟”。因龟长寿，又古人以为龟千年有五聚，问无不知，所以称博学多闻的人为五总龟。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1022 D进制的A+B]]></title>
    <url>%2F2018%2F05%2F01%2FPAT-B1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB%2F</url>
    <content type="text"><![CDATA[输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。 输入格式：输入在一行中依次给出3个整数A、B和D。 输出格式：输出A+B的D进制数。 输入样例： 123 456 8 输出样例： 1103 题目代码： #include&lt;iostream&gt; using namespace std; int main(){ int A,B,D,i=0,c[30]; long sum; cin&gt;&gt;A&gt;&gt;B&gt;&gt;D; sum=A+B; do{ c[i++]=sum%D; sum=sum/D; }while(sum!=0); for(int j=i-1;j&gt;=0;j--){ cout&lt;&lt;c[j]; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1021 个位数统计]]></title>
    <url>%2F2018%2F05%2F01%2FPAT-B1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[给定一个k位整数N = dk-110^k-1 + … + d110^1 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。 输入格式：每个输入包含1个测试用例，即一个不超过1000位的正整数N。 输出格式：对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。 输入样例： 100311 输出样例： 0:2 1:3 3:1 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string s; cin &gt;&gt; s; int a[10] = { 0 }; for (int i = 0;i &lt; s.size();i++) { int n = s[i] - &apos;0&apos;; a[n]++; } for (int i = 0;i &lt; 10;i++) { if (a[i] &gt; 0) cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; a[i] &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1020 月饼]]></title>
    <url>%2F2018%2F04%2F30%2FPAT-B1020-%E6%9C%88%E9%A5%BC%2F</url>
    <content type="text"><![CDATA[月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。 输入样例： 3 20 18 15 10 75 72 45 输出样例： 94.50 题目代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; struct mooncake { int store;//库存量 int total;//总售价 double price;//单价 }; bool cmp(mooncake a, mooncake b) { return a.price &gt; b.price; } int main() { int N, D; cin &gt;&gt; N &gt;&gt; D; vector&lt;mooncake&gt; m(N); for (int i = 0;i &lt; N;i++) { cin &gt;&gt; m[i].store; } for (int i = 0;i &lt; N;i++) { cin &gt;&gt; m[i].total; m[i].price = (1.0*m[i].total) / m[i].store; } sort(m.begin(), m.end(), cmp); double sum = 0; for (int i = 0;i &lt; N;i++) { if (D &lt; m[i].store) { sum += ((D*1.0) / m[i].store)*m[i].total; break; } else { sum += m[i].total; D -= m[i].store; } } printf(&quot;%.2f&quot;, sum); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1019 数字黑洞]]></title>
    <url>%2F2018%2F04%2F30%2FPAT-B1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。 例如，我们从6767开始，将得到 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 ... ... 现给定任意4位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个(0, 10000)区间内的正整数N。 输出格式：如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。 输入样例1： 6767 输出样例1： 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 输入样例2： 2222 输出样例2： 2222 - 2222 = 0000 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; using namespace std; int transfer(string s) { int sum = 0; for (int i = 0;i &lt; 4;i++) { sum = sum * 10 + s[i] - &apos;0&apos;; } return sum; } bool cmp(char a,char b) { return a &gt; b; } int main() { int M; string N, X, Y; cin &gt;&gt; M; N = to_string(M); N.insert(0, 4 - N.length(), &apos;0&apos;); while (N != &quot;6174&quot;) { sort(N.begin(), N.end());//递增排序 X = N; sort(N.begin(), N.end(), cmp);//递减排序 Y = N; if (X == Y) { cout &lt;&lt; N &lt;&lt; &quot; - &quot; &lt;&lt; N &lt;&lt; &quot; = 0000&quot; &lt;&lt; endl; N = &quot;6174&quot;; } else { N = to_string(transfer(Y) - transfer(X)); N.insert(0, 4 - N.length(), &apos;0&apos;); cout &lt;&lt; Y &lt;&lt; &quot; - &quot; &lt;&lt; X &lt;&lt; &quot; = &quot; &lt;&lt; N &lt;&lt; endl; } } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1018 锤子剪刀布]]></title>
    <url>%2F2018%2F04%2F30%2FPAT-B1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83%2F</url>
    <content type="text"><![CDATA[大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。 输出格式：输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。 输入样例： 10 C J J B C B B B B C C C C B J B B C J J 输出样例： 5 3 2 2 3 5 B B 题目代码： #include&lt;iostream&gt; using namespace std; int main() { int N, x = 0, y = 0, z = 0, jia[3] = { 0 }, yi[3] = { 0 }; char a, b, c[4] = { &apos;B&apos;,&apos;C&apos;,&apos;J&apos; }; cin &gt;&gt; N; for (int i = 0;i &lt; N;i++) { cin &gt;&gt; a &gt;&gt; b; if (a == &apos;B&apos;) { if (b == &apos;B&apos;) y++; else if (b == &apos;C&apos;) { x++; jia[0]++; } else { z++; yi[2]++; } } else if (a == &apos;C&apos;) { if (b == &apos;B&apos;) { z++; yi[0]++; } else if (b == &apos;C&apos;) y++; else { x++; jia[1]++; } } else { if (b == &apos;B&apos;) { x++; jia[2]++; } else if (b == &apos;C&apos;) { z++; yi[1]++; } else y++; } } cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl; cout &lt;&lt; z &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl; int max1 = jia[0], max2 = yi[0], m = 0, n = 0; for (int i = 1;i &lt; 3;i++) { if (jia[i] &gt; max1) { max1 = jia[i]; m = i; } if (yi[i] &gt; max2) { max2 = yi[i]; n = i; } } cout &lt;&lt; c[m] &lt;&lt; &quot; &quot; &lt;&lt; c[n]; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.三江》(典故)]]></title>
    <url>%2F2018%2F04%2F30%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E4%B8%89%E6%B1%9F%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、世祖中兴延马武：后汉马武，出身绿林。西汉更始初年，拜为振威将军。东汉光武帝刘秀攻下邯郸后，延请马武率领上谷突骑。马武归顺刘秀后，为刘秀中兴大业屡建军功。 2、桀王失道杀龙逄：龙逄(pang)，夏时人，直谏夏桀，桀无道，终杀龙逄。 3、九泽：古代传说中的九个湖泊，说法不一，《吕氏春秋.有始览》指吴的具区泽、楚的云梦泽、秦的阳华泽、晋的大陆泽、梁的圃田泽、宋的孟诸、齐的海隅、赵的巨鹿、燕的大昭泽等九泽。 4、三江：古代传说中的三条江河，说法不一，据《尚书.禹贡》“三江既入”条下蔡沈注云：三江在震泽下分流，东北入海为娄江，东南入海为东江，并松江为三江。《佩文韵府》云三江乃钱塘江、扬子江、松江。一云为松江、钱塘江、浦阳江。 5、阵上倒戈辛纣战：周武王兴兵伐纣，纣发兵与周武王迎战。纣王众叛亲离，兵众阵前倒戈反击，致使纣王大败，身灭国亡。 6、道旁系剑子婴降：传派高祖刘邦破秦，秦始皇之孙秦王子婴驾素车白马，系剑于道旁，向刘邦军队投降。 7、主簿栖鸾名有览：东汉的仇览，字季智，又名香，先为蒲县亭长，后位主簿，他自称做鹰鹑不如做鸾凤。主簿：县令的属官，主管文书簿籍之事。 8、治中展骥姓惟庞：《三国志.庞统传》记载：庞统，字士元，是三国时期刘备的谋士，与诸葛亮齐名，刘备曾派他做耒阳令。但是在这里却没有做出什么政绩，鲁肃和刘备都认为他不是百里之才，只有使他的官位在治中别驾这样的地位上，才能施展他的才能。治中和别驾都是府佐名。 9、雪屡餐于北海：苏武为西汉大臣，出使匈奴时被扣留，后来被发配到北海牧羊，喝雪水，吞毡毛，历尽千辛万苦，却始终握着汉朝的笏板，直到十九年之后才得以回国。 10、水必决于西江：《庄周.外物》中讲了一个这样的故事，据说有一次，庄子因事外出，在一条车辙当中发现一尾鲋鱼，那条鱼请求庄子给他一些水，好让他不至于渴死，庄子却慷慨地说要去引西江的水过来救他。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统问题整理]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、进程和线程 (1)线程是独立调度的基本单位，进程是拥有资源的基本单位。线程不拥有资源(减小了时空开销)。 (2)一个进程中可以包括多个线程，并且线程共享整个进程的资源(一般都要进行同步和互斥)，一个进程至少包括一个线程。进程内的线程对于其他进程不可见。 (3)引入进程的目的是为了更好地使用多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程度。引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 (4)进程间的通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以直接读/写进程数据段来进行通信。 2、线程同步的几种方式 (1)临界区(CCriticalSection):当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。 (2)互斥量(CMutex):互斥量与临界区的行为完全相同，但是也有一定的区别：互斥量是内核对象，临界区是用户模式下的同步对象，执行速度快于内核对象。 (3)事件(CEvent):通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。 (4)信号量(CSemphore):它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 3、进程间通信(IPC) (1)共享存储：在通信的进程间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程间的通信。(常用到PV操作来进行同步和互斥) (3)消息传递：进程通过系统提供的发送消息和接受消息两个原语进行数据交换。(有直接通信方式和间接通信方式) (3)管道通信(通常指无名管道)是一种半双工的通信方式。它是指用于连接一个读进程和一个写进程以实现他们之间通信的共享文件。 4、缓冲区溢出 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。会产生以下危害：程序崩溃，导致拒绝额服务；跳转并且执行一段恶意代码。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。 5、死锁 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的四个条件如下(有一个条件不成立，则不会产生死锁) (1)互斥条件：一个资源一次只能被一个进程使用。 (2)请求与保持条件：进程已经保持了至少一个资源，但又提出新的资源请求，而该资源被其他进程占用。 (3)不剥夺条件：进程获得的资源，在未使用完之前，不能被强行剥夺，只能主动释放。 (4)循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中的下一个进程所请求。 解决死锁的基本方法: (1)预防死锁：资源一次性分配(破坏请求和保持条件)；可剥夺资源，即当某进程新的资源未满足时，释放已占有的资源(破坏不可剥夺条件)；资源有序分配法，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反(破坏环路等待条件) (2)避免死锁:系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。 (3)检测死锁:这种方法无须事先采取任何限性制措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。 (4)解除死锁:当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。 6、进程的几种状态 (1)就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源。 (2)运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数。 (3)阻塞状态： 进程等待某种条件，在条件满足之前无法执行。 7、动态分区算法 (1)首次适应算法(FF):空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。该算法优先利用内存中低址空间，保留了高址空间，缺点是低址部分不断被划分，留下许多内存碎片。 (2)循环首次适应算法(NF):NF算法每次从上一次分配的地方继续分配，该算法需要一个起始查询的指针用于指示下一次查询的空间地址。缺点是：缺乏大的空间分区。 (3)最佳适应算法(BF):空闲分区以容量递增形成分区链，找到第一个能满足要求的空闲分区。缺点是：留下许多内存碎片。 (4)最坏适应算法(WF):空闲分区以容量递减形成分区链,找到第一个能满足要求的空闲分区。即总是挑选最大的空闲区域分配给作业使用。优点是不至于使空闲区间太小，产生碎片的可能性小，缺点是：缺乏大的空间分区 8、分页和分段的区别 (1)都采用离散分配方式，且都是通过地址映射机构来实现地址的转换。 (2)分页管理不会产生外部碎片，但产生内部碎片；分段管理不会产生内部碎片。 (3)页的大小固定且由系统决定，在采用分页存储管理方式中直接由硬件实现。而段的大小不固定，决定于用户所编写的程序。 (4)分页的地址空间是一维的，分段系统中是二维的。 9、虚拟存储器页面置换算法 (1)最佳置换算法(Optimal):淘汰的页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 (2)先进先出算法(FIFO):总是最先淘汰最先进去的页面。缺点：通常程序调入内存的先后顺序和程序执行的先后顺序不一致，导致缺页率高。 (3)最近最久未使用(LEU):选择最近最长时间未访问过的页面予以淘汰。 (4)时钟置换算法(LFU):在每个页面设置一个移位寄存器记录该页面的访问频率，最近时期最少使用的页面被淘汰。 10、调度算法 (1)先来先服务调度算法(FCFS):每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它。 (2)短作业优先调度算法(SJF):对短作业(运行时间最短)优先调度的算法。 (3)优先级调度算法:每次从后备作业中选择优先级最高的作业，将其调入内存，分配必要的资源。 (4)高响应比优先调度算法:在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 (5)时间片轮转调度算法:将系统中所有就绪进程按照先来先服务的原则，但仅能运行一个时间片。 (6)多级反馈队列调度算法(集合了前几种算法的优点):是时间片轮转调度算法和优先级调度算法的综合和发展。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络问题整理]]></title>
    <url>%2F2018%2F04%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、TCP连接时，为什么要进行三次握手 client发出的一个连接请求报文段在某个网络节点长时间滞留，以致于延误到连接释放以后才到达server。本来是一个早已失效的报文段，但server误认为是client发出的新的连接请求。于是就向client发送确认报文段，同意建立连接。如果不采取三次握手，那么只要server发出确认，新的连接就建立了。但由于client实际上并没有发出连接请求，因此不予理睬server的确认，也不会向server发送确认。但server却认为连接已经建立，并一直等待client发来数据。造成server资源的浪费。 A：“喂，你听得到吗？”。 B：“我听得到呀，你听得到我吗？”(应答和请求同时发出)。 C：我能听得到你，balabala...”。 2、为什么需要四次挥手 (1)当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口，就会发FIN给主机B。 (2)当主机B收到A发送的FIN，表示收到了，就会发送ACK回复A。 (3)但此时B可能还在发送数据，没有想要关闭数据口，所以B的FIN和回复A的ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。 (4)A收到B发来的FIN，知道B的数据也发送完了，回复ACK。A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭连接，B也关闭了连接。 A：“喂，我不说了”。 B：“我知道了。等一下，我还没说完。Balabala...”。 B：“好了，我说完了，我也不说了”。 A：“我知道了”。 client发出最后的ACK回复可能会丢失。server如果没有收到ACK，将不断重复发送FIN片段。所以client不能立即关闭，他必须确认server收到了该ACK。client会在发出ACK之后进入到TIME_Wait状态。同时设置一个计时器，等待2MSL(MSL指一个片段在网络中最大的存活时间)的时间。如果在该段时间内收到FIN，那么需要重发ACK。如果没有再次收到ACK，client就认为server已经收到ACK，结束TCP连接。 3、]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.二冬》(典故)]]></title>
    <url>%2F2018%2F04%2F29%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E4%BA%8C%E5%86%AC%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、冯妇虎：春秋时期，晋国有一个叫冯妇的人，打虎本领很强。 2、叶公龙：指叶公好龙的故事。 3、台高名戏马：戏马台即项羽掠马台，南朝宋武帝刘裕曾在这里宴会宾客。 4、斋小号蟠龙：东晋桓温曾在南州建蟠龙斋，上面画的尽是龙。 5、手擘蟹螯从毕卓：晋毕卓性情高傲豁达，爱喝酒，曾说：“一手持蟹螯，一手持酒杯。拍浮酒池中，便足了一生。”擘(bo)，分开；螯(ao)，螃蟹钳子形状的脚。 6、身披鹤氅自王恭：晋王恭仪表很美，人们夸他“濯濯如春月柳”。他曾经身披鹤氅裘，孟昶看到了，惊叹道：“此真神仙中人也？”鹤氅是用鹜鸟羽毛制成的外套。 7、三姑石：《地舆志》载：南康有三姑石，响声若金镛。金镛(yong)，大钟。 8、陈后主：南朝末年的亡国之君。即陈叔宝，字元秀，在位七年为隋所灭。 9、汉中宗：汉代著名君主。即汉武帝曾孙刘洵，在位二十五年崩，谥号汉宣帝。 10、绣虎：指魏晋著名文学家曹植(曹操之子，魏文帝曹丕的弟弟)。据称他七步成诗一首，人称“绣虎”。 11、雕龙：指古代著名文艺批评著作《文心雕龙》。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1017 A除以B]]></title>
    <url>%2F2018%2F04%2F29%2FPAT-B1017-A%E9%99%A4%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。 输入格式：输入在1行中依次给出A和B，中间以1空格分隔。 输出格式：在1行中依次输出Q和R，中间以1空格分隔。 输入样例： 123456789050987654321 7 输出样例： 17636684150141093474 3 题目代码： #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string s; cin &gt;&gt; s; int a; cin &gt;&gt; a; int len = s.length(); int t = (s[0] - &apos;0&apos;) / a; if ((t != 0 &amp;&amp; len &gt; 1) || len == 1) { cout &lt;&lt; t; } int temp = (s[0] - &apos;0&apos;) % a; for (int i = 1; i &lt; len; i++) { t = (temp * 10 + s[i] - &apos;0&apos;) / a; cout &lt;&lt; t; temp = (temp * 10 + s[i] - &apos;0&apos;) % a; } cout &lt;&lt; &quot; &quot; &lt;&lt; temp; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1016 部分A+B]]></title>
    <url>%2F2018%2F04%2F29%2FPAT-B1016-%E9%83%A8%E5%88%86A%2BB%2F</url>
    <content type="text"><![CDATA[正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。 现给定A、DA、B、DB，请编写程序计算PA + PB。 输入格式：输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 10^10。 输出格式：在一行中输出PA + PB的值。 输入样例1： 3862767 6 13530293 3 输出样例1： 399 输入样例2： 3862767 1 13530293 8 输出样例2： 0 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int PAB(string X, int Y) { int n = 0, sum = 0; for (int i = 0;i &lt; X.size();i++) { if (X[i] - &apos;0&apos; == Y) n++; } for (int i = 0;i &lt; n;i++) { sum = sum * 10 + Y; } return sum; } int main() { int DA, DB; string A, B; cin &gt;&gt; A &gt;&gt; DA &gt;&gt; B &gt;&gt; DB; cout &lt;&lt; PAB(A, DA)+ PAB(B, DB); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1015 德才论]]></title>
    <url>%2F2018%2F04%2F29%2FPAT-B1015-%E5%BE%B7%E6%89%8D%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第1行给出3个正整数，分别为：N（&lt;=10^5），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。 随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。 输出格式：输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例： 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例： 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 题目代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; struct node { int number, moral, talent; }; int cmp(node a, node b) {//sort所需的比较函数。 if ((a.moral + a.talent) != (b.moral + b.talent)) return (a.moral + a.talent) &gt; (b.moral + b.talent); else if (a.moral != b.moral) return a.moral &gt; b.moral; else return a.number &lt; b.number; } int main() { int n, low, high; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;low, &amp;high); vector&lt;node&gt; v[4]; node temp; int m = n; for (int i = 0; i &lt; n; i++) {//根据类别划分不同的动态数组 scanf(&quot;%d %d %d&quot;, &amp;temp.number, &amp;temp.moral, &amp;temp.talent); if (temp.moral &lt; low || temp.talent &lt; low) m--; else if (temp.moral &gt;= high &amp;&amp; temp.talent &gt;= high) v[0].push_back(temp); else if (temp.moral &gt;= high &amp;&amp; temp.talent &lt; high) v[1].push_back(temp); else if (temp.moral &lt; high &amp;&amp; temp.talent &lt; high &amp;&amp; temp.moral &gt;= temp.talent) v[2].push_back(temp); else v[3].push_back(temp); } printf(&quot;%d\n&quot;, m); for (int i = 0; i &lt; 4; i++) { sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j &lt; v[i].size(); j++) printf(&quot;%d %d %d\n&quot;, v[i][j].number, v[i][j].moral, v[i][j].talent); } return 0; } 注意：此题使用cin和cout来输入和输出会产生超时的问题。建议以后的输入和输出全部使用scanf和printf来完成。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1014 福尔摩斯的约会]]></title>
    <url>%2F2018%2F04%2F29%2FPAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[大侦探福尔摩斯接到一张奇怪的字条： “我们约会吧！3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。 大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。 输出格式：在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。 输入样例： 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例： THU 14:04 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string day[7] = { &quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot; }; string str1, str2, str3, str4; cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3 &gt;&gt; str4; int i = 0, j = 0, k = 0, n = 0; while (i &lt; str1.size() &amp;&amp; i &lt; str2.size()) { if ((str1[i] == str2[i]) &amp;&amp; (k == 1) &amp;&amp; ((str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;N&apos;) || (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;))) break; if (str1[i] == str2[i] &amp;&amp; str1[i] &gt;= &apos;A&apos;&amp;&amp;str1[i] &lt;= &apos;G&apos;) { k++; if (k == 1) n = i; } i++; } cout &lt;&lt; day[str1[n] - &apos;A&apos;] &lt;&lt; &quot; &quot;; if (str1[i] &gt;= &apos;0&apos;&amp;&amp;str1[i] &lt;= &apos;9&apos;) {//如果是数字 cout &lt;&lt; &quot;0&quot; &lt;&lt; str1[i] - &apos;0&apos;&lt;&lt;&quot;:&quot;; } else {//如果是字母 cout &lt;&lt; (9 + str1[i] - &apos;A&apos; + 1) &lt;&lt; &quot;:&quot;; } while (j &lt; str3.size() &amp;&amp; j &lt; str4.size()) { if ((str3[j] == str4[j]) &amp;&amp; ((str3[j] &gt;= &apos;A&apos;&amp;&amp;str3[j] &lt;= &apos;Z&apos;) || (str3[j] &gt;= &apos;a&apos;&amp;&amp;str3[j] &lt;= &apos;z&apos;))) break; j++; } if (j &gt;= 0 &amp;&amp; j &lt;= 9) cout &lt;&lt; &quot;0&quot; &lt;&lt; j; else cout &lt;&lt; j; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1013 数素数]]></title>
    <url>%2F2018%2F04%2F29%2FPAT-B1013-%E6%95%B0%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。 输入格式：输入在一行中给出M和N，其间以空格分隔。 输出格式：输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。 输入样例： 5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 题目代码： #include&lt;iostream&gt; using namespace std; bool prime(int n) {//判定是否为素数 if (n &lt;= 1) return false; for (int i = 2;i*i &lt;= n;i++) { if (n%i == 0) return false; } return true; } int main() { int M, N, i = 2, j = 0, k = 0; cin &gt;&gt; M &gt;&gt; N; while (k &lt; N) { if (prime(i)) { k++;//统计目前是第几个素数 if (k &gt;= M) { cout &lt;&lt; i; j++; if (j % 10 == 0) cout &lt;&lt; endl; else { if (k &lt; N) cout &lt;&lt; &quot; &quot;; } } } i++; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1012 数字分类]]></title>
    <url>%2F2018%2F04%2F28%2FPAT-B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字： A1 = 能被5整除的数字中所有偶数的和； A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...； A3 = 被5除后余2的数字的个数； A4 = 被5除后余3的数字的平均数，精确到小数点后1位； A5 = 被5除后余4的数字中最大数字。 输入格式：每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出格式：对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出“N”。 输入样例1： 13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 30 11 2 9.7 9 输入样例2： 8 1 2 4 5 6 7 9 16 输出样例2： N 11 2 N 9 题目代码：需要注意的是最好不要让cout和printf在同一个程序当中出现。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;math.h&gt; using namespace std; int main() { int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0;i &lt; n;i++) { cin &gt;&gt; a[i]; } int A1 = 0, A2 = 0, A3 = 0, A5 = 0, flag2 = 0, j = 0 ; double A4 = 0.0, flag4 = 0.0; for (int i = 0;i &lt; n;i++) { if (a[i] % 5 == 0 &amp;&amp; a[i] % 2 == 0) A1 += a[i]; if (a[i] % 5 == 1) { A2 += (int)(pow(-1, j++)*a[i]); flag2++; } if (a[i] % 5 == 2) A3++; if (a[i] % 5 == 3) { A4 += a[i]; flag4++; } if (a[i] % 5 == 4) if (a[i] &gt; A5) A5 = a[i]; } if (A1 &gt; 0) printf(&quot;%d &quot;, A1); else printf(&quot;N &quot;); if (flag2 &gt; 0) printf(&quot;%d &quot;, A2); else printf(&quot;N &quot;); if (A3 &gt; 0) printf(&quot;%d &quot;, A3); else printf(&quot;N &quot;); if (A4 &gt; 0) printf(&quot;%.1f &quot;, A4 / flag4); else printf(&quot;N &quot;); if (A5 &gt; 0) printf(&quot;%d&quot;, A5); else printf(&quot;N&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1011 A+B和C]]></title>
    <url>%2F2018%2F04%2F28%2FPAT-B1011-A%2BB%E5%92%8CC%2F</url>
    <content type="text"><![CDATA[给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。 输入格式：输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。 输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 题目代码： #include&lt;iostream&gt; using namespace std; int main() { int n; long long A, B, C; cin &gt;&gt; n; for (int i = 0;i &lt; n;i++) { cin &gt;&gt; A &gt;&gt; B &gt;&gt; C; if ((A + B) &gt; C) cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: true&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: false&quot; &lt;&lt; endl; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1010 一元多项式求导]]></title>
    <url>%2F2018%2F04%2F28%2FPAT-B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。） 输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。 输入样例： 3 4 -5 2 6 1 -2 0 输出样例： 12 3 -10 1 6 0 题目代码：这里设立一个flag标志位，如果指数为零并且标志位也同时为零，则说明是零多项式。 #include&lt;iostream&gt; using namespace std; int main() { int m, n, flag = 0; while (cin &gt;&gt; m &gt;&gt; n) { if (!flag &amp;&amp; !n) { cout &lt;&lt; &quot;0 0&quot;;//零多项式 } if (n) { if (flag) cout &lt;&lt; &quot; &quot;;//不是第一组输出时，要在当前这组数据输出前加上空格。 cout &lt;&lt; m*n &lt;&lt; &quot; &quot; &lt;&lt; n - 1; flag = 1; } } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《声律启蒙.卷上.一东》(典故)]]></title>
    <url>%2F2018%2F04%2F28%2F%E3%80%8A%E5%A3%B0%E5%BE%8B%E5%90%AF%E8%92%99.%E5%8D%B7%E4%B8%8A.%E4%B8%80%E4%B8%9C%E3%80%8B(%E5%85%B8%E6%95%85)%2F</url>
    <content type="text"><![CDATA[1、三尺剑：汉高祖刘邦曾说：“我以布衣提三尺取天下。”“三尺”，是剑的大约长度，所以常以“三尺”或“三尺剑”统称为宝剑。 2、六钧弓：三十斤为一钧。《左传.定公》载：“颜高之弓六钧。”指硬度很强的弓。 3、广寒宫：传说唐玄宗梦见一宫殿，上面的榜额写着“广寒清虚之府”，即广寒宫。后多指月宫。 4、颜巷陋：指颜回居住在简陋的地方。 5、阮途穷：晋代竹林七贤之一的阮籍，常以纵酒装疯避祸，走在路上每遇道路阻塞，便痛哭而返。 6、濯足水：语出《孺子歌》：“沧浪之水浊兮，可以濯我足。” 7、同泰寺：佛寺名，南朝梁武帝萧衍大力倡导尊佛崇儒，常与高僧在同泰寺讲论佛经。 8、未央宫：汉高祖刘邦统一天下之后，曾经在未央宫设宴招待。 9、绿绮：有名的乐器。楚庄王有琴叫绕梁，司马相如有琴叫绿绮(卓文君琴名)，蔡邕有琴叫焦尾，都是有名的乐器。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致临安]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%87%B4%E4%B8%B4%E5%AE%89%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我愿在你的身体里为你写诗，我愿在你的怀抱中虚度余生。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;――――题记 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起临安，我会想起什么呢？虽然彼此素未谋面。但我在许嵩的《断桥残雪》里；在柳永的《望海潮》中；从“暖风熏得游人醉，直把杭州作汴州”和“小楼一夜听春雨，深巷明朝卖杏花”那里面窥见的临安城是如此地楚楚动人，惹人喜爱。曾经这样想过：选择了一座城是否就选择了一种生活的方式？后来，自己给出的答案是肯定的。因为外界环境从始至终都会或多或少地影响一个人的心情和状态。再者我想：如果可以在自己喜欢的城市里柴米油盐地生活，便是一种极大的愉悦。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;喜欢一座城，可以具备一定的缘由，或许也可以不问因果。我对杭州起初的向往就像三毛之于撒哈拉一样，怀着一种非此地不居的想法，犹如冥冥之中的神秘引力，让我们彼此惺惺相（吸）。还记得多年以前《新白娘子传奇》中那断桥上的油纸伞吗？还记得杨万里的那句“接天莲叶无穷碧，映日荷花别样红”吗？这其中哪个是我第一次接触到的有关于杭州的记忆，我又是从什么时候起拥有了对杭州的执念，这些都难以追溯。但我知道是什么促进了，加强了甚至是升华了我对杭州的喜爱。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杭州自秦朝设县治以来已有2200多年的历史，曾是吴越国和南宋的都城，因风景秀丽，素有“人间天堂”的美誉。杭州之名从“秦时明月汉时关”里属会稽郡的钱唐，到东汉属吴郡的钱唐，到三国和两晋时期属吴郡但却归于古扬州的钱唐，再到后来隋朝时期“杭州”二字的首次登台，再到为避唐朝国号之讳将此“唐”改为彼“塘”。就这样等到五代十国时期一过，由于先前运河的修建，水利的兴修。杭州便迎来了在中国历史上的全盛时期，也就是宋王朝。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，正如你所看到的，上面这一大段大多都是百度百科里的东西。我所想抓住的便是其中的一个宋字。从北宋到南宋，用“钱塘自古繁华”一句来讲我想是恰如其分的。这些从张择端的《清明上河图》中便可见一斑。谈及北宋，作为苏子瞻这位诗词大文豪的铁杆粉丝，我想这里对他的记录是必不可少的。苏子瞻是四川眉州眉山人，凭借其清心洒脱、豪放不羁的文采征服了当时的文坛领袖欧阳修。在欧阳修的赏识之下，作为初唐宰相苏味道之后的苏子瞻，作为后来唐宋八大家苏氏一家独占三个名额的苏子瞻。顿时便名声大噪。无奈当时王安石变法如火如荼，但苏子瞻的很多师友，包括他自己在内也与王安石集团政见不和。于是遭受排挤在所难免。熙宁四年（1071年），苏子瞻上书皇帝谈论新法之弊病。遭王安石集团之不满，于是请求出京任职，被授为杭州通判。此后历经乌台诗案，被贬黄州。后因神宗驾崩，哲宗即位，高太后把持朝政（其对苏子瞻颇为赏识）。因此，从复为朝奉郎知登州（蓬莱），到以礼部郎中被召还朝，到升为起居舍人，到中书舍人，再到升翰林学士、知制诰，知礼部贡举。虽然苏子瞻一路高歌猛进，但当他发现司马光集团与原来的王安石集团不过是一丘之貉时，便再次向朝廷提出谏议，也因此再次遭受排挤。元祐四年也就是公元1089年，苏子瞻再度自求外调，任龙图阁学士、知杭州。苏子瞻这两次为官在杭州一共呆了五年，这五年我想应是他仕途当中最快乐的时光。远离了政治的中心，远离了朝局，没有了勾心斗角、尔虞我诈。有的是关心民瘼，赈济灾民，兴修水利，浚治西湖。因此也深受杭州百姓的爱戴。他也在闲暇之余，纵情于山水之间，其足迹遍及西湖山水、园林、寺庙等等。留下了颇多的传说、题名、碑刻和诗词。作为诗人和词人，这无疑是一种莫大的享受。可以说苏子瞻为杭州的历史和文化底蕴增添了浓墨重彩的一笔。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起苏堤当然还有白堤，说起词人当然还有李清照，说起诗人当然还有辛弃疾，除了北宋当然还有南宋。靖康之变后，徽钦二帝被俘，北宋沦亡，为金朝所灭。宋高宗赵构定都临安府。或许曾经的宋高宗也为临安的气质所折服才愿意在此偏安一隅吧。想起800多年前的岳鹏举怀着满腔的热血和报国之志踏上这片美丽而又繁华的土地，是否也会驻足回望，为临安的所有而惊艳。常年征战在外的他；身处军营和刀光剑影里的他；写下气势磅礴，英勇而悲壮的《满江红》的他；到头来却被奸佞所诬陷，高宗所猜忌的他。是否也曾在满月的夜里，想着能够和家人在类似于临安的城里共度余生呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我对杭州的眷恋，想来与这些早已故去却一直存在的烟云有着莫大的关联。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1009 说反话]]></title>
    <url>%2F2018%2F04%2F26%2FPAT-B1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例： Hello World Here I Come 输出样例： Come I Here World Hello 题目代码： #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; int main() { stack&lt;string&gt; s; string a; while(cin &gt;&gt; a) s.push(a); cout &lt;&lt; s.top(); s.pop(); while(!s.empty()) { cout &lt;&lt; &quot; &quot; &lt;&lt; s.top(); s.pop(); } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1008 数组元素循环右移问题]]></title>
    <url>%2F2018%2F04%2F26%2FPAT-B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数,之间用空格分隔。 输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例： 6 2 1 2 3 4 5 6 输出样例： 5 6 1 2 3 4 题目代码：本题需要注意的是当移动的次数为0，为N或者大于N的特殊情况。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int main() { int N, M; cin &gt;&gt; N &gt;&gt; M; vector&lt;int&gt; a(N); for (int i = 0;i &lt; N;i++) { cin &gt;&gt; a[i]; } if (M != 0 &amp;&amp; M != N) { if (M &gt; N) M = M%N; reverse(a.begin(), a.begin() + N - M);//将前面的N-M位进行反转 reverse(a.begin() + N - M, a.end());//将后面的M位进行反转 reverse(a.begin(), a.end());//将整个数组进行反转 } for (int i = 0;i &lt; N;i++) { cout &lt;&lt; a[i]; if (i &lt; N - 1) cout &lt;&lt; &quot; &quot;; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1007 素数对猜想]]></title>
    <url>%2F2018%2F04%2F26%2FPAT-B1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。 输入格式：每个测试输入包含1个测试用例，给出正整数N。 输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。 输入样例： 20 输出样例： 4 题目代码： #include&lt;iostream&gt; using namespace std; bool isPrime(int n) {//判定是否为素数 if (n &lt;= 1) return false; for (int i = 2;i*i &lt;= n;i++) { if (n % i == 0) return false; } return true; } int main() { int n, num = 0; cin &gt;&gt; n; for (int i = 5;i &lt;= n;i++) { if (isPrime(i - 2) &amp;&amp; isPrime(i)) num++;//如果相差2的两个数均为素数，则num自增1 } cout &lt;&lt; num; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1006 换个格式输出整数]]></title>
    <url>%2F2018%2F04%2F26%2FPAT-B1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。 输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出n。 输入样例1： 234 输出样例1： BBSSS1234 输入样例2： 23 输出样例2： SS123 题目代码：此题也可以直接输出没有必要创建一个string类型的数据。个十百位也可以使用数组来进行保存。 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { int n, g, s = 0, b = 0; cin &gt;&gt; n; g = n % 10;//个位 n /= 10; if (n) s = n % 10;//十位 n /= 10; if (n) b = n % 10;//百位 string str; while (b) { str += &apos;B&apos;; b--; } while (s) { str += &apos;S&apos;; s--; } for (int i = 1;i &lt;= g;i++) { str +=(i+&apos;0&apos;); } cout &lt;&lt; str; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1005 继续(3n+1)猜想]]></title>
    <url>%2F2018%2F04%2F26%2FPAT-B1005-%E7%BB%A7%E7%BB%AD(3n%2B1)%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。 输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。 输入样例： 6 3 5 6 7 8 11 输出样例： 7 6 题目代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; bool cmp(int a, int b) { return a &gt; b; } int arr[10000];//全局数组默认值为0 int main() { int k, n; cin &gt;&gt; k; vector&lt;int&gt; v(k); for (int i = 0;i &lt; k;i++) { cin &gt;&gt; n; v[i] = n;//初始化动态数组 while (n != 1) { if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; arr[n] = 1;//将所有元素会覆盖的值加入arr当中,1表示覆盖过 } } sort(v.begin(), v.end(), cmp);//将动态数组元素从大到小排序 //用于判定是否输出空格(此处由于无法预知未曾遍历的数组元素当中是否存在没有被覆盖的情况，只好将空格的输出判定放在已经确定的未被覆盖元素之前) int flag = 0; for (int i = 0;i &lt; v.size();i++) {//遍历整个数组 if (!arr[v[i]]) { if (flag == 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; v[i]; flag = 1; } } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我喜欢夜是寂静的]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%88%91%E5%96%9C%E6%AC%A2%E5%A4%9C%E6%98%AF%E5%AF%82%E9%9D%99%E7%9A%84%2F</url>
    <content type="text"><![CDATA[我喜欢夜是寂静的 那遥远的地方跑过来的黑夜 喃喃地呼唤我 将我揽入她的怀抱 她也叫来昏黄的路灯 挂在我的头上 头顶再遥远的地方 淡淡的星子在闪 四周里安静无声，那是因为 夜，也喜欢我是寂静着的]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 二进制中有多少个1]]></title>
    <url>%2F2018%2F04%2F23%2FLintCode-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1%2F</url>
    <content type="text"><![CDATA[计算在一个 32 位的整数的二进制表示中有多少个 1. 样例 给定 32 (100000)，返回 1 给定 5 (101)，返回 2 给定 1023 (1111111111)，返回 10 代码一：此题如果采用的是移位的方法，那么这里唯一需要注意的是当给定的测试用例是负数的时候要先计算位于负号位的1，然后转化为正整数之后再进行移位的操作和计数。 int countOnes(int num) { int count = 0; if (num &lt; 0) { count++; num = num ^ 0x80000000; } while (num &gt; 0) { if (num &amp; 1) { count++; } num = num &gt;&gt; 1; } return count; } 代码二：这种方法还是比较巧妙，这里的数字本身和减一之后的数相与让我想起了计算数是否为2的幂次的程序。 int countOnes(int num){ int count = 0; while(num){ num = num &amp; (num-1); count++; } return count; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1004 成绩排名]]></title>
    <url>%2F2018%2F04%2F21%2FPAT-B1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含1个测试用例，格式为 第1行：正整数n 第2行：第1个学生的姓名 学号 成绩 第3行：第2个学生的姓名 学号 成绩 ... ... ... 第n+1行：第n个学生的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。 输入样例： 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例： Mike CS991301 Joe Math990112 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { int n, score, maxscore = -1, minscore = 101; string name, number, maxname, minname, maxnumber, minnumber; cin &gt;&gt; n; for (int i = 0;i &lt; n;i++) { cin &gt;&gt; name &gt;&gt; number &gt;&gt; score; if (score &gt; maxscore) { maxscore = score; maxname = name; maxnumber = number; } if (score &lt; minscore) { minscore = score; minname = name; minnumber = number; } } cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnumber &lt;&lt; endl; cout &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnumber; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1003 我要通过！]]></title>
    <url>%2F2018%2F04%2F21%2FPAT-B1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81%2F</url>
    <content type="text"><![CDATA[“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。 输入样例： 8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA 输出样例： YES YES YES YES NO NO NO NO 分析：这种题目切不可仓促下笔，需要根据题目给出的条件分析清楚其中潜藏的规律。最好的方法就是使用输入输出样例当中的正确样例进行代入当然也可以自行多加一些样例来让结果更直观。此题的条件一可以说是一目了然，就没有代入的必要了。重点在于条件二和条件三。 条件二：任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举出以下皆正确的样例： PAT APATA AAPATAA AAAPATAAA AAAAPATAAAA ... 从中可以得出：在字符’PAT’的前面和后面添加任意相等个数的字符’A’即可满足条件二。 条件三：如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。那么可以列举以下样例： PAT PAAT PAAAAAT APATA APAATAA APAAATAAA AAPATAA AAPAATAAAA AAPAAATAAAAAA 总结来说：只能有一个P一个T，中间末尾和开头可以随便插入A。但是必须满足开头的A的个数 * 中间的A的个数 = 结尾的A的个数。 #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; int main() { int n, p = 0, t = 0; string s; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; s; map&lt;char, int&gt; m; for(int j = 0; j &lt; s.size(); j++) { m[s[j]]++; if (s[j] == &apos;P&apos;) p = j; if (s[j] == &apos;T&apos;) t = j; } if(m[&apos;P&apos;] == 1 &amp;&amp; m[&apos;A&apos;] != 0 &amp;&amp; m[&apos;T&apos;] == 1 &amp;&amp; m.size() == 3 &amp;&amp; p * (t-p-1) == s.length()-t-1) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1002 写出这个数]]></title>
    <url>%2F2018%2F04%2F21%2FPAT-B1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10^100。 输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。 输入样例： 1234567890987654321123456789 输出样例： yi san wu 题目代码： #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string s; cin &gt;&gt; s; string str[10] = { &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; }; int sum = 0; for (int i = 0;i &lt; s.length();i++) { sum += (s[i] - &apos;0&apos;); } string number = to_string(sum); for (int i = 0;i &lt; number.length();i++) { cout &lt;&lt; str[number[i] - &apos;0&apos;]; if (i &lt; (number.length()-1)) cout &lt;&lt; &quot; &quot;; } return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1001 害死人不偿命的(3n+1)猜想]]></title>
    <url>%2F2018%2F04%2F21%2FPAT-B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n%2B1)%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想： 对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式：输出从n计算到1需要的步数。 输入样例： 3 输出样例： 5 题目代码： #include&lt;iostream&gt; using namespace std; int main() { int n, num = 0; cin &gt;&gt; n; while (n != 1) { if (n % 2 == 0) n /= 2; else n = (3 * n + 1) / 2; num++; } cout &lt;&lt; num; return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT B</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长不下降子序列]]></title>
    <url>%2F2018%2F04%2F21%2F%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[在一个数字序列中，找到一个最长的子序列(可以不连续)，使得这个子序列是不下降(非递减)的。 分析：此题如若采用暴力的方法来解答，即对于每个元素有取或是不取两种选择，时间复杂度可以达到O(2^n)。 令dp[i]表示以A[i]结尾的最长不下降子序列长度(和最大连续子序列和问题一样，以A[i]结尾是强制的要求)。此时会有两种情况：一种是存在A[i]之前的元素Aj，使得A[j]&lt;=A[i]且dp[j]+1&gt;dpi,那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的不下降子序列(dp[i]=dp[j]+1)；另一种是A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS，此时的长度为1。则其状态转移方程为：dp[i]=max(1,dp[j]+1)(j=1,2,…,i-1&amp;&amp;A[j]&lt;A[i])，其边界条件就为：dp[i]=1(1&lt;=i&lt;=n)。其整体复杂度为O(n^2)。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;stdlib.h&gt; using namespace std; const int N=100; int A[N],dp[N]; int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;A[i]; } int num=-1; for(int i=1;i&lt;=n;i++){ dp[i]=1;//边界初始条件 for(int j=1;j&lt;i;j++){ if((A[i]&gt;=A[j])&amp;&amp;(dp[j]+1&gt;dp[i])){ dp[i]=dp[j]+1; } } num=max(num,dp[i]); } cout&lt;&lt;num; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列的和]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个数字序列A1，A2，…，An，求i,j(1&lt;=i&lt;=j&lt;=n)，使得Ai+…+Aj最大，输出这个最大的和。 分析：这个问题如若暴力来做，枚举i,j需要O(n^2)的复杂度，而计算A[i]+…+A[j]需要O(n)的复杂度，因此总的复杂度为O(n^3)。就算采用记录前缀和的方法(预处理S[i]=A[0]+A[1]+…+A[i],这样A[i]+…+A[j]=S[j]-S[i-1])使计算的时间变为O(1)，总的复杂度仍然有O(n^2)。 这里介绍动态规划的做法，复杂度为O(n)。令状态dp[i]表示以A[i]作为末尾的连续序列的最大和(这里的连续指的是从第一个元素开始)。其实所要求的最大和就是dp数组中的最大值。也就是说求dp[i]时，只要dp[i-1]小于零就舍弃前面的和，直接取A[i]的值作为dp[i]即可；而如果dp[i-1]大于零，dp[i]就等于dp[i-1]+A[i]。于是得到dp[i]=max(A[i],dp[i-1]+A[i])。而边界就是dp[0]=A[0]。 #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;algorithm&gt; using namespace std; const int maxn = 10010; int A[maxn], dp[maxn]; int main() { int n; cin &gt;&gt; n; for (int i = 0;i &lt; n;i++) { cin &gt;&gt; A[i]; } dp[0] = A[0];//边界 for (int i = 0;i &lt; n;i++) { dp[i] = max(A[i], dp[i - 1] + A[i]);//状态转移方程 } int k = 0; for (int i = 1;i &lt; n;i++) { if (dp[i] &gt; dp[k]) k = i; } cout &lt;&lt; dp[k]; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[1、动态规划的递归写法(记忆化搜索)：重点在于如何记录子问题的解，从而避免下次遇到同样的子问题时重复计算。以斐波那契数列为例： int F(int n){ if(n==0||n==1) return 1; else return F(n-1)+F(n-2); } 然而上述代码会涉及很多的重复计算，由于没有对中间计算的结果进行保存，实际复杂度会高达O(2^n)。这里通过开一个数组来对已计算出来的数据进行保存。 int dp[max]; int F(int n){ if(n==0||n==1) return 1; if(dp[n]!=-1) return dp[n]; else{ dp[n]=F(n-1)+F(n-2); return dp[n]; } } 这样可以将复杂度从O(2^n)降到O(n)。如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有重叠子问题。因此，一个问题必须拥有重叠子问题，才能使用动态规划进行求解。 2、动态规划的递推写法：其使用的计算方式是自底向上，即从边界开始，不断向上解决问题，直到解决了目标问题为止；而递归写法是自顶向下，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止。以经典的数塔问题为例 首先开一个二维数组array[i][j]对每层的数据进行存放，由于除第一层之外，每一层都至少会有一条重合的路径。不妨零dp[i][j]表示从第i行第j个数字出发到达最底层的所有路径中能得到的最大和。也就会有dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j]。这里把dp[i][j]称为问题的状态，把这个式子称为状态转移方程。数塔的边界是dp[n][j]==array[n][j]，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; const int maxn=1000; int array[maxn][maxn],dp[maxn][maxn]; int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=i;j++){ cin&gt;&gt;array[i][j];//初始化数塔 } } for(int i=1;i&lt;=n;i++){//边界 dp[n][i]=array[n][i]; } for(int i=n-1;i&gt;=1;i--){ for(int j=1;j&lt;=i;j++){ dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+array[i][j];//状态转移方程 } } cout&lt;&lt;dp[1][1]; return 0 } 如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么就称这个问题拥有最优子结构。因此，一个问题必须拥有最优子结构，才能使用动态规划进行求解。 3、两组概念的区分 (1)分治和动态规划 分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题。 (2)贪心和动态规划 贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程对数塔问题而言，贪心法从最上层开始，每次选择左下和右上两个数字中较大的一个，一直到最底层得到最后的结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶下下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，他总是会考虑所有的子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。所以贪心是一种壮士割腕的决策，只要进行了选择，就不后悔；动态规划则要看哪个选择笑到了最后。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1002 A+B for Polynomials]]></title>
    <url>%2F2018%2F04%2F13%2FPAT-A1002-A%2BB-for-Polynomials%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output Specification: For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 此题在一开始写的时候没有注意到当输出系数不为零的个数为0时的情况，故导致格式错误。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; using namespace std; int main() { double a[1001] = { 0.0 }, b[1001] = { 0.0 }, c[1001] = { 0.0 }; int m, n; cin &gt;&gt; m; for (int i = 0;i &lt; m;i++) {//初始化第一个多项式 int j; cin &gt;&gt; j; cin &gt;&gt; a[j]; c[j] += a[j]; } cin &gt;&gt; n; for (int i = 0;i &lt; n;i++) {//初始化第二个多项式 int j; cin &gt;&gt; j; cin &gt;&gt; b[j]; c[j] += b[j]; } int num = 0; for (int i = 0;i &lt; 1001;i++) {//计算系数非零的个数 if (c[i] != 0) num++; } cout &lt;&lt; num; if (num != 0) cout &lt;&lt; &quot; &quot;;//这里需要注意 for (int i = 1000;i &gt;= 0;i--) { if (c[i] == 0) continue; cout &lt;&lt; i &lt;&lt; &quot; &quot;; printf(&quot;%.1f&quot;, c[i]); num--; if (num != 0) cout &lt;&lt; &quot; &quot;; } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1001 A+B Format]]></title>
    <url>%2F2018%2F04%2F12%2FPAT-A1001-A%2BB-Format%2F</url>
    <content type="text"><![CDATA[Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification: Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output Specification: For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input -1000000 9 Sample Output -999,991 此题使用如下代码在PAT测试时出现一个段错误。如有大佬光临寒舍，还望多多指教。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;stack&gt; using namespace std; int main() { int a, b,sum=0; cin &gt;&gt; a &gt;&gt; b; sum = a + b; if (sum &lt; 0) cout &lt;&lt; &quot;-&quot;;//和为负数，就先把负号输出 sum = (sum &lt; 0) ? -sum : sum;//求绝对值 stack&lt;char&gt; s; int num = 0; while (sum) { s.push((sum % 10)+&apos;0&apos;);//从最低位开始入栈 num++;//统计sum中各个位入栈的个数 if (num % 3 == 0) s.push(&apos;,&apos;);//每当sum的位入栈三次，就把‘，’入栈 sum /= 10; } if (s.top() == &apos;,&apos;) s.pop();//如果全栈最顶为‘，’，则直接出栈 while (!s.empty()) { cout &lt;&lt; s.top();//输出栈顶元素 s.pop();//栈顶元素出栈 } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦境]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%A2%A6%E5%A2%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;夜里入梦，梦见自己投身于《生化危机》般的世界。从城镇到山峦，再到陌生的工厂。梦境中的自己一直在逃亡，恐惧、杀戮和死亡如影随形。梦醒时分，才知是梦，但梦境确是异常清晰与真实，仿佛现实般存在。或许是由于这段时间的压力所带来的反应，不知怎的，觉得这样的感觉很好。似乎是压力释放的一种方式，人在极度的恐惧当中，往往会表现出最本真的自己，没有压抑也没有伪装。人需要有所畏惧，有所敬畏，生于忧患，死于安乐。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1053 Path of Equal Weight]]></title>
    <url>%2F2018%2F04%2F08%2FPAT-A1053-Path-of-Equal-Weight%2F</url>
    <content type="text"><![CDATA[Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L. Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1. Input Specification: Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt;= 100, the number of nodes in a tree, M (&lt; N), the number of non-leaf nodes, and 0 &lt; S &lt; 230, the given weight number. The next line contains N positive numbers where Wi (&lt;1000) corresponds to the tree node Ti. Then M lines follow,each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00. Output Specification: For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &lt;= k &lt; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 &gt; Bk+1. Sample Input: 20 9 24 10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2 00 4 01 02 03 04 02 1 05 04 2 06 07 03 3 11 12 13 06 1 09 07 2 08 10 16 1 15 13 3 14 16 17 17 2 18 19 Sample Output: 10 5 2 7 10 4 10 10 3 3 6 2 10 3 3 6 2 题目大意：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的静态写法和遍历]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%A0%91%E7%9A%84%E9%9D%99%E6%80%81%E5%86%99%E6%B3%95%E5%92%8C%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1、存储结构 由于普通树的子节点的个数不定，所以使用指针域的方式不妥(需要在结构体中定义最大子节点数的节点类型的指针个数)。故使用静态写法，用数组下标来代替所谓的地址。虽然也需要在结构体中定义子节点的下标作为指针域。但可以使用STL中的vector容器进行动态分配。 struct node{ typename data;//数据域 vector&lt;typename&gt; child;//指针域，存放所有子节点的下标 }Node[maxn];//节点数组，maxn为节点的上限个数 2、新建一个节点 int index=0; int newNode(int x){ Node[index].data=x;//数据域为x Node[index].child.clear();//清空子节点 return index++;//返回节点下标，并令index自增 } 3、先根遍历 void preOrder(int root){ cout&lt;&lt;Node[root].data&lt;&lt;&quot; &quot;;//访问当前节点 for(int i=0;i&lt;Node[root].child.size();i++){ preOrder(Node[root].child[i]);//递归访问节点root的所有子节点 } } 4、层序遍历 void LayerOrder(int root){ queue&lt;int&gt; q; q.push(root);//根节点入队 while(!q.empty()){ int now=q.front();//取队首元素 q.pop();//队首元素出队 cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域 for(int i=0;i&lt;Node[now].child.size();i++){ q.push(Node[now].child[i]);//将当前节点的所有子节点入队 } } } 如果需要计算每个节点的层次，存储结构和层序遍历如下： struct node{ int layer; typename data; vector&lt;typename&gt; child; } void LayerOrder(int root){ queue&lt;int&gt; q; q.push(root);//根节点入队 Node[root].layer=1; while(!q.empty()){ int now=q.front();//取队首元素 q.pop();//队首元素出队 cout&lt;&lt;Node[now].data&lt;&lt;&quot; &quot;;//访问当前节点的数据域 for(int i=0;i&lt;Node[now].child.size();i++){ Node[Node[now].child[i]].layer=Node[now].layer+1;//子节点的层数加1 q.push(Node[now].child[i]);//将当前节点的所有子节点入队 } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平水韵(入声)]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%B9%B3%E6%B0%B4%E9%9F%B5(%E5%85%A5%E5%A3%B0)%2F</url>
    <content type="text"><![CDATA[1、一屋竹 屋 谷 目 木 熟 菊 腹 哭 服 肉 独 福 速 逐 禄 鹿 麓 肃 轴 牧 宿[住宿] 卜 陆 六 族 筑 毂 祝 沐 斛 馥 穀 犊 掬 缩 築 牍 叔 读[读书] 粥 簇 蹙 复[往来也，返也] 育 秃 覆 碌 復 伏 穆 渎 戮 淑 蓄 縠 矗 扑 幅 镞 菽 漉 竺 燠 蓿 蔌 撲 瀑 曲[酒曲] 簌 椟 睦 鵩 鞠 鹜 觫 蹴 簏 蝠 黩 郁 霂 塾 澳 谡 夙 辘 餗 麴 恧 仆[群飞貌] 畜 榖 衄 洑 濮 蔔 槭 樕 毓 辐 朴 複 孰 匊 倏 浊 舳 醭 讟 樸 輻 鬻 僇 煜 角 蝮 稑 暴[日乾也] 箙 昱 彧 槲 曝 啄 鞫 朒 盝 韣 匐 睩 琭 龊 蓼 蹜 滀 毣 忸 鵴 瀫 俶 踧 袱 鹔 柷 澓 髑 輹 柚 搐 摝 瘯 慉 殰 鏕 碡 副[剖也，判也，裂也] 囿 菔 茯 薁 剭 螰 苜 踀 喌 嘼 蔟 虙 趚 骕 蹗 鱐 楅 贕 鵚 簶 閦 噈 缪[与穆同] 稢 虪 穋 觳 朷 告 葍 腛 勠 鋉 瑴 縬 濲 摍 藗 焀 蓛 熇 遬 汋[激水声也] 蹼 唷 唂 橚 趢 儥 蜟 拲 娽 坶 蔛 涑 樚 鶝 踾 跾 豖 匑 翏 錥 圥 鴔 趗 栜 棴 鮛 楘 蚞 襡 艒 纀 蕧 栿 獛 熝 嬻 躹 鵱 蔍 茿 剹 諔 踿 喐 韇 蓫 沑 鱁 蟏 梀 惐 梮 皾 莥 逳 箼 荲 騼 宓 騳 驧 潚 畐 斀 稪 萺 莤 玊 哊 鉐 鵦 癁 鉃 粶 丵 焂 埱 坴 襆 敊 涋 粷 喅 蓻 鱳 瓄珿 軮 鳆 踓 剢 犕 鑟 蔋 椈 嗀 聏 琡 鞪 鏉 蘛 鼀 疛 巈 淕 絥 鄜 齱 璛 淯 璹 樢 婅 蒮 斣 穙 鍙 趜 雮 偪 阿[阿谁] 疁 骲 篴 媨 罜 殐 掓 稶 嚛 磩 槒 膔 栯 礇 炑 鄐 鳪 轐 殧 塶 螜 閰 媉 棛 篫 諨 摵 椱 砡 樎 鎐 誎 垘 苖 婌 泦 椂 鐭 攴 堉 嗖 鯥 觷 觻 其它僻字： 䘵 䩮 䮷 䱙 䎘 䍡 䉛 䃤 䛢 㳤 㰗 㜚 䞱 䃙 㕰 㰲 㓘 䑿 㚆 䫝 㽤 㥔 䙒 㶖 䜡 㲫 㩋 㧅 䟿 䥮 䘻 㓐 䢱 䟟 䋭 䢗 㑉 䗇 䴪 䇚 䃞 㪩 䑁 䔎 㦇 䊾 䄾 䘐 䋹 㜙 㮋 䏋 㗤 㤢 䗛 㥌 䶊 䪁 㠅 㣎 㜅 㬼 䐨 㼾 䧤 䎌 䡜 䕮 䈸 䜯 䫳 㾄 䃚 㘲 䏱 㝛 䨱 䵈 㾥 㻃 㒔 䪕 䟮 䌒 䎼 㖨 㴼 䮱 䳱 㡔 㵀 䨹 㞺 䞽 㑐 㛬 䙯 㪶 㯟 䤋 㙏 䗱 䚼 䎑 㯈 㜈 䛙 䜼 䱡 䐿 㑛 㯷 䐁 䀰 㣃 㷤 㺉 䀲 㹼 㪖 䖡 㽇 㾇 㞘 㬘 䇍 㦽 𨌥 𪇰 𥪋 𪘏 𩶫 𠱙 𩋟 𣖫 𡡐 𧼭 𣨍 𩑒 𥲒 𥉑 𥳇 𡰿 𪃃 𣤶 𦪇 𤞞 2、二沃绿 玉 俗 烛 足 续 粟 束 促 辱 局 鹄 躅 欲 录 蜀 触 毒 浴 狱 旭 瞩 箓 属 酷 渌 醁 笃 沃 曲 赎 褥 斸 勖 督 嘱 溽 梏 缛 鹆 纛 菉 騄 蠋 蓐 瘃 峪 趣 牿 顼 仆 鄏 幞 裻 告 挶 鳿 喾 襮 歜 輂 斶 锔 鋈 逯 藚 媷 臅 虑 憟 匤 熇 臛 旮[同旭] 蛐 欘 趢 犦 哫 灟 拲 娽 傉 彳 鸀 駶 軉 筁 蝳 蠾 趗 髷 镤 薥 鋊 脨 砡 檋 琟 輍 頶 俈 捁 泶 斀 珛 钃 搙 潥 隺 絭 悎 觷 螸 傶 襡 钰 洬 嚛 錊 噣 孎 錖 誎 嗕 斣 襆 疁 梮 捒 蔋 鶮 其它僻字： 䠱 䪅 㯮 㒒 䒼 䟉 㮂 䥔 䌚 㙇 䞖 䶜 䎤 䌵 䜹 㻿 䞝 䧊 䕽 䙱 䐂 䳔 䡞 䚄 䑑 䅶 䋰 䚛 䛤 㫽 䱚 䴰 㩴 䴆 㿥 㔄 䧼 䅇 㦺 䈞 𤌍 𧰵 𧛔 𩌮 𤞞 3、三觉学 岳 朔 幄 渥 角 濯 邈 握 璞 剥 觉[知觉] 琢 确 卓 壳 雹 擢 鷟 槊 斲 荦 捉 驳 浊 喔 啄 榷 桷 数 [频数] 朴 駮 灂 诼 乐[音乐] 龊 樸 埆 搉 啅 镯 较 倬 珏 戳 鸑 涿 翯 鸴 跑 桌 踔 娖 鸐 硞 峃 椓 擉 药 浞 謈 悫 搦 碻[同确] 鋜 豰 懪 穱 欶 爆 瞀 瓝 偓 瑴 韄 嚗 傕 箾 穛 噣 眊 觳 搠 斠 斮 龌 掿 捔 趵 礐 蒴 烞 晫 洬 嗍 鵫 墣 蠗 窇 鞄 籗 瓁 悎 瞐 鞪 皃 汋 隺 鎙 劰 燢 豿 娕 礭 仢 欘 韷 泶 飑 矠 骲 楃 斀 丵 瞨 墧 鳆 硺 觷 腛 燩 棹[树 枝 直 上 貌] 钋 鑡 簎 菿 龏 敩 攴 顜 齺 篧 捳 髉 琸 珿 犦 籱 搻 壆 鳪 媉 齱 殐 其它僻字： 㧻 㲉 㩧 䃗 䓎 㙾 㰌 㓸 䂍 㮶 㼎 䈏 䑈 䁷 㰒 䃕 䪨 㔬 䮸 㱿 䦠 㙸 㺪 㹒 㿺 㺟 㪬 䇶 㱋 㹊 䨌 㴶 䡈 㦝 䥤 䮓 㵡 䥃 䠎 𥢔 𢁁 𩣡 𪑱 𦢊 𥭖 𢷏 𩺽 𥭓 𧲐 𧞐 𤓊 𧣚 4、四质日 笔 室 一 失 密 术 实 術 疾 逸 律 毕 匹 膝 出 帙 漆 栗 溢 诘 七 橘 必 述 秩 吉 蜜 恤 瑟 乙 质 栉 秫 虱 蟀 荜 悉 慄 黜 弼 叱 潏 嵂 嫉 汩 朮 谧 戌 昵 窒 篥 镒 率 侄 怵 锧 骘 壹 卒[终也] 筚 绌 节 佚 苾 鹬 轶 跸 驲 茁 抶 桎 唧 姪 崒 獝 繂 沭 疋 韠 遹 繘 泆 罼 鳦 袐 铚 衵 蟋 凓 飋 聿 飶 霱 咥 蒺 袟 蔤 沏 泌 鴥 蛭 佾 訹 珌 妷 挃 鞸 礩 厔 耴 尼[近也，止也] 茟 肸 熚 觱 堲 翐 紩 桼 傈 瀄 踤 窋 姞 駜 溧 晊 帅 捽 矞 佶 拮 鷅 銊 馝 璱 饆 佖 荗 膟 鴄 眣 瓆 鬻 摔 圪 咭 沕 疙 宓 蛣 滭 枇[枇杷] 鉥 郅 鹎 銡 楖 怸 螲 怭 铋 滗 趌 黢 鱊 痆 窸 齣 滵 柣 庢 呹 箻 鷝 秷 峚 狤 珬 欪 祑 胵 螏 逫 蠠 秖 抳 塛 榓 跮 恎 絉 鮅 欰 炢 咰 趉 袕 揤 浂 擳 銉 肷 柫 衹 眰 比[比次也] 鏎 腟 僁 焌 搮 恄 箤 燏 鴓 笜 怷 麜 臷 鲒 豑 犵 臸 秪[与秖通，适也] 蝍 詄 瑮 郆 縪 妼 琗 寽 祇[适也，仅仅也] 嬄 宲 鶐 炪 鴶 邲 祗[与祇通，适也] 胇 欥 洷 柒 暨 彃 淧 樒 膣 魓 槉 鞊 櫍 驈 蹫 欯 釰 芛 其它僻字： 䫻 䁥 㗚 䘌 䭿 䬆 䟆 䎉 㘉 㾁 䮡 㔕 㯃 䢖 䫕 㵥 䮇 㪤 㺩 㻎 䒤 䏘 䑇 㓖 䶡 䵒 䢞 㗧 䬹 㻫 䬛 䳳 㟳 䔁 䩛 䢦 㚕 㣟 䬄 䣛 㴵 㮿 㜱 㜼 䱃 㑁 㤕 䢤 㞊 㫘 㣰 䄶 㻶 䔞 㳑 䌏 䡃 㧒 㢶 䤎 㳚 㰵 㗭 㘍 㳼 㮚 䱣 䟈 䏄 䆝 䘤 㔑 㢸 䜉 䳀 䰬 㺷 䋖 䜠 㳴 䖩 㻭 䵑 䢕 㗌 䟣 䤉 㖅 㑵 㲺 㤜 𥠈 𪗨 𥣮 𡢑 𧾣 𧫤 𧗿 𦝭 𦳯 𧽻 𢘍 𧾢 𩋡 𪗻 5、五物物 佛 屈 拂 绂 乞 黻 綍 勿 绋 祓 诎 郁 讫 屹 茀 韨 倔 黦 咈 弗 歘 怫 髴 芴 欻 仡 蔚 刜 沕 崛 不[与弗同] 吃[言蹇难也] 掘 熨 岪 汔 迄 坲 镼 釳 厥[突厥] 魆 肸 艴[色怒也] 尉 岉 沷 菀 昒 忔 鶌 粅 灪 帗 炥 誳 鮄 芞 柭 爩 紑 嶏 蛂 昲 冹 莔 烼 袦 虳 柫 弡 翇 趉 伆 鉘 乀 砩 阢 笰 甶 芾 惌 其它僻字： 㗵 䘿 㭾 䏌 䎢 㷉 䵥 䭮 㐹 䖇 䁌 㻕 䒗 䰴 䛥 㪄 䞞 䠇 䞷 㠨 𠜾 𨧱 𧿳 6、六月月 发 發 骨 阙 没 髮 窟 忽 兀 伐 谒 袜 樾 钺 笏 粤 蕨 突 襪 渤 惚 歇 勃 殁 罚 筏 越 窣 曰 阀 蹶 柮 讷 卒[士卒] 屼 劂 橛 猝 獗 羯 杌 矻 矹 竭 卼 滑[乱也] 鹘 軏 腯 搰 咄 淈 垡 硉 蠍 崒 纥 揭 碣 汨 馞 撅 峍 蟨 核 掘 哕 刖 愲 狘 扢 凸 暍 孛 浡 嗢 堀 鷢 揬 悖 讦 捽 曶 榾 泏 扤 鳜 蚏 抇 阏 龁 抐 瞂 胐 麧 玥 蜶 匫 钀 莈 不 厥 崛 脖 唿 昒 饽 鹁 棁 囫 镢 犵 钠 腽 淴 怢 馉 艴 猲 蓇 桲 葧 椊 葖 稡 阢 昢 瘚 侓 馧[馧馞] 饳 蚎 荸 鈯 嶡 絗 縎 鼵 鶟 杚 枂 颰 冹 榲 趃 亅 埣 坺 顝 熓 怴 朏 籺 摕 侼 欮 堨 迌 趉 寣 揾 瞃 囝 憠 宊 殨 笜 舭 郣 捸 璏 抈 殟 橃 沷 熭 碿 藅 鋍 尳 湥 岄 垏 鍎 歾 琷 鍻 啒 瘟[心闷貌] 糏 哱 犻 貀 鼿 榲 挬 其它僻字： 㪍 䬂 䓤 䎳 㷎 㶿 䞘 䨚 䑔 䬍 䥟 䓛 㖀 㫚 䴯 䚝 㪐 䦍 䟠 㻠 䎀 䖓 䘚 䣹 㳷 㩿 㐳 䩐 㧾 㟑 䪬 㵐 㒴 䡇 䝆 䑢 㨡 䀜 䯇 䟜 㬞 䇅 䂗 䁫 㘺 㴾 䯿 䋐 䙠 䭯 㔜 㵠 䍪 䠈 㲞 㞽 㧮 㾶 㛘 㽾 䮩 䪲 㕹 㛲 𣔻 𩨳 𧉦 𩑡 𢷒 𢪏 𧽸 𩗓 𥝖 𪁽 𪘧 7、七曷阔 末 活 脱 渴 豁 钵 夺 闼 葛 割 沫 聒 抹 遏 拨 泼 达 括 秣 剌 跋 辣 魃 怛 萨 蝎 斡 轕 栝 撮 筈 挞 茇 躠 撒 捋 喝 頞 臈 鹖 敚 褐 鞨 掇 拶 鱍 粝 囋 喇 獭 钹 适[疾也] 鞑 靺 澾 髺 裰 妺 拔 阏 噶 剟 跶 曷 軷 毼 摋 袯 越 咄 蘖 哒 獦 呾 泧 嶱 酦 犮 胺 炟 胈 焥 荙 繓 鸹 捾 暍 鏺 丐 挖 轹 碣 捺 咱 叭 侻 饐 齾 妲 嶭 笪 齃 猲 瘌 鵽 蛞 蝲 敠 靼 嵑 濊 帓 枺 粖 姡 頢 攥 囐 揦 蟽 茉 鼥 癹 礤 萿 毲 秳 癶 莌 妭 頱 濣 趏 蛶 睕 柭 嬒 餲 炥 魩 秡 狚 冭 灒 懖 羍 磆 刽 洝 昩 橃 堨 坺 奯 鬝 匃 驋 攃 汰 痥 燤 螛 咹 幯 湏 颰 仴 鲅 蔎 眓 襊 橽 歇 馛 葀 佸 昲 噧 揧 鮵 啈 蹳 捝 炦 攋 抈 骱 皌 鶷 枂 砞 瓎 脟 懀 眜 其它僻字： 䌨 㔇 䯋 䡾 䴲 䅥 䍨 䟯 㦫 䄑 㳨 䁊 㸊 䒷 㓉 㵶 㿣 㞈 㕲 䫘 䏞 䟦 䶛 㻝 䟛 䢌 䄆 㵧 㣵 䦢 䯏 䵣 㧊 㒓 䣶 㶬 䯦 㮫 䣪 䱫 䦚 䈓 䕣 䃮 㿹 㣞 䖧 䳁 㵣 㺚 䱅 䯺 䳚 㞉 㖕 㭮 䣮 㩵 䬴 𡾲 𥻦 𣁳 𤁢 𤷈 𤫵 𦮀 𥽘 𨣱 𧘟 𩩲 𤸎 𠯑 𥄕 𥄗 𦤦 𩒲 𩢛 𠱥 𧙕 𤀤 𤃴 𣎵 𤿫 𪘼 8、八黠札 刹 八 察 辖 黠 轧 戛 杀 煞 刮 猾 哳 扎 恝 揠 瞎 秸 滑 圠 楬 拔 蚻 肭 擦 嘎 茁 嗗 窡 刷 齾 铡 妠 豽 扴 鬝 扒[刨，挖] 铩 稭 榝 螖 搳 颉 劼 娺 圿 秳 痆 帓 汃 鹘 帕 獭 捺 咶 刖 紥 鸹 錣 磍 鴶 擖 砎 捌 朳 哵 鶷 傄 礣 劜 窫 詙 鲒 聐 磆 柭 菝 詚 蠿 猰 颳 耫 捾 糪 忦 硈 揳 玐 骱 眣 摖 鱊 咭 閁 捖 帴 睰 釛 嗐 縖 袺 檫 趏 仈 歇 螛 袹 鵽 叭 釟 貀 其它僻字： 䀣 㗫 㓤 䕓 䝟 䦪 㮖 㔍 䴳 㓞 䫄 䀨 㨸 䃰 䶪 䱻 䯉 㑻 䓭 䥷 㭭 䦖 䵵 㪴 㕯 㳐 䚴 䂒 㺴 䆯 㔠 䤢 䰲 𡇼 𪙻 𤫶 𪆰 𪈟 𪇷 𦤙 𠝚 𥴭 𩮁 9、九屑雪 别 绝 灭 血 结 拙 热 穴 洁 铁 裂 列 烈 缺 辙 诀 杰 舌 悦 节 彻 说 设 屑 决 哲 冽 劣 咽[呜咽] 阅 切 澈 折 缬 阕 辍 孽 鳖 玦 瞥 窃 啜 鴂 爇 埒 绁 齧 垤 截 撷 挈 跌 耋 泄 掣 嵲 泬 谲 歇 撤 吷 糵 孑 涅 迭 餮 撇 亵 薛 蔑 洌 鐍 竭 抉 蕝 瓞 桀 惙 噎 拽 浙 卨 楔 臬 契 歠 闑 闭 絜 缀 蠛 僣 臲 褉 页 觖 襭 霓 篾 碣 绖 揭 捏 蹩 衊 凸 蘖 巀 昳 岊 媟 呐 驖 莂 隉 轶 緤 晢 颉 哔 楶 朅 蛚 禼 茁 趐 刷 掇 苶 嶭 焫 茢 捩 锲 揲 蜇 摰 咥 讦 蜺 渫 瘪 碟 拮 醊 棁 搣 疖 蠥 蠘 丿 锊 蛭 桔 鷩 橇 迾 趹 蛣 槷 偈 辥 悊 颲 幭 挒 嫳 棳 篞 馝 絬 准[颊权也] 覈 佚 批 褐 谳 姪 踅 憋 龁 帨 剟 咧 紒 屮 唰 瀎 詄 趔 硩 潎 蟞 奊 跮 蠽 咇 僪 蠮 蚗 爡 刔 襒 畷 蒛 蛥 嵥 糏 蔎 懱 芵 鐅 瞲 蛈 僁 醛 掜 蝢 逫 鱴 櫗 囐 藒 孓 赽 趃 袺 啘 蛂 鲒 胅 鈌 鴷 脟 敜 駃 蠿 齛 罬 烲 砓 栨 彆 蠞 夨 呭 滊 臷 幯 鱊 猰 揳 螲 聺 勶 镻 棙 潱 爄 摕 狤 迼 聅 鄨 笍 湀 洯 眓 攦 劽 坲 乴 鮤 朳 莭 恎 叕 靼 滐 粖 姴 趌 蛶 魝 痥 袕 郣 覕 炦 洇 捌 緳 瞮 尐 榝 稧 柭 妜 蛞 擳 栵 諁 籺 蛪 歽 矞[同谲] 詍 睙 搩 靾 炔 眣 蜹 疶 敠 哾 桖 怢 戜 疀 麧 鑖 眜 苵 嵽 巁 眰 揊 炪 哷 坹 櫍 瘛 鴓 虌 徶 疦 馛 砄 毻 燤 櫭 菍 暼 娎 剈 翓 其它僻字： 㧙 㙞 䨮 䁾 䥫 䆷 㿱 䫾 㗧 䕵 䖦 䚢 䞵 㴮 㛃 㬯 㔢 㴪 䇷 㩪 㴽 䌩 㝂 㲳 䫎 䘊 㘿 㓭 䅀 䭇 㯙 㳿 䋉 䂼 䒸 㮮 䌘 䂐 䳤 㭞 㓗 䙽 䩤 䦑 䪼 䆕 䊦 䱑 㸞 㩢 䦬 䊝 㖶 㢼 㸹 㤠 䯵 㐖 㨝 㬚 㭩 䮕 㭈 䩧 㖏 㔃 㔡 䍳 䫼 㦢 䆢 㘶 䟹 䛎 㹟 䠥 䋢 䤿 䏟 䭱 䝌 䟙 㔎 䘷 䒆 䘁 䓆 䨆 䏳 䟾 䞰 㼤 䀗 㣯 䩏 㒝 䏐 㕞 㸅 㓶 䈼 㞕 䥕 䏲 䲙 䐼 㽟 𡿖 𧤾 𢴲 𣧵 𠱕 𡿪 𧎩 𧧸 𩖶 𢗗 𢯳 𢲼 𥉓 𠻜 𥈾 𩠻 𨵪 𤊾 𩢾 𨆳 𥄎 𪏺 10、十药落 薄 鹤 阁 壑 寞 郭 托 酌 漠 泊 略 脚 雀 却 廓 昨 託 跃 洛 弱 缚 恶 鹊 作 萼 乐[哀乐] 约 诺 索 爵 削 钥 橐 络 着 博 错 箔 铄 著[同着] 藿 谑 箨 虐 柝 幕 灼 铎 嚼 礴 霍 怍 鹗 药 愕 瘼 烁 凿 屩 若 酢 籥 锷 讬[同托] 搏 酪 勺 崿 粕 噱 攫 杓 斫 度[谋也] 鳄 蠖 雘 彴 各 掠 莫 貉 涸 镬 谔 绰 疟 鄂 穫 瀹 垩 恪 珞 拓 笮 魄 摸 骆 膊 椁 爚 膜[肉膜] 箬 矱 扩 噩 萚 雒 玃 烙 缴 搁 堮 镈 蠚 泺 获 妁 遌 鞟 焯[明亮] 腭 龠 彍 泽[星名] 爝 格[树枝也] 獲 蒻 亳 钁 艧 饦 礿 礡 矍 醵 咢 襮 躩 蹻 跞 臛 镆 郝 硌 皭 霩 臄 篗 皵 臒 鑮 熇[与謞同] 踱 芍 岝 矐 郤 皬 轹 柞 嗃 煿 蒪 蒦 糳 悫 斮 汋 攉 靃 謞 欂 漷 戄 瞙 飵 鄀 汑 鄚 蝁 猎 躇[超也] 昔 琧 燋 暯 婥 厝 咯 逴 喏 胳 迮 鷇 貜 颚 犦 隺 鐯 瀖 碏 袼 嚯 鮥 猼 喥 彠 辵 婼 硸 袥 烵 凙 矆 楉 馲 鄗 峈 縸 沰 剒 胉 嚩 磭 馎 貈 嗼 杔 崞 毭 剫 笿 矌 犳 曤 鞒 踖 焲 櫎 蘁 偔 娋 莡 稓 慔 謶 蛒 仢 藃 莋 櫮 鎍 岞 秨 逽 魠 敫 覨 劐 斱 擆 狛 搻 鶸 彏 圴 嚛 鈼 撗 谻 櫡 湂 扚 葃 鑩 棤 檴 噋 矡 鱳 籱 溹 嫋[长貌] 擽 庹 庴 縒 矺 癋 妰 詻 嬳 龥 跅 仛 纅 铬 蹃 趞 蠼 鶮 鹱 茖 繑 禚 铂 墌 癨 塻 蠌 牔 鬕 婩 砟 檡 挄 鰝 苲 佫 侂 籗 渃 蘥 鸙 溺 其它僻字： 䋏 㟧 㠋 㹱 䨥 㜰 䱜 䭦 䮤 㓢 㸕 㒂 䧄 䖃 㦜 㦡 㿑 㦍 䨰 䎰 㬦 㚟 㤞 䎊 䖼 㕡 䌇 㸲 㪾 㗥 㨯 䶳 䪙 㮙 㨼 䨣 䈷 㴖 䅴 㘀 䣤 䖛 㩱 䝫 䂄 䚥 㷾 㲋 䁨 䯨 䫷 䧐 䟑 䶈 䶅 䠯 㖸 㬍 㓵 䁻 㤩 䥬 䛚 䀩 䥣 䗚 䌎 䐘 㰛 䣞 㕁 䅵 䲵 䮬 䬪 㤰 䍸 㱳 㗉 䙏 䐞 䰊 㗁 䇥 䇎 䅂 䤕 㷬 䂮 㑼 䧿 䈅 䖋 㖾 䖈 䋤 䐾 䞢 䢲 㗘 䉟 䄸 䨋 𦞦 𧎾 𧕋 𧍷 𧊜 𠶸 𥴮 𤻲 𢜭 𢱢 𪙍 𩌏 𨷲 𥽿 𠠎 𤄶 𤡯 𩍿 𧤽 𩟓 𧘑 11、十一陌客 白 石 迹 碧 夕 宅 尺 席 隔 策 惜 役 屐 陌 璧 益 伯 赤 癖 柏 窄 百 驿 剧 脉 辟 戟 翮 隙 迫 掷 液 僻 责 麦 昔 释 舄 积 额 厄 泽 册 帛 坼 易[变易] 逆 赫 革 籍 脊 择 拍 谪 帻 碛 掖 拆 魄 瘠 格 斥 腋 奕 擘 怿 绎 获 画[卦画也] 獲 索 磔 译 适 珀 射 舶 藉 汐 弈 檗 蹠 膈 硕 绤 鶒 蹐 啧 轭 貊 只 帼 炙 扼 赜 馘 螫 箦 骼 蜴 斁 穸 阨 唶 帟 摘 疫 划[划破] 埸 踯 襫 虢 蝈 峄 哑[笑声] 摭 核 刺[穿也，伤也] 奭 嚇 襞 腊 祏 覈[同核] 擿 咋 薜 摵 迮 栅 躄 亦 湱 擗 虩 霢 借 踖 磶 搦 蓦 穫 醳 鲫 嗌 槅 騞 嚄 剨 婳 峉 筴 鬲 阸 媳 掴 鹡 喀 塉 耤 齸 莫[静也] 齰 嗝 砉 蚱 潟 觡 圛 粣 鼫 翟 愬 鸊 啯 齚 撠 貘 睗 洦 呃[鸡声。] 霸[古与魄同] 謮 晹 縌 詻 橶 敀 滆 郤 霹 睪 胔 啪 哧 柞[除木] 硅 嘀 虴 徦 蛨 佰 礉 檡 塥 缂 礋 漍 乇 覤 鸅 墌 簂 皟 蕮 蚅 茖 腘 郄 舴 蹃 曎 襗 鐴 鉐 榒 帞 銆 雿 箣 鯣 躤 襀 垎 嗼 鲌 嵴 捇 擌 諽 庴 獈 砈 趞 膉 潪 枙 鳠 扸 鳽 杔 瞔 炈 疒 覞 歵 鈠 厏 頙 銏 犱 焃 檘 澅 燚 苩 岶 茦 蚸 拺 嚿 袹 臵 樍 讗 簎 諎 谻 呄 鰿 焟 楁 嬕 跅 丮 釽 铬 躆 蚇 眲 馲 坄 籷 狛 厝 慖 啋 脨 廦 焲 焬 熤 絔 啙 墿 糪 痬 棤 溹 矠 蠌 烢 凙 褯 聑 矺 鏼 棭 謋 獥 貖 洓 葃 泎 窢 莋 劐 掝 憡 聻 厇 礊 韄 嫧 燡 罊 雃 虉 挀 豛 胉 啇 蛒 瞁 煂 搩 瘷 揢 蒚 鶪 屰 焷 耫 碦 覛 豟 閴 其它僻字： 㶁 㗲 㫺 㡿 䘸 䇲 䵂 㧖 㽚 㛭 㦴 䐙 䶦 㥽 䄷 䘔 䃒 㮦 䩹 䳭 䕉 㼟 䐱 㟙 䳆 㩍 䂹 䊞 䘑 㮝 䱮 䛿 㜋 䜺 㑊 㹮 䟄 䬉 䮮 䂸 䐸 䳮 䁺 㡯 㝜 䨛 㘌 㣂 㖪 䮰 㩇 䡛 䧍 䌟 䕪 䭆 㘁 㦎 㠛 㿟 䙐 䈿 䖌 㗆 䰜 䪂 䚂 㭙 䤨 㿭 䲽 䞠 㶠 䣢 䨫 䖨 㣱 䁤 䦝 㴁 䭞 䊂 㳻 㵹 䦴 㼣 㒀 㾊 㦦 䞟 㴒 䂝 䞦 䪝 𠙆 𦒧 𡩡 𤗮 𤖼 𢅰 𤁰 𢓜 𩹺 𡄴 𦵪 𥬰 𡍩 𢮎 𢷾 𢼛 𢯹 𦌠 𢫦 𥆛 𪐏 12、十二锡壁 寂 笛 敌 滴 历 觅 激 戚 檄 绩 击 锡 的 雳 沥 砾 涤 觌 鹢 枥 镝 析 惕 狄 淅 荻 皪 羃 溺 栎 甓 晰 幂 籴 劈 阒 逖 剔 吃 迪 靮 嫡 皙 菂 觋 呖 趯 甋 瓅 霓 鵙 艗 幕 踢 篴 惄 适 轹 阋 汨[汨罗] 焱 郦 鴃 蹢 籊 殈 赥 鼊 摘 蜥 疬 樀 澼 轣 裼 鼜 鬲 倜 礰 緆 秝 翟 鼏 覭 簚 糸 吊 狊 坜 蚸 繴 薂 濗 砳 焃 霹 墒 砉 攦 踧 墼 悐 鶪 幦 虉 磿 幎 嚁 瓋 毄 焬 鐴 菥 譤 苈 塓 湨 鹝 啇 玓 馰 熐 釽 漃 憵 鱳 纅 扸 樍 撽 儮 苖 爏 讈 扚 欫 椺 墑 漞 趘 冖 仢 儥 銢 頔 轚 燩 覛 硩 礕 靋 觻 磩 镉 肑 綼 糑 惁 敫 蒚 犑 獥 婥 蓨 蓧 瞁 歒 廦 鸄 虳 郹 鼳 鄓 蔋 擽 盢 梑 其它僻字： 䍥 䍽 㰅 㭊 䓇 䢮 䥶 䤙 㿨 㣙 䟐 䤨 䢰 䚫 㤸 㢩 䴞 䨤 䵠 㻺 䗩 䣓 䮥 㲻 䂆 䖑 䔉 㦘 㹍 㒪 䳬 䁶 㔏 䮭 㬏 䞶 䚐 㛫 䰛 䑀 㱤 䈪 㱹 䌐 㽁 䨀 㱸 㺡 䚍 䟏 㷴 䯜 𪒄 𦸗 𣒃 𡫁 𣤢 𥍧 𥍠 𥍟 𠴫 𣤩 𥛚 𤄎 𦵦 13、十三职色 得 息 国 力 极 翼 侧 直 黑 忆 墨 域 识[知识] 测 棘 职 臆 贼 刻 食 逼 北 恻 默 德 饰 勒 惑 稷 特 则 即 拭 织 蚀 仄 匿 陟 穑 亿 塞[闭塞] 式 植 抑 殖 敕 亟 克 弋 熄 肋 昃 忒 慝 蜮 轼 饬 啬 踣 阈 泐 殛 嘿 洫 翊 薏 赩 湜 纆 僰 屴 杙 愊 寔 崱 裓 墄 匐 罭 愎 嶷 偪 螣[螟螣] 剋 埴 尅 棫 襋 衋 劾 唧 轖 淢 湢 遫 扐 蠈 緎 淂 蟘 幅 或 恧 荝 栻 鷘 鲗 翌 畟 副 仂 餩 醷 侐 釴 鲫 腷 繶 竻 膱 芅 癔 瀷 蒠 淔 稄 戫 蟔 稙 樴 堲 蝍 菔 犆 趩 堛 掝 蕀 蛡 忑 嫟 恜 瘜 黓 楅 冒 蘵 惐 腘 赲 嘚 稫 脦 煏 玏 戠 溭 穓 鉓 遈 棏 蔷 烒 鶝 艒 鲾 禃 潩 捗 畐 霬 噫 皕 嫼 皀 嬂 謋 琙 捑 骮 揤 蚮 爅 熤 踾 浳 螚 蟙 鳨 釛 澺 垘 鄎 氻 潶 艻 閄 朸 臸 忇 諽 檍 焏 悈 窢 茍 烅 嚜 鉽 侙 殕 懎 慗 揊 熼 鳓 阞 懝 繬 其它僻字： 㳁 㥾 㚤 㘈 䰥 䁿 䈟 㔴 䵗 䘃 㤫 㮩 㥂 㱇 䄩 䐚 䙷 䯆 䁼 䅞 䧗 㕵 䘅 㯤 䵱 㞃 䬎 㝶 䱛 䭒 㢞 㭲 㷵 㻷 䗷 䞳 㱄 䐈 䖁 㘠 㹄 䩯 䘝 㧹 㥁 䴬 㷶 㽣 㔹 㴧 䦗 㚜 䣧 䎪 䮙 㫯 㥛 㯰 㥀 㥶 䮠 䦼 㮨 㵓 䁇 㞋 䉢 䆐 䤭 𪀦 𧏾 𤜜 𡍫 𥇛 𪂉 𤗚 𩋉 𪑝 𥇙 14、十四缉急 立 入 湿 集 泣 及 邑 十 涩 拾 蛰 习 笠 粒 汲 给 吸 袭 揖 什 级 执 隰 挹 絷 汁 戢 葺 岌 浥 缉 辑 悒 翕 熠 笈 伋 楫 噏 濈 歙 裛 潗 唈 蕺 槢 廿 潝 霫 芨 霵 钑 褶 啃 漐 苙 鳛 湆 礏 飁 雭 圾 煜 闟 砬 歰 熻 鵖 湁 俋 咠 卙 慹 鷑 譅 雴 骉 彶 箿 礘 叺 瓡 岦 鴔 鏶 偮 翜 釞 淁 趇 騽 喅 鴗 蓻 謺 嶯 漝 皀 嬆 湒 譶 馵 鉝 孴 卌 諿 其它僻字： 䏉 㴕 㦻 㤂 㙷 㪧 䦹 㠍 䁯 㬛 㵫 䔼 㴔 䶘 䶋 㗊 䩰 䮶 䏠 㲸 㽺 䓃 㣬 䒁 䭂 䉗 㡮 㧀 㱞 㙫 㘊 㿇 䏩 㬤 㗱 䐕 㒊 䇼 䅤 㒆 䲯 䔱 㕸 䙄 㞚 㩉 㞏 㗩 䁒 𧤏 𩆭 𧚨 𩾳 15、十五合合 榻 塔 答 杂 阖 衲 匝 纳 飒 榼 閤 踏 沓 蛤 鸽 盍 遝 荅 塌 蹋 盒 搭 鞳 拉 腊 蜡 帀 蒳 靸 漯 嗑 趿 嗒 噆 鎝 咂 阘 遢 剳 卡 溘 誻 匌 嚃 拓 馺 罨 镴 搕 唈 韐 岋 濌 褟 涾 耠 軜 盖 卅 磕[石声] 哈 瘩 碜 褡 嘁 鲽 瞌 钑 欱 狧 耷 錔 鮯 鞜 鳎 匎 溻 颌 歞 砵 菈 鰪 砐 匒 傝 崉 雥 囃 詥 溚 篕 魶 峇 鉔 峆 鑉 譶 痷 魳 罯 磼 畗 魼 圾 鞥 矺 抸 廅 毾 礘 佮 砝 魥 熆 笚 鎉 翋 龖 儑 姶 磖 拹 笝 殧 柆 铪 硆 厒 榙 枼 韴 遪 其它僻字： 䬃 䕹 㔩 䑽 㷈 㗳 䗶 䑥 䂰 䗘 䍇 㛥 䐦 㹺 㧁 㯓 䵬 㕇 䈳 䌈 䐛 䂿 䪏 䧻 㿯 䵽 㕉 䫦 䈫 䈋 䑜 䃳 䶁 䍝 䪞 㕎 㨥 䶀 䙣 䳴 㭼 㠷 㧺 㥺 䢔 䪺 㛕 㾑 䜚 㿴 㽂 䨿 䑪 㝓 㯚 䪚 䞙 㚫 䓠 㰰 䆟 㡴 𩣯 𪘁 𩋊 𨅔 𥁋 𣣹 𦑶 𤎞 𨜴 𤸱 𩎕 𢕬 𧪞 𢶍 𨃚 𡄋 16、十六叶叶 葉 接 蝶 叠 捷 涉 帖 箧 惬 颊 堞 妾 铗 侠 睫 鬣 牒 靥 浃 屧 蹑 荚 协 摄 贴 慑 燮 挟 楫 馌 烨 摺 镊 躞 谍 晔 猎 蹀 捻 辄 跕 嗫 氎 躐 詟 艓 擪 屟 褶 褋 惵 梜 怗 聂 箑 裛 衱 喋 呫 韘 苶 楪 折 炸 笈 籋 襵 歙 鞢 鍱 魇 霎 厌 婕 偞 菨 崨 倢 椄 讘 欇 筴 邋 鲽 熀 蛱 擸 颞 儠 擛 踥 牃 踕 謵 緁 僷 滠 犣 聗 鎑 錜 銸 徢 惗 穕 帹 蠂 痷 鱲 脻 迠 萐 敜 慹 綊 謺 鮿 鯜 埝 挕 踂 瞱 淁 瞸 獦 鑈 聑 褺 鏶 昅 揞 巤 煠 疌 踗 劦 誱 寁 唊 蓻 枼 殜 霅[霅霅，震电貌] 帇 蓵 渫 其它僻字： 㲲 㫸 䩞 䈉 䐑 䌖 㱌 䢡 䳖 㪑 䁋 䜆 䝃 䵿 㩎 䇣 䜲 䝱 䐲 㸎 䧪 㡇 㬪 㢵 䤮 䪓 㤴 㥈 䴑 㥦 䪉 㴇 䭟 㢎 㩸 㯿 䯀 㤐 㰼 㭯 㳧 㙷 㚔 䛟 䝓 䈎 䜓 䌰 㑙 㾜 㚲 㼪 㩶 㼲 䌌 㤲 㰔 㒤 䠟 䁽 㨩 㷸 㛍 㽊 䝕 䴴 䥡 䌜 𣶏 𦣀 𢬴 𦔮 𤍞 𪑧 𦀖 𤑻 𣀳 𨓊 𪔪 𩣘 𤗽 𦔼 17、十七洽业 法 甲 劫 峡 怯 洽 匣 压 狎 乏 鸭 插 狭 锸 嶪 夹 闸 押 袷 柙 帢 唼 歃 掐 劄 呷 恰 裌 翣 胛 硖 邺 霎 陜 霅 箑 嗋 祫 眨 跲 啑 郏 恊 鵊 扱 凹 胁 鞈 搯 熁 玾 喋 愶 筴 岬 胠 葜 烚 渫 擖 姂 庘 哈 钾 萐 嚈 魻 圔 喢 蜐 饸 譗 姶 湆 魥 鉣 驜 呿 翜 韐 疀 笚 埉 厒 笝 煠 殗 搚 痷 铪 唊 欱[与歃同。尝也] 翈 昅 磼 曱 珨 鸈 魼 歰 嶯 澲 砝 疺 圶 抾 帹 炠 筪 拹 殜 餣 舺 殎 垥 偛 其它僻字： 䶎 㡊 㰱 䬊 䆘 㭘 㵊 㕅 㛼 㳌 䖎 㡋 䎎 䛅 䨐 䧨 䕛 䤶 䛽 㘝 㹤 䂲 䮢 㗼 㽠 䞩 㾀 㙝 㴙 㮑 䱒 䀴 㓣 䮜 䖖 䀷 䀫 䩡 䘥 䲜 㘡 㾎 䁆 䁍 㑢 㿓 㸣 㵤 䶝 㭱 㷅 𢘉 𣣲 𩌍 𢂷 𤴼 𠗨]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1020 Tree Traversals]]></title>
    <url>%2F2018%2F04%2F07%2FPAT-A1020-Tree-Traversals%2F</url>
    <content type="text"><![CDATA[Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification: For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input: 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 Sample Output: 4 1 6 3 5 7 2 题目大意：给出二叉树的后序和中序序列，输出这棵二叉树的层序序列。(所有的二叉树节点的数据都是互不相等的正整数) 分析：根据二叉树的后序和中序序列可以重建二叉树，再对重建好的二叉树进行层序遍历。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;queue&gt; using namespace std; struct node {//二叉树的存储结构 int data;//数据域 node* lchild;//指向左子树根节点的指针 node* rchild;//指向右子树根节点的指针 }; node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树 if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空 node* root = new node;//新建一个节点，用来存放当前二叉树的根节点 root-&gt;data = post[postR];//新建节点的数据域为根节点的值 int k; for (k = inL;k &lt;= inR;k++) { if (in[k] == post[postR]) {//在中序序列中找到根节点 break; } } int num = k - inL;//左子树的节点个数 //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1] root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针 //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR] root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针 return root;//返回根节点地址 } int n; int j=0; void layerorder(node* root) { queue&lt;node*&gt; q;//存储节点地址的队列 q.push(root);//根节点入队 while (!q.empty()) { node* now = q.front(); q.pop();//将队首元素出队 cout &lt;&lt; now-&gt;data;//访问队首元素 j++; if(j&lt;n) cout&lt;&lt;&quot; &quot;; if (now-&gt;lchild != NULL) q.push(now-&gt;lchild);//如果左子树不空，将左子树入队 if (now-&gt;rchild != NULL) q.push(now-&gt;rchild);//如果右子树不空，将左子树入队 } } int main() { cin &gt;&gt; n;//输入二叉树的节点个数 int *in = new int[n];//new一个变长的int型数组 int *post = new int[n]; for (int i = 0;i &lt; n;i++) {//输入后序序列 cin &gt;&gt; post[i]; } for (int i = 0;i &lt; n;i++) {//输入中序序列 cin &gt;&gt; in[i]; } int inL = 0,postL = 0, inR = n - 1, postR = n - 1; layerorder(create(in, post, inL, inR, postL, postR)); delete[] post;//释放内存空间 delete[] in; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由中序和后序序列输出先序序列]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%94%B1%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[先由二叉树的中序序列和后序序列重建这棵二叉树，然后再输出二叉树的先序序列。由后序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct node {//二叉树的存储结构 int data;//数据域 node* lchild;//指向左子树根节点的指针 node* rchild;//指向右子树根节点的指针 }; node* create(int in[], int post[], int inL, int inR, int postL, int postR) {//根据中序序列和后序序列重建二叉树 if (inL&gt;inR) return NULL;//如果后序序列长度小于等于0，直接返回空 node* root = new node;//新建一个节点，用来存放当前二叉树的根节点 root-&gt;data = post[postR];//新建节点的数据域为根节点的值 int k; for (k = inL;k &lt;= inR;k++) { if (in[k] == post[postR]) {//在中序序列中找到根节点 break; } } int num = k - inL;//左子树的节点个数 //左子树的后序序列区间为[postL,postL+num-1],中序序列区间为[inL,k-1] root-&gt;lchild = create(in, post, inL, k - 1, postL, postL + num - 1);//返回左子树的根节点地址，赋值给root的左指针 //右子树的后序序列区间为[postL+num,postR-1],中序序列区间为[k+1,inR] root-&gt;rchild = create(in, post, k + 1, inR, postL + num, postR - 1);//返回右子树的根节点地址，赋值给root的右指针 return root;//返回根节点地址 } void preorder(node* root) {//先序遍历二叉树 if (root == NULL) { return;//递归边界 } cout&lt;&lt;root-&gt;data;//访问根节点 preorder(root-&gt;lchild);//访问左子树 preorder(root-&gt;rchild);//访问右子树 } int main() { int n; cin &gt;&gt; n;//输入二叉树的节点个数 int *in = new int[n];//new一个变长的int型数组 int *post = new int[n]; for (int i = 0;i &lt; n;i++) {//输入中序序列 cin &gt;&gt; in[i]; } for (int i = 0;i &lt; n;i++) {//输入后序序列 cin &gt;&gt; post[i]; } int inL = 0,postL = 0, inR = n - 1, postR = n - 1; preorder(create(in, post, inL, inR, postL, postR)); delete[] post;//释放内存 delete[] in; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由先序和中序序列输出后序序列]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%94%B1%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E8%BE%93%E5%87%BA%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[先由二叉树的先序序列和中序序列重建这棵二叉树，然后再输出二叉树的后序序列。由先序序列可以得到二叉树的根节点，再在中序序列中找到此根节点即可区分出左子树和右子树的范围，递归以上步骤即可重建二叉树。完整代码如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct node {//二叉树的存储结构 int data;//数据域 node* lchild;//指向左子树根节点的指针 node* rchild;//指向右子树根节点的指针 }; node* create(int pre[],int in[],int preL, int preR, int inL, int inR) {//根据先序序列和中序序列重建二叉树 if (preL&gt;preR) return NULL;//如果先序序列长度小于等于0，直接返回空 node* root = new node;//新建一个节点，用来存放当前二叉树的根节点 root-&gt;data = pre[preL];//新建节点的数据域为根节点的值 int k; for (k = inL;k &lt;= inR;k++) { if (in[k] == pre[preL]) {//在中序序列中找到根节点 break; } } int numLeft = k - inL;//左子树的节点个数 //左子树的先序序列区间为[preL+1,preL+numLeft],中序序列区间为[inL,k-1] root-&gt;lchild = create(pre,in,preL + 1, preL + numLeft, inL, k - 1);//返回左子树的根节点地址，赋值给root的左指针 //右子树的先序序列区间为[preL+numLeft+1,preR],中序序列区间为[k+1,inR] root-&gt;rchild = create(pre,in,preL + numLeft + 1, preR, k + 1, inR);//返回右子树的根节点地址，赋值给root的右指针 return root;//返回根节点地址 } void postorder(node* root) {//后序遍历二叉树 if (root == NULL) { return;//递归边界 } postorder(root-&gt;lchild);//访问左子树 postorder(root-&gt;rchild);//访问右子树 cout&lt;&lt;root-&gt;data;//访问根节点 } int main() { int n; cin &gt;&gt; n;//输入二叉树的节点个数 int *pre = new int[n];//new一个变长的int型数组 int *in = new int[n]; for (int i = 0;i &lt; n;i++) {//输入先序序列 cin &gt;&gt; pre[i]; } for (int i = 0;i &lt; n;i++) {//输入中序序列 cin &gt;&gt; in[i]; } int preL = 0,inL = 0, preR = n - 1, inR = n - 1; postorder(create(pre,in,preL, preR, inL, inR)); delete[] in;//释放内存 delete[] pre; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的基本操作]]></title>
    <url>%2F2018%2F04%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1、二叉树的存储结构 struct node { typename data;//数据域 node* lchild;//指向左子树根节点的指针 node* rchild;//指向右子树根节点的指针 }; 2、新建一个二叉树节点 node* newNode(int n) { node* Node = new node;//申请一个node型变量的地址空间 Node-&gt;data = n;//节点权值为n Node-&gt;lchild = Node-&gt;rchild = NULL;//初始状态下左右孩子为空 return Node;//返回新建节点的地址 } 3、查找二叉树中节点数据域为x的节点，并将他们的数据域修改为newdata void search(node* root, int x, int newdata) { if (root == NULL) { return;//空树，死胡同(递归边界) } if (root-&gt;data == x) { root-&gt;data = newdata; } search(root-&gt;lchild, x, newdata);//往左子树搜索x search(root-&gt;rchild, x, newdata);//往右子树搜索x } 4、二叉树节点的插入(二叉树节点的插入位置就是数据域在二叉树中查找失败的位置) void insert(node* &amp;root, int x) { if (root == NULL) { root = newNode(x);//空树，说明查找失败，也即插入的位置(递归边界) return; } if (由二叉树的性质，x应该插在左子树) { insert(root-&gt;lchild, x);//往左子树搜索(递归式) } else { insert(root-&gt;rchild, x);//往右子树搜索(递归式) } } 这里的根节点指针root需要使用引用&amp;，这样才能直接修改原变量的值。与search函数不同的是，search函数中修改的是指针root指向的内容，而不是root本身，而对指针指向的节点内容的修改是不需要加引用的。一般来说，如果函数中需要新建节点，即对二叉树的结构做出修改，就需要加引用；如果只是修改当前已有节点的内容，或仅仅是遍历树，就不需要加引用。 5、二叉树的创建(其实就是二叉树节点的插入过程) node* create(int data[], int n) { node* root = NULL;//新建空根节点 for (int i = 0;i &lt; n;i++) { insert(root, data[i]); } return root;//返回根节点 } 6、二叉树的先序遍历(递归) void preorder(node* root){ if(root==NULL){ return;//递归边界 } cout&lt;&lt;root-&gt;data;//访问根节点 preorder(root-&gt;lchild);//访问左子树 preorder(root-&gt;rchild);//访问右子树 } 7、二叉树的中序遍历(递归) void inorder(node* root){ if(root==NULL){ return;//递归边界 } inorder(root-&gt;lchild);//访问左子树 cout&lt;&lt;root-&gt;data;//访问根节点 inorder(root-&gt;rchild);//访问右子树 } 8、二叉树的后序遍历(递归) void postorder(node* root){ if(root==NULL){ return;//递归边界 } postorder(root-&gt;lchild);//访问左子树 postorder(root-&gt;rchild);//访问右子树 cout&lt;&lt;root-&gt;data;//访问根节点 } 9、二叉树的层序遍历 void LayerOrder(node* root){ queue&lt;node*&gt; q;//队列当中存储的是地址 q.push(root);//将根节点地址入队 while(!q.empty()){ node* now=q.front();//取出队首元素 q.pop(); cout&lt;&lt;now-&gt;data;//访问队首元素 if(now-&gt;lchild!=NULL) q.push(now-&gt;lchild);//左子树非空 if(now-&gt;rchild!=NULL) q.push(now-&gt;rchild);//右子树非空 } } 如果需要计算每个节点所处的层次，二叉树节点的定义如下： struct node{ typename data;//数据域 int layer;//层次 node* lchild;//左指针域 node* rchild;//右指针域 } 此时的层序遍历为： void LayerOrder(node* root){ queue&lt;node*&gt; q;//队列当中存储的是地址 root-&gt;layer=1;//根节点的层数为1 q.push(root);//将根节点地址入队 while(!q.empty()){ node* now=q.front();//取出队首元素 q.pop(); cout&lt;&lt;now-&gt;data;//访问队首元素 if(now-&gt;lchild!=NULL){//左子树非空 now-&gt;lchild-&gt;layer=now-&gt;layer+1;//左孩子的层数为当前层数加1 q.push(now-&gt;lchild); } if(now-&gt;rchild!=NULL){//右子树非空 now-&gt;rchild-&gt;layer=now-&gt;layer+1;//右孩子的层数为当前层数加1 q.push(now-&gt;rchild); } } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(四)]]></title>
    <url>%2F2018%2F04%2F07%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[1、C++中的BSS、数据段、代码段、堆、栈(1)BSS(Block Started by Symbol)通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。 (2)数据段：数据段(data segment)通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 (3)代码段：代码段(code segment/text segment)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 (4)堆(heap)：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用free等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减) (5)栈(stack)：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 2、C++中的左值和右值在C中，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。通常等号左边表示引用，实质上就是内存地址。等号右边表示数据，从内存取的数据，直接给的数据，或者计算出来的数据。内存地址本身也是数据，也可以放到内存中。相当于C++中说的指针。因为等号左边表示地址，变量映射成地址值，也就等号左边不能是常数。 3、volatile关键字如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。当然了，volatile还能让你在编译时期捕捉到非线程安全的代码。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。以下是使用场景： (1)中断服务程序中修改的供其它程序检测的变量需要加volatile。 (2)多任务环境下各任务间共享的标志应该加volatile。 (3)存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。 *可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。 *除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。 *volatile像const一样会从类传递到它的成员。 4、枚举类型(1)定义：enum Suit { Diamonds, Hearts, Clubs, Spades };或enum Suit { Diamonds, Hearts, Clubs, Spades }a,b,c; (2)对于枚举类型来说，只定义了赋值运算符，没有为枚举定义算术运算。 (3)能够将枚举量赋给非枚举变量，因为枚举量是符号常量，赋值编译器会自动把枚举量转换为int类型。 (4)在不进行强制转换的前提下，只能将定义的枚举量赋值给该种枚举的变量，也就是说可以通过强制转换将其他类型值赋给枚举变量。 (5)可以显式的设置枚举量的值(指定的值必须是整数)，也可以只显式的定义一部分枚举量的值。 (6)未被初始化的枚举量的值默认比其前面的枚举量的值大1。当然，枚举量的值可以相同。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗词入门(二)]]></title>
    <url>%2F2018%2F04%2F05%2F%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、拗救(1)拗：不符合诗律的一般规律(出律了) (2)救：在拗的前提下调节平仄使音感和谐。 2、拗救的常见形式以下皆以五言作为例句进行说明，那么也就是说七言的后五字同样适用于这些情况。 (1)本句自救(准律句)：平平平仄仄=》平平仄平仄 例： 凉风起天末，君子意如何。 平平仄平仄，平仄仄平平。 根据诗律的原则，这里的“凉风起天末”句明显出律了。那么是“风”字出律还是“天”字出律呢？我们可以通过“君子意如何”句的平仄来判断。在这一联当中，对句的二四字的平仄为仄、平，那么就可以推出出句的二四字的平仄就为平、仄。也就是说是“天”字出律了(当仄为平时)，那么为什么明明“天”字出律了还会认为是对的呢？这种情况就是属于拗救中的本句自救。我们先来看一下出句的正确的平仄：“平平平仄仄”。这里有这样的规定：如果在诗的创作过程中碰到了“平平平仄仄”这种情况，可以使用另外一种格式，即：把五言的第三四字的平仄位置互换(七言当中第五六字的平仄位置互换)，此时规定五言的第一字必须用平声(七言的第三字必须用平声)，不再是可平可仄的，也就变成了“平平仄平仄”。我们可以发现，这种形式只能出现在出句当中(因为对句必须是押韵的，而近体诗当中是不能压仄声韵的)，同时又由于诗律中的相对和相粘原则，出句之中也只有两句才能出现这种情况。 若首字为仄，则是特例，初学者不建议使用。如：昔闻洞庭水(仄平仄平仄)。虽然说首字为仄的情况也是存在的，但毕竟与首字为平相比还是及其少见的。老杜虽是及其注重格律之人，但他活在格律成形的那个年代，那个时候的格律还是处于可以推敲的阶段，当然也就不能说他是错的。(这里只是希望初学者不要钻牛角尖，只要记住这种拗救的形式就行) 又例： 遥怜小儿女，未解忆长安。 平平仄平仄，仄仄仄平平。 何时倚虚晃，双照泪痕干。 平平仄平仄，平仄仄平平。 西望瑶池降王母(平仄平平仄平仄) (2)对句相救：出句第四字当平为仄时，对句第三字只能是平声。(但一定要保证出句是以仄声结尾) 例： 向晚意不适，驱车登古原。 仄仄仄仄仄，平平平仄平。 *在诗词当中，“不”字几乎可以说是只能为仄声。但也不是绝对的，当“不”字通“否”字时且作为韵脚时，它是平声的。如果它位于句中就一定是仄声。 同样，这里根据对句的平仄可以判断出，是出句当中的第四字“不”字出律了(当平为仄时)。此时，可以通过对句的第三字(此时必为平声)来救，也就是例句中的“登”字。按照“一三五不论”的原则，“登”字本是可平可仄的，但是在这种情况之下就只能为平声了。因为是出句由对句来救，所以这种情况只能发生在出句当中。 又例： 野火烧不尽，春风吹又生。 仄仄平仄仄，平平平仄平。 *吹字是可平可仄的，作名词的时候为仄声(歌吹是扬州)，作动词的时候为平声。 3、“一三五不论”需要排除的三种情况(1)三平尾：在已经确定倒数第一和倒数第二字为平声的情况之下，如果仍然令倒数第三字为平声的话，就会变成“平平平”。三平尾是写诗的大忌。 (2)三仄尾：在已经确定倒数第一和倒数第二字为仄声的情况之下，如果仍然令倒数第三字为仄声的话，就会变成“仄仄仄”。三仄尾也是写诗的大忌。 (3)孤平：就是“仄平仄仄平”。孤平同样是写诗的大忌。这里可以将第三字改为平声来补偿，以免犯孤平。 4、根据平仄判断律句，若非律句再判断是否可救的步骤(1)先判断二四六字是否是平仄交替的。如果是则说明暂时是一个律句，进行第二步；否则说明此句不是一个标准的律句，进行第三步。 (2)是否出现了三平尾、三仄尾或者是孤平。如果出现了其中一种，则必定是错误的。若没有，则说明是可以用的。 (3)判断是否符合拗救的两种基本形式。如果符合其中之一说明是可以用的；如果都不符合则说明是错误的。 5、作业如果是本句自救(准律句)，打半钩；如果是对句自救，则标记出其对句该如何。如果最终不符合格律则打叉，符合则打钩。若有学有余力，为正确的律句查找相应的诗句。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的问题整理]]></title>
    <url>%2F2018%2F04%2F05%2FMySQL%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、mysql共享锁和排他锁 (1)产生的原因：数据库上的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排它锁。 (2)共享锁也叫读锁，简称S锁，原理：一个事务获取了一个数据行的共享锁，其他事务能获得该行对应的共享锁，但不能获得排他锁，即一个事务在读取一个数据行的时候，其他事务也可以读，但不能对该数据行进行增删改。 (3)排他锁也叫写锁，简称x锁，原理：一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁(排他锁或者共享锁)，即一个事务在读取一个数据行的时候，其他事务不能对该数据行进行增删改。但是获取排他锁的事务是可以对数据进行读取和修改。 (4)设置共享锁：SELECT … LOCK IN SHARE MODE;设置排他锁：SELECT … FOR UPDATE; (5)对于select 语句，innodb不会加任何锁，也就是可以多个并发去进行select的操作，不会有任何的锁冲突，因为根本没有锁。 对于insert，update，delete操作，innodb会自动给涉及到的数据加排他锁，只有查询select需要我们手动设置排他锁。 2、MySQL几种备份方式 (1)逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。 优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。 缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。 (2)物理备份：直接拷贝mysql的数据目录。直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。 缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。 (3)双机热备份。mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备)。 优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。 3、数据库范式：一张数据表的表结构所符合的某种设计标准的级别 (1)第一范式(1NF) 在任何一个关系数据库中，第一范式(1NF)是对关系模式的基本要求，不满足第一范式(1NF)的数据库就不是关系数据库。所谓第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式(1NF)中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 (2)第二范式(2NF) 第二范式(2NF)是在第一范式(1NF)的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。第二范式(2NF)要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式(2NF)要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是消除了非主属性对于码的部分函数依赖。 (3)第三范式(3NF) 满足第三范式(3NF)必须先满足第二范式(2NF)。简而言之，第三范式(3NF)要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号(dept_id)、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是消除了非主属性对于码的传递函数依赖。 4、SQL语句优化 (1)应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 (2)应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 (3)很多时候用 exists 代替 in 是一个好的选择。 (4)用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过。 5、存储过程与触发器的区别 (1)触发器与存储过程非常相似，它是一种特殊类型的存储过程。触发器也是SQL语句集，他们都像是数据库中运行的方法。两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发(激活)执行。 (2)触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。 (3)触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。 6、union 与union all的区别 union 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。union all 则会显示重复结果,只是简单的两个结果合并并返回.所以效率比union高,在保证没有重复数据的情况下用union all。 7、MyISAM和InnoDB区别 (1)InnoDB支持外键，而MyISAM不支持。 (2)InnoDB不支持全文索引，而MyISAM支持。 (3)InnoDB支持行级锁，而MyISAM支持表级锁。 (4)MyISAM不提供事务支持。InnoDB提供事务支持。 (5)MyISAM保存有表的总行数，如果select count() from table;会直接取出出该值。InnoDB：没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 (6)MyISAM可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 (7)MyISAM可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。 (8)如果执行大量的SELECT，MyISAM是更好的选择。如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 (9)每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 8、MySQL的三级模式 (1)模式(逻辑模式)：是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 (2)外模式(用户模式)：是数据库用户的数据视图，是局部数据的逻辑结构和特征的描述。 (3)内模式(存储模式)：一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。 9、mysql中视图和表的区别以及联系 区别： (1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。 (2)视图没有实际的物理记录，而表有。 (3)视图是窗口，表是内容。 (4)视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。 (5)表可以及时对它进行修改；而视图只能用创建语句来修改。 (6)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。 (7)从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。 (8)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 (9)视图的建立和删除只影响视图本身，不影响对应的表。 联系： (1)视图是在表之上建立的虚表，它的结构(所定义的列)和内容(所有记录)都来自表，视图依据表存在而存在。一个视图可以对应多个表。视图是表的抽象和在逻辑意义上建立的新关系。 (2)删除视图中的数据,数据库中表的数据会一起被删除。 10、存储过程(procedure)和函数(function)区别 (1)本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。 (2)函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。 (3)函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务]]></title>
    <url>%2F2018%2F04%2F04%2FMySQL%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ (1)在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 (2)事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 (3)事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 (1)原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 (2)一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 (3)隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 a、未提交读（RU）：最弱的隔离级别，事务中的修改即使没有提交，对其他事务也都是可见的。（即脏读） b、不可重复读（RC）：大多数数据库系统的默认隔离级别。解决了脏读的问题，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。一个事务两次执行同样的查询，可能会得到不一样的结果。 c、可重复读（RR）：mysql默认隔离级别。解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。 该级无法解决幻读的问题，幻读是当某个事务在读取某个范围内的记录时，一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读。 innodb和xtradb存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。 d、可串行化：该级是最高的级别，通过强制事务串行执行，避免了幻读的问题，该级会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题， (4)持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务必使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： (1)BEGIN或START TRANSACTION；显式地开启一个事务； (2)COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； (3)ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； (4)SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； (5)RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； (6)ROLLBACK TO identifier；把事务回滚到标记点； (7)SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT来实现 (1)BEGIN 开始一个事务 (2)ROLLBACK 事务回滚 (3)COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: (1)SET AUTOCOMMIT=0 禁止自动提交 (2)SET AUTOCOMMIT=1 开启自动提交]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F04%2F04%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1、在学习红黑树之前有必要先来了解一下二叉查找树。二叉查找树是基于二分查找的思想，查找所需的次数为二叉查找树的高度；在插入节点时也是通过一层一层的比较来找到合适插入的位置。但它仍然存在缺陷，就是当插入的数据是依次递增时，它会不断地插在节点的右子树上(或者是当插入的数据是依次递减时，它会不断地插在节点的左子树)。此时的二叉查找树的查找性能几乎变成了线性。那么如何解决二叉查找树多次插入新节点而导致的不平衡呢？红黑树也就应运而生了。 二叉查找树的性质： a、左子树上所有结点的值均小于或等于它的根结点的值。 b、右子树上所有结点的值均大于或等于它的根结点的值。 c、左、右子树也分别为二叉排序树。 2、红黑树(Red Black Tree)是一种平衡的二叉查找树(但不是一个完美的平衡二叉树)。它的应用有很多，Java中的TreeSet和TreeMap数据结构，Java8中的HashMap也用到了红黑树；在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。 (1)性质 a、节点是红色或黑色。 b、根节点是黑色。 c、每个叶子节点都是黑色的空节点（NIL节点）。 d、每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) e、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 以上这些限制强化了红黑树的关键属性：从根节点到最远叶节点的路径不超过从根到最近叶节点的路径的两倍(最短的路径是:全部都是黑色节点，最长的路径是:在红色和黑色节点之间交替)。这也是红黑树和二叉查找树之间最大的不同。 (2)左旋转和右旋转 a、左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右子树取代，而父节点自己成为自己右子树(现在已经是父节点了)的左子树。现在已经是父节点的的左子树成为曾经的父节点的右子树。 b、右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左子树取代，而父节点自己成为自己左子树(现在已经是父节点了)的右子树。现在已经是父节点的的右子树成为曾经的父节点的左子树。 (3)插入节点 a、当前节点位于树的根部。为了满足（根节点是黑色），将其颜色变成黑色。由于这会向每条路径都添加一个黑色节点，所以（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）不会被违反。 b、当前节点的父节点是黑色的。所以（每个红色节点的两个子节点都是黑色）不会失效。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）没有受到威胁，因为当前节点有两个黑色节点，但由于当前节点是红色，所以到达其每个叶子节点路径上的黑色节点的数量与它所替换的叶子节点路径上的黑色节点的数量是相同的。 c、如果父节点和父节点的兄弟节点都是红色的，那么可以将他们的颜色都变成黑色，并且将祖父母节点的颜色变成红色以维持（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）。由于通过父节点和父节点的兄弟节点的任何路径必须经过祖父母节点，所以这些路径上的黑色节点的数目并没有改变。然而，祖父母节点现在可能违反了（根节点是黑色），如果它是根或（每个红色节点的两个子节点都是黑色），如果它具有红色的父母节点。为了解决这个问题，树上的红黑修复程序在祖父母节点上重新运行。 d、父节点是红色的，但是父节点的兄弟节点是黑色的。最终目标是将当前节点旋转到祖父母节点的位置，但如果当前节点位于祖父母节点下子树的“内部” （即，如果当前节点是祖父母节点的右子节点的左子节点或者是祖父母节点的左子节点的右子节点）。在这种情况下，可以在父节点上执行左旋转以切换当前节点及其父节点的位置。由于父节点和当前的插入节点都是红色的，所以旋转这两个节点不会使（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）受到旋转的影响。这一步完成后（每个红色节点的两个子节点都是黑色）仍然被违反。此时，当前节点现在肯定位于祖父母节点的子树的外部（左子节点或右子节点）。在这种情况下，执行祖父母节点上的右旋转;其中前父母节点现在是当前节点和前祖父母节点的父母节点。此时前父母节点和前祖父母节点的颜色互换，结果树满足（每个红色节点的两个子节点都是黑色）。（从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点）也依然不满足，再将前祖父母节点和其右子节点的颜色互换即可。 *具体的红黑树中插入和删除出现的有关旋转和变色的情况，请自行跳转至维基百科查看：维基百科红黑树]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柴]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%9F%B4%2F</url>
    <content type="text"><![CDATA[你本是泥土里的种子 春雨下来，便破土而出，发芽又抽绿 阳光透过乔木和灌木的叶子漏下来 照耀着你微弱的身体 后来呀，雨露下来，寒风穿过 土壤也时而干燥 根在土里生长 叶在空气里徜徉 向着更广阔的空间里延伸 春夏秋冬地过去，轮回。 那一日，我手持柴刀独自上山 无意间来到你的身旁 此时的你已巍然成木 在多少次的手起刀落后 在洁白的木屑四散飞溅后 你轰然倒下 倒在你无比熟悉的地点 我残忍地脱去你的外衣，卸下你的臂膀 甚至头颅。 你已经死了 你的尸体跟随我下了山 你永远地离开了生生世世守护的这方土地 被我丢弃在陌生的沙土之上 无情的斧子借着外力将你的尸体大卸八块 陈列在清灰色瓦片盖的土坯房子里 静静等候与烈火的相遇 化为炊烟又化为尘土]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%96%87%E5%AD%97%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;庆山在书中写到：文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关，但从记录中回溯，可看到自我构建和行进的一个过程。那么我想写博客的意义也大抵如此，文件夹中所有的文件前缀清晰地呈现出文件创建的日期，文件的标题可以一眼看出这其中包含了什么。那么点开“阅读全文”的扩展链接，你会知道自己在某天的某个时间段做了什么。可能是有关学习的知识点，可能是有关生活的感悟或自己的思考，又或者仅仅是记录了一件事情的发生。所有这些，过后回望的确会有及其深刻的意义。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(三)]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[1、家里花园池塘，荷花已盛开。通常先有一朵最早绽放，一夜之间，其他次第开放。荷叶可煮米粥，白米汤染上微润绿汁，带有莲花清香，和上冰糖。荷叶在米粥煮熟即将熄火时放入覆盖。今年，一池塘红色荷花唯独长出一株白莲。不知它因何而起。 2、经过提纯的内心空间，不是不懂，不知，而是不问，不计较，不介意，不追究。愿意把别人想得好一些，不把人想得复杂，考虑到对方的立场。可说，可不说时，不如选择不说。 4、不存在无可救药的人、感情、生活。一切终究有变化。如果你认为它无可救药，不过是沉溺。我们可以选择完全的放下，或者完全的承担。唯独不能伪装成一个懒怠的理所当然的姿势。你尽可拖延和故作不知，企图获得其他妥协。命运静静等待一侧，旁观你辗转煎熬，最终会逼迫你把脚步移向注定的一格。实践一旦进行，错误和方式就会自动调整和归位。出发时首要的。 5、跪拜只是一个仪式，为了让心恭敬谦卑平和柔顺，在毫无杂念从事这一重复举动时训练和观照自己。调伏这颗充满傲慢我执的刚硬的心。这是一个修行的任务。 6、不应在原地等待，要一边前行一边等待。 7、看完一本书，即使觉得好，日后也常常想不起其中句子，也不会使用或摆弄。也许阅读它，如同喝下的一杯清水，不过是维持日常的生存。 8、如果曾经为别人做过什么，不要事后提醒对方记得你的付出。如果别人曾经出于信任对你分享过他的软弱，不要事后以此攻击对方以证明自身强大。这均是高贵举动。 9、时间最终会带来解脱，重要或者不重要的事物，在最后纷纷露出它们的本来面目。 10、我的心是一座浸泡在海水中的宫殿。多年之后，你会记得它，也许忘却它。最终，你会怀念它。这种悲哀与击伤。这种怜悯与温柔。这空无而充盈的力量。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的抽象类和接口]]></title>
    <url>%2F2018%2F03%2F31%2FJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、抽象类和常规类很像，但是不能使用new操作符创建它的实例，但抽象类可以用作一种数据类型，因此：GeometricObject[] objects=new GeometricObject[10];objects[0]=new Circle();像上面这样创建一个元素是GeometricObject类型的数组，然后创建一个GeometricObject的实例，并将它的引用赋值给数组是可以的。虽然不能使用new操作符创建它的实例，但仍然可以定义它的构造方法，抽象类的构造方法定义为protected，因为它只被子类使用。抽象方法只有定义而没有实现。它的实现由子类提供。 2、抽象方法不能包含在非抽象类中，也就是说一个包含抽象方法的类必须声明为抽象类。但是，可以定义一个不包含抽象方法的抽象类(同样不能使用new操作符创建它的实例)，这种类是用来定义新子类的基类的。如果抽象父类的子类不能实现所有的抽象方法，那么这个子类也必须定义为抽象的。另外，抽象方法是非静态的。 3、即使子类的父类是具体的，这个子类也可以是抽象的。比如：object类是具体的，但继承于它的类却可以是抽象的。子类可以覆盖父类的方法并将它定义为abstract(这是很少见的)，但是它在当父类的方法实现在子类中变得不合法时是很有用的。在这种情况下，子类必须为abstract。 4、接口是一种与类相似的结构，只包含常量和抽象方法。它和抽象类相似，不能使用new操作创建接口的实例。由于接口中所有的数据域都是public final static而且所有的方法都是public abstract，所以java允许忽略这些修饰符。 5、Java只允许为类的扩展做单一继承，但是允许使用接口做多重继承。用关键字extends，接口可以继承其他接口，但是不可扩展类。一个类可以扩展它的父类同时实现多个接口。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[画地为牢]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%94%BB%E5%9C%B0%E4%B8%BA%E7%89%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人需要去探索未知的领域，包括周围的环境、与专业相关的内容或者是周围的人群。因为在那些事物当中往往会有很多的惊喜等着你。或许它们一直都存在，只是很多时候受到各种条件的限制，尤其是来自于我们思想的禁锢和束缚。没有突破，置身其中，画地为牢，就连滋生好奇心的培养皿都没有。生活需要一双发现美的眼睛，同时也需要有伸向外界的触角和勇气。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strcpy函数的实现]]></title>
    <url>%2F2018%2F03%2F28%2FStrcpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[(1)strcpy函数的代码实现 char *strcpy(char *dst,const char *src){//源字符串参数用const修饰，防止修改源字符串。 assert(dst != NULL &amp;&amp; src != NULL);//检查指针的有效性，如果它的条件返回错误，则终止程序执行。 char *ret = dst; while ((*dst++=*src++)!=&apos;\0&apos;); return ret; } (2)为什么要返回char *? 返回dst的原始值使函数能够支持链式表达式。链式表达式的形式如：int l=strlen(strcpy(strA,strB));又如：char * strA=strcpy(new char[10],strB); 返回strSrc的原始值是错误的。 其一，源字符串肯定是已知的，返回它没有意义。 其二，不能支持形如第二例的表达式。 其三，把const char *作为char *返回，类型不符，编译报错。 (3)考虑dst和src内存重叠的情况 所谓重叠，就是src未处理的部分已经被dst给覆盖了，只有一种情况：src&lt;=dst&lt;=src+strlen(src)。C函数memcpy自带内存重叠检测功能，下面给出memcpy的实现my_memcpy。 char *strcpy(char *dst,const char *src){ assert(dst != NULL &amp;&amp; src != NULL); char *ret = dst; my_memcpy(dst, src, strlen(src)+1); return ret; } my_memcpy的实现： char *my_memcpy(char *dst, const char* src, int cnt){ assert(dst != NULL &amp;&amp; src != NULL); char *ret = dst; if(dst &gt;= src &amp;&amp; dst &lt;= src+cnt-1){//内存重叠，从高地址开始复制 dst = dst+cnt-1; src = src+cnt-1; while (cnt--) *dst-- = *src--; }else{//正常情况，从低地址开始复制 while (cnt--) *dst++ = *src++; } return ret; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三月二十七号]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%89%E6%9C%88%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;奔走于图书馆和教学楼之间的小径，仲春时节。湖北海棠开得热烈，散发出浓厚的香气；迎春花点缀在桥的两头，静静躺卧；溪中的水生植被在被割去旧年的枝干之后，在流水中已生发出嫩绿的新叶；晨梦亭下有人读书；阳光的热度适合出游与赏玩。自身脚步匆匆，但春日里的生机能够感受得到，这是一种力量的传递与引导，人与自然需要一定的联结。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(二)]]></title>
    <url>%2F2018%2F03%2F27%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、在这个苍茫的人世，还会有谁一直等着我，又会有谁这样忍着难过甘心让我远远走掉。我带着行囊在这视线中默默转身，不曾想过某一天有诀别。我不知道他去了哪里。我们是否会重逢。唯一确认的是，他以自己的方式爱过我，在我的血液里留下悲剧性的烙印。这些黑暗的质素缓慢流淌，一刻也不曾停息。仿佛一种强悍的无法屈服的意愿。 2、我们最终所得到的训练无非是，面对无所知、无常、虚妄，时时抚平心绪，保持警惕、平静、坚强、有方向地活下去。并且静观这个世间所有破落的碎片擦身而过。 3、人的生活需要公园。它为日常生活提供一处停顿。停顿意味暂时没有心念，没有目标，略作小憩，与己共存。 4、如果要做到不伤害他人，前提是不要对他人抱有期待。同时也不让他人抱有对你的期待。做到后一条更为困难。这意味着在某些时刻，你必须显示你自己真实的立场，而没有一丝自私的隐藏或者造作。 5、有时，我们爱人，是取悦自己渴望被爱的欲求；对他人的提供，是试图填补内在匮乏的需求；憎恶或攻击他人，是被对方提醒了不愿意被揭示的遮蔽的暗处；愤恨或者狂躁，联结着内心长期积累的软弱和无力。。。自我战争不过是冲突于牢笼之中。 6、时间很重要，物证很重要。它们会使某些曾经被蒙蔽或忽略的情感，在很久之后被澄清和浮出。我也会手写书信给生命中真正重要的人。只为了让他或她，在以后某天终会明白我的心。 7、摘完杏，和农夫闲聊。他说果实在树上，阳光的温度或突降的暴雨都会给予它影响。每一天它的内在都在发生变化，都在面临无常。所以，及时地摘下并享用它即是最好的方式。 8、人由自我限制而生发的对他人的狭窄念头，毫发无损于对方，只使自己捉襟见肘。若能置身事外，才不会画地为牢。 9、当下享受是最好的态度。接受无常，接纳完整的存在，而不试图重新塑造，也不扭曲自己和他人。关系第一原则，应是允许他人以独立和自愿的方式存在。期望是自以为是的权力。 10、在一本书里，读者感受到作者的精神方式、观念、特质，觉得与之契合，有共鸣，遂在心里把他当作一个知己。他们之间的关系，有时会比生活中实际相处的人抵达更为深邃的心灵限度。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(三)]]></title>
    <url>%2F2018%2F03%2F26%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[1、define与const的区别 (1)define在预处理阶段进行替换;const在编译时确定其值。 (2)用define可以定义一些简单的函数，const是不可以定义函数的。 (3)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的。 (4)define无类型，不进行类型安全检查，可能会产生意想不到的错误;const有数据类型,编译时会进行类型检查。 (5)define不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大;const在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。 (6)宏定义的作用范围仅限于当前文件;而const对象在默认状态下，只在文件内有效，当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字(在声明和定义时都要加。 2、构造函数不能为虚函数，而析构函数可以且常常是虚函数 (1)如果构造函数是虚函数，那么就需要通过vtable来调用，但此时面对一块raw memeory是找不到vtable的，vtable是在构造函数中才初始化的，而不是在其之前。因此构造函数不能为虚函数。 (2)析构函数可以是虚函数,此时vtable已经初始化了,况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。 3、虚函数和纯虚函数的作用与区别 (1)虚函数为了重载和多态的需要，在基类中是有定义的，即便定义是空，所以子类中可以重写也可以不重写基类中的此函数。 (2)纯虚函数在基类中是没有定义的，必须在子类中加以实现，很像java中的接口函数。它不能直接实例化，需要派生类来实现函数定义。 4、面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。他们之间的共同点是抽象和创建可重用代码，但它们的理念决然不同。泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板，模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型，它们都是STL通用方法的重要组成部分。 5、头文件中的#ifndef/#define/#endif的作用 其作用是防止该头文件被重复引用。”被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include “c.h”而此时b.cpp文件导入了#include”a.h”和#include”c.h”此时就会造成c.h重复引用。有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些。但是对于大工程而言编译效率低下就会是一件很痛苦的事情了。 6、动态内存分配的初始化问题 1)malloc函数：void *malloc(unsigned int size) 在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。 2)calloc函数： void *calloc(unsigned int num, unsigned int size) 按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。 3)realloc函数：void realloc(void ptr, unsigned int size) 动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。申请的内存空间不会进行初始化。 4)new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。 7、指针和const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值可以改变。 const int *x = &amp;y; //指针所指向的内存可变，但内存中的值不能通过指针改变。 int const *x = &amp;y; //指针所指向的内存可变，但内存中的值不能通过指针改变。 const int const *x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。 const int * const x = &amp;y; //指针所指向的内存不可变，内存中的值也不能通过指针改变。 当const在*的左边，则表示指针所指向的空间的内容不能通过改变*p的值来修改，或者说指针所指向空间的值不能被修改。 当const在*的右边，则表示指针的地址不能被修改，或者说指针的指向不能被修改。 8、无论是整型数组还是字符数组，数组名作为右值的时候都代表数组首元素的首地址。数组发生降级(数组名退化为数组首元素的地址)的情况：数组传参、数组名参与运算。数组名不会发生降级的情况：sizeof(数组名)、取地址数组名(取到的是整个数组的地址而不是首元素的地址)。 9、重载、覆盖和隐藏 (1)成员函数被重载的特征： a、相同的范围(在同一个类中)； b、函数名字相同； c、参数不同； d、virtual关键字可有可无。 (2)覆盖是指派生类函数覆盖基类函数，只作用于派生类函数，特征是： a、不同的范围(分别位于派生类与基类)； b、函数名字相同； c、参数相同； d、基类函数必须有virtual关键字。实际上虚函数的作用，就是实现覆盖。 (3)“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： a、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏(注意别与重载混淆)。 b、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏(注意别与覆盖混淆)。 10、类模板与模板类的概念 (1)类模板:一个类模板(也称为类属类或类生成类)允许用户为类定义一种模式，使得类中的某些数据成员、默认成员函数的参数、某些成员函数的返回值，能够取任意类型（包括系统预定义的和用户自定义的）。如果一个类中数据成员的数据类型不能确定，或者是某个成员函数的参数或返回值的类型不能确定，就必须将此类声明为模板，它的存在不是代表一个具体的、实际的类，而是代表着一类类。 (2)模板类是类模板实例化后的一个产物。可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。类模板的重点是模板，表示的是一个模板，专门用于产生类的模子。模板类的重点是类，表示的是由一个模板生成而来的类。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(二)]]></title>
    <url>%2F2018%2F03%2F26%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1、成员方法又称为实例方法，静态方法又称为类方法。静态方法中没有this指针。 2、this指针内容为const，是不允许更改的。如果对它进行了更改将会导致编译不成功，如果只有delete this;这一句存在于析构函数当中，则能通过编译，但是会导致栈的溢出。 3、构造函数初始化时必须采用初始化列表的一共有三种情况 (1)需要初始化的数据成员是对象(继承时调用基类构造函数) (2)需要初始化const修饰的类成员 (3)需要初始化引用成员数据 *由于static属于类并不属于具体的对象，所以static成员是不允许在类内初始化的。static const成员也不在初始化列表中。 *static属于类，它在未实例化的时候就已经存在了，而构造函数的初始化列表，只有在实例化的时候才执行。 *static成员不属于对象。我们在调用构造函数自然是创建对象，一个跟对象没直接关系的成员没有必要初始化。 4、实参可以是任何类型（可以是常量，变量或表达式），但是形参却不能是表达式。C语言中最简单的数据类型包括整型、实型(实型又称浮点数或者实数)、字符型。在C语言中，没有专门的逻辑型数据类型，而是用0和1来表示逻辑值。 5、类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐。基类中存在虚函数时，派生类会继承基类的虚函数(虚函数也是类的成员函数)，因此派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域），而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。(指向虚函数的指针为4个字节) 6、fork()与clone的区别 函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；clone()函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可以通过参数设定选择的，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。 7、关于浅复制和深复制 所谓浅复制，就是在构造函数当中直接为复制的对象的数据成员赋值。在很多情况下，这是可以的。创建新的对象，要为对象的数据成员分配存储空间，直接赋值就将值保存在相应的空间中。但是如果在构造函数当中出现了指针类型的数据成员时，也按照上面那样直接赋值而未经过地址的分配就会在调试的时候出错，这种指针被称为“野指针”。解决这样的问题的方法，就是在构造函数中，为指针类型的成员，分配专门的空间。以这条规则构建的复制，称作为深复制。 8、C语言中的未定义行为(Undefined Behavior) 未定义行为是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。 9、C++面向对象的三个基本特征(封装、继承和多态) (1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行。封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。 (2)继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 (3)多态：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上。同时又有这些多态的形式，参数多态：指参数方面，包含函数模板与类模板；包含多态：含有virtual关键字；重载多态：函数名相同，但函数参数的个数或类型不同构成多态；强制多态：通过强制类型转换形成；重载多态和强制多态是指特定多态。参数多态和包含多态是指通用多态。 *封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现接口重用！ 10、虚函数如何实现的 (1)虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针。 (2)在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。 (3)实际上在编译的时候，编译器会自动加上虚表。 (4)虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函 数重新定义。 (5)虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续 表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。 (6)必须通过基类类型的引用或指针进行函数调用才会发生多态。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中个人常用快捷键]]></title>
    <url>%2F2018%2F03%2F26%2FWindows%E4%B8%AD%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[1、Ctrl类 (1)撤消操作：Ctrl+Z (2)复制选定文本：Ctrl+C (3)粘贴选定文本：Ctrl+V (4)剪切选定文本：Ctrl+X (5)打开新窗口：Ctrl+N (6)关闭当前所在窗口：Ctrl+W (7)恢复关闭的窗口：ctrl+shift+T (8)新建文件夹：Ctrl+Shift+N (9)选择文档或窗口中的所有项目：Ctrl+A (10)在本应用下的窗口之间进行切换：Ctrl+Tab 2、Windows类 (1)电脑锁屏：Windows+L (2)显示和隐藏桌面：Windows+D (3)打开任务视图：Windows+Tab (4)打开“运行”对话框：Windows+R (5)打开文件资源管理器：Windows+E (6)添加虚拟桌面：Windows+Ctrl+D (7)关闭你正在使用的虚拟桌面：Windows+Ctrl+F4 (8)在你于右侧创建的虚拟桌面之间切换：Windows+Ctrl+向右键 (9)在你于左侧创建的虚拟桌面之间切换：Windows+Ctrl+向左键 3、其他 (1)刷新当前窗口：F5 (2)在所有打开的应用之间进行切换：Alt+Tab]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和引用的区别]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[(1)可以有const指针，但是没有const引用。 (2)指针可以有多级，但是引用只能是一级(int **p;合法而int &amp;&a;是不合法的)。 (3)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。 (4)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 (5)指针可以是空值，可以在任何时候被初始化。而引用不可以为空且在被创建的时候，必须初始化。此处引用类似于const的指针。 (6)指针和引用的自增(++)运算意义不一样。指针自增是所指的数据类型变量的下一个数据类型的地址。而引用是引用所指向的变量的值加1。 (7)”sizeof(引用)”得到的是所指向的变量(对象)的大小(即引用的sizeof为所引用的对象在内存中分配空间的大小(单位字节))，而”sizeof(指针)”得到的是指针本身的大小。在C++当中，存放一个地址和一个int类型的大小相同：4字节。即sizeof(指针)=4。 (8)指针是一个变量，只不过这个变量存储的是一个地址，是指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。引用变量的主要作用是用作函数的形参，通过将引用变量用作形参，函数将使用原始数据，而不是其副本。 注意：要把引用的&amp;和取地址运算符&amp;区分开来，引用并不是取地址的意思，引用符号是类型标识的一部分。由于引用是产生变量的别名，故常量不可使用引用。指针变量其实是unsigned类型的整数，这也解释了为什么在C++当中指针类型的变量的sizeof就是4个字节。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的问题整理(一)]]></title>
    <url>%2F2018%2F03%2F25%2FC%2B%2B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、#include&lt;filename.h&gt;和#include“filename.h”有什么区别?答：对于#include&lt;filename.h&gt;,编译器从标准库路径开始搜索filename.h,而对于#include “filename.h”,编译器从用户的工作路径开始搜索filename.h。 2、在C++程序中调用被C编译器编译后的函数,为什么要加extern“C”?答：C++语言支持函数重载,C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为:void foo(int x, int y);该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int 之类的名字。C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。 3、一个类有基类、内部有一个其他类的成员对象,构造函数的执行顺序是怎样的?答：先执行基类的(如果基类当中有虚基类,要先执行虚基类的,其他基类则按照声明派生类时的顺序依次执行),再执行成员对象的,最后执行自己的。 4、New/delete与malloc/free的区别是什么？(1)new/delete是C++的操作符，而malloc/free是C中的函数。 (2)new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。 (3)new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。 (4)new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。 5、Struct和class的区别是什么？答：struct中成员变量和成员函数默认访问权限是public,class是private。 6、多态有哪些分类？答：多态可以分为编译时多态和运行时多态。编译时多态可以通过函数的重载来实现，具体表现在根据参数的个数和类型的不同选择合适的同名函数。运行时多态通过虚函数实现，就是运行时根据对象类型自动选择正确的调用函数(也叫动态绑定)。模板属于编译时多态性，因为编译时自动根据模板生成模板函数。虚函数的动态绑定仅在基类指针或引用绑定派生类对象时发生。如果函数的形参不是指针或者引用，则调用哪个类的函数就已经确定。 7、为了提高访问内存的速度而进行内存对齐，说明内存对齐是什么？(1)默认情况下，编译器的对齐系数为8 (2)内存对齐：就是每个成员的起始位置必须是对齐系数与成员自身大小二者中较小者的整数倍。 (3)内存补齐：取结构体或类的成员中最大的那个值，与对齐系统相比，取二者中的较小者。然后保证整个对象结尾地址的下一个地址是较小者的整数倍。 (4)结构体对齐除了第1点之外还要求结构体数组也必须是对齐的，也就是说每个相邻的结构体内部都是对齐的。 可以看一下这篇文章:http://www.cppblog.com/cc/archive/2006/08/01/10765.html 8、在win32中创建一个窗口需要设计一个窗口类，注册窗口类，创建窗口，显示及刷新窗口等几个步骤。9、const 有什么用途？(1)可以定义const常量。 (2)const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。被const修饰的函数定义体的函数能被const或者非const对象调用，但是const对象只能调用被const修饰过定义体的函数。 10、什么是内联函数？(1)编译器使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存。例如：如果程序在10个不同的地方调用了同一个内联函数，则该程序将包含该代码的10个副本。 (2)在函数声明之前加上关键字inline或者在函数定义之前加上inline。关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。 (3)定义在类声明之中的成员函数将自动地成为内联函数。所以不管是class声明中定义的inline函数，还是class实现中定义的inline函数，不存在优先不优先的问题，因为class的成员函数都是inline的，加了关键字inline也没什么特殊的。 (4)由于使用inline关键字的函数只是用户希望它成为内联函数，但是编译器有权忽略这个请求，比如：若此函数体太大，则不会把它作为内联函数展开的。内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗词入门(一)]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AF%97%E8%AF%8D%E5%85%A5%E9%97%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、格律(1)平仄:单个汉字发音的音调 a、古代汉语的四种声调包括：平、上(第三声)、去、入。其中平声又分为阴平和阳平。四声当中平声属于平仄当中的平声,而另外三声上、去、入则属于平仄中的仄声。 b、古代汉语的四声和今天普通话的声调种类不完全相同。上图中的黑色线条对古代汉语四声和现代汉语四声的连接是比较容易区分的：平声分为阴平和阳平，其中阴平对应现代汉语中的第一声，而阳平则对应现代汉语中的第二声；属于仄声的上声对应现代汉语中的第三声；属于仄声的去声则对应现代汉语中的第四声。 c、上图中用灰色线条连接起来的有关属于仄声的入声的演化是学习近体诗中平仄最让人费解的了。虽然现代江浙、福建、广东、广西、湖南和江西等处都还保存着入声，北方也有不少地方保存着入声这一个调类。但在普通话当中，入声字已经不复存在了。而是分别演化派进了现代汉语中的一、二、三、四声中去(也就是派进了古代汉语中的平、上、去三声当中，也称之为‘入派三声’)。当然对于演化成现代汉语中的三、四声的字我们无需担心(因为三、四声所对应的上声和去声本就是属于古代汉语中的仄声)，所以令我们困惑的就只是演化成现代汉语中一、二声的入声字(即入声演化为平声的情况)。而这一困惑是需要依靠查字典或者韵书才能消除的(当然如果你非常幸运地发现自己的方言就能辨别入声字，那你就一个人自己偷着乐吧)。这里素师推荐使用龙榆生的《唐宋词格律》。 d、这里引用大家耳熟能详的柳宗元的《江雪》作为例子来说明入派三声 《江雪》柳宗元 千山鸟飞绝，万径人踪灭。 孤舟蓑笠翁，独钓寒江雪。 这里的绝(jue)、雪(xue)、灭(mie)都是入声字，分别演化派入于平、上、去三声当中。 e、古仄今平、古平今仄和可平可仄。 古仄今平：就是上面提到过的入声派入平声。例：黑、白、竹、屋、绝、笛。。。 古平今仄：俱(ju第一声)、论(lun第二声)语 可平可仄：看;听;骑(qi)马(平)、一骑(ji)红尘妃子笑(仄) *素师说，在读近体诗的时候要么用方言，要么用普通话。不要四不像。 (2)韵律:诗从平水韵，词从词林正韵。不可用中华新韵(完全丢弃了入声的概念)，中原音韵。 2、体式(1)诗体 一般而言，我们当下所说的古诗指的是诗体当中的古体诗。古体诗不受平仄的束缚，但是受韵的束缚(这是在沈佺期和宋之问等人在以沈约、谢眺等为代表的永明体基础上，从原来的讲求四声发展到只辨平仄，从消极的“回忌声病”发展到悟出积极的平仄规律，又由原来只讲求一句一联的音节、协调发展到全篇平仄的粘对，以及中间二联必须上下句属对，从而形成完整的律诗。规范了格律之后脱离出来的体裁)。 那诗体中的近体诗(也叫今体诗)就是我们当下学习的诗体。它不但受平仄的束缚，而且受到押韵的束缚。其中由八句组成的称之为律诗，四句组成的称之为绝句。在律诗当中又有五律(每句五个字)和七律(每句七个字)之分，相应的绝句也有五绝和七绝之分。 (2)词体 3、诗律(以杜甫的登高为例) 上图中的竖线表示仄声，横线表示平声，三角形表示押韵。在一首诗当中有四联，分别为首联(第一、二句)、颔联(第三、四句)、颈联(第五、六句)和尾联(第七、八句)。一联的前一句称之为出句，后一句称之为对句。 (1)一三五不论，二四六分明。第一、三、五字不考虑平仄，第二、四、六字平仄分明。 (2)一句之内平仄相间，一联之间平仄相对(不符合即为：失对)，两联之间平仄相粘(上一联对句和下一联出句的平仄一致。不符合即为：失粘) (3)首句可入韵可不入韵 (4)不入韵的句末必为仄 *三平尾和三仄尾是大忌(此时的五须论，五律和七律皆如此) *平起还是仄起看的是首联出句的第二个字。 4、作业(1)在唐诗三百首当中找出一首诗：平起首句不入韵的七言律诗，抄写一遍标注平仄、押韵。 (2)预习拗救]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文参考文献标准格式要求]]></title>
    <url>%2F2018%2F03%2F24%2F%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1、参考文献的分类按参考文献的提供目的划分,可分为引文文献、阅读型文献和推荐型文献3大类: (1)引文文献是著者在撰写或编辑论著的过程中,为正文中的直接引语(如数据、公式、理论、观点、图表等)或间接引语而提供的有关文献信息资源。 (2)阅读型文献是著者在撰写或编辑论著的过程中,曾经阅读过的文献信息资源。 (3)推荐型文献通常是专家或教师为特定读者、特定目的而提供的、可供读者查阅的文献信息资源。 2、文献类型和标识代码参考文献目前共有16个文献类型和标识代码:普通图书M,会议录C,汇编G,报纸N,期刊J,学位论文D,报告R,标准S,专利P,数据库DB,计算机程序CP,电子公告EB,档案A,舆图CM,数据集DS,其他Z.凡无法归属于前15个类型的文献,均可以用Z来标志。 3、参考文献格式要求1、参考文献按正文部分标注的序号依次列出,并在序号中加[]。 2、对于常见的各类参考文献标注方法如下: (1)著作:作者姓名,题名[M].出版地:出版者,出版年. (2)期刊论文:作者姓名.题名[J].期刊名称,年,卷(期):页码. (3)会议论文集:作者姓名.题名[C]//论文集名称,会议地点,会议日期. (4)学位论文:作者姓名.题名[D].出版地:出版者,出版年. (5)专利文献:专利申请者或所有者姓名.专利题名:专利国别,专利号[P].公告日期或公开日期.获取路径. (6)电子文献:作者姓名.题名[文献类型标志(含文献载体标志)见其它].出版地:出版者,出版年(更新或修改日期),获取路径. (7)报告:作者姓名. 题名[R].出版地:出版者,出版年. (8)标准:标准号.题名[S].出版地:出版者,出版年. 3、同一著作中作者姓名不超过3名时,全部照录,超过3名时,只著录前3名作者,其后加“, 等”。 4、其他:数据库(DB),计算机程序(GP),光盘(CD),联机网络(OL)。 4、参考文献著录格式参考文献按在正文中出现的先后次序列表于文后;表上以“参考文献:” (左顶格) 或“[参考文献]”(居中)作为标识;参考文献的序号左顶格,并用数字加方括号表示,如[1], [2],…,以与正文中的指示序号格式一致. 参照ISO690及ISO 6 9 0-2,每一参考文献条目的最后均以结束. 各类参考文献条目的编排格式及示例如下: a.专著、论文集、学位论文、报告 [序号]主要责任者. 文献题名[文献类型标识].出版地:出版者,出版年. [1]刘国钧,陈绍业,王凤者. 图书馆目录[M].北京:高等教育出版社,1957. [2]辛希孟. 信息技术与信息服务国际研讨会论文集:A集[C].北京:中国社会科学出版社,1994. [3]张筑生. 微分半动力系统的不变集[D].北京:北京大学数学系数学研究所,1983. [4]冯西桥. 核反应堆压力管道与压力容器的LBB分析[R].北京:清华大学核能技术设计研究院,1997. [5]尼葛洛庞帝. 数字化生存[M].胡泳,范海燕,译. 海口:海南出版社,19%. b.期刊文章 [序号]主要责任者. 文献题名[J].刊名,年,卷 (期) :起止页码. [5]何龄修. 读顾城《南明史》[J].中国史研究,1998, (3) :167-173. [6]金显贺,王昌长,王忠东,等·一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版) , 1993, 33 (4) :62-67. c.论文集中的析出文献 [序号]析出文献主要责任者. 析出文献题名[A].原文献主要责任者 (任选}.原文献题名[C].出版地:出版者,出版年. 析出文献起止页码. [7]钟文发·非线性规划在可燃毒物配置中的应用[A].赵玮. 运筹学的理论与应用-中国运筹学会第五届大会论文集[C].西安:西安电子科技大学出版社,1996.468-471. d.报纸文章 [序号]主要责任者. 文献题名[N].报纸名,出版日期 (版次) . [8]谢希德. 创造学习的新思路[N].人民日报,1998-12-25 (10) . e.国际、国家标准 [序号]标准编号,标准名称[S]. [9]GB/T 16159-1996, 汉语拼音正词法基本规则[S]. f.专利 [序号]专利所有者,专利题名[P].专利国别:专利号,出版日期. [10]姜锡洲. 一种温热外敷药制备方案[P].中国专利:881056073, 1989-07-26. g.电子文献 [序号]主要责任者. 电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址,发表或更新日期/引用曰期 (任选) . [11]学术堂. 论文参考文献标准格式要求[EB/OL].http://www.lunwenstudy.com/cankaowenxian/130239.html.2018-03-14. [12]万锦堃. 中国大学学报论文文摘 (1983-1993) .英文版[D B/C D].北京:中国大百科全书出版社,19%. h.各种未定义类型的文献 [序号]主要责任者. 文献题名[Z].出版地:出版者,出版年. 5、文内参考文献标注格式文内所列参考文献应限于作者直接阅读过的、最主要的、且为发表在正式出版物上的文章.私人通信和未发表 (含待发表) 的著作及论文,一般不宜作为参考文献. 参考文献还应注重权威性和时效性.文内标注参考文献时应按文献出现的先后顺序用阿拉伯数字连续编码,并将序号置于方括号中.可根据具体情况分别按下述3种格式之一标注. (1) 文中已标明原始文献作者姓名时,序号标注于作者姓名右上角. 例如：Vairaktaris等[7]研究表明,MMP-9-1562C/T基因多态性与口腔癌关系密切. (2) 正文未标明作者或非原始文献作者时,序号标注于引用内容的句末. 例如：……在中枢神经系统中具有保护神经的作用,减少缺氧、缺血对动物脑神经元的损害[1]. (3) 正文直接述及文献序号时则将之作为语句的组成部分时不用角码标注. 例如：肱动脉超声检查的方法见文献[2]. 文中多次引用同一参考文献,只在第一次出现时编排序号 (在参考文献表中也只出现一次) , 其他处使用同一序号；如果多次引用的是同一参考文献的不同页的内容,则应参考文献表中按引用顺序一一列出页码.若某一问题使用了多篇文献说明,这时将各文献的序号在一个方括号内全部列出,中间加逗号,若遇连续序号,则在起止序号中间加“-”表示.如：……组织型RAS激活也成为心肌肥厚、心肌纤维化、心腔扩大、心力衰竭的主要因素[1,3,9-10].]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>参考文献</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的成员变量、全局变量和局部变量]]></title>
    <url>%2F2018%2F03%2F22%2FC%2B%2B%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1、成员变量:写在类声明的大括号中的变量,称之为成员变量(属性,实例变量)成员变量只能通过对象来访问。 注意:成员变量不能离开类,离开类之后就不是成员变量,成员变量不能在定义的同时进行初始化。 存储:堆(当前对象对应的堆的存储空间中)存储在堆中的数据,不会被自动释放,只能程序员手动释放。 2、全局变量:写在函数和大括号外部的变量,称之为全局变量。 作用域:从定义的那一行开始,一直到文件末尾。全局变量可以先定义再初始化,也可以定义的同时初始化。 存储:静态区。程序一启动就会分配存储空间,直到程序结束才会释放。 3、局部变量:写在函数或者代码块中的变量,称之为局部变量。 作用域:从定义的那一行开始,一直到遇到大括号或者return。局部变量可以先定义再初始化,也可以定义的同时初始化。 存储:栈。存储在栈中的数据有一个特点,系统会自动给我们释放。 *全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。 *非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。另外，静态全局变量只初使化一次，防止在其他文件单元中被引用。 *局部变量和静态局部变量的区别在于它们的存储方式不同，前者存储在栈当中，而后者存储在静态区当中。 *静态函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。静态函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。类中的非静态函数默认是有this指针的，表明为该类的对象所有，静态函数不属于任何类的对象，没有this指针，由类直接调用。也就是说全局函数，静态函数都不能使用this。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《眠空》摘句(一)]]></title>
    <url>%2F2018%2F03%2F22%2F%E3%80%8A%E7%9C%A0%E7%A9%BA%E3%80%8B%E6%91%98%E5%8F%A5(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、文字具备即刻的意义，记下的观点和细节，过后回望，已显得不再重要或已无关。但从记录中回溯，可看到自我构建和行进的一个过程。 2、感情的结果最终是一种理性。是人的天性不具备足够的留恋，还是前进的生活强迫抛却蜕除下来的旧壳？我们远比自己想象的更为无情和客观。 3、他说，要善待自己，放下和消融内在积存的创伤。它们使你沉重而不够轻盈，要不断去清洗。我说，我在你面前仿佛一览无余。他说，人是有很多面的，哪有一览无余。你对我来说，始终是一个没有答案的谜语。但你的谜题措辞优美。 4、应尽量保持真实和自在地去生活。不违背不辜负，无需他人旁观，更无需他人同情。只需始终忠于自我。 5、不知道杭州苏堤白堤的花开了没有，柳树绿了没有。想孤身前往去看一场花事。如果午后微雨突袭，你恰好渡船而过，不妨让我们在春柳拂面的桥头相见。 6、自我摧毁是有快感的，所有下堕的行为都伴随着快感。摔破一个罐子与长时间塑造和建设一个罐子，前者让你享受到更为强大的自我妄想，觉得自己具有力量。但事实并非如此，行动应该携带和突破重力而上升。 7、男女不管关系性质如何，有些原则不能随意更改，底线不能突破。一旦突破，破镜难圆。感情忌讳懈怠及理所当然，至少要始终保持尊重、克制、发力、欣赏及感恩之心。 8、一个印第安巫师说，如果让儿童目睹一次葬礼，抚摸死人的尸体，会驯服孩子内心的浅薄和顽劣不羁。他获得了真正的灵魂的成长。死亡是最需要被学习和认识的内容。 9、泛滥的感情方式，不严格区分对象，只以获取难易作为是否前进的指标。对待不同的人，所给予的内容完全重复，是一次批量化生产之后的零售生意。润滑一些的方式，无非是让不同客户拿到这只被复制的点心盒子，产生为自己特制的幻觉。始乱终弃，以满足欲望为前提，不管这欲望是虚荣、寂寞、爱欲、证明还是其他。这何尝不是一种乏味而肤浅的恋爱方式。无法视对方为独特个体，因此也无法获取来自对方的源泉和力量(也许这是不需要的东西，他们要的只是乐趣)。把对方视为猎物，忽略人的内在生命，以占有和征服为目的。低级的方式决定这关系没有创造力，不具有可追索的深度。是对生命能量的贬低和消费。 10、奥修说，死去的人，将在他生前所爱的人身上收回他的能量，这些能量会被他带走。因此，那个被爱着的人，会感觉到自己的身心被挖掉一块。这一块区域将始终是空的，是匮乏的。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自省]]></title>
    <url>%2F2018%2F03%2F22%2F%E8%87%AA%E7%9C%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连续几日在图书馆的自习，对面的人换了又换，然而他(她)们都有一个令人心生厌恶之处：吃零食或者喝牛奶不断产生的声响和气味。对旁人的感受持漠然的态度。对此，虽完全可以凭借自身的力量尽量避免，但从中自身须得到反省：在生活中，是否具有其他不当的行为让他人感到不适(包括除图书馆以外的场所)。答案是有。有些是一时半会无法去除的缺点，有些是当下即可做到的修改。这些都需要内心的自持和坚韧才能实现，结果要交给时间去检验。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水流众生]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%B0%B4%E6%B5%81%E4%BC%97%E7%94%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李健的《水流众生》是诞生在他西藏的旅途中的，他的歌，总是充满了灵性与自然。在平淡当中述说，却又蕴含深切的主题。这首歌是写给他自己的，也是写给众生的，同时还是写给这个社会的。当今社会物质的极大丰富满足不了人们的欲望，对物质无止境的追求、对自然的过分索取导致人们都迷失了自我，深陷其中，无法自拔却并不自知。李健为了寻求他的解脱之法，于是踏上旅途，当然他的旅途不是我们当下传统意义上的旅行，不是组团或者邀约三五好友匆匆赶赴著名的旅游景点拍照留恋而后又匆匆而归的旅行。他的旅途是内心和自然的相互倾听和感受。当然，最终他还是从自然里、在旅途中找到了自我，看见了辽阔的。每一个人都需要反省，自我观照，在水自成旋涡之前及时转身。(另外李健的《水流众生》和庆山的《莲花》很般配)]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1051 Pop Sequence]]></title>
    <url>%2F2018%2F03%2F21%2FPAT-A1051-Pop-Sequence%2F</url>
    <content type="text"><![CDATA[Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. Output Specification: For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO 题目大意：给出size为M大小的栈，分别把1…N入栈，给出K组出栈顺序，问入栈出栈顺序是否顺利。 分析：先把需要判断的序列放进一维数组当中，给出数组的当前下标为0，然后1…N顺序入栈，如果元素入栈之后，栈的size大于M，则此序列不符合；如果栈的size小于等于M，在while循环中如果栈非空且其值等于此时的数组元素，则栈顶元素出栈，数组的下标自增一位。以上所有步骤进行K次。 注意：能用一维数组时尽量别用二维数组 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;stdlib.h&gt; using namespace std; int main() { int M, N, K; cin &gt;&gt; M &gt;&gt; N &gt;&gt; K; vector&lt;int&gt; a(N);//定义可变长的一维数组 stack&lt;int&gt; st;//引入STL中的栈 for (int i = 0;i &lt; K;i++) {//一共有K组数据 while (!st.empty()) st.pop();//清空栈 for (int j = 0;j &lt; N;j++) {//读入一组数据 cin &gt;&gt; a[j]; } int n=0; for (int x = 1;x &lt;= N;x++) { st.push(x); if (st.size() &gt; M) {//序列有误 break; }else{ while (!st.empty() &amp;&amp; st.top() == a[n]) {//如果栈非空且栈顶元素等于当前的序列当前位置值就把顶部元素出栈，验证序列后移一位 st.pop(); n++; } } } if (!st.empty()) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL基础]]></title>
    <url>%2F2018%2F03%2F21%2FMYSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[MySQL是最流行的关系型数据库管理系统(关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。)，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。由瑞典MySQL AB公司开发，目前属于Oracle公司。 1、MySQL的特点(1)MySQL是开源的，所以你不需要支付额外的费用。 (2)MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 (3)MySQL使用标准的SQL数据语言形式。 (4)MySQL可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。 (5)MySQL是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。 2、MySQL的管理(1)为MySQL数据库中的user表添加新用户root@host# mysql -u root -p Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; INSERT INTO user (host, user, password, select_priv, insert_priv, update_priv) VALUES (&apos;localhost&apos;, &apos;guest&apos;, PASSWORD(&apos;guest123&apos;), &apos;Y&apos;, &apos;Y&apos;, &apos;Y&apos;); Query OK, 1 row affected (0.20 sec) mysql&gt; FLUSH PRIVILEGES; Query OK, 1 row affected (0.01 sec) mysql&gt; SELECT host, user, password FROM user WHERE user = &apos;guest&apos;; +-----------+---------+------------------+ | host | user | password | +-----------+---------+------------------+ | localhost | guest | 6f8c114b58f2ce9e | +-----------+---------+------------------+ 1 row in set (0.00 sec) 注意需要执行FLUSH PRIVILEGES语句。 这个命令执行后会重新载入授权表。如果你不使用该命令，你就无法使用新创建的用户来连接MySQL服务器，除非你重启MySQL服务器。 你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下： Select_priv Insert_priv Update_priv Delete_priv Create_priv Drop_priv Reload_priv Shutdown_priv Process_priv File_priv Grant_priv References_priv Index_priv Alter_priv 另外一种添加用户的方法为通过SQL的GRANT命令，以下命令会给指定数据库TUTORIALS添加用户zara，密码为zara123 。 root@host# mysql -u root -p password; Enter password:******* mysql&gt; use mysql; Database changed mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP -&gt; ON TUTORIALS.* -&gt; TO &apos;zara&apos;@&apos;localhost&apos; -&gt; IDENTIFIED BY &apos;zara123&apos;; *MySQL的SQL语句以分号 (;) 作为结束标识。 (2)管理MySQL的命令a、USE 数据库名;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。mysql&gt; use RUNOOB; Database changed b、SHOW DATABASES;列出MySQL数据库管理系统当前的数据库列表。mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | RUNOOB | | cdcol | | mysql | | onethink | | performance_schema | | phpmyadmin | | test | | wecenter | | wordpress | +--------------------+ 10 rows in set (0.02 sec) c、SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用USE命令来选择要操作的数据库。mysql&gt; use RUNOOB; Database changed mysql&gt; SHOW TABLES; +------------------+ | Tables_in_runoob | +------------------+ | employee_tbl | | runoob_tbl | | tcount_tbl | +------------------+ 3 rows in set (0.00 sec) d、SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。mysql&gt; SHOW COLUMNS FROM runoob_tbl; +-----------------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+--------------+------+-----+---------+-------+ | runoob_id | int(11) | NO | PRI | NULL | | | runoob_title | varchar(255) | YES | | NULL | | | runoob_author | varchar(255) | YES | | NULL | | | submission_date | date | YES | | NULL | | +-----------------+--------------+------+-----+---------+-------+ 4 rows in set (0.01 sec) e、SHOW INDEX FROM 数据表;显示数据表的详细索引信息，包括PRIMARY KEY（主键）。mysql&gt; SHOW INDEX FROM runoob_tbl; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | runoob_tbl | 0 | PRIMARY | 1 | runoob_id | A | 2 | NULL | NULL | | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set (0.00 sec) f、SHOW TABLE STATUS LIKE [FROM db_name] [LIKE ‘pattern’] \G;该命令将输出Mysql数据库管理系统的性能及统计信息。mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;; # 表名以runoob开头的表的信息 mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;\G; # 加上 \G，查询结果按列打印 3、数据库的基本操作语句(1)创建数据表CREATE TABLE table_name (column_name column_type); root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.16 sec) mysql&gt; *如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL，在操作数据库时如果输入该字段的数据为NULL ，就会报错。 *AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 *PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 *ENGINE 设置存储引擎，CHARSET 设置编码。 (2)删除数据表DROP TABLE table_name ; root@host# mysql -u root -p Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; DROP TABLE runoob_tbl Query OK, 0 rows affected (0.8 sec) mysql&gt; 查看一下： mysql&gt; show tables; Empty set (0.01 sec) (3)插入数据INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1,value2,...valueN ); root@host# mysql -u root -p password; Enter password:******* mysql&gt; use RUNOOB; Database changed mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW()); Query OK, 1 rows affected, 1 warnings (0.01 sec) mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;); Query OK, 1 rows affected (0.00 sec) mysql&gt; *如果数据是字符型，必须使用单引号或者双引号，如：&quot;value&quot;。 *使用箭头标记-&gt;不是SQL语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写SQL语句，SQL语句的命令结束符为分号 ;。 (4)查询数据SELECT column_name,column_name FROM table_name [WHERE Clause][LIMIT N][ OFFSET M]; select * from runoob_tbl; SELECT * from runoob_tbl WHERE runoob_author=&apos;菜鸟教程&apos;; *查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 *SELECT 命令可以读取一条或者多条记录。你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 *你可以使用 WHERE 语句来包含任何条件。例如使用 AND 或者 OR 指定一个或多个条件。WHERE子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。WHERE子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 *你可以使用 LIMIT 属性来设定返回的记录数。 *你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 (5)更新数据表UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]; mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3; Query OK, 1 rows affected (0.01 sec) mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3; +-----------+--------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+--------------+---------------+-----------------+ | 3 | 学习 C++ | RUNOOB.COM | 2016-05-06 | +-----------+--------------+---------------+-----------------+ 1 rows in set (0.01 sec) *你可以同时更新一个或多个字段。 *你可以在 WHERE 子句中指定任何条件。 *你可以在一个单独表中同时更新数据。 (6)删除MySQL数据表中的记录DELETE FROM table_name [WHERE Clause]; mysql&gt; use RUNOOB; Database changed mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3; Query OK, 1 row affected (0.23 sec) *如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 *你可以在 WHERE 子句中指定任何条件 *您可以在单个表中一次性删除记录。 (7)删除，添加或修改表字段删除：ALTER TABLE alter_tbl DROP columnname;删除指定字段 添加：ALTER TABLE alter_tbl ADD new_column_name new_typename AFTER columnname;指定添加位置 修改： ALTER TABLE alter_tbl MODIFY columnname new_typename;修改字段类型 ALTER TABLE alter_tbl CHANGE oldcolumnname newcolumnname newtypename;修改字段及类型 ALTER TABLE alter_tbl RENAME TO alter_tb2;修改表名 (8)UNION操作符SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; 使用 UNION ALL 从 &quot;Websites&quot; 和 &quot;apps&quot; 表中选取所有的中国(CN)的数据（也有重复的值）： SELECT country, name FROM Websites WHERE country=&apos;CN&apos; UNION ALL SELECT country, app_name FROM apps WHERE country=&apos;CN&apos; ORDER BY country; *expression1, expression2, ... expression_n: 要检索的列。 *tables: 要检索的数据表。 *WHERE conditions: 可选，检索条件。 *DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 *UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值。 (9)排序SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]]; SELECT * from runoob_tbl ORDER BY submission_date ASC; SELECT * from runoob_tbl ORDER BY submission_date DESC; *你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 *你可以设定多个字段来排序。 *你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列。 *你可以添加 WHERE...LIKE 子句来设置条件。 (10)GROUP BY语法SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;将数据表按名字进行分组，并统计每个人有多少条记录 (11)LIKE子句SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; 在 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录： mysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE &apos;%COM&apos;; +-----------+---------------+---------------+-----------------+ | runoob_id | runoob_title | runoob_author | submission_date | +-----------+---------------+---------------+-----------------+ | 3 | 学习 Java | RUNOOB.COM | 2015-05-01 | | 4 | 学习 Python | RUNOOB.COM | 2016-03-06 | +-----------+---------------+---------------+-----------------+ 2 rows in set (0.01 sec) *你可以在 WHERE 子句中指定任何条件。 *你可以在 WHERE 子句中使用LIKE子句。 *你可以使用LIKE子句代替等号 =。 *LIKE子句中使用百分号 % 字符来表示任意字符，类似于UNIX或正则表达式中的星号 * 。 *你可以使用 AND 或者 OR 指定一个或多个条件。 *你可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件。 (12)连接的使用INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 a、内连接示例 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; 等价于 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author; b、左连接示例 读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; c、右连接示例 读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; (13)NULL值处理IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 *关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。 *在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。 (14)索引CREATE INDEX indexName ON mytable(username(length)); 创建索引 ALTER table tableName ADD INDEX indexName(columnName); 修改表结构(添加索引) 创建表的时候直接指定索引 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); DROP INDEX [indexName] ON mytable; 删除索引 CREATE UNIQUE INDEX indexName ON mytable(username(length)); 创建唯一索引 ALTER table mytable ADD UNIQUE [indexName] (username(length)); 修改表结构 创建表的时候直接指定唯一索引 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1052 Linked List Sorting]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1052-Linked-List-Sorting%2F</url>
    <content type="text"><![CDATA[A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification: Each input file contains one test case. For each case, the first line contains a positive N (&lt; 105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Key next where Address is the address of the node in memory, Key is an integer in [-105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification: For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input: 5 00001 11111 100 -1 00001 0 22222 33333 100000 11111 12345 -1 33333 22222 1000 12345 Sample Output: 5 12345 12345 -1 00001 00001 0 11111 11111 100 22222 22222 1000 33333 33333 100000 -1 题目大意：给出一个静态链表，将链表按照数据域data的值从小到大进行排序，然后把排序后的静态链表上的结点从头结点顺序输出。 分析：建立存储静态节点的结构体数组，从首节点开始的顺序(直到-1)遍历整个静态链表，将在静态链表中节点的flag标记为true，并且统计count(有效结点的个数)大小，这里是因为有的你输入的节点根本不在静态链表上。之后将静态链表进行排序，这里需要进行二次排序：如果两个节点中有一个节点的标志位为false就把它移动到后面(reuturn a.flag&gt;b.flag)，否则就按照节点数据域从小到大进行排序(return a.data&lt;b.data)。最后只输出前count个静态链表节点。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;stdlib.h&gt; using namespace std; const int maxn = 100010; struct Node { int address; int data; int next; bool flag; }node[maxn]; bool cmp(Node a, Node b) { if (a.flag == false || b.flag == false) { return a.flag &gt; b.flag;//将无效节点放到后面 } else { return a.data &lt; b.data;//按照数据域的顺序从大到小排列 } } int main() { int n, x; cin &gt;&gt; n &gt;&gt; x; int address, data, next; for (int i = 0;i&lt;n;i++) {//初始化静态链表 cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].address = address; node[address].data = data; node[address].next = next; } for (int i = 0;i &lt; maxn;i++) { node[i].flag = false;//初始化标志位 } int count = 0; while (x != -1) {//遍历静态链表，对有效的节点进行标记，同时统计有效节点的个数(因为存在一些你输入的节点但是不在链表上情况) node[x].flag = true; count++; x = node[x].next; } if (count == 0) {//如果头结点为-1，即链表中没有节点 cout &lt;&lt; &quot;0 -1&quot; &lt;&lt; endl; } else { sort(node, node + maxn, cmp);//筛选有效节点，按data从小到大排列 printf(&quot;%d %05d\n&quot;, count, node[0].address); for (int i = 0;i &lt; count;i++) { if (i==count-1) printf(&quot;%05d %d -1\n&quot;, node[i].address, node[i].data); else printf(&quot;%05d %d %05d\n&quot;, node[i].address, node[i].data, node[i+1].address); } } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1032 Sharing]]></title>
    <url>%2F2018%2F03%2F20%2FPAT-A1032-Sharing%2F</url>
    <content type="text"><![CDATA[To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, “loading” and “being” are stored as showed in Figure 1.You are supposed to find the starting position of the common suffix (e.g. the position of “i” in Figure 1). Input Specification: Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (&lt;= 105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1.Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node. Output Specification: For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output “-1” instead. Sample Input 1: 11111 22222 9 67890 i 00002 00010 a 12345 00003 g -1 12345 D 67890 00002 n 00003 22222 B 23456 11111 L 00001 23456 e 67890 00001 o 00010 Sample Output 1: 67890 Sample Input 2: 00001 00002 4 00001 a 10001 10001 s -1 00002 a 10002 10002 t -1 Sample Output 2: -1 题目大意：求两个存储英语单词的字母链表的首个公共结点的地址。如果没有，就输出-1 分析：本题是在链表当中寻找起始公共节点的位置且地址的范围比较小，此处选择使用静态链表来处理。用结构体数组进行存储，node[i]表示地址为i的结点，data表示值，next为下一个结点的地址，flag表示第一条链表有没有该结点。遍历第一条链表，将访问过的结点的flag都标记为true，当遍历第二条结点的时候，如果遇到了true的结点就输出并结束程序，没有遇到就输出-1。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct Node { char data; int next; bool flag;//用于判断公共节点的初始位置 }node[100010]; void Create(int n) {//创建一个静态链表 int address, next; char data; for (int i = 0;i &lt; 100010;i++) {//初始化链表节点的标志为false node[i].flag = false; } for (int i = 0;i &lt; n;i++) { cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; node[address].data = data; node[address].next = next; } } int main() { int x, y, n,i; cin &gt;&gt; x &gt;&gt; y &gt;&gt; n; Create(n);//创建一个静态链表 for (i = x;i != -1;i = node[i].next) {//将第一个单词走过的节点的标志位设为true node[i].flag = true; } for (i = y;i != -1;i = node[i].next) { if (node[i].flag == true) { printf(&quot;%5d&quot;, i);//如果此时的节点的标志位为true说明是公共节点 system(&quot;pause&quot;); return 0; } } printf(&quot;-1&quot;);//否则输出-1 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表属于线性表中的一种数据结构，它由若干个节点组成(每个节点代表一个元素)，且节点在内存中的存储位置通常是不连续的。这里我们先来了解动态链表，动态链表的两个节点之间一般通过一个指针来从一个节点指向另一个节点 ，因此动态链表的节点一般由两部分构成，即数据域和指针域： struct node{ int data; node* next; }; (1)创建一个动态链表： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std; struct node { int data; node* next; }; node* create(int Array[]) { node *p, *pre, *head;//pre保存当前节点的前驱节点，head为头结点 head = new node;//创建头结点 head-&gt;next = NULL;//头结点不需要数据，且指针域指向NULL pre = head;//记录pre为head for (int i = 0;i &lt; 5;i++) { p = new node;//新建节点 p-&gt;data = Array[i];//将Array[i]赋给新建的节点作为数据域，也可以cin输入 p-&gt;next = NULL;//新节点的指针域设为NULL pre-&gt;next = p;//前驱节点的指针域设为当前新建节点的地址 pre = p;//把p设为pre，作为下一个节点的前驱节点 } return head;//返回头结点指针 } int main() { int Array[5] = { 5,3,6,1,2 }; node* L = create(Array);//新建链表，返回头指针head给L L = L-&gt;next;//从第一个节点开始有数据域 while (L != NULL) { cout &lt;&lt; L-&gt;data &lt;&lt; endl;//输出每个节点的数据域 L = L-&gt;next; } system(&quot;pause&quot;); return 0; } (2)动态链表查找元素： int search(node* head, int x) { int count = 0;//计数器 node* p = head-&gt;next;//指向链表的第一个节点 while (p != NULL) {//遍历整个链表 if (p-&gt;data == x) count++;//当节点数据域为x时，则count++ p = p-&gt;next;//指向下一个节点 } return count; } (3)动态链表插入元素： void insert(node* head, int pos, int x) { node* p = head;//指向链表的头节点 for (int i = 0;i &lt; pos - 1;i++) {//遍历到链表的pos-1的位置，即插入位置的前一个节点位置 p = p-&gt;next; } node* q = new node;//新建节点 q-&gt;data = x;//其数据域为x q-&gt;next = p-&gt;next;//新节点的下一个节点指向原先插入位置的节点 p-&gt;next = q;//前一个位置的节点指向新节点 } (4)动态链表删除元素： void del(node* head, int x) { node* p = head;//指向链表的头结点 node* q = p-&gt;next;//指向链表的第一个节点 while (q != NULL) { if (q-&gt;data == x) {//数据域为x，删除q节点 p-&gt;next = q-&gt;next;//删除q节点 delete(q);//释放内存空间 q = p-&gt;next; }else {//数据域不为x，p、q节点同时后移一位 p = q; q = q-&gt;next; } } } 以上所述都是动态链表的范畴，需要指针来建立节点之间的连接关系。而对于有些问题来说，节点的地址是比较小的整数(例如5位数的地址)，这样就没有必要去建立动态链表，而应该使用方便得多的静态链表。静态链表的实现原理是hash，即通过建立一个结构体数组，并令数组的下标直接表示节点的地址，以此来达到直接访问数组中的元素就能访问节点的效果。需要注意的是：在使用静态链表时，尽量不要把结构体类型名和结构体变量名取成相同的名字。其定义方法如下： struct Node{ typename date;//数据域 int next;//指针域 XXX;//节点的某个性质，不同的题目会有不同的设置 }node[maxn]; 其中的next是一个int型的整数，用来存放下一个节点的地址(事实上就是数组下标)，例如：如果初始节点的地址为11111，第二个节点的地址为22222，第三个节点的地址为33333，且第三个节点为链表末尾，那么整个静态链表的节点就可以通过下面的写法连接起来： node[11111].next=22222; node[22222].next=33333; node[33333].next=-1;//-1对应动态链表中的NULL，表示没有后继节点 一般来说，静态链表的初始化需要对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字(而常常需要小于所能达到的数字)，例： for(int i=0;i&lt;maxn;i++){ node[i].XXX=0; } 一般的题目都会给出一条静态链表的首节点的地址，因此我们可以依据这个地址来遍历得到整条链表。这一步同时也是对节点性质XXX进行标记，并且对有效节点的个数进行计数的时候，例如对节点是否在链表上这个性质来说，当我们遍历链表时，就可以把XXX置为1。 int p=begin,count=0; while(p!=-1){//-1代表静态链表结束 XXX=1; count++; p=node[p].next; } 由于使用静态链表时时直接采用地址映射的方式，这就会使得数组小标的不连续。而很多时候题目给出的节点并不都是有效节点(即不在静态链表上的节点)。为了能够可控地访问有效节点，一般都需要对数组进行排序来把有效节点移动到数组的左端。这里我们用到上面所提及的XXX，这也就是为什么在XXX进行初始化时要取比正常取值要小的值。因为无效节点并不会执行XXX=1这一步，因此一定比有效节点的XXX小。于是在写sort函数的排序函数cmp时就可以在cmp的两个参数节点中有无效节点时按XXX从大到小排序，这样就能把有效节点全部移动到数组左端。当然，在cmp函数中还可以有第二级的排序，例如：题目可能要求把链表按节点顺序排序，此时就需要在cmp函数中建立第二级的排序： bool cmp(Node a,Node b){ if(a.XXX==-1||b.XXX==-1){//如果有节点是无效节点，就把它放到数组的后端 return a.XXX&gt;b.XXX; }else{//否则就按节点的数据域从大到小排序 return a.data&gt;b.data; } }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++申请动态内存]]></title>
    <url>%2F2018%2F03%2F19%2FC-C%2B%2B%E7%94%B3%E8%AF%B7%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[(1)malloc函数 malloc函数是C语言中#include&lt;stdlib.h&gt;头文件下用于申请动态内存的函数，其返回类型是申请的同变量类型的指针，其基本用法如下： typename* p=(typename*)malloc(sizeof(typename)); int* p=(int*)malloc(sizeof(int)); node* p=(node*)malloc(sizeof(node)); 这个写法的解释如下：以需要申请的内存空间大小(即sizeof(node))为malloc函数的参数，这样malloc函数就会向内存申请一块大小为sizeof(node)的空间，并且返回指向这块空间的指针。但是此时这个指针是一个为确定类型的指针void*，因此需要把它强制转换成node型的指针，在malloc之前加上(node)。再把这个指针赋给node*型的指针变量p，就成功地申请了一块node类型大小的内存空间。如果申请失败，则会返回空指针NULL。申请失败一般在使用malloc申请了较大动态数组时发生。 在使用完malloc开辟出来的空间后必须将其释放，否则会造成内存的泄露。malloc函数需要使用free函数来进行内存的释放。假设需要释放的内存空间的指针变量为p，则：free(p);就可以实现内存的释放了。 (2)new运算符 new是C++中用来申请动态空间的运算符，其返回类型同样是申请的同变量类型的指针，其基本用法如下： typename* p=new typename; int* p=new int; node* p=new node; 相比于malloc函数来说，new的写法要简洁得多。另外，如果new运算符申请动态空间失败，则会启动异常机制处理而不是像malloc那样返回NULL。和malloc一样的是：申请失败一般是在申请了较大动态数组时发生。与此同时，new运算符也有对应的释放内存函数：delete(p);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeup 1918 简单计算器]]></title>
    <url>%2F2018%2F03%2F19%2FCodeup-1918-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述： 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入： 测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出： 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 样例输入： 30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 * 6 + 51 / 29 + 79 * 87 + 57 * 92 0 样例输出： 12178.21 分析：本题需要分两个步骤进行解答：一是中缀表达式转化为后缀表达式；二是计算后缀表达式。 步骤一： (1)分别设立一个操作符栈和一个队列，操作符栈用来暂时存放操作符，而队列则用来存放后缀表达式。 (2)从左到右扫描中缀表达式。 (3)如果碰到操作数(这里的操作数可能占几位，所以需要一位一位读取再合并)，就把操作数处理之后加入后缀表达式中。如果碰到的是操 作符，就将其优先级与操作符栈的栈顶元素比较：如果优先级高于栈顶操作符则直接入栈；如果优先级小于或等于栈顶操作符，则将操作符 栈的操作符不断弹出到后缀表达式，直到其优先级高于栈顶操作符为止。 (4)重复执行(2)(3)步骤，直到中缀表达式扫描完为止，之后若操作符栈中还有元素，则将他们依次弹出至后缀表达式当中。 步骤二： 从左到右扫描后缀表达式，如果是操作数，则压入栈中；如果是操作符，就连续弹出两个操作数(这里先弹出的是第二操作数，后弹出的是 第一操作数)，然后进行操作符的运算，生成的新操作符压入栈中。反复执行，直到后缀表达式扫描完毕。此时栈中只剩下一个数，就是计算 结果。 注意： (1)操作数的类型需要设置为double型。 (2)为了便于在后缀表达式中判断出队的是操作符还是操作数，这里使用了具有操作数、操作符和判别两者类型的bool类型的结构体， 当然，在这种情况之下就需要引进STL中的queue和stack容器来存储相应的结构体类型的数据。 (3)另外还需要引进STL中的map容器，从而来定义操作符所对应的优先级。 具体的程序如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; struct node { double num;//操作数 char op;//操作符 bool flag;//true表示操作数，false表示操作符 }; string s; queue&lt;node&gt; q;//定义node类型的队列用于存储后缀表达式 stack&lt;node&gt; st;//定义node类型的栈用于在转化为后缀表达式时暂存操作符和在计算后缀表达式时存储操作数 map&lt;char, int&gt; op;//map用于匹配操作符和优先级数字 void Change() {//将中缀表达式转化为后缀表达式 node temp; for (string::iterator it = s.begin();it != s.end();it++) {//删除字符串当中的空格 if (*it == &apos; &apos;) s.erase(it); } for (int i = 0;i &lt; s.length();) { if (s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) {//如果是数字的话 temp.flag = true;//标记为数字 temp.num = s[i++] - &apos;0&apos;; while (i&lt;s.length()&amp;&amp;s[i] &gt;= &apos;0&apos;&amp;&amp;s[i] &lt;= &apos;9&apos;) { temp.num = temp.num * 10 + (s[i++] - &apos;0&apos;); } q.push(temp);//将操作数压入后缀表达式队列 }else {//如果是操作符 temp.flag = false; while (!st.empty() &amp;&amp; op[s[i]] &lt;= op[st.top().op]) {//如果栈不空且当前操作符的优先级小于等于栈顶的优先级 q.push(st.top());//将栈顶元素放入后缀表达式队列 st.pop();//栈顶元素出栈 } temp.op = s[i++]; st.push(temp);//将此操作符入栈 } } while (!st.empty()) {//如果栈中还有操作符就把它们都放入后缀表达式队列 q.push(st.top()); st.pop(); } } double Calculate() {//计算后缀表达式 double temp1=0, temp2=0; node temp; while (!st.empty()) st.pop();//将栈清空 while (!q.empty()) { if (q.front().flag == true) st.push(q.front());//如果是操作数就直接入栈 else {//如果是操作符 temp2 = st.top().num;//取第二个操作数 st.pop();//栈顶元素出栈 temp1 = st.top().num;//取第一个操作数 st.pop(); if (q.front().op == &apos;+&apos;) temp.num = temp1 + temp2; else if (q.front().op == &apos;-&apos;) temp.num = temp1 - temp2; else if (q.front().op == &apos;*&apos;) temp.num = temp1*temp2; else temp.num = temp1 / temp2; temp.flag = true; st.push(temp);//将本次的计算结果压入栈中 } q.pop();//将该操作符或者操作数出队列 } return st.top().num;//返回后缀表达式的计算结果 } int main() { op[&apos;+&apos;] = op[&apos;-&apos;] = 1;//map设定操作符的优先级 op[&apos;*&apos;] = op[&apos;/&apos;] = 2; while (getline(cin, s), s != &quot;0&quot;) { while (!st.empty()) st.pop();//初始化栈 Change();//将中缀表达式转化为后缀表达式 printf(&quot;%.2f\n&quot;,Calculate());//计算后缀表达式 } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Codeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1060 Are They Equal]]></title>
    <url>%2F2018%2F03%2F19%2FPAT-A1060-Are-They-Equal%2F</url>
    <content type="text"><![CDATA[If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123*105 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification: Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10100, and that its total digit number is less than 100. Output Specification: For each test case, print in a line “YES” if the two numbers are treated equal, and then the number in the standard form “0.d1…dN*10^k” (d1&gt;0 unless the number is 0); or “NO” if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1: 3 12300 12358.9 Sample Output 1: YES 0.123*10^5 Sample Input 2: 3 120 128 Sample Output 2: NO 0.120*10^3 0.128*10^3 题目大意：给出两个数，问将它们写成保留N位小数的科学计数法后是否相等。如果相等，输出YES，同时输出他们的科学记数法表示的方式；如果不相等输出NO，分别输出他们的科学计数法表示方式。 注意：无需四舍五入。 分析：将两个数以字符串的形式输入，如果他们有前导0则删除前导0。删除前导0之后会碰到两种情况：如果是小数点，说明这个数小于1，接下来将小数点删除，如果删除小数点之后的那个数值是0需要把0删除同时令指数相应地减1，直到不为0为止；如果不是小数点的话，则在while循环当中去寻找后面可能存在的小数点，在没有找到小数点之前，字符串下标每向后移动一位，指数便加1。跳出while循环之后，如果字符串下标小于字符串此时的长度，说明找到了小数点，删除小数点。在这两种情况都处理完之后，如果字符串的长度为0，则说明这个数为0。接下来令数组下标为0，在while循环中只要题目要求的精度没有达到就不断执行。而只要字符串此时的下标还小于字符串的长度就直接把数字加到新字符串的末尾，否则就添0。 #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string&gt; using namespace std; int n;//有效位数 string deal(string s, int &amp;e) { int k = 0;//s的下标 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除前导0 } if (s[0] == &apos;.&apos;) {//删除前导0之后是小数点，说明s是小于1的小数 s.erase(s.begin());//删除小数点 while (s.length() &gt; 0 &amp;&amp; s[0] == &apos;0&apos;) { s.erase(s.begin());//删除小数点后非0位前的所有0 e--;//每删除一个0，指数就减1 } }else {//删除前导0之后不是小数点，则找到后面的小数点删除 while (k &lt; s.length() &amp;&amp; s[k] != &apos;.&apos;) { k++; e++;//只要没碰到小数点指数就加1 } if (k &lt; s.length()) s.erase(s.begin() + k);//如果此时k&lt;s.length()则说明碰到了小数点，删除小数点 } if (s.length() == 0) e = 0;//删除前导0之后s的长度变为0，说明这个数是0 int num = 0; k = 0; string res; while (num &lt; n) { if (k &lt; s.length()) res += s[k++];//只要还有数字，就加到res的末尾 else res += &apos;0&apos;;//否则就在res的末尾加0 num++;//精度加1 } return res; } int main() { string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if (s3 == s4&amp;&amp;e1 == e2) cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; endl; else cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot;&lt;&lt; e2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>PAT A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的sort函数]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84sort%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[sort()函数使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)。要使用algorithm头文件下的sort()函数,需要加上#include头文件和”using namespace std;” 1、在介绍sort()函数之前,先来了解algorithm头文件下一些其他的函数 (1)max(x,y)和min(x,y)分别返回x和y中的最大值和最小值(x和y可以是浮点数)。 (2)abs(x)返回x的绝对值,这里的x必须是整数,浮点数需要使用math头文件下的fabs。 (3)swap()用来交换x和y的值,注意:这里的swap()函数和Java中的swap()函数有着本质的不同。 (4)reverse(x,y)将数组指针在[x,y)之间的元素或容器的迭代器在[x,y)范围内的元素进行反转。 (5)next_permutation(x,y)给出一个序列在全排列的下一个序列。 (6)fill(x,y,a)可以把数组或容器中的array[x]~array[y-1]区间赋值为a。和memset不同,这里的赋值可以是数组类型对应范围中的任意值。 (7)lower_bound(first,last,val)和upper_bound(first,last,val)分别用来寻找在数组或容器[first,last)范围内第一个值大于等于val和第一个值大于val的元素的位置,如果是数组,则返回该位置的指针;如果是容器,则返回该位置的迭代器。如果数组或者容器中没有需要寻找的元素,则两个函数均返回可以插入该元素的位置的指针或者迭代器,它们的时间复杂度均为O(log(last-first))。 2、sort()函数 (1)使用方式:sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数(非必填)); 如果不填比较函数,则默认对前面给出的区间[first,last)进行递增排序。 (2)比较函数cmp a、基本数据类型数组的排序 bool cmp(int a,int b){//int型数据递减排序 return a&gt;b;//当a&gt;b是把a放在b前面 } bool cmp(double a,double b){//double型数据递减排序 return a&gt;b; } bool cmp(char a,char b){//char型数据递减排序 return a&gt;b; } 其实这里也可不必如此:sort(a,a+10,greater&lt;typename&gt;());也可以实现以上三个比较函数的功能。 b、结构体数组的排序 struct node{ int x,y; }st[10]; bool cmp(node a,node b){//递减排序 return a.x&gt;b.x; } bool cmp(node a,node b){//先按x从大到小排序,但当x相等时,按照y从小到大来排序 if(a.x!=b.x) return a.x&gt;b.x; else return a.y&lt;b.y; } sort(st,st+3,cmp);//对下标为0,1,2的结构体类型排序 c、容器的排序 在STL标准容器中,只有vector、string、deque是可以使用sort的。这是因为set、map这种容器是用红黑树实现的,元素本身有序,故不允许使用sort排序。以vector为例: bool cmp(int a,int b){ return a&gt;b; } vector&lt;int&gt; v; v.push_back(3); v.push_back(1); v.push_back(2); sort(v.begin(),v.end(),cmp);//对整个vector排序]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的stack]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84stack%2F</url>
    <content type="text"><![CDATA[在编程过程中，常常使用stack用来模拟实现一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函数来递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题。stack是一种先进后出的数据结构。要使用stack，必须包含头文件#include还有命名空间”using namespace std;”。 1、stack的定义:stack&lt;typename> name;例如: stack&lt;int&gt; name; 2、stack容器内元素的访问 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main(){ stack&lt;int&gt; st; for(int i=1;i&lt;=5;i++){ st.push(i);//push(i)将i压入队列 } cout&lt;&lt;st.top();//取栈顶元素 return 0; } 3、stack常用的函数 (1)push(x):将x进行入栈，时间复杂度为O(1)。 (2)pop():栈顶元素出栈，时间复杂度为O(1)。 (3)top():获得栈顶元素，时间复杂度为O(1)。 (4)empty():检测stack是否为空，时间复杂度为O(1)。 (5)size():返回stack内的元素个数，时间复杂度为O(1)。 (6)STL中没有实现栈的清空，如果需要实现栈的清空，可以用一个while循环反复pop出元素直到栈为空： while(!st.empty){ st.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的queue]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84queue%2F</url>
    <content type="text"><![CDATA[在编程过程中，当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue作为代替，以提高程序的准确性。要使用queue，必须包含头文件#include还有命名空间”using namespace std;”。STL的容器中还有两种容器和队列有关，分别是双端队列(deque)和优先队列(priority_queue)，前者是首位皆可以插入和删除的队列，后者是使用堆实现的默认将当前队列最大元素置于队首的容器。 1、queue的定义:queue&lt;typename> name;例如: queue&lt;int&gt; name;//typename可以是任意基本数据类型或容器 2、queue容器内元素的访问 由于队列queue是一种先进先出的限制性数据结构,因此在STL中只能通过front()来访问队首元素,或者通过back()来访问队尾元素。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main(){ queue&lt;int&gt; q; for(int i=1;i&lt;=5;i++){ q.push(i);//push(i)将i压入队列 } cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;&lt;&lt;q.back(); return 0; } 3、queue常用的函数 (1)push(x):将x进行入队，时间复杂度为O(1)。 (2)pop():令队首元素出队，时间复杂度为O(1)。使用pop()函数之前必须用empty()判断队列是否为空。 (3)front():获得队首元素，时间复杂度为O(1)。使用front()函数之前必须用empty()判断队列是否为空。 (4)back():获得队尾元素，时间复杂度为O(1)。 (5)empty():检测queue是否为空，时间复杂度为O(1)。 (6)size():返回queue内的元素个数，时间复杂度为O(1)。 (7)STL中没有实现队列的清空，如果需要实现队列的清空，可以用一个while循环反复pop出元素直到队列为空： while(!q.empty){ q.pop(); }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的map]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B%E4%B8%AD%E7%9A%84map%2F</url>
    <content type="text"><![CDATA[在编程过程中，如果需要建立字符(或者字符串)与整数之间的映射;判断大整数或者其他类型数据是否存在;甚至是字符串和字符串之间的映射。此时我们应当想到map，因为map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)。map和其他的STL容器有点不一样，因为map需要确定映射前类型(键key)和映射后类型(值value),所以需要在&lt;&gt;内填写两个类型。需要注意的是:map中的键是唯一的，而且map会以键从小到大的顺序自动排序(这是由于map内部是使用红黑树实现的，set也是，在建立映射的过程中会自动实现从小到大的排序功能)。如果需要使用map，必须包含头文件#include还有命名空间”using namespace std;”。 1、map的定义:map&lt;typename1,typename2> name;例如: map&lt;string,int&gt; name;//如果是字符串到整型的映射，必须使用string而不能用char数组 map&lt;set&lt;int&gt;,string&gt; name;//将一个set容器映射到一个字符串 2、map容器内元素的访问 (1)通过下标访问，例如：一个定义为map&lt;char,int&gt; name的map来说，可以直接使用name[&apos;c&apos;]来访问对应的整数。 (2)通过迭代器访问,其定义是:map&lt;typename1,typename2&gt;::iterator it;但map迭代器的使用方式和其他STL容器的迭代器不同,因为map的每一对映射都有两个typename,此时我们可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main(){ map&lt;char,int&gt; mp; mp[&apos;m&apos;]=20; mp[&apos;r&apos;]=30; mp[&apos;a&apos;]=40; for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,map的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 3、map常用的函数 (1)find(key):用以返回键为key的映射的迭代器，时间复杂度为O(logN)。map&lt;char,int&gt;::iterator it=mp.find(&apos;b&apos;) (2)size():用来获得map中映射的对数，时间复杂度为O(1)。 (3)clear():用来清空map中的所有元素，时间复杂度为O(N)。 (4)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:mp.erase(it),it位所需要删除元素的迭代器,时间复杂度O(1);mp.erase(key),key为欲删除的映射的键,时间复杂度为O(logN)。删除一个区间内的所有元素:mp.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。时间复杂度为O(last-first)。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的set]]></title>
    <url>%2F2018%2F03%2F17%2FC%2B%2B%E4%B8%AD%E7%9A%84set%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现去掉重复元素的情况，而且有可能因为这些元素比较大或者类型不是int型而不能直接开散列表。此时我们应当想到set，set是关联式容器。其作为一个容器是用来存储同一类型数据的数据类型，比如：int、char、double、结构体等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行递增排序,这是因为其内部是用红黑树实现的。如果需要使用set，必须包含头文件#include还有命名空间”using namespace std;”。 1、set的定义:set&lt;typename> name;例如: set&lt;int&gt; name; //声明一个int容器 set&lt;int&gt; name(10); //声明一个初始大小为10的int型容器 set&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型容器 set&lt;int&gt; name(a); //声明一个初始大小为a的int型容器 set&lt;node&gt; name; //node是结构体的类型 如果typename是set，定义的时候记得在&gt;&gt;符号之间加上空格: set&lt;set&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、set数组的定义:set&lt;typename> arrayname[arraysize];例如: set&lt;int&gt; a[100];//a[0]~a[99]中的每一个都是一个set容器 与set&lt;set&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、set容器内元素的访问 set只能通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:set&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问set中的元素例如: #include&lt;iostream&gt; #include&lt;set&gt; using namespace std ; int main(){ set&lt;int&gt; a; a.insert(3);//将3插入set中 a.insert(5); a.insert(2); a.insert(3); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++){//a.begin()为取a的首元素地址，而it指向这个地址 cout&lt;&lt;*it; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,set的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。另外,除vector和string之外的STL容器都不支持*(it+i)的访问方式。因此只能按如上的方式枚举。 4、set常用的函数 (1)insert(x):在set容器中添加一个元素,并自动递增排序,时间复杂度为O(logN),N为set内元素个数。 (2)find(x):用以返回set中对应值为x的迭代器，时间复杂度为O(logN)。set&lt;int&gt;::iterator it=a.find(2) (3)size():用来获得set中的元素的个数，时间复杂度为O(1)。 (4)clear():用来清空set中的所有元素，时间复杂度为O(N)。 (5)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(1);a.erase(x),x为所要删除元素的值,时间复杂度为O(logN)。删除一个区间内的所有元素:a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的vector]]></title>
    <url>%2F2018%2F03%2F16%2FC%2B%2B%E4%B8%AD%E7%9A%84vector%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现普通数组浪费大量的内存空间或者无法使用邻接矩阵(节点数太多)又害怕使用指针实现邻接表的情况。此时我们应当想到vector。向量vector是一种对象实体, 能够容纳许多其他类型相同的元素,比如：int、char、double、结构体等。 因此又被称为容器。与string相同,vector同属于STL(Standard Template Library,标准模板库)中的一种自定义的数据类型, 可以广义上认为是数组的增强版。vector是一个能够存放任意类型的动态数组。如果需要使用vector，必须包含头文件#include还有命名空间”using namespace std;”。 1、vector的定义:vector&lt;typename> name;例如: vector&lt;int&gt; name; //声明一个int向量 vector&lt;int&gt; name(10); //声明一个初始大小为10的int型向量 vector&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型向量 vector&lt;int&gt; name(a); //声明一个初始大小为a的int型向量 vector&lt;node&gt; name; //node是结构体的类型 如果typename是vector，定义的时候记得在&gt;&gt;符号之间加上空格: vector&lt;vector&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、vector数组的定义:vector&lt;typename> arrayname[arraysize];例如: vector&lt;int&gt; vi[100];//vi[0]~vi[99]中的每一个都是一个vector容器 与vector&lt;vector&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、vector容器内元素的访问 (1)通过下标访问，即vi[0]~vi[size-1]进行访问。 (2)通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:vector&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问vector中的元素例如: #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std ; int main(){ vector&lt;int&gt; vi; for(int i=1;i&lt;=5;i++){ vi.push_back(i); } vector&lt;int&gt;::iterator it=vi.begin();//vi.begin()为取vi的首元素地址，而it指向这个地址 for(int i=0;i&lt;5;i++){ cout&lt;&lt;*(it+i); } return 0; } 上述程序中出现了去vi的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。另外，vector的迭代器不支持it&lt;vi.end()的写法，因此循环条件只能用it!=vi.end()。除此之外，迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 (3)定义并初始化动态的二维数组，然后遍历。 vector&lt;vector&lt;int&gt; &gt; array(n);//定义一个存储数塔的动态二维数组 for (int i = 0;i &lt; n;i++) { array[i].resize(5); for (int j = 0;j &lt; array[0].size();j++) { cin &gt;&gt; array[i][j];//初始化 } } vector&lt;int&gt;::iterator it; vector&lt;vector&lt;int&gt; &gt;::iterator iter; vector&lt;int&gt; tmp; for (iter = array.begin();iter != array.end();iter++) { tmp = *iter; for (it = tmp.begin();it != tmp.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//遍历 } cout &lt;&lt; endl; } 4、vector常用的函数 (1)push_back(x):在vector后面添加一个元素，时间复杂度为O(1)。 (2)pop_back():用以删除vector的尾元素，时间复杂度为O(1)。 (3)size():用来获得vector中的元素的个数，时间复杂度为O(1)。返回的是unsigned类型。 (4)clear():用来清空vector中的所有元素，时间复杂度为O(N)。N为vector中元素的个数。 (5)insert(it,x):用来向vector的任意迭代器it处插入一个元素x，时间复杂度O(N)。 (6)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(N);a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题使用过程中所遇见的问题及解决措施]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[1、有时在hexo s之后本地没有问题，但是在hexo d推送到GitHub之后没有样式显示，此时很可能是GitHub网站本身的原因，稍微等等再刷新就没事了。实在不行的话就把刚才的修改内容改回之前的状态。先hexo clean清理缓存，再hexo g;hexo d刷新查看。 2、平时对博客的修改和更新直接使用hexo g;hexo s查看本地无误之后一般直接hexo d就行了。但是在其中某一步执行完报错之后，记得要先hexo clean再重新执行其他的操作。 3、博客在本地显示正常，hexo d到github上后只显示框架，内容空白时。进入next主题的source目录，将vendors文件的文件名改成任意其他名字，如：VEN。接着在next主题的配置文件_config.yml中,将vendors: 块中的_internal: vendors项改成前面重命名文件夹的名称,如_internal: VEN，保存。(注意在hexo中的大多数情况之下冒号和要填写数据之间必须有一个空格符，否则会在hexo g时便报错)。接下来hexo clean;hexo g;hexo d;打开博客主页，清理缓存，多刷新几次即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的除法]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的除法也可以叫做高精度与低精度的除法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相除呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从大整数的高位开始，上一步的余数(余数的初始值为0)乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步需要注意高位可能有多余的0，要去除，但同时也要保证至少有一位数。有一点需要注意的是：这里的除法函数当中使用了引用变量，引用不产生副本，而是给原变量取了一个别名，对引用变量的操作就是对原变量(即算法中的全局变量)的操作。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign divide(bign a, int b,int &amp;r) {//a/b bign c; c.len = a.len;//被除数的每一位和商的每一位是一一对应的。 for (int i = c.len - 1;i &gt;= 0;i--) {//从高位开始除。 r = r * 10 + a.d[i];//和上一位的余数进行组合。这里的r是引用变量，对引用变量的操作就是对原全局变量的操作。 if (r &lt; b) c.d[i] = 0;//不够除，该位的商为0。 else { c.d[i] = r / b;//商 r = r % b;//获得新的余数。 } } while((c.len-1&gt;=1)&amp;&amp;c.d[c.len-1]==0){ c.len--;//去除高位的0，同时至少保留一位最低位。 } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b,r=0; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(divide(a, b,r));//商 cout &lt;&lt;&quot; &quot;&lt;&lt; r;//余数 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的乘法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的乘法也可以叫做高精度与低精度的乘法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相乘呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从int型数组的低位开始取数与int型数据相乘，再与进位相加，所得的结果的个位数作为该位的结果，高部位作为新的进位。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign multi(bign a, int b) {//a*b bign c; int carry = 0;//进位 for (int i = 0;i &lt; a.len;i++) { int temp = a.d[i] * b + carry; c.d[c.len++] = temp % 10;//个位作为该位的结果。 carry = temp / 10;//高位部分作为新的进位。 } while (carry != 0) {//此处和加法略有不同，乘法的进位可能不止一位。 c.d[c.len++] = carry % 10; carry /= 10; } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(multi(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数减法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数减法又称之为高精度减法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相减呢？其实本质上和小学的减法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相减之前去比较两者的大小，如果是小的减大的则先把负号输出来，将两者进行交换之后再按大的减小的的步骤来。在减的过程中如果当前位是小减大，那么当前位先加10再减，被减数的当前位的下一位同时需要减1。在所有的位都彼此相减完之后，此时还需要考虑高位为0的情况：例如两数是相等的情况，那么就需要消去高位的0。完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign sub(bign a, bign b) {//a-b。 bign c; for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { if (a.d[i] &lt; b.d[i]) { a.d[i + 1]--;//向高位借位。 a.d[i] += 10;//当前位加10。 } c.d[c.len++] = a.d[i] - b.d[i];//当前位相减。 } while ((c.len - 1 &gt;= 1) &amp;&amp; c.d[c.len - 1] == 0) { c.len--;//去除高位的0，同时如果两数相等保留一个0。 } return c; } int compare(bign a, bign b) {//比较两数的大小，先比较长度，再比较各个位的数值大小。 if (a.len &gt; b.len) return 1;//a大 else if (b.len &gt; a.len) return -1;//b大 else { for (int i = a.len - 1;i &gt;= 0;i--) { if (a.d[i] &gt; b.d[i]) return 1; else if (a.d[i] &lt; b.d[i]) return -1; } return 0; } } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); if (compare(a, b) &lt; 0) {//如果a小于b，就交换。 cout &lt;&lt; &quot;-&quot;; bign c = a; a = b; b = c; } print(sub(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数加法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数加法又称之为高精度加法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相加呢？其实本质上和小学的加法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相加完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign add(bign a, bign b) {//a+b。 bign c; int carry = 0;//存储进位。 for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10;//两数之和的个位。 carry = temp / 10;//两数之和的十位。 } if (carry != 0) c.d[c.len++] = carry;//两个大整数的最高位相加之后有进位。 return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); print(add(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的String]]></title>
    <url>%2F2018%2F03%2F14%2FJava%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[1、在Java中字符串是一个对象，同样的，String变量存储的是对String对象的引用。且Sting对象的内容是不可变的，但保存String引用的变量是可变的，即String变量存储其他的String对象的引用。 2、Java虚拟机为了提高效率并节约内存，对具有相同字符串序列的字符串直接量(请注意这里不是指具有相同字符串序列的String对象)使用同一个实例。 3、字符串的比较：运算符==只能检测两个String是否指向同一个对象，但不会告诉你他们的内容是否相等。而equals方法则可以用来判断两个字符串变量的内容是否相等。compareTo方法用来比较两个字符串时的返回值是，两个字符串从左到右第一个不同字符之间的差值。 4、StringBuffer类和StringBuilder类都比String类更灵活且这两个类是很相似的，它们创建的对象的值都可以被修改。不过在多任务并发访问的情况下就使用StringBuffer；而如果是单任务访问，就使用StringBuilder更有效。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%97%A9%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨夜雨疏风骤，晨起的道上落满了香樟树的叶子，叶子大多橙黄，意味着新生。空气湿润，给人以深呼吸的欲望。上课的人群络绎不绝；环游车从耳旁呼啸而过；还有鸟儿藏在春日的绿里，送来阵阵悦耳的啼鸣。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo的next主题添加点击出现桃心效果的功能]]></title>
    <url>%2F2018%2F03%2F11%2F%E4%B8%BAhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%A1%83%E5%BF%83%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、在路径/themes/next/source/js/src里面新建love.js文件。 2、将下列代码copy进去: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 3、然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 4、接下来你懂的: hexo g hexo s hexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中需要注意的Points]]></title>
    <url>%2F2018%2F03%2F11%2FJava%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84Points%2F</url>
    <content type="text"><![CDATA[1、数组的创建不同于基本数据类型变量的声明，声明一个数组变量时并不在内存中给数组分配任何空间。它只是创建一个对数组的引用的存储位置。 2、在给方法传值的过程中，对于基本数据类型来说，传递的是实参的值，而方法内部的形参获得的值的改变并不会造成方法外部的值的变化；而对于数组类型来说，传递的是数组的引用，也就是说方法中的数组和方法外的数组是一样的，所以如果改变方法中的数组，那么方法外的数组也跟着变化了。 3、对象是通过对象引用变量来访问的，通常在实例化一个类时包括：声明对象引用变量、创建对象以及将对象的引用赋值给这个变量。其实此处类似于数组的创建，从严格意义上来讲，对象引用变量和对象是不同的，但大多数情况下可以忽略这种不同。另外，类中的数据域(即类中的属性)如果未被初始化，那么会被赋予默认值：引用类型的数据域的默认值是null，数值类型的数据域的默认值是0，boolean是false，char是’\u0000’。但是java没有给方法中的局部变量赋默认值。 4、java中的静态变量可以被一个类的所有实例共享数据，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。java中的静态变量和静态方法都无须创建类的实例就可以被调用。但是实例方法和实例变量只能在实例方法中使用，不能在静态方法中使用。由此可知，math类中的所有数据域和方法都是静态的。 5、在类、方法、和数据域前使用public修饰符表示可以在任何其他的类中进行访问；如果没有使用可见性修饰符，那么默认为类、方法和数据域是可以被同一个包中的任何一个类访问；private修饰符限定方法和数据域只能在它自己的类中被访问。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加标签和分类页面]]></title>
    <url>%2F2018%2F03%2F09%2FAdd-tags-and-categories-to-Blogs%2F</url>
    <content type="text"><![CDATA[1、添加标签页面 定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page: $ cd hexo目录 $ hexo new page tags 内容如下所示，如果要关闭tags页面的评论可以设置comments为false: --- title: 标签 date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 这样以后tags页面在每次执行hexo generate后自动更新。 2、添加分类页面 和上面的一样，在hexo目录下执行下面命令： $ hexo new page categories 内容为： --- title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 3、添加404页面 新建一个404.html文件，放到themes\next\source目录下，内容你自己定。 4、添加博文 $ hexo new [filename] --- title: filename! date: create_time tags: tags categories: categories --- 或者写好文章后，找到菜单栏的“导出到本地”选项.以md格式导出到本地，然后copy该md文件，粘贴到你当初建的博客站点文件夹下的source\ _posts目录下，一个md文件对应一篇博客文章。 5、多标签和多分类的表示方法 tags: [tags1,tags2,tags3] categories: [cat1,cat2,cat3] 6、对本地作出的修改进行测试和上传 在你博客站点文件夹下右键空白处，选择Git Bash Here， 输入：hexo generate，回车，生成静态页面， 再输入：hexo server，回车，到localhost:4000预览博客效果， 最后输入：hexo deploy，回车，同步到github上去就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门(一)]]></title>
    <url>%2F2018%2F03%2F08%2FGit%E5%85%A5%E9%97%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1、git配置//配置你的名字 $ git config --global user.name &quot;Your Name&quot; //配置你的email $ git config --global user.email &quot;email@example.com&quot; 2、获得一个git仓库(1)clone一个仓库 //下面的URL填写你在GitHub上的仓库链接 $ git clone https://github.com/shiyanlou/gitproject (2)或者初始化一个新的仓库 //新建一个目录 $ mkdir project //进入这个目录 $ cd project //初始化git仓库 $ git init 3、git的基本流程(1)创建或修改文件 //进入之前创建好的目录 $ cd project //创建三个文件，可以使用vim进行编辑 $ touch file1 file2 file3 //查看当前git仓库的状态，发现有三个文件处于untracked状态 $ git status (2)使用git add命令添加新创建或修改的文件到本地的缓存区 //新建三个文件(也可以是修改过的文件) $ git add file1 file2 file3 //再次查看git仓库状态，此时已经为commit做好了准备 $ git status //查看缓存区中哪些文件被修改了，进入到git diff --cached界面后需要输入q才可以退出如果没有--cached参数，git diff 会显示当前你所有已做的但没有加入到索引里的修改。 $ git diff --cached (3)使用git commit命令提交到本地仓库 //使用git commit把所有被添加到缓存区的新建，修改的文件都提交到本地代码库。使用-m添加本次修改的注释，完成后就会记录一个新的项目版本。 $ git commit -m &quot;add 3 files&quot; //我们还可以用下面的命令将所有没有加到缓存区的修改也一起提交，但-a命令不会添加新建的文件。 $ git commit -a -m &quot;add 3 files&quot; //再次查看git仓库状态，此时的代码库已经没有待提交的文件了，缓存区已经被清空。 $ git status 需要注意的是如果是修改文件，也需要使用git add命令添加到缓存区才可以提交。如果是删除文件，则直接使用git rm命令删除后会自动将已删除文件的信息添加到缓存区，git commit提交后就会将本地仓库中的对应文件删除。 这时如果我们希望将本地仓库关联到远端服务器，我们可以使用 git remote 命令，不同于刚刚的 git clone 命令，直接将远端的仓库克隆下来。 我们当前的仓库是使用 git init 初始化的本地仓库，所以我们需要将本地仓库与远程仓库关联，使用如下命令（需要修改下面的远程仓库地址为自己的仓库地址） //git remote add命令用于添加远程主机，origin是主机名，此处我们可以自定义，不一定非要使用 origin。后面的URL需要替换为自己的远程仓库地址 $ git remote add origin https://github.com/kinglion580 (4)使用git push命令将本地代码库同步到远端代码库 //这个时候如果本地的仓库连接到了远程Git服务器，可以使用下面的命令将本地仓库同步到远端服务器。需要输入仓库对应的用户名和密码 $ git push origin master //下面的网址是远程仓库的ssh网址，左侧的master是本地工作区的分支名，一般都是master；而右侧的master则是远程的分支名，所以也就可以是你该远程仓库的其他分支名。 $ git push git@github.com:EchoDemo/EchoDemo.github.io.git master:master 4、git的分支与合并(1)创建分支 //创建一个名为experimental的分支 $ git branch experimental //查看当前的分支列表，experimental 分支是你刚才创建的，master分支是Git系统默认创建的主分支。星号标识了你此时工作在哪个分支下 $ git branch (2)切换分支 //切换到其他分支 $ git checkout experimental 切换完成后，先编辑里面的一个文件，再提交(commit)改动，最后切换回 “master”分支: //修改文件file1 $ echo &quot;update&quot; &gt;&gt; file1 //查看当前状态 git status //添加并提交file1的修改到本地缓冲区 $ git add file1 //提交到本地仓库 $ git commit -m &quot;update file1&quot; //查看file1的内容 $ cat file1 //切换到master分支 $ git checkout master 此时查看下file1中的内容会发现刚才做的修改已经看不到了。因为刚才的修改时在experimental分支下，现在切换回了master分支，目录下的文件都是master分支上的文件了。 (3)合并分支 现在可以在master分支下再作一些不同的修改: //修改文件file2 $ echo &quot;update again&quot; &gt;&gt; file2 //查看当前状态 $ git status //添加并提交file2的修改 $ git add file2 //提交到本地仓库 $ git commit -m &quot;update file2 on master&quot; //查看file2的内容 $ cat file2 此时两个分支就有了各自不同的修改，分支的内容都已经不同。由于两个branch修改了两个不同的文件，所以合并时不会有冲突，执行下面的命令后合并就完成了: //切换到master分支 $ git checkout master //将experimental分支合并到master，-m参数仍然是需要填写合并的注释信息。 $ git merge -m &apos;merge experimental branch&apos; experimental 如果两个分支都改了一个文件file3，则会产生冲突，合并时会失败。首先我们在master分支上修改file3文件并提交: //切换到master分支 $ git checkout master //修改file3文件 $ echo &quot;master: update file3&quot; &gt;&gt; file3 //提交修改后的文件至本地缓冲区 $ git add file3 //提交到master分支 $ git commit -a -m &apos;update file3 on master&apos; 然后切换到experimental，修改file3并提交: //切换到experimental分支 $ git checkout experimental //修改file3文件 $ echo &quot;experimental: update file3&quot; &gt;&gt; file3 //提交修改后的文件至本地缓冲区 $ git add file3 //提交到experimental分支 $ git commit -a -m &apos;update file3 on experimental&apos; 切换到master进行合并： //切换到master分支 $ git checkout master //将experimental分支合并到master $ git merge experimental 合并失败后先用git status查看状态，会发现file3显示为both modified。使用cat查看file3的内容，可以看到冲突的内容都被添加到了file3中，我们使用vim编辑这个文件，去掉git自动产生标志冲突的&lt;&lt;&lt;&lt;&lt;&lt;等符号后，根据需要只保留我们需要的内容后保存，然后使用git add file3和git commit命令来提交合并后的file3内容，这个过程是手动解决冲突的流程。 //编辑冲突文件 $ vim file3 //提交修改后的文件至本地缓冲区 $ git add file3 //提交到本地仓库 $ git commit -m &apos;merge file3&apos; (4)删除分支 //git branch -d只能删除那些已经被当前分支的合并的分支。如果你要强制删除某个分支的话就用git branch –D $ git branch -d experimental (5)撤销一个合并 $ git reset --hard HEAD^ 查看file3的内容，已经恢复到合并前的master上的文件内容 $ cat file3 5、git日志(1)查看日志 //git log命令可以显示所有的提交(commit)。如果提交的历史纪录很长，回车会逐步显示，输入q可以退出。 $ git log (2)日志统计 //它会显示在每个提交(commit)中哪些文件被修改了, 这些文件分别添加或删除了多少行内容，这个命令相当于打印详细的提交记录 $ git log --stat (3)格式化日志 你可以按你的要求来格式化日志输出。–pretty 参数可以使用若干表现格式。如： $ git log --pretty=oneline 你也可以使用 short 格式: $ git log --pretty=short 你也可用medium,full,fuller,email 或raw。 如果这些格式不完全符合你的需求， 你也可以用–pretty=format参数定义格式。 –graph 选项可以可视化你的提交图(commit graph)，会用ASCII字符来画出一个很漂亮的提交历史(commit history)线： $ git log --graph --pretty=oneline (4)日志排序 按默认情况，提交会按逆时间顺序显示，可以指定–topo-order参数，让提交按拓扑顺序来显示(就是子提交在它们的父提交前显示)。你也可以用 –reverse参数来逆向显示所有提交日志。 $ git log --pretty=format:&apos;%h : %s&apos; --topo-order --graph 注：执行一遍如下命令之后可以省去每次push都需输入账号和密码的烦恼哦！（当然，这一次的账号还是要输入的，此后便可以一劳永逸了，哈哈！）git config --global credential.helper store git push origin master]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于等到你]]></title>
    <url>%2F2018%2F03%2F08%2F%E7%BB%88%E4%BA%8E%E7%AD%89%E5%88%B0%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[不知道 头顶遥远的苍穹闪烁的星光 在无穷无尽里飞行了多少光年 终于赶来与我的目光相会 不知道 手中捧握的书卷古老的诗篇 在岁月长河中留存了多少记忆 此刻也将属于我的悉心珍藏 不知道 你与我不断发酵生酯的相逢 在冥冥注定中酝酿了多少韶华 但我仍然记得你发梢的芳香]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
</search>
