<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++中的map]]></title>
    <url>%2F2018%2F03%2F18%2FC-%E4%B8%AD%E7%9A%84map%2F</url>
    <content type="text"><![CDATA[在编程过程中，如果需要建立字符(或者字符串)与整数之间的映射;判断大整数或者其他类型数据是否存在;甚至是字符串和字符串之间的映射。此时我们应当想到map，因为map可以将任何基本类型(包括STL容器)映射到任何基本类型(包括STL容器)。map和其他的STL容器有点不一样，因为map需要确定映射前类型(键key)和映射后类型(值value),所以需要在&lt;&gt;内填写两个类型。需要注意的是:map中的键是唯一的，而且map会以键从小到大的顺序自动排序(这是由于map内部是使用红黑树实现的，set也是，在建立映射的过程中会自动实现从小到大的排序功能)。如果需要使用map，必须包含头文件#include还有命名空间”using namespace std;”。 1、map的定义:map&lt;typename1,typename2> name;例如: map&lt;string,int&gt; name;//如果是字符串到整型的映射，必须使用string而不能用char数组 map&lt;set&lt;int&gt;,string&gt; name;//将一个set容器映射到一个字符串 2、map容器内元素的访问 (1)通过下标访问，例如：一个定义为map&lt;char,int&gt; name的map来说，可以直接使用name[&apos;c&apos;]来访问对应的整数。 (2)通过迭代器访问,其定义是:map&lt;typename1,typename2&gt;::iterator it;但map迭代器的使用方式和其他STL容器的迭代器不同,因为map的每一对映射都有两个typename,此时我们可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main(){ map&lt;char,int&gt; mp; mp[&apos;m&apos;]=20; mp[&apos;r&apos;]=30; mp[&apos;a&apos;]=40; for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,map的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 4、map常用的函数 (1)find(key):用以返回键为key的映射的迭代器，时间复杂度为O(logN)。map&lt;char,int&gt;::iterator it=mp.find(&apos;b&apos;) (2)size():用来获得map中映射的对数，时间复杂度为O(1)。 (3)clear():用来清空map中的所有元素，时间复杂度为O(N)。 (4)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:mp.erase(it),it位所需要删除元素的迭代器,时间复杂度O(1);mp.erase(key),key为欲删除的映射的键,时间复杂度为O(logN)。删除一个区间内的所有元素:mp.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。时间复杂度为O(last-first)。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的set]]></title>
    <url>%2F2018%2F03%2F17%2FC-%E4%B8%AD%E7%9A%84set%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现去掉重复元素的情况，而且有可能因为这些元素比较大或者类型不是int型而不能直接开散列表。此时我们应当想到set，set是关联式容器。其作为一个容器是用来存储同一类型数据的数据类型，比如：int、char、double、结构体等。在set中每个元素的值都唯一，而且系统能根据元素的值自动进行递增排序。如果需要使用set，必须包含头文件#include还有命名空间”using namespace std;”。 1、set的定义:set&lt;typename> name;例如: set&lt;int&gt; name; //声明一个int容器 set&lt;int&gt; name(10); //声明一个初始大小为10的int型容器 set&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型容器 set&lt;int&gt; name(a); //声明一个初始大小为a的int型容器 set&lt;node&gt; name; //node是结构体的类型 如果typename是set，定义的时候记得在&gt;&gt;符号之间加上空格: set&lt;set&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、set数组的定义:set&lt;typename> arrayname[arraysize];例如: set&lt;int&gt; a[100];//a[0]~a[99]中的每一个都是一个set容器 与set&lt;set&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、set容器内元素的访问 set只能通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:set&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问set中的元素例如: #include&lt;iostream&gt; #include&lt;set&gt; using namespace std ; int main(){ set&lt;int&gt; a; a.insert(3);//将3插入set中 a.insert(5); a.insert(2); a.insert(3); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++){//a.begin()为取a的首元素地址，而it指向这个地址 cout&lt;&lt;*it; } return 0; } 上述程序中出现了去a的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外,set的迭代器不支持it&lt;a.end()的写法,因此循环条件只能用it!=a.end()。除此之外,迭代器还实现了两种自加操作:it++和++it(自减操作同理)。另外,除vector和string之外的STL容器都不支持*(it+i)的访问方式。因此只能按如上的方式枚举。 4、set常用的函数 (1)insert(x):在set容器中添加一个元素,并自动递增排序,时间复杂度为O(logN),N为set内元素个数。 (2)find(x):用以返回set中对应值为x的迭代器，时间复杂度为O(logN)。set&lt;int&gt;::iterator it=a.find(2) (3)size():用来获得set中的元素的个数，时间复杂度为O(1)。 (4)clear():用来清空set中的所有元素，时间复杂度为O(N)。 (6)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。删除单个元素有两种用法:a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(1);a.erase(x),x为所要删除元素的值,时间复杂度为O(logN)。删除一个区间内的所有元素:a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的vector]]></title>
    <url>%2F2018%2F03%2F16%2FC-%E4%B8%AD%E7%9A%84vector%2F</url>
    <content type="text"><![CDATA[在编程过程中，有时经常出现普通数组浪费大量的内存空间或者无法使用邻接矩阵(节点数太多)又害怕使用指针实现邻接表的情况。此时我们应当想到vector。向量vector是一种对象实体, 能够容纳许多其他类型相同的元素,比如：int、char、double、结构体等。 因此又被称为容器。与string相同,vector同属于STL(Standard Template Library,标准模板库)中的一种自定义的数据类型, 可以广义上认为是数组的增强版。vector是一个能够存放任意类型的动态数组。如果需要使用vector，必须包含头文件#include还有命名空间”using namespace std;”。 1、vector的定义:vector&lt;typename> name;例如: vector&lt;int&gt; name; //声明一个int向量 vector&lt;int&gt; name(10); //声明一个初始大小为10的int型向量 vector&lt;int&gt; name(10,1);//声明一个初始大小为10且初始值都为1的int型向量 vector&lt;int&gt; name(a); //声明一个初始大小为a的int型向量 vector&lt;node&gt; name; //node是结构体的类型 如果typename是vector，定义的时候记得在&gt;&gt;符号之间加上空格: vector&lt;vector&lt;int&gt; &gt; name;//&gt;&gt;之间要有空格 2、vector数组的定义:vector&lt;typename> arrayname[arraysize];例如: vector&lt;int&gt; vi[100];//vi[0]~vi[99]中的每一个都是一个vector容器 与vector&lt;vector&lt;int&gt; &gt; name;不同的是，这种写法的一维长度已经固定为arraysize，另一维才是变长的。 3、vector容器内元素的访问 (1)通过下标访问，即vi[0]~vi[size-1]进行访问。 (2)通过迭代器访问,迭代器可以理解为一种类似指针的东西，其定义是:vector&lt;typename&gt;::iterator it;这样得到迭代器it之后，就可以通过*it来访问vector中的元素例如: #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std ; int main(){ vector&lt;int&gt; vi; for(int i=1;i&lt;=5;i++){ vi.push_back(i); } vector&lt;int&gt;::iterator it=vi.begin();//vi.begin()为取vi的首元素地址，而it指向这个地址 for(int i=0;i&lt;5;i++){ cout&lt;&lt;*(it+i); } return 0; } 上述程序中出现了去vi的首地址的begin()函数,那么就不得不提到end()函数。与begin()函数不同的是,end()函数作为迭代器的末尾标志,取的是尾元素地址的下一个地址,不存储任何元素。 另外，vector的迭代器不支持it&lt;vi.end()的写法，因此循环条件只能用it!=vi.end()。除此之外，迭代器还实现了两种自加操作:it++和++it(自减操作同理)。 4、vector常用的函数 (1)push_back(x):在vector后面添加一个元素，时间复杂度为O(1)。 (2)pop_back():用以删除vector的尾元素，时间复杂度为O(1)。 (3)size():用来获得vector中的元素的个数，时间复杂度为O(1)。返回的是unsigned类型。 (4)clear():用来清空vector中的所有元素，时间复杂度为O(N)。N为vector中元素的个数。 (5)insert(it,x):用来向vector的任意迭代器it处插入一个元素x，时间复杂度O(N)。 (6)erase():有两种用法:删除单个元素,删除一个区间内的所有元素。a.erase(it),it为所需要删除元素的迭代器,时间复杂度O(N);a.erase(first,last),first为起始迭代器,而last为删除区间的末尾迭代器的下一个地址。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题使用过程中所遇见的问题及解决措施]]></title>
    <url>%2F2018%2F03%2F16%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[1、有时在hexo s之后本地没有问题，但是在hexo d推送到GitHub之后没有样式显示，此时很可能是GitHub网站本身的原因，稍微等等再刷新就没事了。实在不行的话就把刚才的修改内容改回之前的状态。先hexo clean清理缓存，再hexo g;hexo d刷新查看。 2、平时对博客的修改和更新直接使用hexo g;hexo s查看本地无误之后一般直接hexo d就行了。但是在其中某一步执行完报错之后，记得要先hexo clean再重新执行其他的操作。 3、博客在本地显示正常，hexo d到github上后只显示框架，内容空白时。进入next主题的source目录，将vendors文件的文件名改成任意其他名字，如：VEN。接着在next主题的配置文件_config.yml中,将vendors: 块中的_internal: vendors项改成前面重命名文件夹的名称,如_internal: VEN，保存。(注意在hexo中的大多数情况之下冒号和要填写数据之间必须有一个空格符，否则会在hexo g时便报错)。接下来hexo clean;hexo g;hexo d;打开博客主页，清理缓存，多刷新几次即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的除法]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的除法也可以叫做高精度与低精度的除法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相除呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从大整数的高位开始，上一步的余数(余数的初始值为0)乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步需要注意高位可能有多余的0，要去除，但同时也要保证至少有一位数。有一点需要注意的是：这里的除法函数当中使用了引用变量，引用不产生副本，而是给原变量取了一个别名，对引用变量的操作就是对原变量(即算法中的全局变量)的操作。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign divide(bign a, int b,int &amp;r) {//a/b bign c; c.len = a.len;//被除数的每一位和商的每一位是一一对应的。 for (int i = c.len - 1;i &gt;= 0;i--) {//从高位开始除。 r = r * 10 + a.d[i];//和上一位的余数进行组合。这里的r是引用变量，对引用变量的操作就是对原全局变量的操作。 if (r &lt; b) c.d[i] = 0;//不够除，该位的商为0。 else { c.d[i] = r / b;//商 r = r % b;//获得新的余数。 } } while((c.len-1&gt;=1)&amp;&amp;c.d[c.len-1]==0){ c.len--;//去除高位的0，同时至少保留一位最低位。 } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b,r=0; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(divide(a, b,r));//商 cout &lt;&lt;&quot; &quot;&lt;&lt; r;//余数 system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数与int型数据的乘法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8Eint%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数与int型数据的乘法也可以叫做高精度与低精度的乘法，所谓的高精度就是基本数据类型无法存储的数据，比如1000个数位的整数；而所谓的低精度就是可以用基本数据类型存储的数据，比如int类型。那么该如何进行相乘呢？其实本质上和小学的乘法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。从int型数组的低位开始取数与int型数据相乘，再与进位相加，所得的结果的个位数作为该位的结果，高部位作为新的进位。这里的算法没有考虑大整数和整数为负的情况。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign multi(bign a, int b) {//a*b bign c; int carry = 0;//进位 for (int i = 0;i &lt; a.len;i++) { int temp = a.d[i] * b + carry; c.d[c.len++] = temp % 10;//个位作为该位的结果。 carry = temp / 10;//高位部分作为新的进位。 } while (carry != 0) {//此处和加法略有不同，乘法的进位可能不止一位。 c.d[c.len++] = carry % 10; carry /= 10; } return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000]; int b; cin &gt;&gt; str1 &gt;&gt; b; bign a = change(str1); print(multi(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数减法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%87%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数减法又称之为高精度减法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相减呢？其实本质上和小学的减法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相减之前去比较两者的大小，如果是小的减大的则先把负号输出来，将两者进行交换之后再按大的减小的的步骤来。在减的过程中如果当前位是小减大，那么当前位先加10再减，被减数的当前位的下一位同时需要减1。在所有的位都彼此相减完之后，此时还需要考虑高位为0的情况：例如两数是相等的情况，那么就需要消去高位的0。完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign sub(bign a, bign b) {//a-b。 bign c; for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { if (a.d[i] &lt; b.d[i]) { a.d[i + 1]--;//向高位借位。 a.d[i] += 10;//当前位加10。 } c.d[c.len++] = a.d[i] - b.d[i];//当前位相减。 } while ((c.len - 1 &gt;= 1) &amp;&amp; c.d[c.len - 1] == 0) { c.len--;//去除高位的0，同时如果两数相等保留一个0。 } return c; } int compare(bign a, bign b) {//比较两数的大小，先比较长度，再比较各个位的数值大小。 if (a.len &gt; b.len) return 1;//a大 else if (b.len &gt; a.len) return -1;//b大 else { for (int i = a.len - 1;i &gt;= 0;i--) { if (a.d[i] &gt; b.d[i]) return 1; else if (a.d[i] &lt; b.d[i]) return -1; } return 0; } } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); if (compare(a, b) &lt; 0) {//如果a小于b，就交换。 cout &lt;&lt; &quot;-&quot;; bign c = a; a = b; b = c; } print(sub(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数加法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大整数加法又称之为高精度加法，大整数其含义就是基本数据类型无法存储的整数。比如A和B是有着1000个数位的整数。那么该如何进行相加呢？其实本质上和小学的加法是一样的。我们将无法储存的大整数放进int型的数组，大整数的高位存储在数组的高位，低位存储在数组的低位。在相加完成之后再将其反向输出就行了。具体的算法如下： #include &quot;stdafx.h&quot; #include&lt;iostream&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; using namespace std; struct bign { int d[1000];//使用int型数组存放大整数的每一位。 int len;//记录大整数的长度。 bign() {//&quot;构造函数&quot;用于初始化结构体。 memset(d, 0, sizeof(d)); len=0; } }; bign change(char str[]) {//将存储在字符数组中的大整数转换为bign bign a; a.len = strlen(str); for (int i = 0;i &lt; a.len;i++) {//大整数的高位存储在数组的高位，低位存储在数组的低位。 a.d[i] = str[a.len - i - 1] - &apos;0&apos;; } return a; } bign add(bign a, bign b) {//a+b。 bign c; int carry = 0;//存储进位。 for (int i = 0;i &lt; a.len || i &lt; b.len;i++) { int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10;//两数之和的个位。 carry = temp / 10;//两数之和的十位。 } if (carry != 0) c.d[c.len++] = carry;//两个大整数的最高位相加之后有进位。 return c; } void print(bign a) {//输出bign。 for (int i = a.len - 1;i &gt;= 0;i--) { cout &lt;&lt; a.d[i]; } } int main() { char str1[1000], str2[1000]; cin &gt;&gt; str1 &gt;&gt; str2; bign a = change(str1); bign b = change(str2); print(add(a, b)); system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的String]]></title>
    <url>%2F2018%2F03%2F14%2FJava%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[1、在Java中字符串是一个对象，同样的，String变量存储的是对String对象的引用。且Sting对象的内容是不可变的，但保存String引用的变量是可变的，即String变量存储其他的String对象的引用。 2、Java虚拟机为了提高效率并节约内存，对具有相同字符串序列的字符串直接量(请注意这里不是指具有相同字符串序列的String对象)使用同一个实例。 3、字符串的比较：运算符==只能检测两个String是否指向同一个对象，但不会告诉你他们的内容是否相等。而equals方法则可以用来判断两个字符串变量的内容是否相等。compareTo方法用来比较两个字符串时的返回值是，两个字符串从左到右第一个不同字符之间的差值。 4、StringBuffer类和StringBuilder类都比String类更灵活且这两个类是很相似的，它们创建的对象的值都可以被修改。不过在多任务并发访问的情况下就使用StringBuffer；而如果是单任务访问，就使用StringBuilder更有效。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%97%A9%2F</url>
    <content type="text"><![CDATA[昨夜雨疏风骤，晨起的道上落满了香樟树的叶子，叶子大多橙黄，意味着新生。空气湿润，给人以深呼吸的欲望。上课的人群络绎不绝；环游车从耳旁呼啸而过；还有鸟儿藏在春日的绿里，送来阵阵悦耳的啼鸣。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为hexo的next主题添加点击出现桃心效果的功能]]></title>
    <url>%2F2018%2F03%2F11%2F%E4%B8%BAhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%A1%83%E5%BF%83%E6%95%88%E6%9E%9C%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、在路径/themes/next/source/js/src里面新建love.js文件。 2、将下列代码copy进去: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 3、然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 4、接下来你懂的: hexo g hexo s hexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中需要注意的Points]]></title>
    <url>%2F2018%2F03%2F11%2FJava%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84Points%2F</url>
    <content type="text"><![CDATA[1、数组的创建不同于基本数据类型变量的声明，声明一个数组变量时并不在内存中给数组分配任何空间。它只是创建一个对数组的引用的存储位置。 2、在给方法传值的过程中，对于基本数据类型来说，传递的是实参的值，而方法内部的形参获得的值的改变并不会造成方法外部的值的变化；而对于数组类型来说，传递的是数组的引用，也就是说方法中的数组和方法外的数组是一样的，所以如果改变方法中的数组，那么方法外的数组也跟着变化了。 3、对象是通过对象引用变量来访问的，通常在实例化一个类时包括：声明对象引用变量、创建对象以及将对象的引用赋值给这个变量。其实此处类似于数组的创建，从严格意义上来讲，对象引用变量和对象是不同的，但大多数情况下可以忽略这种不同。另外，类中的数据域(即类中的属性)如果未被初始化，那么会被赋予默认值：引用类型的数据域的默认值是null，数值类型的数据域的默认值是0，boolean是false，char是’\u0000’。但是java没有给方法中的局部变量赋默认值。 4、java中的静态变量可以被一个类的所有实例共享数据，如果某一个对象修改了静态变量的值，那么同一个类的所有对象都会受到影响。java中的静态变量和静态方法都无须创建类的实例就可以被调用。但是实例方法和实例变量只能在实例方法中使用，不能在静态方法中使用。由此可知，math类中的所有数据域和方法都是静态的。 5、在类、方法、和数据域前使用public修饰符表示可以在任何其他的类中进行访问；如果没有使用可见性修饰符，那么默认为类、方法和数据域是可以被同一个包中的任何一个类访问；private修饰符限定方法和数据域只能在它自己的类中被访问。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加标签和分类页面]]></title>
    <url>%2F2018%2F03%2F09%2FAdd-tags-and-categories-to-Blogs%2F</url>
    <content type="text"><![CDATA[1、添加标签页面 定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page: $ cd hexo目录 $ hexo new page tags 内容如下所示，如果要关闭tags页面的评论可以设置comments为false: --- title: 标签 date: 2014-12-22 12:39:04 type: &quot;tags&quot; comments: false --- 这样以后tags页面在每次执行hexo generate后自动更新。 2、添加分类页面 和上面的一样，在hexo目录下执行下面命令： $ hexo new page categories 内容为： --- title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 3、添加404页面 新建一个404.html文件，放到themes\next\source目录下，内容你自己定。 4、添加博文 $ hexo new [filename] --- title: filename! date: create_time tags: tags categories: categories --- 或者写好文章后，找到菜单栏的“导出到本地”选项.以md格式导出到本地，然后copy该md文件，粘贴到你当初建的博客站点文件夹下的source\ _posts目录下，一个md文件对应一篇博客文章。 5、多标签和多分类的表示方法 tags: [tags1,tags2,tags3] categories: [cat1,cat2,cat3] 6、对本地作出的修改进行测试和上传 在你博客站点文件夹下右键空白处，选择Git Bash Here， 输入：hexo generate，回车，生成静态页面， 再输入：hexo server，回车，到localhost:4000预览博客效果， 最后输入：hexo deploy，回车，同步到github上去就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git push to github]]></title>
    <url>%2F2018%2F03%2F08%2FGit-push-to-github%2F</url>
    <content type="text"><![CDATA[1、git status 查看目前代码的修改状态 a) 已暂存 (changes to be committed) new file //表示新建文件 modified //表示修改文件 deleted //表示删除文件 b) 已修改 (changed but not updated) modified //表示修改文件 deleted //表示删除文件 c) 未跟踪 (untracked files) 另外，git 给出了可能需要的操作命令，git add/rm, gitcheckout – 2、git diff 查看代码修改的内容(按q键退出) 比较某文件与最近提交节点的差异。 注意：如果该文件已暂存，那么应该使用git diff –cached 技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。(也可以利用^运算符) 3、git add [filename] 暂存需要提交的文件 如果是新建的文件则git add 如果是修改的文件则git add 如果是删除的文件则 git rm 4、git commit -m “description informations” 提交已暂存的文件(注意注释填写规范) git commit –amend 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。 5、git pull origin master –allow-unrelated-histories 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 命令：git checkout – &lt;有冲突的文件路径&gt; 6、git push -u origin master&lt;本地分支名&gt; 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。 7、如果过程中出现‘please enter a commit message…’(即进入了vim),首先esc然后输入:wq即可。 git rm −r 我的文件夹/此处−r表示递归所有子目录，如果你要删除的，是空的文件夹，此处可以不用带上−r。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This is my first blog!]]></title>
    <url>%2F2018%2F03%2F08%2FThis-is-my-first-blog%2F</url>
    <content type="text"><![CDATA[不知道 不知道 头顶遥远的苍穹闪烁的星光 在无穷无尽里飞行了多少光年 终于赶来与我的目光相会 不知道 手中捧握的书卷古老的诗篇 在岁月长河中留存了多少记忆 此刻也将属于我的悉心珍藏 不知道 你与我不断发酵生酯的相逢 在冥冥注定中酝酿了多少韶华 但我仍然记得你发梢的芳香]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
